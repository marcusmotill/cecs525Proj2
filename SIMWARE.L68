00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.15.04
Created On: 9/24/15 10:26:17 PM

00000000                             1  *        TSBUG2 - 68000 monitor - version of 05 January 2010 
00000000                             2  
00000000                             3      ORG      $0
00000000= 00004400 00001000 ...      4           DC.L STACK,RESET,BUS_ER,ADD_ER,IL_ER,DIV0_ER,X_UN,X_UN,PRIV_ER,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN
00000040= 00001BCC 00001BCC ...      5           DC.L X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN
00000080= 00001638 00001BCC ...      6           DC.L TRAP_0,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN
000000C4= 00001BCC 00001BCC ...      7           DC.L X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN
00000104= 00001BCC 00001BCC ...      8           DC.L X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN
00000144= 00001BCC 00001BCC ...      9           DC.L X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN
00000184= 00001BCC 00001BCC ...     10           DC.L X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN
000001C4= 00001BCC 00001BCC ...     11           DC.L X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN
00000204= 00001BCC 00001BCC ...     12           DC.L X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN
00000244= 00001BCC 00001BCC ...     13           DC.L X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN
00000284= 00001BCC 00001BCC ...     14           DC.L X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN
000002C4= 00001BCC 00001BCC ...     15           DC.L X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN
00000304= 00001BCC 00001BCC ...     16           DC.L X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN
00000344= 00001BCC 00001BCC ...     17           DC.L X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN
00000384= 00001BCC 00001BCC ...     18           DC.L X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN
000003C4= 00001BCC 00001BCC ...     19           DC.L X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN
00000404                            20  *                                   Symbol equates 
00000404  =00000008                 21  BS       EQU      $08               Back_space 
00000404  =0000000D                 22  CR       EQU      $0D               Carriage_return 
00000404  =00000000                 23  NUL      EQU      $00               NUL character
00000404  =0000000A                 24  LF       EQU      $0A               Line_feed 
00000404  =00000020                 25  SPACE    EQU      $20               Space 
00000404  =00000057                 26  WAIT     EQU      'W'               Wait character (to suspend output) 
00000404  =0000001B                 27  ESC      EQU      $1B               ASCII escape character (used by TM) 
00000404  =00000001                 28  CTRL_A   EQU      $01               Control_A forces return to monitor 
00000404                            29  *                                   Device addresses 
00000404  =00004400                 30  STACK    EQU      $4400             Stack_pointer
00000404  =00008001                 31  ACIA_1   EQU      $8001             Console ACIA control 
00000404  =00008001                 32  ACIA_2   EQU      ACIA_1            Auxilary ACIA control 
00000404  =00004000                 33  X_BASE   EQU      $4000             Start of exception vector table 
00000404  =00004E4E                 34  TRAP_16  EQU      $4E4E             Code for TRAP #14 
00000404  =00000040                 35  MAXCHR   EQU      64                Length of input line buffer  
00000404                            36  * 
00000404  =00004800                 37  DATA     EQU      $4800             Data origin 
00000404                            38  LNBUFF   DS.B     MAXCHR            Input line buffer
00000444  =00000443                 39  BUFFEND  EQU      LNBUFF+MAXCHR-1   End of line buffer 
00000444                            40  BUFFPT   DS.L     1                 Pointer to line buffer 
00000448                            41  PARAMTR  DS.L     1                 Last parameter from line buffer 
0000044C                            42  ECHO     DS.B     1                 When clear this enable input echo 
0000044D                            43  U_CASE   DS.B     1                 Flag for upper case conversion 
0000044E                            44  UTAB     DS.L     1                 Pointer to user command table 
00000452                            45  CN_IVEC  DS.L     1                 Pointer to console input DCB 
00000456                            46  CN_OVEC  DS.L     1                 Pointer to console output DCB 
0000045A                            47  TSK_T    DS.W     37                Frame for D0-D7, A0-A6, USP, SSP, SW, PC 
000004A4                            48  BP_TAB   DS.W     24                Breakpoint table 
000004D4                            49  FIRST    DS.B     512               DCB area 
000006D4                            50  BUFFER   DS.B     256               256 bytes for I/O buffer 
000007D4= 00004000                  51  MIN_RAM  DC.L     $004000
000007D8= 00004100                  52  MAX_RAM  DC.L     $004100
000007DC                            53  * 
000007DC                            54  ************************************************************************* 
000007DC                            55  * 
000007DC                            56  *  This is the main program which assembles a command in the line 
000007DC                            57  *  buffer, removes leading/embedded spaces and interprets it by matching 
000007DC                            58  *  it with a command in the user table or the built-in table COMTAB 
000007DC                            59  *  All variables are specified with respect to A6 
000007DC                            60  *
00001000                            61           ORG      $1000             Monitor Origin
00001000  =00001000                 62  RESET:   EQU      *
00001000  4DF8 4800                 63           LEA.L    DATA,A6           A6 points to data area 
00001004  2D4E 0492                 64           MOVE.L    A6,TSK_T+56(A6)   initialize A6 in the regster Frame
00001008  42AE 044E                 65           CLR.L    UTAB(A6)          Reset pointer to user extension table 
0000100C  1D7C 0001 044C            66           MOVE.B   #1,ECHO(A6)       Set automatic character echo 
00001012  422E 044D                 67           CLR.B    U_CASE(A6)        Clear case conversion flag (UC<-LC) 
00001016  6100 05B4                 68           BSR.L     X_SET         what change did i do here
0000101A  6100 046C                 69           BSR.L    SET_DCB           Setup DCB table in RAM
0000101E  6166                      70           BSR.S    NEWLINE
00001020  49FA 0BBA                 71           LEA.L    BANNER(PC),A4    
00001024  6170                      72           BSR.S    PSTRING
00001026  615E                      73           BSR.S    NEWLINE           
00001028  49FA 0BCC                 74           LEA.L     MODIFY(PC),A4
0000102C  6168                      75           BSR.S    PSTRING
0000102E  6156                      76           BSR.S    NEWLINE
00001030  49FA 0BF2                 77           LEA.L     WHY(PC),A4
00001034  6160                      78           BSR.S    PSTRING
00001036  614E                      79           BSR.S    NEWLINE
00001038  49FA 0C22                 80           LEA.L     WHERE(PC),A4
0000103C  6158                      81           BSR.S    PSTRING
0000103E  6146                      82           BSR.S    NEWLINE
00001040  207C 00003000             83           MOVE.L   #$3000,A0         A0 points to extension ROM 
00001046  2010                      84           MOVE.L   (A0),D0           Read first longword in extension ROM 
00001048  B0BC 524F4D32             85           CMP.L    #'ROM2',D0        If extension begins with 'ROM2' then 
0000104E  6604                      86           BNE.S    NO_EXT            call the subroutine at EXT_ROM+8 
00001050  4EA8 0008                 87           JSR      8(A0)             else continue 
00001054  4E71                      88  NO_EXT:  NOP                        Two NOPs to allow for a future 
00001056  4E71                      89           NOP                        call to an initialization routine
00001058  383C 0008                 90           MOVE.W   #8,D4
0000105C  3A3C 0002                 91           MOVE.W   #2,D5
00001060  123C 0013                 92           MOVE.B   #19,D1
00001064  4EB9 00001638             93           JSR      TRAP_0
0000106A  1003                      94           MOVE.B   D3,D0
0000106C  6100 01CA                 95           BSR.W    OUT8X
00001070  4EB9 000017EA             96           JSR      LOGIN
00001076  4287                      97  WARM:    CLR.L    D7                Warm entry point - clear error flag 
00001078  610C                      98           BSR.S    NEWLINE           Print a newline 
0000107A  6130                      99           BSR.S    GETLINE           Get a command line 
0000107C  6100 0064                100           BSR      TIDY              Tidy up input buffer contents 
00001080  6100 00A2                101           BSR      EXECUTE           Interpret command 
00001084  60F0                     102           BRA      WARM              Repeat indefinitely 
00001086                           103  * 
00001086                           104  ************************************************************************* 
00001086                           105  * 
00001086                           106  *  Some initialization and basic routines 
00001086                           107  * 
00001086                           108  * 
00001086  =00001086                109  NEWLINE  EQU      *                 Move cursor to start of newline 
00001086  48E7 0008                110           MOVEM.L  A4,-(A7)          Save A4 
0000108A  49FA 0BEA                111           LEA.L    CRLF(PC),A4       Point to CR/LF string 
0000108E  6106                     112           BSR.S    PSTRING           Print it 
00001090  4CDF 1000                113           MOVEM.L  (A7)+,A4          Restore A4 
00001094  4E75                     114           RTS                        Return 
00001096                           115  * 
00001096  =00001096                116  PSTRING  EQU      *                 Display the string pointed at by A4 
00001096  2F00                     117           MOVE.L   D0,-(A7)          Save D0 
00001098  101C                     118  PS1      MOVE.B   (A4)+,D0          Get character to be printed 
0000109A  6706                     119           BEQ.S    PS2               If null then return 
0000109C  6100 04C6                120           BSR      PUTCHAR           Else print it 
000010A0  60F6                     121           BRA      PS1               Continue 
000010A2  201F                     122  PS2      MOVE.L   (A7)+,D0          Restore D0 and exit 
000010A4  4E75                     123           RTS 
000010A6                           124  * 
000010A6  61DE                     125  HEADING  BSR      NEWLINE           Same as PSTRING but with newline 
000010A8  61EC                     126           BSR      PSTRING 
000010AA  60DA                     127           BRA      NEWLINE 
000010AC                           128  * 
000010AC                           129  ************************************************************************* 
000010AC                           130  * 
000010AC                           131  *  GETLINE  inputs a string of characters into a line buffer 
000010AC                           132  *           A3 points to next free entry in line buffer 
000010AC                           133  *           A2 points to end of buffer 
000010AC                           134  *           A1 points to start of buffer 
000010AC                           135  *           D0 holds character to be stored 
000010AC                           136  * 
000010AC  43EE 0404                137  GETLINE  LEA.L    LNBUFF(A6),A1     A1 points to start of line buffer 
000010B0  47D1                     138           LEA.L    (A1),A3           A3 points to start (initially) 
000010B2  45E9 0040                139           LEA.L    MAXCHR(A1),A2     A2 points to end of buffer 
000010B6  6100 047C                140  GETLN2   BSR      GETCHAR           Get a character 
000010BA  B03C 0001                141           CMP.B    #CTRL_A,D0        If control_A then reject this line 
000010BE  671E                     142           BEQ.S    GETLN5            and get another line 
000010C0  B03C 0008                143           CMP.B    #BS,D0            If back_space then move back pointer 
000010C4  660A                     144           BNE.S    GETLN3            Else skip past wind-back routine 
000010C6  B7C9                     145           CMP.L    A1,A3             First check for empty buffer 
000010C8  67EC                     146           BEQ      GETLN2            If buffer empty then continue 
000010CA  47EB FFFF                147           LEA      -1(A3),A3         Else decrement buffer pointer 
000010CE  60E6                     148           BRA      GETLN2            and continue with next character 
000010D0  16C0                     149  GETLN3   MOVE.B   D0,(A3)+          Store character and update pointer 
000010D2  B03C 000D                150           CMP.B    #CR,D0            Test for command terminator 
000010D6  6602                     151           BNE.S    GETLN4            If not CR then skip past exit 
000010D8  60AC                     152           BRA      NEWLINE           Else new line before next operation 
000010DA  B7CA                     153  GETLN4   CMP.L    A2,A3             Test for buffer overflow 
000010DC  66D8                     154           BNE      GETLN2            If buffer not full then continue 
000010DE  61A6                     155  GETLN5   BSR      NEWLINE           Else move to next line and 
000010E0  60CA                     156           BRA      GETLINE           repeat this routine 
000010E2                           157  * 
000010E2                           158  ************************************************************************* 
000010E2                           159  * 
000010E2                           160  *  TIDY cleans up the line buffer by removing leading spaces and multiple 
000010E2                           161  *       spaces between parameters. At the end of TIDY, BUFFPT points to 
000010E2                           162  *       the first parameter following the command. 
000010E2                           163  *       A0 = pointer to line buffer. A1 = pointer to cleaned up buffer 
000010E2                           164  * 
000010E2  41EE 0404                165  TIDY     LEA.L    LNBUFF(A6),A0     A0 points to line buffer 
000010E6  43D0                     166           LEA.L    (A0),A1           A1 points to start of line buffer 
000010E8  1018                     167  TIDY1    MOVE.B   (A0)+,D0          Read character from line buffer 
000010EA  B03C 0020                168           CMP.B    #SPACE,D0         Repeat until the first non-space 
000010EE  67F8                     169           BEQ      TIDY1             character is found 
000010F0  41E8 FFFF                170           LEA.L    -1(A0),A0         Move pointer back to first char 
000010F4  1018                     171  TIDY2    MOVE.B   (A0)+,D0          Move the string left to remove 
000010F6  12C0                     172           MOVE.B   D0,(A1)+          any leading spaces 
000010F8  B03C 0020                173           CMP.B    #SPACE,D0         Test for embedded space 
000010FC  660A                     174           BNE.S    TIDY4             If not space then test for EOL 
000010FE  0C18 0020                175  TIDY3    CMP.B    #SPACE,(A0)+      If space skip multiple embedded 
00001102  67FA                     176           BEQ      TIDY3             spaces 
00001104  41E8 FFFF                177           LEA.L    -1(A0),A0         Move back pointer 
00001108  B03C 000D                178  TIDY4    CMP.B    #CR,D0            Test for end_of_line (EOL) 
0000110C  66E6                     179           BNE      TIDY2             If not EOL then read next char 
0000110E  41EE 0404                180           LEA.L    LNBUFF(A6),A0     Restore buffer pointer 
00001112  0C10 000D                181  TIDY5    CMP.B    #CR,(A0)          Test for EOL 
00001116  6706                     182           BEQ.S    TIDY6             If EOL then exit 
00001118  0C18 0020                183           CMP.B    #SPACE,(A0)+      Test for delimiter 
0000111C  66F4                     184           BNE      TIDY5             Repeat until delimiter or EOL 
0000111E  2D48 0444                185  TIDY6    MOVE.L   A0,BUFFPT(A6)     Update buffer pointer 
00001122  4E75                     186           RTS 
00001124                           187  * 
00001124                           188  ************************************************************************* 
00001124                           189  * 
00001124                           190  *  EXECUTE matches the first command in the line buffer with the 
00001124                           191  *  commands in a command table. An external table pointed at by 
00001124                           192  *  UTAB is searched first and then the built-in table, COMTAB. 
00001124                           193  * 
00001124  4AAE 044E                194  EXECUTE  TST.L    UTAB(A6)          Test pointer to user table 
00001128  670C                     195           BEQ.S    EXEC1             If clear then try built-in table 
0000112A  266E 044E                196           MOVE.L   UTAB(A6),A3       Else pick up pointer to user table 
0000112E  6120                     197           BSR.S    SEARCH            Look for command in user table 
00001130  6404                     198           BCC.S    EXEC1             If not found then try internal table 
00001132  2653                     199           MOVE.L   (A3),A3           Else get absolute address of command 
00001134  4ED3                     200           JMP      (A3)              from user table and execute it 
00001136                           201  * 
00001136  47FA 0EC8                202  EXEC1    LEA.L    COMTAB(PC),A3     Try built-in command table 
0000113A  6114                     203           BSR.S    SEARCH            Look for command in built-in table 
0000113C  6508                     204           BCS.S    EXEC2             If found then execute command 
0000113E  49FA 0C49                205           LEA.L    ERMES2(PC),A4     Else print "invalid command" 
00001142  6000 FF52                206           BRA.L    PSTRING           and return 
00001146  2653                     207  EXEC2    MOVE.L   (A3),A3           Get the relative command address 
00001148  49FA 0EB6                208           LEA.L    COMTAB(PC),A4     pointed at by A3 and add it to 
0000114C  D7CC                     209           ADD.L    A4,A3             the PC to generate the actual 
0000114E  4ED3                     210           JMP      (A3)              command address. Then execute it. 
00001150                           211  * 
00001150  =00001150                212  SEARCH   EQU      *                 Match the command in the line buffer 
00001150  4280                     213           CLR.L    D0                with command table pointed at by A3 
00001152  1013                     214           MOVE.B   (A3),D0           Get the first character in the 
00001154  6734                     215           BEQ.S    SRCH7             current entry. If zero then exit 
00001156  49F3 0006                216           LEA.L    6(A3,D0.W),A4     Else calculate address of next entry 
0000115A  122B 0001                217           MOVE.B   1(A3),D1          Get number of characters to match 
0000115E  4BEE 0404                218           LEA.L    LNBUFF(A6),A5     A5 points to command in line buffer 
00001162  142B 0002                219           MOVE.B   2(A3),D2          Get first character in this entry 
00001166  B41D                     220           CMP.B    (A5)+,D2          from the table and match with buffer 
00001168  6704                     221           BEQ.S    SRCH3             If match then try rest of string 
0000116A  264C                     222  SRCH2    MOVE.L   A4,A3             Else get address of next entry 
0000116C  60E2                     223           BRA      SEARCH            and try the next entry in the table 
0000116E  5301                     224  SRCH3    SUB.B    #1,D1             One less character to match 
00001170  670E                     225           BEQ.S    SRCH6             If match counter zero then all done 
00001172  47EB 0003                226           LEA.L    3(A3),A3          Else point to next character in table 
00001176  141B                     227  SRCH4    MOVE.B   (A3)+,D2          Now match a pair of characters 
00001178  B41D                     228           CMP.B    (A5)+,D2 
0000117A  66EE                     229           BNE      SRCH2             If no match then try next entry 
0000117C  5301                     230           SUB.B    #1,D1             Else decrement match counter and 
0000117E  66F6                     231           BNE      SRCH4             repeat until no chars left to match 
00001180  47EC FFFC                232  SRCH6    LEA.L    -4(A4),A3         Calculate address of command entry 
00001184  003C 0001                233           OR.B     #1,CCR            point. Mark carry flag as success 
00001188  4E75                     234           RTS                        and return 
0000118A  023C 00FE                235  SRCH7    AND.B    #$FE,CCR          Fail - clear carry to indicate 
0000118E  4E75                     236           RTS                        command not found and return 
00001190                           237  * 
00001190                           238  ************************************************************************* 
00001190                           239  * 
00001190                           240  *  Basic input routines 
00001190                           241  *  HEX    =  Get one   hexadecimal character  into D0 
00001190                           242  *  BYTE   =  Get two   hexadecimal characters into D0 
00001190                           243  *  WORD   =  Get four  hexadecimal characters into D0 
00001190                           244  *  LONGWD =  Get eight hexadecimal characters into D0 
00001190                           245  *  PARAM  =  Get a longword from the line buffer into D0 
00001190                           246  *  Bit 0 of D7 is set to indicate a hexadecimal input error 
00001190                           247  * 
00001190  6100 03A2                248  HEX      BSR      GETCHAR           Get a character from input device 
00001194  0400 0030                249           SUB.B    #$30,D0           Convert to binary 
00001198  6B0E                     250           BMI.S    NOT_HEX           If less than $30 then exit with error 
0000119A  B03C 0009                251           CMP.B    #$09,D0           Else test for number (0 to 9) 
0000119E  6F0C                     252           BLE.S    HEX_OK            If number then exit - success 
000011A0  5F00                     253           SUB.B    #$07,D0           Else convert letter to hex 
000011A2  B03C 000F                254           CMP.B    #$0F,D0           If character in range "A" to "F" 
000011A6  6F04                     255           BLE.S    HEX_OK            then exit successfully 
000011A8  8E3C 0001                256  NOT_HEX  OR.B     #1,D7             Else set error flag 
000011AC  4E75                     257  HEX_OK   RTS                        and return 
000011AE                           258  * 
000011AE  2F01                     259  BYTE     MOVE.L   D1,-(A7)          Save D1 
000011B0  61DE                     260           BSR      HEX               Get first hex character 
000011B2  E900                     261           ASL.B    #4,D0             Move it to MS nybble position 
000011B4  1200                     262           MOVE.B   D0,D1             Save MS nybble in D1 
000011B6  61D8                     263           BSR      HEX               Get second hex character 
000011B8  D001                     264           ADD.B    D1,D0             Merge MS and LS nybbles 
000011BA  221F                     265           MOVE.L   (A7)+,D1          Restore D1 
000011BC  4E75                     266           RTS 
000011BE                           267  * 
000011BE  61EE                     268  WORD     BSR      BYTE              Get upper order byte 
000011C0  E140                     269           ASL.W    #8,D0             Move it to MS position 
000011C2  60EA                     270           BRA      BYTE              Get LS byte and return 
000011C4                           271  * 
000011C4  61F8                     272  LONGWD   BSR      WORD              Get upper order word 
000011C6  4840                     273           SWAP     D0                Move it to MS position 
000011C8  60F4                     274           BRA      WORD              Get lower order word and return 
000011CA                           275  * 
000011CA                           276  *  PARAM reads a parameter from the line buffer and puts it in both 
000011CA                           277  *  PARAMTR(A6) and D0. Bit 1 of D7 is set on error. 
000011CA                           278  * 
000011CA  2F01                     279  PARAM    MOVE.L   D1,-(A7)          Save D1 
000011CC  4281                     280           CLR.L    D1                Clear input accumulator 
000011CE  206E 0444                281           MOVE.L   BUFFPT(A6),A0     A0 points to parameter in buffer 
000011D2  1018                     282  PARAM1   MOVE.B   (A0)+,D0          Read character from line buffer 
000011D4  B03C 0020                283           CMP.B    #SPACE,D0         Test for delimiter 
000011D8  6720                     284           BEQ.S    PARAM4            The permitted delimiter is a 
000011DA  B03C 000D                285           CMP.B    #CR,D0            space or a carriage return 
000011DE  671A                     286           BEQ.S    PARAM4            Exit on either space or C/R 
000011E0  E981                     287           ASL.L    #4,D1             Shift accumulated result 4 bits left 
000011E2  0400 0030                288           SUB.B    #$30,D0           Convert new character to hex 
000011E6  6B1E                     289           BMI.S    PARAM5            If less than $30 then not-hex 
000011E8  B03C 0009                290           CMP.B    #$09,D0           If less than 10 
000011EC  6F08                     291           BLE.S    PARAM3            then continue 
000011EE  5F00                     292           SUB.B    #$07,D0           Else assume $A - $F 
000011F0  B03C 000F                293           CMP.B    #$0F,D0           If more than $F 
000011F4  6E10                     294           BGT.S    PARAM5            then exit to error on not-hex 
000011F6  D200                     295  PARAM3   ADD.B    D0,D1             Add latest nybble to total in D1 
000011F8  60D8                     296           BRA      PARAM1            Repeat until delimiter found 
000011FA  2D48 0444                297  PARAM4   MOVE.L   A0,BUFFPT(A6)     Save pointer in memory 
000011FE  2D41 0448                298           MOVE.L   D1,PARAMTR(A6)    Save parameter in memory 
00001202  2001                     299           MOVE.L   D1,D0             Put parameter in D0 for return 
00001204  6004                     300           BRA.S    PARAM6            Return without error 
00001206  8E3C 0002                301  PARAM5   OR.B     #2,D7             Set error flag before return 
0000120A  221F                     302  PARAM6   MOVE.L   (A7)+,D1          Restore working register 
0000120C  4E75                     303           RTS                        Return with error 
0000120E                           304  * 
0000120E                           305  ************************************************************************* 
0000120E                           306  * 
0000120E                           307  *  Output routines 
0000120E                           308  *  OUT1X   = print one   hexadecimal character 
0000120E                           309  *  OUT2X   = print two   hexadecimal characters 
0000120E                           310  *  OUT4X   = print four  hexadecimal characters 
0000120E                           311  *  OUT8X   = print eight hexadecimal characters 
0000120E                           312  *  In each case, the data to be printed is in D0 
0000120E                           313  * 
0000120E  3F00                     314  OUT1X    MOVE.W   D0,-(A7)          Save D0 
00001210  C03C 000F                315           AND.B    #$0F,D0           Mask off MS nybble 
00001214  0600 0030                316           ADD.B    #$30,D0           Convert to ASCII 
00001218  B03C 0039                317           CMP.B    #$39,D0           ASCII = HEX + $30 
0000121C  6302                     318           BLS.S    OUT1X1            If ASCII <= $39 then print and exit 
0000121E  5E00                     319           ADD.B    #$07,D0           Else ASCII := HEX + 7 
00001220  6100 0342                320  OUT1X1   BSR      PUTCHAR           Print the character 
00001224  301F                     321           MOVE.W   (A7)+,D0          Restore D0 
00001226  4E75                     322           RTS 
00001228                           323  * 
00001228  E818                     324  OUT2X    ROR.B    #4,D0             Get MS nybble in LS position 
0000122A  61E2                     325           BSR      OUT1X             Print MS nybble 
0000122C  E918                     326           ROL.B    #4,D0             Restore LS nybble 
0000122E  60DE                     327           BRA      OUT1X             Print LS nybble and return 
00001230                           328  * 
00001230  E058                     329  OUT4X    ROR.W    #8,D0             Get MS byte in LS position 
00001232  61F4                     330           BSR      OUT2X             Print MS byte 
00001234  E158                     331           ROL.W    #8,D0             Restore LS byte 
00001236  60F0                     332           BRA      OUT2X             Print LS byte and return 
00001238                           333  * 
00001238  4840                     334  OUT8X    SWAP     D0                Get MS word in LS position 
0000123A  61F4                     335           BSR      OUT4X             Print MS word 
0000123C  4840                     336           SWAP     D0                Restore LS word 
0000123E  60F0                     337           BRA      OUT4X             Print LS word and return 
00001240                           338  * 
00001240                           339  ************************************************************************* 
00001240                           340  * 
00001240                           341  * JUMP causes execution to begin at the address in the line buffer 
00001240                           342  * 
00001240  6188                     343  JUMP     BSR     PARAM              Get address from buffer 
00001242  4A07                     344           TST.B   D7                 Test for input error 
00001244  6608                     345           BNE.S   JUMP1              If error flag not zero then exit 
00001246  4A80                     346           TST.L   D0                 Else test for missing address 
00001248  6704                     347           BEQ.S   JUMP1              field. If no address then exit 
0000124A  2040                     348           MOVE.L  D0,A0              Put jump address in A0 and call the 
0000124C  4ED0                     349           JMP     (A0)               subroutine. User to supply RTS!! 
0000124E  49FA 0B1B                350  JUMP1    LEA.L   ERMES1(PC),A4      Here for error - display error 
00001252  6000 FE42                351           BRA     PSTRING            message and return 
00001256                           352  * 
00001256                           353  ************************************************************************* 
00001256                           354  * 
00001256                           355  *  Display the contents of a memory location and modify it 
00001256                           356  * 
00001256  6100 FF72                357  MEMORY   BSR      PARAM             Get start address from line buffer 
0000125A  4A07                     358           TST.B    D7                Test for input error 
0000125C  6634                     359           BNE.S    MEM3              If error then exit 
0000125E  2640                     360           MOVE.L   D0,A3             A3 points to location to be opened 
00001260  6100 FE24                361  MEM1     BSR      NEWLINE 
00001264  612E                     362           BSR.S    ADR_DAT           Print current address and contents 
00001266  6140                     363           BSR.S    PSPACE             update pointer, A3, and O/P space 
00001268  6100 02CA                364           BSR      GETCHAR           Input char to decide next action 
0000126C  B03C 000D                365           CMP.B    #CR,D0            If carriage return then exit 
00001270  6720                     366           BEQ.S    MEM3              Exit 
00001272  B03C 002D                367           CMP.B    #'-',D0           If "-" then move back 
00001276  6606                     368           BNE.S    MEM2              Else skip wind-back procedure 
00001278  47EB FFFC                369           LEA.L    -4(A3),A3         Move pointer back 2+2 
0000127C  60E2                     370           BRA      MEM1              Repeat until carriage return 
0000127E  B03C 0020                371  MEM2     CMP.B    #SPACE,D0         Test for space (= new entry) 
00001282  66DC                     372           BNE.S    MEM1              If not space then repeat 
00001284  6100 FF38                373           BSR      WORD              Else get new word to store 
00001288  4A07                     374           TST.B    D7                Test for input error 
0000128A  6606                     375           BNE.S    MEM3              If error then exit 
0000128C  3740 FFFE                376           MOVE.W   D0,-2(A3)         Store new word 
00001290  60CE                     377           BRA      MEM1              Repeat until carriage return 
00001292  4E75                     378  MEM3     RTS 
00001294                           379  * 
00001294  2F00                     380  ADR_DAT  MOVE.L   D0,-(A7)          Print the contents of A3 and the 
00001296  200B                     381           MOVE.L   A3,D0             word pointed at by A3. 
00001298  619E                     382           BSR      OUT8X              and print current address 
0000129A  610C                     383           BSR.S    PSPACE            Insert delimiter 
0000129C  3013                     384           MOVE.W   (A3),D0           Get data at this address in D0 
0000129E  6190                     385           BSR      OUT4X              and print it 
000012A0  47EB 0002                386           LEA.L    2(A3),A3          Point to next address to display 
000012A4  201F                     387           MOVE.L   (A7)+,D0          Restore D0 
000012A6  4E75                     388           RTS 
000012A8                           389  * 
000012A8  1F00                     390  PSPACE   MOVE.B   D0,-(A7)          Print a single space 
000012AA  103C 0020                391           MOVE.B   #SPACE,D0 
000012AE  6100 02B4                392           BSR      PUTCHAR 
000012B2  101F                     393           MOVE.B   (A7)+,D0 
000012B4  4E75                     394           RTS 
000012B6                           395  * 
000012B6                           396  ************************************************************************* 
000012B6                           397  * 
000012B6                           398  *  LOAD  Loads data formatted in hexadecimal "S" format from Port 2 
000012B6                           399  *        NOTE - I/O is automatically redirected to the aux port for 
000012B6                           400  *        loader functions. S1 or S2 records accepted 
000012B6                           401  * 
000012B6  2F2E 0456                402  LOAD     MOVE.L   CN_OVEC(A6),-(A7) Save current output device name 
000012BA  2F2E 0452                403           MOVE.L   CN_IVEC(A6),-(A7) Save current input device name 
000012BE  2D7C 0000206C 0456       404           MOVE.L   #DCB4,CN_OVEC(A6) Set up aux ACIA as output 
000012C6  2D7C 0000205A 0452       405           MOVE.L   #DCB3,CN_IVEC(A6) Set up aux ACIA as input 
000012CE  522E 044C                406           ADD.B    #1,ECHO(A6)       Turn off character echo 
000012D2  6100 FDB2                407           BSR      NEWLINE           Send newline to host 
000012D6  6100 015A                408           BSR      DELAY             Wait for host to "settle" 
000012DA  6100 0156                409           BSR      DELAY 
000012DE  286E 0444                410           MOVE.L   BUFFPT(A6),A4     Any string in the line buffer is 
000012E2  101C                     411  LOAD1    MOVE.B   (A4)+,D0          transmitted to the host computer 
000012E4  6100 027E                412           BSR      PUTCHAR           before the loading begins 
000012E8  B03C 000D                413           CMP.B    #CR,D0            Read from the buffer until EOL 
000012EC  66F4                     414           BNE      LOAD1 
000012EE  6100 FD96                415           BSR      NEWLINE           Send newline before loading 
000012F2  6100 0240                416  LOAD2    BSR      GETCHAR           Records from the host must begin 
000012F6  B03C 0053                417           CMP.B    #'S',D0           with S1/S2 (data) or S9/S8 (term) 
000012FA  66F6                     418           BNE.S    LOAD2             Repeat GETCHAR until char = "S" 
000012FC  6100 0236                419           BSR      GETCHAR           Get character after "S" 
00001300  B03C 0039                420           CMP.B    #'9',D0           Test for the two terminators S9/S8 
00001304  6706                     421           BEQ.S    LOAD3             If S9 record then exit else test 
00001306  B03C 0038                422           CMP.B    #'8',D0           for S8 terminator. Fall through to 
0000130A  662A                     423           BNE.S    LOAD6             exit on S8 else continue search 
0000130C  =0000130C                424  LOAD3    EQU      *                 Exit point from LOAD 
0000130C  2D5F 0452                425           MOVE.L   (A7)+,CN_IVEC(A6) Clean up by restoring input device 
00001310  2D5F 0456                426           MOVE.L   (A7)+,CN_OVEC(A6) and output device name 
00001314  422E 044C                427           CLR.B    ECHO(A6)          Restore input character echo 
00001318  0807 0000                428           BTST     #0,D7             Test for input errors 
0000131C  6708                     429           BEQ.S    LOAD4             If no I/P error then look at checksum 
0000131E  49FA 0A4B                430           LEA.L    ERMES1(PC),A4     Else point to error message 
00001322  6100 FD72                431           BSR      PSTRING           Print it 
00001326  0807 0003                432  LOAD4    BTST     #3,D7             Test for checksum error 
0000132A  6708                     433           BEQ.S    LOAD5             If clear then exit 
0000132C  49FA 0A6D                434           LEA.L    ERMES3(PC),A4     Else point to error message 
00001330  6100 FD64                435           BSR      PSTRING           Print it and return 
00001334  4E75                     436  LOAD5    RTS 
00001336                           437  * 
00001336  B03C 0031                438  LOAD6    CMP.B    #'1',D0           Test for S1 record 
0000133A  671E                     439           BEQ.S    LOAD6A            If S1 record then read it 
0000133C  B03C 0032                440           CMP.B    #'2',D0           Else test for S2 record 
00001340  66B0                     441           BNE.S    LOAD2             Repeat until valid header found 
00001342  4203                     442           CLR.B    D3                Read the S2 byte count and address, 
00001344  613C                     443           BSR.S    LOAD8             clear the checksum 
00001346  5900                     444           SUB.B    #4,D0             Calculate size of data field 
00001348  1400                     445           MOVE.B   D0,D2             D2 contains data bytes to read 
0000134A  4280                     446           CLR.L    D0                Clear address accumulator 
0000134C  6134                     447           BSR.S    LOAD8             Read most sig byte of address 
0000134E  E180                     448           ASL.L    #8,D0             Move it one byte left 
00001350  6130                     449           BSR.S    LOAD8             Read the middle byte of address 
00001352  E180                     450           ASL.L    #8,D0             Move it one byte left 
00001354  612C                     451           BSR.S    LOAD8             Read least sig byte of address 
00001356  2440                     452           MOVE.L   D0,A2             A2 points to destination of record 
00001358  6012                     453           BRA.S    LOAD7             Skip past S1 header loader 
0000135A  4203                     454  LOAD6A   CLR.B    D3                S1 record found - clear checksum 
0000135C  6124                     455           BSR.S    LOAD8             Get byte and update checksum 
0000135E  5700                     456           SUB.B    #3,D0             Subtract 3 from record length 
00001360  1400                     457           MOVE.B   D0,D2             Save byte count in D2 
00001362  4280                     458           CLR.L    D0                Clear address accumulator 
00001364  611C                     459           BSR.S    LOAD8             Get MS byte of load address 
00001366  E180                     460           ASL.L    #8,D0             Move it to MS position 
00001368  6118                     461           BSR.S    LOAD8             Get LS byte in D2 
0000136A  2440                     462           MOVE.L   D0,A2             A2 points to destination of data 
0000136C  6114                     463  LOAD7    BSR.S    LOAD8             Get byte of data for loading 
0000136E  14C0                     464           MOVE.B   D0,(A2)+          Store it 
00001370  5302                     465           SUB.B    #1,D2             Decrement byte counter 
00001372  66F8                     466           BNE      LOAD7             Repeat until count = 0 
00001374  610C                     467           BSR.S    LOAD8             Read checksum 
00001376  5203                     468           ADD.B    #1,D3             Add 1 to total checksum 
00001378  6700 FF78                469           BEQ      LOAD2             If zero then start next record 
0000137C  8E3C 0008                470           OR.B     #%00001000,D7     Else set checksum error bit, 
00001380  608A                     471           BRA      LOAD3             restore I/O devices and return 
00001382                           472  * 
00001382  6100 FE2A                473  LOAD8    BSR     BYTE               Get a byte 
00001386  D600                     474           ADD.B   D0,D3              Update checksum 
00001388  4E75                     475           RTS                         and return 
0000138A                           476  * 
0000138A                           477  ************************************************************************* 
0000138A                           478  * 
0000138A                           479  *  DUMP   Transmit S1 formatted records to host computer 
0000138A                           480  *         A3 = Starting address of data block 
0000138A                           481  *         A2 = End address of data block 
0000138A                           482  *         D1 = Checksum, D2 = current record length 
0000138A                           483  * 
0000138A  6100 0096                484  DUMP     BSR      RANGE             Get start and end address 
0000138E  4A07                     485           TST.B    D7                Test for input error 
00001390  6708                     486           BEQ.S    DUMP1             If no error then continue 
00001392  49FA 09D7                487           LEA.L    ERMES1(PC),A4     Else point to error message, 
00001396  6000 FCFE                488           BRA      PSTRING           print it and return 
0000139A  B08B                     489  DUMP1    CMP.L    A3,D0             Compare start and end addresses 
0000139C  6A08                     490           BPL.S    DUMP2             If positive then start < end 
0000139E  49FA 0B6A                491           LEA.L    ERMES7(PC),A4     Else print error message 
000013A2  6000 FCF2                492           BRA      PSTRING           and return 
000013A6  2F2E 0456                493  DUMP2    MOVE.L   CN_OVEC(A6),-(A7) Save name of current output device 
000013AA  2D7C 0000206C 0456       494           MOVE.L   #DCB4,CN_OVEC(A6) Set up Port 2 as output device 
000013B2  6100 FCD2                495           BSR      NEWLINE           Send newline to host and wait 
000013B6  617A                     496           BSR.S    DELAY 
000013B8  286E 0444                497           MOVE.L   BUFFPT(A6),A4     Before dumping, send any string 
000013BC  101C                     498  DUMP3    MOVE.B   (A4)+,D0          in the input buffer to the host 
000013BE  6100 01A4                499           BSR      PUTCHAR           Repeat 
000013C2  B03C 000D                500           CMP.B    #CR,D0            Transmit char from buffer to host 
000013C6  66F4                     501           BNE      DUMP3             Until char = C/R 
000013C8  6100 FCBC                502           BSR      NEWLINE 
000013CC  6164                     503           BSR.S    DELAY             Allow time for host to settle 
000013CE  528A                     504           ADDQ.L   #1,A2             A2 contains length of record + 1 
000013D0  240A                     505  DUMP4    MOVE.L   A2,D2             D2 points to end address 
000013D2  948B                     506           SUB.L    A3,D2             D2 contains bytes left to print 
000013D4  B4BC 00000011            507           CMP.L    #17,D2            If this is not a full record of 16 
000013DA  6502                     508           BCS.S    DUMP5             then load D2 with record size 
000013DC  7410                     509           MOVEQ    #16,D2            Else preset byte count to 16 
000013DE  49FA 08A1                510  DUMP5    LEA.L    HEADER(PC),A4     Point to record header 
000013E2  6100 FCB2                511           BSR      PSTRING           Print header 
000013E6  4201                     512           CLR.B    D1                Clear checksum 
000013E8  1002                     513           MOVE.B   D2,D0             Move record length to output register 
000013EA  5600                     514           ADD.B    #3,D0             Length includes address + count 
000013EC  612E                     515           BSR.S    DUMP7             Print number of bytes in record 
000013EE  200B                     516           MOVE.L   A3,D0             Get start address to be printed 
000013F0  E158                     517           ROL.W    #8,D0             Get MS byte in LS position 
000013F2  6128                     518           BSR.S    DUMP7             Print MS byte of address 
000013F4  E058                     519           ROR.W    #8,D0             Restore LS byte 
000013F6  6124                     520           BSR.S    DUMP7             Print LS byte of address 
000013F8  101B                     521  DUMP6    MOVE.B   (A3)+,D0          Get data byte to be printed 
000013FA  6120                     522           BSR.S    DUMP7             Print it 
000013FC  5302                     523           SUB.B    #1,D2             Decrement byte count 
000013FE  66F8                     524           BNE      DUMP6             Repeat until all this record printed 
00001400  4601                     525           NOT.B    D1                Complement checksum 
00001402  1001                     526           MOVE.B   D1,D0             Move to output register 
00001404  6116                     527           BSR.S    DUMP7             Print checksum 
00001406  6100 FC7E                528           BSR      NEWLINE 
0000140A  B7CA                     529           CMP.L    A2,A3             Have all records been printed? 
0000140C  66C2                     530           BNE      DUMP4             Repeat until all done 
0000140E  49FA 0877                531           LEA.L    TAIL(PC),A4       Point to message tail (S9 record) 
00001412  6100 FC82                532           BSR      PSTRING           Print it 
00001416  2D5F 0456                533           MOVE.L   (A7)+,CN_OVEC(A6) Restore name of output device 
0000141A  4E75                     534           RTS                        and return 
0000141C                           535  * 
0000141C  D200                     536  DUMP7    ADD.B    D0,D1             Update checksum, transmit byte 
0000141E  6000 FE08                537           BRA      OUT2X             to host and return 
00001422                           538  * 
00001422  =00001422                539  RANGE    EQU      *                 Get the range of addresses to be 
00001422  4207                     540           CLR.B    D7                transmitted from the buffer 
00001424  6100 FDA4                541           BSR      PARAM             Get starting address 
00001428  2640                     542           MOVE.L   D0,A3             Set up start address in A3 
0000142A  6100 FD9E                543           BSR      PARAM             Get end address 
0000142E  2440                     544           MOVE.L   D0,A2             Set up end address in A2 
00001430  4E75                     545           RTS 
00001432                           546  * 
00001432  =00001432                547  DELAY    EQU       *                Provide a time delay for the host 
00001432  48E7 8008                548           MOVEM.L   D0/A4,-(A7)      to settle. Save working registers 
00001436  203C 00004000            549           MOVE.L    #$4000,D0        Set up delay constant 
0000143C  5380                     550  DELAY1   SUB.L     #1,D0            Count down         (8 clk cycles) 
0000143E  66FC                     551           BNE       DELAY1           Repeat until zero  (10 clk cycles) 
00001440  4CDF 1001                552           MOVEM.L   (A7)+,D0/A4      Restore working registers 
00001444  4E75                     553           RTS 
00001446                           554  * 
00001446                           555  ************************************************************************* 
00001446                           556  * 
00001446                           557  *  TM  Enter transparant mode (All communication to go from terminal to 
00001446                           558  *  the host processor until escape sequence entered). End sequence 
00001446                           559  *  = ESC, E. A newline is sent to the host to "clear it down". 
00001446                           560  * 
00001446  13FC 0055 00008001       561  TM       MOVE.B    #$55,ACIA_1      Force RTS* high to re-route data 
0000144E  522E 044C                562           ADD.B     #1,ECHO(A6)      Turn off character echo 
00001452  6100 00E0                563  TM1      BSR       GETCHAR          Get character 
00001456  B03C 001B                564           CMP.B     #ESC,D0          Test for end of TM mode 
0000145A  66F6                     565           BNE       TM1              Repeat until first escape character 
0000145C  6100 00D6                566           BSR       GETCHAR          Get second character 
00001460  B03C 0045                567           CMP.B     #'E',D0          If second char = E then exit TM 
00001464  66EC                     568           BNE       TM1              Else continue 
00001466  2F2E 0456                569           MOVE.L    CN_OVEC(A6),-(A7) Save output port device name 
0000146A  2D7C 0000206C 0456       570           MOVE.L    #DCB4,CN_OVEC(A6) Get name of host port (aux port) 
00001472  6100 FC12                571           BSR       NEWLINE          Send newline to host to clear it 
00001476  2D5F 0456                572           MOVE.L    (A7)+,CN_OVEC(A6) Restore output device port name 
0000147A  422E 044C                573           CLR.B     ECHO(A6)         Restore echo mode 
0000147E  13FC 0015 00008001       574           MOVE.B    #$15,ACIA_1      Restore normal ACIA mode (RTS* low) 
00001486  4E75                     575           RTS 
00001488                           576  * 
00001488                           577  ************************************************************************* 
00001488                           578  * 
00001488                           579  *  This routine sets up the system DCBs in RAM using the information 
00001488                           580  *  stored in ROM at address DCB_LST. This is called at initialization. 
00001488                           581  *  CN_IVEC contains the name "DCB1" and IO_VEC the name "DCB2" 
00001488                           582  * 
00001488  48E7 F0F0                583  SET_DCB  MOVEM.L A0-A3/D0-D3,-(A7) Save all working registers 
0000148C  41EE 04D4                584           LEA.L   FIRST(A6),A0    Pointer to first DCB destination in RAM 
00001490  43FA 0BA4                585           LEA.L   DCB_LST(PC),A1  A1 points to DCB info block in ROM 
00001494  303C 0005                586           MOVE.W  #5,D0           6 DCBs to set up 
00001498  323C 000F                587  ST_DCB1  MOVE.W  #15,D1          16 bytes to move per DCB header 
0000149C  10D9                     588  ST_DCB2  MOVE.B  (A1)+,(A0)+     Move the 16 bytes of a DCB header 
0000149E  51C9 FFFC                589           DBRA    D1,ST_DCB2      from ROM to RAM 
000014A2  3619                     590           MOVE.W  (A1)+,D3        Get size of parameter block (bytes) 
000014A4  3083                     591           MOVE.W  D3,(A0)         Store size in DCB in RAM 
000014A6  41F0 3002                592           LEA.L   2(A0,D3.W),A0   A0 points to tail of DCB in RAM 
000014AA  47E8 0004                593           LEA.L   4(A0),A3        A3 contains address of next DCB in RAM 
000014AE  208B                     594           MOVE.L  A3,(A0)         Store pointer to next DCB in this DCB 
000014B0  41D3                     595           LEA.L   (A3),A0         A0 now points at next DCB in RAM 
000014B2  51C8 FFE4                596           DBRA    D0,ST_DCB1      Repeat until all DCBs set up 
000014B6  47EB FFFC                597           LEA.L   -4(A3),A3       Adjust A3 to point to last DCB pointer 
000014BA  4293                     598           CLR.L   (A3)            and force last pointer to zero 
000014BC  2D7C 00002036 0452       599           MOVE.L  #DCB1,CN_IVEC(A6) Set up vector to console input DCB 
000014C4  2D7C 00002048 0456       600           MOVE.L  #DCB2,CN_OVEC(A6) Set up vector to console output DCB 
000014CC  4CDF 0F0F                601           MOVEM.L (A7)+,A0-A3/D0-D3 Restore registers 
000014D0  4E75                     602           RTS 
000014D2                           603  * 
000014D2                           604  ************************************************************************* 
000014D2                           605  * 
000014D2                           606  *  IO_REQ handles all input/output transactions. A0 points to DCB on 
000014D2                           607  *  entry. IO_REQ calls the device driver whose address is in the DCB. 
000014D2                           608  * 
000014D2  48E7 00C0                609  IO_REQ   MOVEM.L A0-A1,-(A7)     Save working registers 
000014D6  43E8 0008                610           LEA.L   8(A0),A1        A1 points to device handler field in DCB 
000014DA  2251                     611           MOVE.L  (A1),A1         A1 contains device handler address 
000014DC  4E91                     612           JSR     (A1)            Call device handler 
000014DE  4CDF 0300                613           MOVEM.L (A7)+,A0-A1     Restore working registers 
000014E2  4E75                     614           RTS 
000014E4                           615  * 
000014E4                           616  ************************************************************************* 
000014E4                           617  * 
000014E4                           618  *  CON_IN handles input from the console device 
000014E4                           619  *  Exit with input in D0 
000014E4                           620  * 
000014E4  48E7 4000                621  CON_IN   MOVEM.L D1,-(A7)         Save working registers 
000014E8  4228 0013                622      CLR.B    19(A0)
000014EC  103C 0005                623           MOVE.B    #5,D0             Read input from ACIA
000014F0  4E4F                     624      TRAP     #15
000014F2  1001                     625      MOVE.B  D1,D0
000014F4  4CDF 0002                626           MOVEM.L (A7)+,D1     `   Restore working registers 
000014F8  4E75                     627           RTS 
000014FA                           628  * 
000014FA                           629  ************************************************************************* 
000014FA                           630  * 
000014FA                           631  *   This is the CON_OUT device driver. Output in D0  
000014FA                           632  * 
000014FA  48E7 4000                633  CON_OUT  MOVEM.L D1,-(A7)  Save working registers 
000014FE  4228 0013                634      CLR.B    19(A0)
00001502  1200                     635           MOVE.B    D0,D1
00001504  103C 0006                636           MOVE.B    #6,D0
00001508  4E4F                     637           TRAP   #15
0000150A  4CDF 0002                638           MOVEM.L (A7)+,D1  Restore working registers 
0000150E  4E75                     639           RTS 
00001510                           640  * 
00001510                           641  ************************************************************************* 
00001510                           642  * 
00001510                           643  *  AUX_IN and AUX_OUT are simplified versions of CON_IN and 
00001510                           644  *  CON_OUT for use with the port to the host processor 
00001510                           645  * 
00001510  43E8 000C                646  AUX_IN   LEA.L   12(A0),A1       Get pointer to aux ACIA from DCB 
00001514  2251                     647           MOVE.L  (A1),A1         Get address of aux ACIA 
00001516  0811 0000                648  AUX_IN1  BTST.B  #0,(A1)         Test for data ready 
0000151A  67FA                     649           BEQ     AUX_IN1         Repeat until ready 
0000151C  1029 0002                650           MOVE.B  2(A1),D0        Read input 
00001520  4E75                     651           RTS 
00001522                           652  * 
00001522  43E8 000C                653  AUX_OUT  LEA.L   12(A0),A1       Get pointer to aux ACIA from DCB 
00001526  2251                     654           MOVE.L  (A1),A1         Get address of aux ACIA 
00001528  0811 0001                655  AUX_OT1  BTST.B  #1,(A1)         Test for ready to transmit 
0000152C  67FA                     656           BEQ     AUX_OT1         Repeat until transmitter ready 
0000152E  1340 0002                657           MOVE.B  D0,2(A1)        Transmit data 
00001532  4E75                     658           RTS 
00001534                           659  * 
00001534                           660  ************************************************************************* 
00001534                           661  * 
00001534                           662  *  GETCHAR gets a character from the console device 
00001534                           663  *  This is the main input routine and uses the device whose name  
00001534                           664  *  is stored in CN_IVEC. Changing this name redirects input. 
00001534                           665  * 
00001534  2F08                     666  GETCHAR  MOVE.L  A0,-(A7)        Save working register 
00001536  206E 0452                667           MOVE.L  CN_IVEC(A6),A0  A0 points to name of console DCB 
0000153A  6156                     668           BSR.S   IO_OPEN         Open console (get DCB address in A0) 
0000153C  0807 0003                669           BTST    #3,D7           D7(3) set if open error 
00001540  661E                     670           BNE.S   GETCH3          If error then exit now 
00001542  618E                     671           BSR     IO_REQ          Else execute I/O transaction 
00001544  C03C 007F                672           AND.B   #$7F,D0         Strip msb of input 
00001548  4A2E 044D                673           TST.B   U_CASE(A6)      Test for upper -> lower case conversion 
0000154C  660A                     674           BNE.S   GETCH2          If flag not zero do not convert case 
0000154E  0800 0006                675           BTST    #6,D0             Test input for lower case 
00001552  6704                     676           BEQ.S   GETCH2          If upper case then skip conversion 
00001554  C03C 00DF                677           AND.B   #%11011111,D0   Else clear bit 5 for upper case conv 
00001558  4A2E 044C                678  GETCH2   TST.B   ECHO(A6)        Do we need to echo the input? 
0000155C  6602                     679           BNE.S   GETCH3          If ECHO not zero then no echo 
0000155E  6104                     680           BSR.S   PUTCHAR         Else echo the input 
00001560  205F                     681  GETCH3   MOVE.L  (A7)+,A0        Restore working register 
00001562  4E75                     682           RTS                     and return 
00001564                           683  * 
00001564                           684  ************************************************************************* 
00001564                           685  * 
00001564                           686  *  PUTCHAR sends a character to the console device 
00001564                           687  *  The name of the output device is in CN_OVEC. 
00001564                           688  * 
00001564  BC3C 0001                689  PUTCHAR  CMP.B   #1,D6
00001568                           690           *BEQ     PUTASK
00001568  2F08                     691           MOVE.L  A0,-(A7)        Save working register
0000156A  206E 0456                692           MOVE.L  CN_OVEC(A6),A0  A0 points to name of console output 
0000156E  6122                     693           BSR.S   IO_OPEN         Open console (Get address of DCB) 
00001570  6100 FF60                694           BSR     IO_REQ          Perform output with DCB pointed at by A0 
00001574  205F                     695           MOVE.L  (A7)+,A0        Restore working register 
00001576  4E75                     696           RTS 
00001578                           697  
00001578                           698  *PUTASK   MOVE    D0,-(A5)
00001578                           699  *         MOVE    #'*',D0
00001578                           700  *         MOVE.L  A0,-(A7)        Save working register
00001578                           701  *         MOVE.L  CN_OVEC(A6),A0  A0 points to name of console output 
00001578                           702  *         BSR.S   IO_OPEN         Open console (Get address of DCB) 
00001578                           703  *         BSR     IO_REQ          Perform output with DCB pointed at by A0 
00001578                           704  *         MOVE.L  (A7)+,A0        Restore working register
00001578                           705  *         MOVE    (A5)+,D0
00001578                           706  *         RTS 
00001578                           707  * 
00001578                           708  ************************************************************************* 
00001578                           709  * 
00001578                           710  *  BUFF_IN and BUFF_OUT are two rudimentary input and output routines 
00001578                           711  *  which input data from and output data to a buffer in RAM. These are 
00001578                           712  *  used by DCB5 and DCB6, respectively. 
00001578                           713  * 
00001578  43E8 000C                714  BUFF_IN  LEA.L   12(A0),A1       A1 points to I/P buffer 
0000157C  2451                     715           MOVE.L  (A1),A2         A2 gets I/P pointer from buffer 
0000157E  1022                     716           MOVE.B  -(A2),D0        Read char from buffer and adjust A2 
00001580  228A                     717           MOVE.L  A2,(A1)         Restore pointer in buffer 
00001582  4E75                     718           RTS 
00001584                           719  * 
00001584  43E8 000C                720  BUFF_OT  LEA.L   12(A0),A1       A1 points to O/P buffer 
00001588  2469 0004                721           MOVE.L  4(A1),A2        A2 gets O/P pointer from buffer 
0000158C  14C0                     722           MOVE.B  D0,(A2)+        Store char in buffer and adjust A2 
0000158E  228A                     723           MOVE.L  A2,(A1)         Restore pointer in buffer 
00001590  4E75                     724           RTS 
00001592                           725  * 
00001592                           726  ************************************************************************* 
00001592                           727  * 
00001592                           728  *  Open - opens a DCB for input or output. IO_OPEN converts the 
00001592                           729  *  name pointed at by A0 into the address of the DCB pointed at 
00001592                           730  *  by A0. Bit 3 of D7 is set to zero if DCB not found 
00001592                           731  * 
00001592  48E7 F870                732  IO_OPEN  MOVEM.L  A1-A3/D0-D4,-(A7) Save working registers 
00001596  43EE 04D4                733           LEA.L    FIRST(A6),A1   A1 points to first DCB in chain in RAM 
0000159A  45D1                     734  OPEN1    LEA.L    (A1),A2        A2 = temp copy of pointer to DCB 
0000159C  47D0                     735           LEA.L    (A0),A3        A3 = temp copy of pointer to DCB name 
0000159E  303C 0007                736           MOVE.W   #7,D0          Up to 8 chars of DCB name to match 
000015A2  181A                     737  OPEN2    MOVE.B   (A2)+,D4       Compare DCB name with string 
000015A4  B81B                     738           CMP.B    (A3)+,D4 
000015A6  6608                     739           BNE.S    OPEN3          If no match try next DCB 
000015A8  51C8 FFF8                740           DBRA     D0,OPEN2       Else repeat until all chars matched 
000015AC  41D1                     741           LEA.L    (A1),A0        Success - move this DCB address to A0 
000015AE  6016                     742           BRA.S    OPEN4          and return 
000015B0  =000015B0                743  OPEN3    EQU      *              Fail - calculate address of next DCB 
000015B0  3229 0010                744           MOVE.W   16(A1),D1      Get parameter block size of DCB 
000015B4  43F1 1012                745           LEA.L    18(A1,D1.W),A1 A1 points to pointer to next DCB 
000015B8  2251                     746           MOVE.L   (A1),A1        A1 now points to next DCB 
000015BA  B3FC 00000000            747           CMP.L    #0,A1          Test for end of DCB chain 
000015C0  66D8                     748           BNE      OPEN1          If not end of chain then try next DCB 
000015C2  8E3C 0008                749           OR.B     #8,D7          Else set error flag and return 
000015C6  4CDF 0E1F                750  OPEN4    MOVEM.L  (A7)+,A1-A3/D0-D4 Restore working registers 
000015CA  4E75                     751           RTS 
000015CC                           752  * 
000015CC                           753  ************************************************************************* 
000015CC                           754  * 
000015CC                           755  *  Exception vector table initialization routine 
000015CC                           756  *  All vectors not setup are loaded with uninitialized routine vector 
000015CC                           757  * 
000015CC  303C 0007                758  X_SET   MOVE.W  #7,D0             Now clear the breakpoint table 
000015D0  41EE 04A4                759          LEA.L   BP_TAB(A6),A0     Point to table 
000015D4  4298                     760  X_SET2  CLR.L   (A0)+             Clear an address entry 
000015D6  4258                     761          CLR.W   (A0)+             Clear the corresponding data 
000015D8  51C8 FFFA                762          DBRA    D0,X_SET2         Repeat until all 8 cleared 
000015DC  4E75                     763          RTS 
000015DE                           764  * 
000015DE                           765  *************************************************************************
000015DE  DA04                     766  ADD_0   ADD.B     D4,D5
000015E0  1605                     767          MOVE.B    D5,D3
000015E2  183C 0000                768          MOVE.B    #0,D4           resetting neg flag
000015E6  6B00 003A                769          BMI       SETNEG
000015EA  4E75                     770          RTS
000015EC                           771  
000015EC  9A04                     772  SUB_0   SUB.B     D4,D5
000015EE  1605                     773          MOVE.B    D5,D3
000015F0  183C 0000                774          MOVE.B    #0,D4           resetting neg flag
000015F4  6B00 002C                775          BMI       SETNEG
000015F8  4E75                     776          RTS
000015FA                           777          
000015FA  CBC4                     778  MUL_0   MULS      D4,D5
000015FC  383C 0000                779          MOVE.W    #0,D4           resetting neg flag
00001600  2605                     780          MOVE.L    D5,D3
00001602  6B00 0024                781          BMI       MULNEG
00001606  4E75                     782          RTS
00001608                           783  
00001608  8BC4                     784  DIV_0   DIVS      D4,D5
0000160A  183C 0000                785          MOVE.B    #0,D4           resetting neg flag
0000160E  1605                     786          MOVE.B    D5,D3
00001610  4603                     787          NOT.B     D3
00001612  C63C 007F                788          AND.B     #%01111111,D3
00001616  5203                     789          ADD.B     #1,D3
00001618  BA7C 007F                790          CMP.W     #127,D5
0000161C  6500 0004                791          BCS       SETNEG
00001620  4E75                     792          RTS
00001622                           793  
00001622  183C 0001                794  SETNEG  MOVE.B    #1,D4
00001626  4E75                     795          RTS
00001628                           796  
00001628  183C 0001                797  MULNEG  MOVE.B    #1,D4
0000162C  4683                     798          NOT.L     D3
0000162E  C6BC 7FFFFFFF            799          AND.L     #%01111111111111111111111111111111,D3
00001634  5203                     800          ADD.B     #1,D3
00001636  4E75                     801          RTS
00001638                           802  
00001638                           803  * 
00001638                           804  ************************************************************************* 
00001638                           805  * 
00001638  =00001638                806  TRAP_0  EQU     *                 User links to  TS2BUG via TRAP #0 
00001638  B23C 0000                807          CMP.B   #0,D1             D1 = 0 = Get character 
0000163C  6606                     808          BNE.S   FOO1           
0000163E  6100 FEF4                809          BSR     GETCHAR 
00001642  4E73                     810          RTE 
00001644  B23C 0001                811  FOO1    CMP.B   #1,D1             D1 = 1 = Print character 
00001648  6606                     812          BNE.S   FOO2 
0000164A  6100 FF18                813          BSR     PUTCHAR 
0000164E  4E73                     814          RTE 
00001650  B23C 0002                815  FOO2    CMP.B   #2,D1             D1 = 2 = Newline 
00001654  6606                     816          BNE.S   FOO3 
00001656  6100 FA2E                817          BSR     NEWLINE 
0000165A  4E73                     818          RTE 
0000165C  B23C 0003                819  FOO3    CMP.B   #3,D1             D1 = 3 = Get parameter from buffer 
00001660  6606                     820          BNE.S   FOO4 
00001662  6100 FB66                821          BSR     PARAM 
00001666  4E73                     822          RTE 
00001668  B23C 0004                823  FOO4    CMP.B   #4,D1             D1 = 4 = Print string pointed at by A4 
0000166C  6606                     824          BNE.S   FOO5 
0000166E  6100 FA26                825          BSR     PSTRING 
00001672  4E73                     826          RTE 
00001674  B23C 0005                827  FOO5    CMP.B   #5,D1             D1 = 5 = Get a hex character 
00001678  6606                     828          BNE.S   FOO6 
0000167A  6100 FB14                829          BSR     HEX 
0000167E  4E73                     830          RTE 
00001680  B23C 0006                831  FOO6    CMP.B   #6,D1             D1 = 6 = Get a hex byte 
00001684  6606                     832          BNE.S   FOO7 
00001686  6100 FB26                833          BSR     BYTE 
0000168A  4E73                     834          RTE 
0000168C  B23C 0007                835  FOO7    CMP.B   #7,D1             D1 = 7 = Get a word 
00001690  6606                     836          BNE.S   FOO8 
00001692  6100 FB2A                837          BSR     WORD 
00001696  4E73                     838          RTE 
00001698  B23C 0008                839  FOO8    CMP.B   #8,D1             D1 = 8 = Get a longword 
0000169C  6606                     840          BNE.S   FOO9 
0000169E  6100 FB24                841          BSR     LONGWD 
000016A2  4E73                     842          RTE 
000016A4  B23C 0009                843  FOO9    CMP.B   #9,D1             D1 = 9 = Output hex byte 
000016A8  6606                     844          BNE.S   FOO10  
000016AA  6100 FB7C                845          BSR     OUT2X 
000016AE  4E73                     846          RTE 
000016B0  B23C 000A                847  FOO10   CMP.B   #10,D1            D1 = 10 = Output hex word 
000016B4  6606                     848          BNE.S   FOO11 
000016B6  6100 FB78                849          BSR     OUT4X 
000016BA  4E73                     850          RTE 
000016BC  B23C 000B                851  FOO11   CMP.B   #11,D1            D1 = 11 = Output hex longword 
000016C0  6606                     852          BNE.S   FOO12 
000016C2  6100 FB74                853          BSR     OUT8X 
000016C6  4E73                     854          RTE 
000016C8  B23C 000C                855  FOO12   CMP.B   #12,D1            D1 = 12 = Print a space 
000016CC  6606                     856          BNE.S   FOO13 
000016CE  6100 FBD8                857          BSR     PSPACE 
000016D2  4E73                     858          RTE 
000016D4  B23C 000D                859  FOO13   CMP.B   #13,D1            D1 = 13 = Get a line of text into 
000016D8  6606                     860          BNE.S   FOO14            the line buffer 
000016DA  6100 F9D0                861          BSR     GETLINE 
000016DE  4E73                     862          RTE 
000016E0  B23C 000E                863  FOO14   CMP.B   #14,D1            D1 = 14 = Tidy up the line in the 
000016E4  6606                     864          BNE.S   FOO15            line buffer by removing leading 
000016E6  6100 F9FA                865          BSR     TIDY              leading and multiple embeded spaces 
000016EA  4E73                     866          RTE 
000016EC  B23C 000F                867  FOO15   CMP.B   #15,D1            D1 = 15 = Execute the command in 
000016F0  6606                     868          BNE.S   FOO16            the line buffer 
000016F2  6100 FA30                869          BSR     EXECUTE 
000016F6  4E73                     870          RTE 
000016F8  B23C 0010                871  FOO16   CMP.B   #16,D1            D1 = 16 = Call RESTORE to transfer 
000016FC  6606                     872          BNE.S   FOO17            the registers in TSK_T to the 68000 
000016FE  6100 035C                873          BSR     RESTORE           and therefore execute a program 
00001702  4E73                     874          RTE 
00001704  B23C 0011                875  FOO17   CMP.B   #17,D1            D1 = 17 = Call ADD_0
00001708  6606                     876          BNE.S   FOO18            
0000170A  6100 FED2                877          BSR     ADD_0            
0000170E  4E73                     878          RTE 
00001710  B23C 0012                879  FOO18   CMP.B   #18,D1            D1 = 18 = Call SUB_0
00001714  6606                     880          BNE.S   FOO19            
00001716  6100 FED4                881          BSR     SUB_0            
0000171A  4E73                     882          RTE 
0000171C  B23C 0013                883  FOO19   CMP.B   #19,D1            D1 = 19 = Call MUL_0
00001720  6606                     884          BNE.S   FOO20            
00001722  6100 FED6                885          BSR     MUL_0            
00001726  4E73                     886          RTE 
00001728  B23C 0014                887  FOO20   CMP.B   #20,D1            D1 = 20 = Call DIV_0
0000172C  6606                     888          BNE.S   FOO21            
0000172E  6100 FED8                889          BSR     DIV_0            
00001732  4E73                     890          RTE
00001734  4E73                     891  FOO21   RTE         
00001736                           892  * 
00001736                           893  
00001736                           894  ************************************************************************* 
00001736                           895  * 
00001736                           896  *  Display exception frame (D0 - D7, A0 - A6, USP, SSP, SR, PC) 
00001736                           897  *  EX_DIS prints registers saved after a breakpoint or exception 
00001736                           898  *  The registers are saved in TSK_T 
00001736                           899  * 
00001736  4BEE 045A                900  EX_DIS  LEA.L   TSK_T(A6),A5      A5 points to display frame 
0000173A  49FA 056C                901          LEA.L   MES3(PC),A4       Point to heading 
0000173E  6100 F966                902          BSR     HEADING           and print it 
00001742  3C3C 0007                903          MOVE.W  #7,D6             8 pairs of registers to display 
00001746  4205                     904          CLR.B   D5                D5 is the line counter 
00001748  1005                     905  EX_D1   MOVE.B  D5,D0             Put current register number in D0 
0000174A  6100 FAC2                906          BSR     OUT1X             and print it 
0000174E  6100 FB58                907          BSR     PSPACE            and a space 
00001752  5205                     908          ADD.B   #1,D5             Update counter for next pair 
00001754  2015                     909          MOVE.L  (A5),D0           Get data register to be displayed 
00001756  6100 FAE0                910          BSR     OUT8X             from the frame and print it 
0000175A  49FA 056A                911          LEA.L   MES4(PC),A4       Print string of spaces 
0000175E  6100 F936                912          BSR.L   PSTRING           between data and address registers 
00001762  202D 0020                913          MOVE.L  32(A5),D0         Get address register to be displayed 
00001766  6100 FAD0                914          BSR     OUT8X             which is 32 bytes on from data reg 
0000176A  6100 F91A                915          BSR     NEWLINE 
0000176E  4BED 0004                916          LEA.L   4(A5),A5          Point to next pair (ie Di, Ai) 
00001772  51CE FFD4                917          DBRA    D6,EX_D1          Repeat until all displayed 
00001776  4BED 0020                918          LEA.L   32(A5),A5         Adjust pointer by 8 longwords 
0000177A  6100 F90A                919          BSR     NEWLINE           to point to SSP 
0000177E  49FA 051F                920          LEA.L   MES2A(PC),A4      Point to "SS =" 
00001782  6100 F912                921          BSR     PSTRING           Print it 
00001786  201D                     922          MOVE.L  (A5)+,D0          Get SSP from frame 
00001788  6100 FAAE                923          BSR     OUT8X             and display it 
0000178C  6100 F8F8                924          BSR     NEWLINE 
00001790  49FA 04FB                925          LEA.L   MES1(PC),A4       Point to 'SR =' 
00001794  6100 F900                926          BSR     PSTRING           Print it 
00001798  301D                     927          MOVE.W  (A5)+,D0          Get status register 
0000179A  6100 FA94                928          BSR     OUT4X             Display status 
0000179E  6100 F8E6                929          BSR     NEWLINE 
000017A2  49FA 04F2                930          LEA.L   MES2(PC),A4       Point to 'PC =' 
000017A6  6100 F8EE                931          BSR     PSTRING           Print it 
000017AA  201D                     932          MOVE.L  (A5)+,D0          Get PC 
000017AC  6100 FA8A                933          BSR     OUT8X             Display PC 
000017B0  6000 F8D4                934          BRA     NEWLINE           Newline and return 
000017B4                           935  * 
000017B4                           936  ************************************************************************* 
000017B4  49F9 00001DEB            937  HELP     LEA.L    JUMPHELP,A4
000017BA  6100 F8DA                938           BSR.W    PSTRING
000017BE  6100 F8C6                939           BSR.W    NEWLINE
000017C2  49F9 00001E21            940           LEA.L    MEMHELP,A4
000017C8  6100 F8CC                941           BSR.W    PSTRING
000017CC  6100 F8B8                942           BSR.W    NEWLINE
000017D0  49F9 00001E6E            943           LEA.L    LOADHELP,A4
000017D6  6100 F8BE                944           BSR.W    PSTRING
000017DA  6100 F8AA                945           BSR.W    NEWLINE
000017DE  49F9 00001EB8            946           LEA.L    TVHELP,A4
000017E4  6100 F8B0                947           BSR.W    PSTRING
000017E8  4E75                     948           RTS
000017EA                           949  *      
000017EA                           950  *************************************************************************
000017EA  B83C 0003                951  LOGIN    CMP.B    #3,D4
000017EE  6700 00C2                952           BEQ      QUIT
000017F2  49F9 00001F25            953           LEA.L    LOGINM1,A4
000017F8  6100 F89C                954           BSR.W    PSTRING           
000017FC  6100 F888                955           BSR.W    NEWLINE
00001800  6100 F8AA                956           BSR      GETLINE
00001804  49F9 00001F17            957           LEA.L    UNAME,A4
0000180A  1A19                     958  LOGIN1   MOVE.B   (A1)+,D5
0000180C  BA1C                     959           CMP.B    (A4)+,D5
0000180E  67FA                     960           BEQ      LOGIN1            iterate through checking each char
00001810  0C21 000D                961           CMP.B    #CR,-(A1)         check for carriage return
00001814  6600 006A                962           BNE      WRONG             if not then wrong input
00001818  0C24 0000                963           CMP.B    #NUL,-(A4)        check for end of stored string
0000181C  6600 0062                964           BNE      WRONG             if not then wrong input
00001820  49F9 00001F5A            965           LEA.L    USRSUC,A4         print success
00001826  6100 F86E                966           BSR.W    PSTRING
0000182A  6100 F85A                967           BSR.W    NEWLINE
0000182E  49F9 00001F36            968           LEA.L    LOGINM2,A4
00001834  6100 F860                969           BSR.W    PSTRING
00001838  6100 F84C                970           BSR.W    NEWLINE
0000183C  1C3C 0001                971           MOVE.B   #1,D6
00001840  6100 F86A                972           BSR.W    GETLINE
00001844  1C3C 0000                973           MOVE.B   #0,D6
00001848  49F9 00001F1C            974           LEA.L    PWORD,A4
0000184E  1A19                     975  LOGIN2   MOVE.B   (A1)+,D5
00001850  BA1C                     976           CMP.B    (A4)+,D5
00001852  67FA                     977           BEQ      LOGIN2            iterate through checking each char
00001854  0C21 000D                978           CMP.B    #CR,-(A1)          check for carriage return
00001858  6600 0026                979           BNE      WRONG             if not then wrong input
0000185C  0C24 0000                980           CMP.B    #NUL,-(A4)            check for end of stored string
00001860  6600 0032                981           BNE      WRONGPW             if not then wrong input
00001864  49F9 00001F7E            982           LEA.L    PWSUC,A4
0000186A  6000 F82A                983           BRA      PSTRING
0000186E  49F9 00001F25            984           LEA.L    LOGINM1,A4
00001874  6100 F820                985           BSR.W    PSTRING           print success
00001878  6100 F80C                986           BSR.W    NEWLINE
0000187C  6000 F7F8                987           BRA      WARM
00001880                           988  
00001880  49F9 00001F47            989  WRONG    LEA.L    USRERR,A4   
00001886  6100 F80E                990           BSR.W    PSTRING
0000188A  6100 F7FA                991           BSR.W    NEWLINE
0000188E  5204                     992           ADD.B    #1,D4
00001890  6000 FF58                993           BRA      LOGIN
00001894                           994  
00001894  49F9 00001F6B            995  WRONGPW  LEA.L    PWERR,A4   
0000189A  6100 F7FA                996           BSR.W    PSTRING
0000189E  6100 F7E6                997           BSR.W    NEWLINE
000018A2  5204                     998           ADD.B    #1,D4
000018A4  6000 FF44                999           BRA      LOGIN
000018A8                          1000  
000018A8  49F9 00001F5A           1001  UPASS    LEA.L    USRSUC,A4
000018AE  6000 F7E6               1002           BRA      PSTRING  
000018B2                          1003  
000018B2  4EF8 18B2               1004  QUIT     JMP      QUIT
000018B6                          1005  *
000018B6                          1006  ************************************************************************* 
000018B6  2878 07D4               1007  TV       MOVE.L   MIN_RAM,A4
000018BA  1C3C 0000               1008           MOVE.B   #0,D6
000018BE  323C 0000               1009  LOOPRAM  MOVE.W   #0,D1
000018C2  3881                    1010           MOVE.W   D1,(A4)
000018C4  49EC 0002               1011           LEA.L    2(A4),A4          Point to next address to display
000018C8  B9F8 07D8               1012           CMP.L    MAX_RAM,A4
000018CC  66F0                    1013           BNE      LOOPRAM
000018CE  2878 07D4               1014           MOVE.L   MIN_RAM,A4
000018D2  3214                    1015  CHECK1   MOVE.W   (A4),D1
000018D4  B27C 0000               1016           CMP.W    #0,D1
000018D8  6600 0042               1017           BNE      MEMFAIL
000018DC  49EC 0002               1018  CHECK2   LEA.L    2(A4),A4          Point to next address to read
000018E0  B9F8 07D8               1019           CMP.L    MAX_RAM,A4
000018E4  66EC                    1020           BNE      CHECK1
000018E6  2878 07D4               1021           MOVE.L   MIN_RAM,A4
000018EA  323C FFFF               1022  LOOPRAM1 MOVE.W   #65535,D1
000018EE  3881                    1023           MOVE.W   D1,(A4)
000018F0  49EC 0002               1024           LEA.L    2(A4),A4          Point to next address to display
000018F4  B9F8 07D8               1025           CMP.L    MAX_RAM,A4
000018F8  66F0                    1026           BNE      LOOPRAM1
000018FA  2878 07D4               1027           MOVE.L   MIN_RAM,A4
000018FE  3214                    1028  CHECK3   MOVE.W   (A4),D1
00001900  B27C FFFF               1029           CMP.W    #65535,D1
00001904  6600 0032               1030           BNE      MEMFAIL2
00001908  49EC 0002               1031  CHECK4   LEA.L    2(A4),A4          Point to next address to read
0000190C  B9F8 07D8               1032           CMP.L    MAX_RAM,A4
00001910  66EC                    1033           BNE      CHECK3
00001912  BC3C 0000               1034           CMP.B    #0,D6
00001916  6700 003C               1035           BEQ      MEMGOOD
0000191A  4E75                    1036           RTS
0000191C                          1037  
0000191C  2F0C                    1038  MEMFAIL  MOVE.L  A4,-(A7)          Save A4 
0000191E  7C01                    1039           MOVE.L  #1,D6
00001920  6100 F764               1040           BSR.W   NEWLINE
00001924  49F9 00001F8F           1041           LEA.L   MEMFMSG,A4
0000192A  6100 F76A               1042           BSR.W   PSTRING
0000192E  285F                    1043           MOVE.L  (A7)+,A4          Restore A4
00001930  200C                    1044           MOVE.L  A4,D0
00001932  6100 F904               1045           BSR.W    OUT8X 
00001936  60A4                    1046           BRA     CHECK2
00001938                          1047  
00001938  2F0C                    1048  MEMFAIL2 MOVE.L  A4,-(A7)          Save A4 
0000193A  7C01                    1049           MOVE.L  #1,D6
0000193C  6100 F748               1050           BSR.W   NEWLINE
00001940  49F9 00001F8F           1051           LEA.L   MEMFMSG,A4
00001946  6100 F74E               1052           BSR.W   PSTRING
0000194A  285F                    1053           MOVE.L  (A7)+,A4          Restore A4
0000194C  200C                    1054           MOVE.L  A4,D0
0000194E  6100 F8E8               1055           BSR.W    OUT8X 
00001952  60B4                    1056           BRA     CHECK4         
00001954                          1057   
00001954  49F9 00001F9F           1058  MEMGOOD  LEA.L  MEMGMSG,A4
0000195A  6100 F73A               1059           BSR.W  PSTRING
0000195E  4E75                    1060           RTS
00001960                          1061  
00001960                          1062  *************************************************************************         
00001960                          1063  * 
00001960                          1064  *  Exception handling routines 
00001960                          1065  * 
00001960  =00001960               1066  IL_ER   EQU      *                Illegal instruction exception 
00001960  2F0C                    1067          MOVE.L  A4,-(A7)          Save A4 
00001962  49FA 038C               1068          LEA.L   MES10(PC),A4      Point to heading 
00001966  6100 F73E               1069          BSR     HEADING           Print it 
0000196A  285F                    1070          MOVE.L  (A7)+,A4          Restore A4 
0000196C  6100 009C               1071          BSR.W   GROUP2            Save registers in display frame 
00001970  6100 FDC4               1072          BSR     EX_DIS            Display registers saved in frame 
00001974  6000 F700               1073          BRA     WARM              Abort from illegal instruction 
00001978                          1074  * 
00001978  =00001978               1075  BUS_ER  EQU     *                 Bus error (group 1) exception 
00001978  2F0C                    1076          MOVE.L  A4,-(A7)          Save A4 
0000197A  49FA 0354               1077          LEA.L   MES8(PC),A4       Point to heading 
0000197E  6100 F726               1078          BSR     HEADING           Print it 
00001982  285F                    1079          MOVE.L  (A7)+,A4          Restore A4 
00001984  6050                    1080          BRA.S   GROUP1            Deal with group 1 exception 
00001986                          1081  * 
00001986  =00001986               1082  ADD_ER  EQU     *                 Address error (group 1) exception 
00001986  2F0C                    1083          MOVE.L  A4,-(A7)          Save A4 
00001988  49FA 0354               1084          LEA.L   MES9(PC),A4       Point to heading 
0000198C  6100 F718               1085          BSR     HEADING           Print it 
00001990  285F                    1086          MOVE.L  (A7)+,A4          Restore A4 
00001992  6042                    1087          BRA.S   GROUP1            Deal with group 1 exception 
00001994                          1088  * 
00001994  =00001994               1089  DIV0_ER  EQU     *                   Divide By Zero Exception
00001994  2F0C                    1090          MOVE.L  A4,-(A7)          Save A4 
00001996  49FA 0385               1091          LEA.L   MES13(PC),A4       Point to heading 
0000199A  6100 F70A               1092          BSR     HEADING           Print it 
0000199E  285F                    1093          MOVE.L  (A7)+,A4          Restore A4 
000019A0  6034                    1094          BRA.S   GROUP1            Deal with group 1 exception 
000019A2                          1095  *
000019A2  =000019A2               1096  PRIV_ER   EQU     *                 Privilege Violation Exception
000019A2  2F0C                    1097          MOVE.L  A4,-(A7)          Save A4 
000019A4  49FA 038C               1098          LEA.L   MES14(PC),A4      Point to heading 
000019A8  6100 F6FC               1099          BSR     HEADING           Print it 
000019AC  285F                    1100          MOVE.L  (A7)+,A4          Restore A4
000019AE  6100 FD86               1101          BSR     EX_dis
000019B2  6000 F6C2               1102          BRA     WARM
000019B6  601E                    1103          BRA.S   GROUP1            Deal with group 1 exception 
000019B8                          1104  * 
000019B8  =000019B8               1105  BRKPT   EQU     *                   Deal with breakpoint 
000019B8  48E7 FFFE               1106          MOVEM.L D0-D7/A0-A6,-(A7)   Save all registers 
000019BC  6100 0180               1107          BSR     BR_CLR              Clear breakpoints in code 
000019C0  4CDF 7FFF               1108          MOVEM.L (A7)+,D0-D7/A0-A6   Restore registers 
000019C4  6144                    1109          BSR.S   GROUP2            Treat as group 2 exception 
000019C6  49FA 033E               1110          LEA.L   MES11(PC),A4      Point to heading 
000019CA  6100 F6DA               1111          BSR     HEADING           Print it 
000019CE  6100 FD66               1112          BSR     EX_DIS            Display saved registers 
000019D2  6000 F6A2               1113          BRA     WARM              Return to monitor 
000019D6                          1114  
000019D6                          1115  * 
000019D6                          1116  *       GROUP1 is called by address and bus error exceptions 
000019D6                          1117  *       These are "turned into group 2" exceptions (eg TRAP) 
000019D6                          1118  *       by modifying the stack frame saved by a group 1 exception 
000019D6                          1119  * 
000019D6  48E7 8080               1120  GROUP1  MOVEM.L D0/A0,-(A7)       Save working registers 
000019DA  206F 0012               1121          MOVE.L  18(A7),A0         Get PC from group 1 stack frame 
000019DE  302F 000E               1122          MOVE.W  14(A7),D0         Get instruction from stack frame 
000019E2  B060                    1123          CMP.W   -(A0),D0          Now backtrack to find the "correct PC" 
000019E4  670E                    1124          BEQ.S   GROUP1A           by matching the op-code on the stack 
000019E6  B060                    1125          CMP.W   -(A0),D0          with the code in the region of the 
000019E8  670A                    1126          BEQ.S   GROUP1A           PC on the stack 
000019EA  B060                    1127          CMP.W   -(A0),D0 
000019EC  6706                    1128          BEQ.S   GROUP1A 
000019EE  B060                    1129          CMP.W   -(A0),D0 
000019F0  6702                    1130          BEQ.S   GROUP1A 
000019F2  5588                    1131          SUBQ.L  #2,A0 
000019F4  2F48 0012               1132  GROUP1A MOVE.L  A0,18(A7)          Restore modified PC to stack frame 
000019F8  4CDF 0101               1133          MOVEM.L (A7)+,D0/A0        Restore working registers 
000019FC  4FEF 0008               1134          LEA.L   8(A7),A7           Adjust stack pointer to group 1 type 
00001A00  6108                    1135          BSR.S   GROUP2             Now treat as group 1 exception 
00001A02  6100 FD32               1136          BSR     EX_DIS             Display contents of exception frame 
00001A06  6000 F66E               1137          BRA     WARM               Exit to monitor - no RTE from group 2 
00001A0A                          1138  * 
00001A0A  =00001A0A               1139  GROUP2  EQU     *                 Deal with group 2 exceptions 
00001A0A  48E7 FFFF               1140          MOVEM.L A0-A7/D0-D7,-(A7) Save all registers on the stack 
00001A0E  303C 000E               1141          MOVE.W  #14,D0            Transfer D0 - D7, A0 - A6 from 
00001A12  41EE 045A               1142          LEA.L   TSK_T(A6),A0      the stack to the display frame 
00001A16  20DF                    1143  GROUP2A MOVE.L  (A7)+,(A0)+       Move a register from stack to frame 
00001A18  51C8 FFFC               1144          DBRA    D0,GROUP2A        and repeat until D0-D7/A0-A6 moved 
00001A1C  4E6A                    1145          MOVE.L  USP,A2            Get the user stack pointer and put it 
00001A1E  20CA                    1146          MOVE.L  A2,(A0)+          in the A7 position in the frame 
00001A20  201F                    1147          MOVE.L  (A7)+,D0          Now transfer the SSP to the frame, 
00001A22  0480 0000000A           1148          SUB.L   #10,D0            remembering to account for the 
00001A28  20C0                    1149          MOVE.L  D0,(A0)+          data pushed on the stack to this point 
00001A2A  225F                    1150          MOVE.L  (A7)+,A1          Copy TOS (return address) to A1 
00001A2C  30DF                    1151          MOVE.W  (A7)+,(A0)+       Move SR to display frame 
00001A2E  201F                    1152          MOVE.L  (A7)+,D0          Get PC in D0 
00001A30  5580                    1153          SUBQ.L  #2,D0             Move back to current instruction 
00001A32  20C0                    1154          MOVE.L  D0,(A0)+          Put adjusted PC in display frame 
00001A34  4ED1                    1155          JMP     (A1)              Return from subroutine 
00001A36                          1156  * 
00001A36                          1157  ************************************************************************* 
00001A36                          1158  * 
00001A36                          1159  *  GO executes a program either from a supplied address or 
00001A36                          1160  *  by using the data in the display frame 
00001A36  6100 F792               1161  GO       BSR     PARAM               Get entry address (if any) 
00001A3A  4A07                    1162           TST.B   D7                  Test for error in input 
00001A3C  6708                    1163           BEQ.S   GO1                 If D7 zero then OK 
00001A3E  49FA 032B               1164           LEA.L   ERMES1(PC),A4       Else point to error message, 
00001A42  6000 F652               1165           BRA     PSTRING             print it and return 
00001A46  4A80                    1166  GO1      TST.L   D0                  If no address entered then get 
00001A48  670A                    1167           BEQ.S   GO2                 address from display frame 
00001A4A  2D40 04A0               1168           MOVE.L  D0,TSK_T+70(A6)     Else save address in display frame 
00001A4E  3D7C 0700 049E          1169           MOVE.W  #$0700,TSK_T+68(A6) Store dummy status in frame 
00001A54  6006                    1170  GO2      BRA.S   RESTORE             Restore volatile environment and go 
00001A56                          1171  * 
00001A56  6100 007A               1172  GB       BSR     BR_SET              Same as go but presets breakpoints 
00001A5A  60DA                    1173           BRA.S   GO                  Execute program 
00001A5C                          1174  * 
00001A5C                          1175  *        RESTORE moves the volatile environment from the display 
00001A5C                          1176  *        frame and transfers it to the 68000's registers. This 
00001A5C                          1177  *        re-runs a program suspended after an exception 
00001A5C                          1178  * 
00001A5C  47EE 045A               1179  RESTORE  LEA.L   TSK_T(A6),A3        A3 points to display frame 
00001A60  47EB 004A               1180           LEA.L   74(A3),A3           A3 now points to end of frame + 4 
00001A64  4FEF 0004               1181           LEA.L   4(A7),A7            Remove return address from stack 
00001A68  303C 0024               1182           MOVE.W  #36,D0              Counter for 37 words to be moved 
00001A6C  3F23                    1183  REST1    MOVE.W  -(A3),-(A7)         Move word from display frame to stack 
00001A6E  51C8 FFFC               1184           DBRA    D0,REST1            Repeat until entire frame moved 
00001A72  4CDF 00FF               1185           MOVEM.L (A7)+,D0-D7         Restore old data registers from stack 
00001A76  4CDF 7F00               1186           MOVEM.L (A7)+,A0-A6         Restore old address registers 
00001A7A  4FEF 0008               1187           LEA.L   8(A7),A7            Except SSP/USP - so adjust stack 
00001A7E  4E73                    1188           RTE                         Return from exception to run program 
00001A80                          1189  * 
00001A80  =00001A80               1190  TRACE    EQU     *                   TRACE exception (rudimentary version) 
00001A80  287A 0292               1191           MOVE.L  MES12(PC),A4        Point to heading 
00001A84  6100 F620               1192           BSR     HEADING             Print it 
00001A88  6100 FF4C               1193           BSR     GROUP1              Save volatile environment 
00001A8C  6100 FCA8               1194           BSR     EX_DIS              Display it 
00001A90  6000 F5E4               1195           BRA     WARM                Return to monitor 
00001A94                          1196  * 
00001A94                          1197  ************************************************************************* 
00001A94                          1198  *  Breakpoint routines: BR_GET gets the address of a breakpoint and 
00001A94                          1199  *  puts it in the breakpoint table. It does not plant it in the code. 
00001A94                          1200  *  BR_SET plants all breakpoints in the code. NOBR removes one or all 
00001A94                          1201  *  breakpoints from the table. KILL removes breakpoints from the code. 
00001A94                          1202  * 
00001A94  6100 F734               1203  BR_GET   BSR     PARAM               Get breakpoint address in table 
00001A98  4A07                    1204           TST.B   D7                  Test for input error 
00001A9A  6708                    1205           BEQ.S   BR_GET1             If no error then continue 
00001A9C  49FA 02CD               1206           LEA.L   ERMES1(PC),A4       Else display error 
00001AA0  6000 F5F4               1207           BRA     PSTRING             and return 
00001AA4  47EE 04A4               1208  BR_GET1  LEA.L   BP_TAB(A6),A3       A6 points to breakpoint table 
00001AA8  2A40                    1209           MOVE.L  D0,A5               Save new BP address in A5 
00001AAA  2C00                    1210           MOVE.L  D0,D6               and in D6 because D0 gets corrupted 
00001AAC  3A3C 0007               1211           MOVE.W  #7,D5               Eight entries to test 
00001AB0  201B                    1212  BR_GET2  MOVE.L  (A3)+,D0            Read entry from breakpoint table 
00001AB2  660C                    1213           BNE.S   BR_GET3             If not zero display existing BP 
00001AB4  4A86                    1214           TST.L   D6                  Only store a non-zero breakpoint 
00001AB6  6710                    1215           BEQ.S   BR_GET4 
00001AB8  274D FFFC               1216           MOVE.L  A5,-4(A3)           Store new breakpoint in table 
00001ABC  3695                    1217           MOVE.W  (A5),(A3)           Save code at BP address in table 
00001ABE  4286                    1218           CLR.L   D6                  Clear D6 to avoid repetition 
00001AC0  6100 F776               1219  BR_GET3  BSR     OUT8X               Display this breakpoint 
00001AC4  6100 F5C0               1220           BSR     NEWLINE 
00001AC8  47EB 0002               1221  BR_GET4  LEA.L   2(A3),A3            Step past stored op-code 
00001ACC  51CD FFE2               1222           DBRA    D5,BR_GET2          Repeat until all entries tested 
00001AD0  4E75                    1223           RTS                         Return 
00001AD2                          1224  * 
00001AD2  =00001AD2               1225  BR_SET   EQU     *                   Plant any breakpoints in user code 
00001AD2  41EE 04A4               1226           LEA.L   BP_TAB(A6),A0       A0 points to BP table 
00001AD6  45EE 04A0               1227           LEA.L   TSK_T+70(A6),A2     A2 points to PC in display frame 
00001ADA  2452                    1228           MOVE.L  (A2),A2             Now A2 contains value of PC 
00001ADC  303C 0007               1229           MOVE.W  #7,D0               Up to eight entries to plant 
00001AE0  2218                    1230  BR_SET1  MOVE.L  (A0)+,D1            Read breakpoint address from table 
00001AE2  670A                    1231           BEQ.S   BR_SET2             If zero then skip planting 
00001AE4  B28A                    1232           CMP.L   A2,D1               Don't want to plant BP at current PC 
00001AE6  6706                    1233           BEQ.S   BR_SET2             location, so skip planting if same 
00001AE8  2241                    1234           MOVE.L  D1,A1               Transfer BP address to address reg 
00001AEA  32BC 4E4E               1235           MOVE.W  #TRAP_16,(A1)       Plant op-code for TRAP #14 in code 
00001AEE  41E8 0002               1236  BR_SET2  LEA.L   2(A0),A0            Skip past op-code field in table 
00001AF2  51C8 FFEC               1237           DBRA    D0,BR_SET1          Repeat until all entries tested 
00001AF6  4E75                    1238           RTS 
00001AF8                          1239  * 
00001AF8  =00001AF8               1240  NOBR     EQU     *                   Clear one or all breakpoints 
00001AF8  6100 F6D0               1241           BSR     PARAM               Get BP address (if any) 
00001AFC  4A07                    1242           TST.B   D7                  Test for input error 
00001AFE  6708                    1243           BEQ.S   NOBR1               If no error then skip abort 
00001B00  49FA 0269               1244           LEA.L   ERMES1(PC),A4       Point to error message 
00001B04  6000 F590               1245           BRA     PSTRING             Display it and return 
00001B08  4A80                    1246  NOBR1    TST.L   D0                  Test for null address (clear all) 
00001B0A  6720                    1247           BEQ.S   NOBR4               If no address then clear all entries 
00001B0C  2240                    1248           MOVE.L  D0,A1               Else just clear breakpoint in A1 
00001B0E  41EE 04A4               1249           LEA.L   BP_TAB(A6),A0       A0 points to BP table 
00001B12  303C 0007               1250           MOVE.W  #7,D0               Up to eight entries to test 
00001B16  2218                    1251  NOBR2    MOVE.L  (A0)+,D1            Get entry and 
00001B18  41E8 0002               1252           LEA.L   2(A0),A0            skip past op-code field 
00001B1C  B289                    1253           CMP.L   A1,D1               Is this the one? 
00001B1E  6706                    1254           BEQ.S   NOBR3               If so go and clear entry 
00001B20  51C8 FFF4               1255           DBRA    D0,NOBR2            Repeat until all tested 
00001B24  4E75                    1256           RTS 
00001B26  42A8 FFFA               1257  NOBR3    CLR.L   -6(A0)              Clear address in BP table 
00001B2A  4E75                    1258           RTS 
00001B2C  41EE 04A4               1259  NOBR4    LEA.L   BP_TAB(A6),A0       Clear all 8 entries in BP table 
00001B30  303C 0007               1260           MOVE.W  #7,D0               Eight entries to clear 
00001B34  4298                    1261  NOBR5    CLR.L   (A0)+               Clear breakpoint address 
00001B36  4258                    1262           CLR.W   (A0)+               Clear op-code field 
00001B38  51C8 FFFA               1263           DBRA    D0,NOBR5            Repeat until all done 
00001B3C  4E75                    1264           RTS 
00001B3E                          1265  * 
00001B3E  =00001B3E               1266  BR_CLR   EQU     *                   Remove breakpoints from code 
00001B3E  41EE 04A4               1267           LEA.L   BP_TAB(A6),A0       A0 points to breakpoint table 
00001B42  303C 0007               1268           MOVE.W  #7,D0               Up to eight entries to clear 
00001B46  2218                    1269  BR_CLR1  MOVE.L  (A0)+,D1            Get address of BP in D1 
00001B48  2241                    1270           MOVE.L  D1,A1               and put copy in A1 
00001B4A  4A81                    1271           TST.L   D1                  Test this breakpoint 
00001B4C  6702                    1272           BEQ.S   BR_CLR2             If zero then skip BP clearing 
00001B4E  3290                    1273           MOVE.W  (A0),(A1)           Else restore op-code 
00001B50  41E8 0002               1274  BR_CLR2  LEA.L   2(A0),A0            Skip past op-code field 
00001B54  51C8 FFF0               1275           DBRA    D0,BR_CLR1          Repeat until all tested 
00001B58  4E75                    1276           RTS 
00001B5A                          1277  * 
00001B5A                          1278  *  REG_MOD modifies a register in the display frame. The command 
00001B5A                          1279  *  format is REG <reg> <value>. E.g. REG D3 1200 
00001B5A                          1280  * 
00001B5A  4281                    1281  REG_MOD  CLR.L   D1                  D1 to hold name of register 
00001B5C  41EE 0444               1282           LEA.L   BUFFPT(A6),A0       A0 contains address of buffer pointer 
00001B60  2050                    1283           MOVE.L  (A0),A0             A0 now points to next char in buffer 
00001B62  1218                    1284           MOVE.B  (A0)+,D1            Put first char of name in D1 
00001B64  E159                    1285           ROL.W   #8,D1               Move char one place left 
00001B66  1218                    1286           MOVE.B  (A0)+,D1            Get second char in D1 
00001B68  41E8 0001               1287           LEA.L   1(A0),A0            Move pointer past space in buffer 
00001B6C  2D48 0444               1288           MOVE.L  A0,BUFFPT(A6)       Update buffer pointer 
00001B70  4282                    1289           CLR.L   D2                  D2 is the character pair counter 
00001B72  41FA 01CE               1290           LEA.L   REGNAME(PC),A0      A0 points to string of character pairs 
00001B76  43D0                    1291           LEA.L   (A0),A1             A1 also points to string 
00001B78  B258                    1292  REG_MD1  CMP.W   (A0)+,D1            Compare a char pair with input 
00001B7A  6712                    1293           BEQ.S   REG_MD2             If match then exit loop 
00001B7C  5282                    1294           ADD.L   #1,D2               Else increment match counter 
00001B7E  B4BC 00000013           1295           CMP.L   #19,D2              Test for end of loop 
00001B84  66F2                    1296           BNE     REG_MD1             Continue until all pairs matched 
00001B86  49FA 01E3               1297           LEA.L   ERMES1(PC),A4       If here then error 
00001B8A  6000 F50A               1298           BRA     PSTRING             Display error and return 
00001B8E  43EE 045A               1299  REG_MD2  LEA.L   TSK_T(A6),A1        A1 points to display frame 
00001B92  E582                    1300           ASL.L   #2,D2               Multiply offset by 4 (4 bytes/entry) 
00001B94  B4BC 00000048           1301           CMP.L   #72,D2              Test for address of PC 
00001B9A  6602                    1302           BNE.S   REG_MD3             If not PC then all is OK 
00001B9C  5582                    1303           SUB.L   #2,D2               else dec PC pointer as Sr is a word 
00001B9E  45F1 2000               1304  REG_MD3  LEA.L   (A1,D2),A2          Calculate address of entry in disptable 
00001BA2  2012                    1305           MOVE.L  (A2),D0             Get old contents 
00001BA4  6100 F692               1306           BSR     OUT8X               Display them 
00001BA8  6100 F4DC               1307           BSR     NEWLINE 
00001BAC  6100 F61C               1308           BSR     PARAM               Get new data 
00001BB0  4A07                    1309           TST.B   D7                  Test for input error 
00001BB2  6708                    1310           BEQ.S   REG_MD4             If no error then go and store data 
00001BB4  49FA 01B5               1311           LEA.L   ERMES1(PC),A4       Else point to error message 
00001BB8  6000 F4DC               1312           BRA     PSTRING             print it and return 
00001BBC  B4BC 00000044           1313  REG_MD4  CMP.L   #68,D2              If this address is the SR then 
00001BC2  6704                    1314           BEQ.S   REG_MD5             we have only a word to store 
00001BC4  2480                    1315           MOVE.L  D0,(A2)             Else store new data in display frame 
00001BC6  4E75                    1316           RTS 
00001BC8  3480                    1317  REG_MD5  MOVE.W  D0,(A2)             Store SR (one word) 
00001BCA  4E75                    1318           RTS 
00001BCC                          1319  * 
00001BCC                          1320  ************************************************************************* 
00001BCC                          1321  * 
00001BCC  =00001BCC               1322  X_UN    EQU     *                 Uninitialized exception vector routine 
00001BCC  49FA 0203               1323          LEA.L   ERMES6(PC),A4     Point to error message 
00001BD0  6100 F4C4               1324          BSR     PSTRING           Display it 
00001BD4  6100 FB60               1325          BSR     EX_DIS            Display registers 
00001BD8  6000 F49C               1326          BRA     WARM              Abort 
00001BDC                          1327  * 
00001BDC                          1328  ************************************************************************* 
00001BDC                          1329  * 
00001BDC                          1330  *  All strings and other fixed parameters here 
00001BDC                          1331  * 
00001BDC= 54 53 42 55 47 20 ...   1332  BANNER   DC.B     'TSBUG 2 Version 23.07.86',0,0
00001BF6= 4D 6F 64 69 66 69 ...   1333  MODIFY    DC.B   'Modified by Eugene A. Rockey Jr. Jan.05.2010',0,0
00001C24= 66 6F 72 20 75 73 ...   1334  WHY      DC.B     'for use with the M68000 Minimal Computer Configuration',0,0 
00001C5C= 55 6E 69 76 65 72 ...   1335  WHERE    DC.B     'University of Louisville',0,0
00001C76= 0D 0A 54 53 32 4D ...   1336  CRLF     DC.B     CR,LF,'TS2MON >',0 
00001C81= 0D 0A 53 31 00 00       1337  HEADER   DC.B     CR,LF,'S','1',0,0 
00001C87= 53 39 20 20 00 00       1338  TAIL     DC.B     'S9  ',0,0 
00001C8D= 20 53 52 20 20 3D ...   1339  MES1     DC.B     ' SR  =  ',0 
00001C96= 20 50 43 20 20 3D ...   1340  MES2     DC.B     ' PC  =  ',0 
00001C9F= 20 53 53 20 20 3D ...   1341  MES2A    DC.B     ' SS  =  ',0 
00001CA8= 20 20 44 61 74 61 ...   1342  MES3     DC.B     '  Data reg       Address reg',0,0 
00001CC6= 20 20 20 20 20 20 ...   1343  MES4     DC.B     '        ',0,0 
00001CD0= 42 75 73 20 65 72 ...   1344  MES8     DC.B     'Bus error   ',0,0 
00001CDE= 41 64 64 72 65 73 ...   1345  MES9     DC.B     'Address error   ',0,0 
00001CF0= 49 6C 6C 65 67 61 ...   1346  MES10    DC.B     'Illegal instruction ',0,0 
00001D06= 42 72 65 61 6B 70 ...   1347  MES11    DC.B     'Breakpoint  ',0,0 
00001D14= 54 72 61 63 65 20 ...   1348  MES12    DC.B     'Trace   ',0 
00001D1D= 44 69 76 69 64 65 ...   1349  MES13    DC.B     'Divide by zero error', 0
00001D32= 50 72 69 76 69 6C ...   1350  MES14    DC.B     'Privilege error', 0
00001D42= 44 30 44 31 44 32 ...   1351  REGNAME  DC.B     'D0D1D2D3D4D5D6D7' 
00001D52= 41 30 41 31 41 32 ...   1352           DC.B     'A0A1A2A3A4A5A6A7' 
00001D62= 53 53 53 52             1353           DC.B     'SSSR' 
00001D66= 50 43 20 20 00          1354           DC.B     'PC  ',0 
00001D6B= 4E 6F 6E 2D 76 61 ...   1355  ERMES1   DC.B     'Non-valid hexadecimal input  ',0 
00001D89= 49 6E 76 61 6C 69 ...   1356  ERMES2   DC.B     'Invalid command  ',0 
00001D9B= 4C 6F 61 64 69 6E ...   1357  ERMES3   DC.B     'Loading error',0 
00001DA9= 54 61 62 6C 65 20 ...   1358  ERMES4   DC.B     'Table full  ',0,0 
00001DB7= 42 72 65 61 6B 70 ...   1359  ERMES5   DC.B     'Breakpoint not active   ',0,0 
00001DD1= 55 6E 69 6E 69 74 ...   1360  ERMES6   DC.B     'Uninitialized exception ',0,0 
00001DEB= 4A 55 4D 50 20 3C ...   1361  JUMPHELP DC.B     'JUMP <address> causes execution to begin at <address>',0   
00001E21= 4D 45 4D 4F 52 59 ...   1362  MEMHELP  DC.B     'MEMORY <address> examines contents of address> and allows them to be changed', 0   
00001E6E= 4C 4F 41 44 20 3C ...   1363  LOADHELP DC.B     'LOAD <string> loads S1/S2 records from the host. <string> is sent to host', 0
00001EB8= 54 56 20 63 68 65 ...   1364  TVHELP   DC.B     'TV checks all RAM addresses from $4000 to $40FE. Reports corrupt memory addresses', 0
00001F0A= 20 52 61 6E 67 65 ...   1365  ERMES7   DC.B     ' Range error',0
00001F17= 55 53 45 52 00          1366  UNAME    DC.B     'USER', 0
00001F1C= 50 41 53 53 57 4F ...   1367  PWORD    DC.B     'PASSWORD',0
00001F25= 45 6E 74 65 72 20 ...   1368  LOGINM1  DC.B     'Enter username: ', 0
00001F36= 45 6E 74 65 72 20 ...   1369  LOGINM2  DC.B     'Enter password: ', 0
00001F47= 49 6E 63 6F 72 72 ...   1370  USRERR   DC.B     'Incorrect username', 0
00001F5A= 43 6F 72 72 65 63 ...   1371  USRSUC   DC.B     'Correct Username', 0
00001F6B= 49 6E 63 6F 72 72 ...   1372  PWERR   DC.B     'Incorrect password', 0
00001F7E= 43 6F 72 72 65 63 ...   1373  PWSUC    DC.B     'Correct Password', 0
00001F8F= 4D 45 4D 4F 52 59 ...   1374  MEMFMSG  DC.B     'MEMORY BAD AT: ',0
00001F9F= 41 4C 4C 20 52 41 ...   1375  MEMGMSG  DC.B      'ALL RAM GOOD', 0
00001FAC= 48 45 4C 4C 4F 00       1376  HELLO    DC.B      'HELLO',0
00001FB2                          1377   
00001FB2                          1378  * 
00001FB2                          1379  *  COMTAB is the built-in command table. All entries are made up of 
00001FB2                          1380  *         a string length + number of characters to match + the string 
00001FB2                          1381  *         plus the address of the command relative to COMTAB 
00001FB2                          1382  * 
00002000                          1383           ORG      $2000
00002000= 04 04                   1384  COMTAB   DC.B     4,4              JUMP <address> causes execution to 
00002002= 4A 55 4D 50             1385           DC.B     'JUMP'           begin at <address> 
00002006= FFFFF240                1386           DC.L     JUMP-COMTAB                                           
0000200A= 08 03                   1387           DC.B     8,3              MEMORY <address> examines contents of 
0000200C= 4D 45 4D 4F 52 59 ...   1388           DC.B     'MEMORY  '       <address> and allows them to be changed 
00002014= FFFFF256                1389           DC.L     MEMORY-COMTAB 
00002018= 04 02                   1390           DC.B     4,2              LOAD <string> loads S1/S2 records 
0000201A= 4C 4F 41 44             1391           DC.B     'LOAD'           from the host. <string> is sent to host 
0000201E= FFFFF2B6                1392           DC.L     LOAD-COMTAB 
00002022= 04 04                   1393           DC.B    4,4               HELP 
00002024= 48 45 4C 50             1394           DC.B    'HELP'            
00002028= FFFFF7B4                1395           DC.L    HELP-COMTAB      
0000202C= 02 02                   1396           DC.B    2,2
0000202E= 54 56                   1397           DC.B    'TV'
00002030= FFFFF8B6                1398           DC.L    TV-COMTAB
00002034= 00 00                   1399           DC.B    0,0 
00002036                          1400  * 
00002036                          1401  ************************************************************************* 
00002036                          1402  * 
00002036                          1403  *  This is a list of the information needed to setup the DCBs 
00002036                          1404  * 
00002036  =00002036               1405  DCB_LST  EQU     * 
00002036= 43 4F 4E 5F 49 4E ...   1406  DCB1     DC.B    'CON_IN  '          Device name (8 bytes) 
0000203E= 000014E4 00008001       1407           DC.L    CON_IN,ACIA_1       Address of driver routine, device 
00002046= 0002                    1408           DC.W    2                   Number of words in parameter field 
00002048= 43 4F 4E 5F 4F 55 ...   1409  DCB2     DC.B    'CON_OUT ' 
00002050= 000014FA 00008001       1410           DC.L    CON_OUT,ACIA_1 
00002058= 0002                    1411           DC.W    2 
0000205A= 41 55 58 5F 49 4E ...   1412  DCB3     DC.B    'AUX_IN  ' 
00002062= 00001510 00008001       1413           DC.L    AUX_IN,ACIA_2 
0000206A= 0002                    1414           DC.W    2 
0000206C= 41 55 58 5F 4F 55 ...   1415  DCB4     DC.B    'AUX_OUT ' 
00002074= 00001522 00008001       1416           DC.L    AUX_OUT,ACIA_2 
0000207C= 0002                    1417           DC.W    2 
0000207E= 42 55 46 46 5F 49 ...   1418  DCB5     DC.B    'BUFF_IN ' 
00002086= 00001578 000006D4       1419           DC.L    BUFF_IN,BUFFER 
0000208E= 0002                    1420           DC.W    2 
00002090= 42 55 46 46 5F 4F ...   1421  DCB6     DC.B    'BUFF_OUT' 
00002098= 00001584 000006D4       1422           DC.L    BUFF_OT,BUFFER 
000020A0= 0002                    1423           DC.W    2 
000020A2                          1424  * 
000020A2                          1425  ************************************************************************* 
000020A2                          1426  * 
000020A2                          1427  *  DCB structure 
000020A2                          1428  * 
000020A2                          1429  *              ----------------------- 
000020A2                          1430  *       0 ->   | DCB  name           | 
000020A2                          1431  *              |---------------------| 
000020A2                          1432  *       8 ->   | Device driver       | 
000020A2                          1433  *              |---------------------| 
000020A2                          1434  *      12 ->   | Device address      | 
000020A2                          1435  *              |---------------------| 
000020A2                          1436  *      16 ->   |Size of param block  | 
000020A2                          1437  *              |---------------------| --- 
000020A2                          1438  *      18 ->   |      Status         |   | 
000020A2                          1439  *              | logical  | physical |   | S 
000020A2                          1440  *              |---------------------|   | 
000020A2                          1441  *              .                     .   . 
000020A2                          1442  *              |---------------------| --- 
000020A2                          1443  *    18+S ->   | Pointer to next DCB | 
000020A2                          1444  * 
000020A2                          1445           END RESET 

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ACIA_1              8001
ACIA_2              8001
ADD_0               15DE
ADD_ER              1986
ADR_DAT             1294
AUX_IN              1510
AUX_IN1             1516
AUX_OT1             1528
AUX_OUT             1522
BANNER              1BDC
BP_TAB              4A4
BRKPT               19B8
BR_CLR              1B3E
BR_CLR1             1B46
BR_CLR2             1B50
BR_GET              1A94
BR_GET1             1AA4
BR_GET2             1AB0
BR_GET3             1AC0
BR_GET4             1AC8
BR_SET              1AD2
BR_SET1             1AE0
BR_SET2             1AEE
BS                  8
BUFFEND             443
BUFFER              6D4
BUFFPT              444
BUFF_IN             1578
BUFF_OT             1584
BUS_ER              1978
BYTE                11AE
CHECK1              18D2
CHECK2              18DC
CHECK3              18FE
CHECK4              1908
CN_IVEC             452
CN_OVEC             456
COMTAB              2000
CON_IN              14E4
CON_OUT             14FA
CR                  D
CRLF                1C76
CTRL_A              1
DATA                4800
DCB1                2036
DCB2                2048
DCB3                205A
DCB4                206C
DCB5                207E
DCB6                2090
DCB_LST             2036
DELAY               1432
DELAY1              143C
DIV0_ER             1994
DIV_0               1608
DUMP                138A
DUMP1               139A
DUMP2               13A6
DUMP3               13BC
DUMP4               13D0
DUMP5               13DE
DUMP6               13F8
DUMP7               141C
ECHO                44C
ERMES1              1D6B
ERMES2              1D89
ERMES3              1D9B
ERMES4              1DA9
ERMES5              1DB7
ERMES6              1DD1
ERMES7              1F0A
ESC                 1B
EXEC1               1136
EXEC2               1146
EXECUTE             1124
EX_D1               1748
EX_DIS              1736
FIRST               4D4
FOO1                1644
FOO10               16B0
FOO11               16BC
FOO12               16C8
FOO13               16D4
FOO14               16E0
FOO15               16EC
FOO16               16F8
FOO17               1704
FOO18               1710
FOO19               171C
FOO2                1650
FOO20               1728
FOO21               1734
FOO3                165C
FOO4                1668
FOO5                1674
FOO6                1680
FOO7                168C
FOO8                1698
FOO9                16A4
GB                  1A56
GETCH2              1558
GETCH3              1560
GETCHAR             1534
GETLINE             10AC
GETLN2              10B6
GETLN3              10D0
GETLN4              10DA
GETLN5              10DE
GO                  1A36
GO1                 1A46
GO2                 1A54
GROUP1              19D6
GROUP1A             19F4
GROUP2              1A0A
GROUP2A             1A16
HEADER              1C81
HEADING             10A6
HELLO               1FAC
HELP                17B4
HEX                 1190
HEX_OK              11AC
IL_ER               1960
IO_OPEN             1592
IO_REQ              14D2
JUMP                1240
JUMP1               124E
JUMPHELP            1DEB
LF                  A
LNBUFF              404
LOAD                12B6
LOAD1               12E2
LOAD2               12F2
LOAD3               130C
LOAD4               1326
LOAD5               1334
LOAD6               1336
LOAD6A              135A
LOAD7               136C
LOAD8               1382
LOADHELP            1E6E
LOGIN               17EA
LOGIN1              180A
LOGIN2              184E
LOGINM1             1F25
LOGINM2             1F36
LONGWD              11C4
LOOPRAM             18BE
LOOPRAM1            18EA
MAXCHR              40
MAX_RAM             7D8
MEM1                1260
MEM2                127E
MEM3                1292
MEMFAIL             191C
MEMFAIL2            1938
MEMFMSG             1F8F
MEMGMSG             1F9F
MEMGOOD             1954
MEMHELP             1E21
MEMORY              1256
MES1                1C8D
MES10               1CF0
MES11               1D06
MES12               1D14
MES13               1D1D
MES14               1D32
MES2                1C96
MES2A               1C9F
MES3                1CA8
MES4                1CC6
MES8                1CD0
MES9                1CDE
MIN_RAM             7D4
MODIFY              1BF6
MULNEG              1628
MUL_0               15FA
NEWLINE             1086
NOBR                1AF8
NOBR1               1B08
NOBR2               1B16
NOBR3               1B26
NOBR4               1B2C
NOBR5               1B34
NOT_HEX             11A8
NO_EXT              1054
NUL                 0
OPEN1               159A
OPEN2               15A2
OPEN3               15B0
OPEN4               15C6
OUT1X               120E
OUT1X1              1220
OUT2X               1228
OUT4X               1230
OUT8X               1238
PARAM               11CA
PARAM1              11D2
PARAM3              11F6
PARAM4              11FA
PARAM5              1206
PARAM6              120A
PARAMTR             448
PRIV_ER             19A2
PS1                 1098
PS2                 10A2
PSPACE              12A8
PSTRING             1096
PUTCHAR             1564
PWERR               1F6B
PWORD               1F1C
PWSUC               1F7E
QUIT                18B2
RANGE               1422
REGNAME             1D42
REG_MD1             1B78
REG_MD2             1B8E
REG_MD3             1B9E
REG_MD4             1BBC
REG_MD5             1BC8
REG_MOD             1B5A
RESET               1000
REST1               1A6C
RESTORE             1A5C
SEARCH              1150
SETNEG              1622
SET_DCB             1488
SPACE               20
SRCH2               116A
SRCH3               116E
SRCH4               1176
SRCH6               1180
SRCH7               118A
STACK               4400
ST_DCB1             1498
ST_DCB2             149C
SUB_0               15EC
TAIL                1C87
TIDY                10E2
TIDY1               10E8
TIDY2               10F4
TIDY3               10FE
TIDY4               1108
TIDY5               1112
TIDY6               111E
TM                  1446
TM1                 1452
TRACE               1A80
TRAP_0              1638
TRAP_16             4E4E
TSK_T               45A
TV                  18B6
TVHELP              1EB8
UNAME               1F17
UPASS               18A8
USRERR              1F47
USRSUC              1F5A
UTAB                44E
U_CASE              44D
WAIT                57
WARM                1076
WHERE               1C5C
WHY                 1C24
WORD                11BE
WRONG               1880
WRONGPW             1894
X_BASE              4000
X_SET               15CC
X_SET2              15D4
X_UN                1BCC
