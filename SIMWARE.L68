00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.15.04
Created On: 9/23/15 1:11:39 AM

00000000                             1  *        TSBUG2 - 68000 monitor - version of 05 January 2010 
00000000                             2  
00000000                             3      ORG      $0
00000000= 00004400 00001000          4           DC.L     STACK,RESET
00000008                             5  *                                   Symbol equates 
00000008  =00000008                  6  BS       EQU      $08               Back_space 
00000008  =0000000D                  7  CR       EQU      $0D               Carriage_return 
00000008  =00000000                  8  NUL      EQU      $00               NUL character
00000008  =0000000A                  9  LF       EQU      $0A               Line_feed 
00000008  =00000020                 10  SPACE    EQU      $20               Space 
00000008  =00000057                 11  WAIT     EQU      'W'               Wait character (to suspend output) 
00000008  =0000001B                 12  ESC      EQU      $1B               ASCII escape character (used by TM) 
00000008  =00000001                 13  CTRL_A   EQU      $01               Control_A forces return to monitor 
00000008                            14  *                                   Device addresses 
00000008  =00004400                 15  STACK    EQU      $4400             Stack_pointer
00000008  =00008001                 16  ACIA_1   EQU      $8001             Console ACIA control 
00000008  =00008001                 17  ACIA_2   EQU      ACIA_1            Auxilary ACIA control 
00000008  =00004000                 18  X_BASE   EQU      $4000             Start of exception vector table 
00000008  =00004E4E                 19  TRAP_14  EQU      $4E4E             Code for TRAP #14 
00000008  =00000040                 20  MAXCHR   EQU      64                Length of input line buffer  
00000008                            21  * 
00000008  =00004800                 22  DATA     EQU      $4800             Data origin 
00000008                            23  LNBUFF   DS.B     MAXCHR            Input line buffer
00000048  =00000047                 24  BUFFEND  EQU      LNBUFF+MAXCHR-1   End of line buffer 
00000048                            25  BUFFPT   DS.L     1                 Pointer to line buffer 
0000004C                            26  PARAMTR  DS.L     1                 Last parameter from line buffer 
00000050                            27  ECHO     DS.B     1                 When clear this enable input echo 
00000051                            28  U_CASE   DS.B     1                 Flag for upper case conversion 
00000052                            29  UTAB     DS.L     1                 Pointer to user command table 
00000056                            30  CN_IVEC  DS.L     1                 Pointer to console input DCB 
0000005A                            31  CN_OVEC  DS.L     1                 Pointer to console output DCB 
0000005E                            32  TSK_T    DS.W     37                Frame for D0-D7, A0-A6, USP, SSP, SW, PC 
000000A8                            33  BP_TAB   DS.W     24                Breakpoint table 
000000D8                            34  FIRST    DS.B     512               DCB area 
000002D8                            35  BUFFER   DS.B     256               256 bytes for I/O buffer 
000003D8= 00004000                  36  MIN_RAM  DC.L     $004000
000003DC= 00004100                  37  MAX_RAM  DC.L     $004100
000003E0                            38  * 
000003E0                            39  ************************************************************************* 
000003E0                            40  * 
000003E0                            41  *  This is the main program which assembles a command in the line 
000003E0                            42  *  buffer, removes leading/embedded spaces and interprets it by matching 
000003E0                            43  *  it with a command in the user table or the built-in table COMTAB 
000003E0                            44  *  All variables are specified with respect to A6 
000003E0                            45  *
00001000                            46           ORG      $1000             Monitor Origin
00001000  =00001000                 47  RESET:   EQU      *
00001000  4DF8 4800                 48           LEA.L    DATA,A6           A6 points to data area 
00001004  2D4E 0096                 49      MOVE.L    A6,TSK_T+56(A6)   initialize A6 in the regster Frame
00001008  42AE 0052                 50           CLR.L    UTAB(A6)          Reset pointer to user extension table 
0000100C  1D7C 0001 0050            51           MOVE.B   #1,ECHO(A6)       Set automatic character echo 
00001012  422E 0051                 52           CLR.B    U_CASE(A6)        Clear case conversion flag (UC<-LC) 
00001016  6100 05A4                 53      BSR.L     X_SET         what change did i do here
0000101A  6100 045C                 54           BSR.L    SET_DCB           Setup DCB table in RAM
0000101E  6156                      55           BSR.S    NEWLINE
00001020  49FA 0AB8                 56           LEA.L    BANNER(PC),A4    
00001024  6160                      57           BSR.S    PSTRING
00001026  614E                      58           BSR.S    NEWLINE           
00001028  49FA 0ACA                 59      LEA.L     MODIFY(PC),A4
0000102C  6158                      60           BSR.S    PSTRING
0000102E  6146                      61           BSR.S    NEWLINE
00001030  49FA 0AF0                 62      LEA.L     WHY(PC),A4
00001034  6150                      63           BSR.S    PSTRING
00001036  613E                      64           BSR.S    NEWLINE
00001038  49FA 0B20                 65      LEA.L     WHERE(PC),A4
0000103C  6148                      66           BSR.S    PSTRING
0000103E  6136                      67           BSR.S    NEWLINE
00001040  49FA 0B32                 68      LEA.L     ADDRE(PC),A4
00001044  6140                      69           BSR.S    PSTRING
00001046  612E                      70           BSR.S    NEWLINE
00001048  207C 00003000             71           MOVE.L   #$3000,A0         A0 points to extension ROM 
0000104E  2010                      72           MOVE.L   (A0),D0           Read first longword in extension ROM 
00001050  B0BC 524F4D32             73           CMP.L    #'ROM2',D0        If extension begins with 'ROM2' then 
00001056  6604                      74           BNE.S    NO_EXT            call the subroutine at EXT_ROM+8 
00001058  4EA8 0008                 75           JSR      8(A0)             else continue 
0000105C  4E71                      76  NO_EXT:  NOP                        Two NOPs to allow for a future 
0000105E  4E71                      77           NOP                        call to an initialization routine 
00001060  4EB9 0000172A             78           JSR      LOGIN
00001066  4287                      79  WARM:    CLR.L    D7                Warm entry point - clear error flag 
00001068  610C                      80           BSR.S    NEWLINE           Print a newline 
0000106A  6130                      81           BSR.S    GETLINE           Get a command line 
0000106C  6100 0064                 82           BSR      TIDY              Tidy up input buffer contents 
00001070  6100 00A2                 83           BSR      EXECUTE           Interpret command 
00001074  60F0                      84           BRA      WARM              Repeat indefinitely 
00001076                            85  * 
00001076                            86  ************************************************************************* 
00001076                            87  * 
00001076                            88  *  Some initialization and basic routines 
00001076                            89  * 
00001076                            90  * 
00001076  =00001076                 91  NEWLINE  EQU      *                 Move cursor to start of newline 
00001076  48E7 0008                 92           MOVEM.L  A4,-(A7)          Save A4 
0000107A  49FA 0B1B                 93           LEA.L    CRLF(PC),A4       Point to CR/LF string 
0000107E  6106                      94           BSR.S    PSTRING           Print it 
00001080  4CDF 1000                 95           MOVEM.L  (A7)+,A4          Restore A4 
00001084  4E75                      96           RTS                        Return 
00001086                            97  * 
00001086  =00001086                 98  PSTRING  EQU      *                 Display the string pointed at by A4 
00001086  2F00                      99           MOVE.L   D0,-(A7)          Save D0 
00001088  101C                     100  PS1      MOVE.B   (A4)+,D0          Get character to be printed 
0000108A  6706                     101           BEQ.S    PS2               If null then return 
0000108C  6100 04C6                102           BSR      PUTCHAR           Else print it 
00001090  60F6                     103           BRA      PS1               Continue 
00001092  201F                     104  PS2      MOVE.L   (A7)+,D0          Restore D0 and exit 
00001094  4E75                     105           RTS 
00001096                           106  * 
00001096  61DE                     107  HEADING  BSR      NEWLINE           Same as PSTRING but with newline 
00001098  61EC                     108           BSR      PSTRING 
0000109A  60DA                     109           BRA      NEWLINE 
0000109C                           110  * 
0000109C                           111  ************************************************************************* 
0000109C                           112  * 
0000109C                           113  *  GETLINE  inputs a string of characters into a line buffer 
0000109C                           114  *           A3 points to next free entry in line buffer 
0000109C                           115  *           A2 points to end of buffer 
0000109C                           116  *           A1 points to start of buffer 
0000109C                           117  *           D0 holds character to be stored 
0000109C                           118  * 
0000109C  43EE 0008                119  GETLINE  LEA.L    LNBUFF(A6),A1     A1 points to start of line buffer 
000010A0  47D1                     120           LEA.L    (A1),A3           A3 points to start (initially) 
000010A2  45E9 0040                121           LEA.L    MAXCHR(A1),A2     A2 points to end of buffer 
000010A6  6100 047C                122  GETLN2   BSR      GETCHAR           Get a character 
000010AA  B03C 0001                123           CMP.B    #CTRL_A,D0        If control_A then reject this line 
000010AE  671E                     124           BEQ.S    GETLN5            and get another line 
000010B0  B03C 0008                125           CMP.B    #BS,D0            If back_space then move back pointer 
000010B4  660A                     126           BNE.S    GETLN3            Else skip past wind-back routine 
000010B6  B7C9                     127           CMP.L    A1,A3             First check for empty buffer 
000010B8  67EC                     128           BEQ      GETLN2            If buffer empty then continue 
000010BA  47EB FFFF                129           LEA      -1(A3),A3         Else decrement buffer pointer 
000010BE  60E6                     130           BRA      GETLN2            and continue with next character 
000010C0  16C0                     131  GETLN3   MOVE.B   D0,(A3)+          Store character and update pointer 
000010C2  B03C 000D                132           CMP.B    #CR,D0            Test for command terminator 
000010C6  6602                     133           BNE.S    GETLN4            If not CR then skip past exit 
000010C8  60AC                     134           BRA      NEWLINE           Else new line before next operation 
000010CA  B7CA                     135  GETLN4   CMP.L    A2,A3             Test for buffer overflow 
000010CC  66D8                     136           BNE      GETLN2            If buffer not full then continue 
000010CE  61A6                     137  GETLN5   BSR      NEWLINE           Else move to next line and 
000010D0  60CA                     138           BRA      GETLINE           repeat this routine 
000010D2                           139  * 
000010D2                           140  ************************************************************************* 
000010D2                           141  * 
000010D2                           142  *  TIDY cleans up the line buffer by removing leading spaces and multiple 
000010D2                           143  *       spaces between parameters. At the end of TIDY, BUFFPT points to 
000010D2                           144  *       the first parameter following the command. 
000010D2                           145  *       A0 = pointer to line buffer. A1 = pointer to cleaned up buffer 
000010D2                           146  * 
000010D2  41EE 0008                147  TIDY     LEA.L    LNBUFF(A6),A0     A0 points to line buffer 
000010D6  43D0                     148           LEA.L    (A0),A1           A1 points to start of line buffer 
000010D8  1018                     149  TIDY1    MOVE.B   (A0)+,D0          Read character from line buffer 
000010DA  B03C 0020                150           CMP.B    #SPACE,D0         Repeat until the first non-space 
000010DE  67F8                     151           BEQ      TIDY1             character is found 
000010E0  41E8 FFFF                152           LEA.L    -1(A0),A0         Move pointer back to first char 
000010E4  1018                     153  TIDY2    MOVE.B   (A0)+,D0          Move the string left to remove 
000010E6  12C0                     154           MOVE.B   D0,(A1)+          any leading spaces 
000010E8  B03C 0020                155           CMP.B    #SPACE,D0         Test for embedded space 
000010EC  660A                     156           BNE.S    TIDY4             If not space then test for EOL 
000010EE  0C18 0020                157  TIDY3    CMP.B    #SPACE,(A0)+      If space skip multiple embedded 
000010F2  67FA                     158           BEQ      TIDY3             spaces 
000010F4  41E8 FFFF                159           LEA.L    -1(A0),A0         Move back pointer 
000010F8  B03C 000D                160  TIDY4    CMP.B    #CR,D0            Test for end_of_line (EOL) 
000010FC  66E6                     161           BNE      TIDY2             If not EOL then read next char 
000010FE  41EE 0008                162           LEA.L    LNBUFF(A6),A0     Restore buffer pointer 
00001102  0C10 000D                163  TIDY5    CMP.B    #CR,(A0)          Test for EOL 
00001106  6706                     164           BEQ.S    TIDY6             If EOL then exit 
00001108  0C18 0020                165           CMP.B    #SPACE,(A0)+      Test for delimiter 
0000110C  66F4                     166           BNE      TIDY5             Repeat until delimiter or EOL 
0000110E  2D48 0048                167  TIDY6    MOVE.L   A0,BUFFPT(A6)     Update buffer pointer 
00001112  4E75                     168           RTS 
00001114                           169  * 
00001114                           170  ************************************************************************* 
00001114                           171  * 
00001114                           172  *  EXECUTE matches the first command in the line buffer with the 
00001114                           173  *  commands in a command table. An external table pointed at by 
00001114                           174  *  UTAB is searched first and then the built-in table, COMTAB. 
00001114                           175  * 
00001114  4AAE 0052                176  EXECUTE  TST.L    UTAB(A6)          Test pointer to user table 
00001118  670C                     177           BEQ.S    EXEC1             If clear then try built-in table 
0000111A  266E 0052                178           MOVE.L   UTAB(A6),A3       Else pick up pointer to user table 
0000111E  6120                     179           BSR.S    SEARCH            Look for command in user table 
00001120  6404                     180           BCC.S    EXEC1             If not found then try internal table 
00001122  2653                     181           MOVE.L   (A3),A3           Else get absolute address of command 
00001124  4ED3                     182           JMP      (A3)              from user table and execute it 
00001126                           183  * 
00001126  47FA 0C8A                184  EXEC1    LEA.L    COMTAB(PC),A3     Try built-in command table 
0000112A  6114                     185           BSR.S    SEARCH            Look for command in built-in table 
0000112C  6508                     186           BCS.S    EXEC2             If found then execute command 
0000112E  49FA 0B55                187           LEA.L    ERMES2(PC),A4     Else print "invalid command" 
00001132  6000 FF52                188           BRA.L    PSTRING           and return 
00001136  2653                     189  EXEC2    MOVE.L   (A3),A3           Get the relative command address 
00001138  49FA 0C78                190           LEA.L    COMTAB(PC),A4     pointed at by A3 and add it to 
0000113C  D7CC                     191           ADD.L    A4,A3             the PC to generate the actual 
0000113E  4ED3                     192           JMP      (A3)              command address. Then execute it. 
00001140                           193  * 
00001140  =00001140                194  SEARCH   EQU      *                 Match the command in the line buffer 
00001140  4280                     195           CLR.L    D0                with command table pointed at by A3 
00001142  1013                     196           MOVE.B   (A3),D0           Get the first character in the 
00001144  6734                     197           BEQ.S    SRCH7             current entry. If zero then exit 
00001146  49F3 0006                198           LEA.L    6(A3,D0.W),A4     Else calculate address of next entry 
0000114A  122B 0001                199           MOVE.B   1(A3),D1          Get number of characters to match 
0000114E  4BEE 0008                200           LEA.L    LNBUFF(A6),A5     A5 points to command in line buffer 
00001152  142B 0002                201           MOVE.B   2(A3),D2          Get first character in this entry 
00001156  B41D                     202           CMP.B    (A5)+,D2          from the table and match with buffer 
00001158  6704                     203           BEQ.S    SRCH3             If match then try rest of string 
0000115A  264C                     204  SRCH2    MOVE.L   A4,A3             Else get address of next entry 
0000115C  60E2                     205           BRA      SEARCH            and try the next entry in the table 
0000115E  5301                     206  SRCH3    SUB.B    #1,D1             One less character to match 
00001160  670E                     207           BEQ.S    SRCH6             If match counter zero then all done 
00001162  47EB 0003                208           LEA.L    3(A3),A3          Else point to next character in table 
00001166  141B                     209  SRCH4    MOVE.B   (A3)+,D2          Now match a pair of characters 
00001168  B41D                     210           CMP.B    (A5)+,D2 
0000116A  66EE                     211           BNE      SRCH2             If no match then try next entry 
0000116C  5301                     212           SUB.B    #1,D1             Else decrement match counter and 
0000116E  66F6                     213           BNE      SRCH4             repeat until no chars left to match 
00001170  47EC FFFC                214  SRCH6    LEA.L    -4(A4),A3         Calculate address of command entry 
00001174  003C 0001                215           OR.B     #1,CCR            point. Mark carry flag as success 
00001178  4E75                     216           RTS                        and return 
0000117A  023C 00FE                217  SRCH7    AND.B    #$FE,CCR          Fail - clear carry to indicate 
0000117E  4E75                     218           RTS                        command not found and return 
00001180                           219  * 
00001180                           220  ************************************************************************* 
00001180                           221  * 
00001180                           222  *  Basic input routines 
00001180                           223  *  HEX    =  Get one   hexadecimal character  into D0 
00001180                           224  *  BYTE   =  Get two   hexadecimal characters into D0 
00001180                           225  *  WORD   =  Get four  hexadecimal characters into D0 
00001180                           226  *  LONGWD =  Get eight hexadecimal characters into D0 
00001180                           227  *  PARAM  =  Get a longword from the line buffer into D0 
00001180                           228  *  Bit 0 of D7 is set to indicate a hexadecimal input error 
00001180                           229  * 
00001180  6100 03A2                230  HEX      BSR      GETCHAR           Get a character from input device 
00001184  0400 0030                231           SUB.B    #$30,D0           Convert to binary 
00001188  6B0E                     232           BMI.S    NOT_HEX           If less than $30 then exit with error 
0000118A  B03C 0009                233           CMP.B    #$09,D0           Else test for number (0 to 9) 
0000118E  6F0C                     234           BLE.S    HEX_OK            If number then exit - success 
00001190  5F00                     235           SUB.B    #$07,D0           Else convert letter to hex 
00001192  B03C 000F                236           CMP.B    #$0F,D0           If character in range "A" to "F" 
00001196  6F04                     237           BLE.S    HEX_OK            then exit successfully 
00001198  8E3C 0001                238  NOT_HEX  OR.B     #1,D7             Else set error flag 
0000119C  4E75                     239  HEX_OK   RTS                        and return 
0000119E                           240  * 
0000119E  2F01                     241  BYTE     MOVE.L   D1,-(A7)          Save D1 
000011A0  61DE                     242           BSR      HEX               Get first hex character 
000011A2  E900                     243           ASL.B    #4,D0             Move it to MS nybble position 
000011A4  1200                     244           MOVE.B   D0,D1             Save MS nybble in D1 
000011A6  61D8                     245           BSR      HEX               Get second hex character 
000011A8  D001                     246           ADD.B    D1,D0             Merge MS and LS nybbles 
000011AA  221F                     247           MOVE.L   (A7)+,D1          Restore D1 
000011AC  4E75                     248           RTS 
000011AE                           249  * 
000011AE  61EE                     250  WORD     BSR      BYTE              Get upper order byte 
000011B0  E140                     251           ASL.W    #8,D0             Move it to MS position 
000011B2  60EA                     252           BRA      BYTE              Get LS byte and return 
000011B4                           253  * 
000011B4  61F8                     254  LONGWD   BSR      WORD              Get upper order word 
000011B6  4840                     255           SWAP     D0                Move it to MS position 
000011B8  60F4                     256           BRA      WORD              Get lower order word and return 
000011BA                           257  * 
000011BA                           258  *  PARAM reads a parameter from the line buffer and puts it in both 
000011BA                           259  *  PARAMTR(A6) and D0. Bit 1 of D7 is set on error. 
000011BA                           260  * 
000011BA  2F01                     261  PARAM    MOVE.L   D1,-(A7)          Save D1 
000011BC  4281                     262           CLR.L    D1                Clear input accumulator 
000011BE  206E 0048                263           MOVE.L   BUFFPT(A6),A0     A0 points to parameter in buffer 
000011C2  1018                     264  PARAM1   MOVE.B   (A0)+,D0          Read character from line buffer 
000011C4  B03C 0020                265           CMP.B    #SPACE,D0         Test for delimiter 
000011C8  6720                     266           BEQ.S    PARAM4            The permitted delimiter is a 
000011CA  B03C 000D                267           CMP.B    #CR,D0            space or a carriage return 
000011CE  671A                     268           BEQ.S    PARAM4            Exit on either space or C/R 
000011D0  E981                     269           ASL.L    #4,D1             Shift accumulated result 4 bits left 
000011D2  0400 0030                270           SUB.B    #$30,D0           Convert new character to hex 
000011D6  6B1E                     271           BMI.S    PARAM5            If less than $30 then not-hex 
000011D8  B03C 0009                272           CMP.B    #$09,D0           If less than 10 
000011DC  6F08                     273           BLE.S    PARAM3            then continue 
000011DE  5F00                     274           SUB.B    #$07,D0           Else assume $A - $F 
000011E0  B03C 000F                275           CMP.B    #$0F,D0           If more than $F 
000011E4  6E10                     276           BGT.S    PARAM5            then exit to error on not-hex 
000011E6  D200                     277  PARAM3   ADD.B    D0,D1             Add latest nybble to total in D1 
000011E8  60D8                     278           BRA      PARAM1            Repeat until delimiter found 
000011EA  2D48 0048                279  PARAM4   MOVE.L   A0,BUFFPT(A6)     Save pointer in memory 
000011EE  2D41 004C                280           MOVE.L   D1,PARAMTR(A6)    Save parameter in memory 
000011F2  2001                     281           MOVE.L   D1,D0             Put parameter in D0 for return 
000011F4  6004                     282           BRA.S    PARAM6            Return without error 
000011F6  8E3C 0002                283  PARAM5   OR.B     #2,D7             Set error flag before return 
000011FA  221F                     284  PARAM6   MOVE.L   (A7)+,D1          Restore working register 
000011FC  4E75                     285           RTS                        Return with error 
000011FE                           286  * 
000011FE                           287  ************************************************************************* 
000011FE                           288  * 
000011FE                           289  *  Output routines 
000011FE                           290  *  OUT1X   = print one   hexadecimal character 
000011FE                           291  *  OUT2X   = print two   hexadecimal characters 
000011FE                           292  *  OUT4X   = print four  hexadecimal characters 
000011FE                           293  *  OUT8X   = print eight hexadecimal characters 
000011FE                           294  *  In each case, the data to be printed is in D0 
000011FE                           295  * 
000011FE  3F00                     296  OUT1X    MOVE.W   D0,-(A7)          Save D0 
00001200  C03C 000F                297           AND.B    #$0F,D0           Mask off MS nybble 
00001204  0600 0030                298           ADD.B    #$30,D0           Convert to ASCII 
00001208  B03C 0039                299           CMP.B    #$39,D0           ASCII = HEX + $30 
0000120C  6302                     300           BLS.S    OUT1X1            If ASCII <= $39 then print and exit 
0000120E  5E00                     301           ADD.B    #$07,D0           Else ASCII := HEX + 7 
00001210  6100 0342                302  OUT1X1   BSR      PUTCHAR           Print the character 
00001214  301F                     303           MOVE.W   (A7)+,D0          Restore D0 
00001216  4E75                     304           RTS 
00001218                           305  * 
00001218  E818                     306  OUT2X    ROR.B    #4,D0             Get MS nybble in LS position 
0000121A  61E2                     307           BSR      OUT1X             Print MS nybble 
0000121C  E918                     308           ROL.B    #4,D0             Restore LS nybble 
0000121E  60DE                     309           BRA      OUT1X             Print LS nybble and return 
00001220                           310  * 
00001220  E058                     311  OUT4X    ROR.W    #8,D0             Get MS byte in LS position 
00001222  61F4                     312           BSR      OUT2X             Print MS byte 
00001224  E158                     313           ROL.W    #8,D0             Restore LS byte 
00001226  60F0                     314           BRA      OUT2X             Print LS byte and return 
00001228                           315  * 
00001228  4840                     316  OUT8X    SWAP     D0                Get MS word in LS position 
0000122A  61F4                     317           BSR      OUT4X             Print MS word 
0000122C  4840                     318           SWAP     D0                Restore LS word 
0000122E  60F0                     319           BRA      OUT4X             Print LS word and return 
00001230                           320  * 
00001230                           321  ************************************************************************* 
00001230                           322  * 
00001230                           323  * JUMP causes execution to begin at the address in the line buffer 
00001230                           324  * 
00001230  6188                     325  JUMP     BSR     PARAM              Get address from buffer 
00001232  4A07                     326           TST.B   D7                 Test for input error 
00001234  6608                     327           BNE.S   JUMP1              If error flag not zero then exit 
00001236  4A80                     328           TST.L   D0                 Else test for missing address 
00001238  6704                     329           BEQ.S   JUMP1              field. If no address then exit 
0000123A  2040                     330           MOVE.L  D0,A0              Put jump address in A0 and call the 
0000123C  4ED0                     331           JMP     (A0)               subroutine. User to supply RTS!! 
0000123E  49FA 0A27                332  JUMP1    LEA.L   ERMES1(PC),A4      Here for error - display error 
00001242  6000 FE42                333           BRA     PSTRING            message and return 
00001246                           334  * 
00001246                           335  ************************************************************************* 
00001246                           336  * 
00001246                           337  *  Display the contents of a memory location and modify it 
00001246                           338  * 
00001246  6100 FF72                339  MEMORY   BSR      PARAM             Get start address from line buffer 
0000124A  4A07                     340           TST.B    D7                Test for input error 
0000124C  6634                     341           BNE.S    MEM3              If error then exit 
0000124E  2640                     342           MOVE.L   D0,A3             A3 points to location to be opened 
00001250  6100 FE24                343  MEM1     BSR      NEWLINE 
00001254  612E                     344           BSR.S    ADR_DAT           Print current address and contents 
00001256  6140                     345           BSR.S    PSPACE             update pointer, A3, and O/P space 
00001258  6100 02CA                346           BSR      GETCHAR           Input char to decide next action 
0000125C  B03C 000D                347           CMP.B    #CR,D0            If carriage return then exit 
00001260  6720                     348           BEQ.S    MEM3              Exit 
00001262  B03C 002D                349           CMP.B    #'-',D0           If "-" then move back 
00001266  6606                     350           BNE.S    MEM2              Else skip wind-back procedure 
00001268  47EB FFFC                351           LEA.L    -4(A3),A3         Move pointer back 2+2 
0000126C  60E2                     352           BRA      MEM1              Repeat until carriage return 
0000126E  B03C 0020                353  MEM2     CMP.B    #SPACE,D0         Test for space (= new entry) 
00001272  66DC                     354           BNE.S    MEM1              If not space then repeat 
00001274  6100 FF38                355           BSR      WORD              Else get new word to store 
00001278  4A07                     356           TST.B    D7                Test for input error 
0000127A  6606                     357           BNE.S    MEM3              If error then exit 
0000127C  3740 FFFE                358           MOVE.W   D0,-2(A3)         Store new word 
00001280  60CE                     359           BRA      MEM1              Repeat until carriage return 
00001282  4E75                     360  MEM3     RTS 
00001284                           361  * 
00001284  2F00                     362  ADR_DAT  MOVE.L   D0,-(A7)          Print the contents of A3 and the 
00001286  200B                     363           MOVE.L   A3,D0             word pointed at by A3. 
00001288  619E                     364           BSR      OUT8X              and print current address 
0000128A  610C                     365           BSR.S    PSPACE            Insert delimiter 
0000128C  3013                     366           MOVE.W   (A3),D0           Get data at this address in D0 
0000128E  6190                     367           BSR      OUT4X              and print it 
00001290  47EB 0002                368           LEA.L    2(A3),A3          Point to next address to display 
00001294  201F                     369           MOVE.L   (A7)+,D0          Restore D0 
00001296  4E75                     370           RTS 
00001298                           371  * 
00001298  1F00                     372  PSPACE   MOVE.B   D0,-(A7)          Print a single space 
0000129A  103C 0020                373           MOVE.B   #SPACE,D0 
0000129E  6100 02B4                374           BSR      PUTCHAR 
000012A2  101F                     375           MOVE.B   (A7)+,D0 
000012A4  4E75                     376           RTS 
000012A6                           377  * 
000012A6                           378  ************************************************************************* 
000012A6                           379  * 
000012A6                           380  *  LOAD  Loads data formatted in hexadecimal "S" format from Port 2 
000012A6                           381  *        NOTE - I/O is automatically redirected to the aux port for 
000012A6                           382  *        loader functions. S1 or S2 records accepted 
000012A6                           383  * 
000012A6  2F2E 005A                384  LOAD     MOVE.L   CN_OVEC(A6),-(A7) Save current output device name 
000012AA  2F2E 0056                385           MOVE.L   CN_IVEC(A6),-(A7) Save current input device name 
000012AE  2D7C 00001E82 005A       386           MOVE.L   #DCB4,CN_OVEC(A6) Set up aux ACIA as output 
000012B6  2D7C 00001E70 0056       387           MOVE.L   #DCB3,CN_IVEC(A6) Set up aux ACIA as input 
000012BE  522E 0050                388           ADD.B    #1,ECHO(A6)       Turn off character echo 
000012C2  6100 FDB2                389           BSR      NEWLINE           Send newline to host 
000012C6  6100 015A                390           BSR      DELAY             Wait for host to "settle" 
000012CA  6100 0156                391           BSR      DELAY 
000012CE  286E 0048                392           MOVE.L   BUFFPT(A6),A4     Any string in the line buffer is 
000012D2  101C                     393  LOAD1    MOVE.B   (A4)+,D0          transmitted to the host computer 
000012D4  6100 027E                394           BSR      PUTCHAR           before the loading begins 
000012D8  B03C 000D                395           CMP.B    #CR,D0            Read from the buffer until EOL 
000012DC  66F4                     396           BNE      LOAD1 
000012DE  6100 FD96                397           BSR      NEWLINE           Send newline before loading 
000012E2  6100 0240                398  LOAD2    BSR      GETCHAR           Records from the host must begin 
000012E6  B03C 0053                399           CMP.B    #'S',D0           with S1/S2 (data) or S9/S8 (term) 
000012EA  66F6                     400           BNE.S    LOAD2             Repeat GETCHAR until char = "S" 
000012EC  6100 0236                401           BSR      GETCHAR           Get character after "S" 
000012F0  B03C 0039                402           CMP.B    #'9',D0           Test for the two terminators S9/S8 
000012F4  6706                     403           BEQ.S    LOAD3             If S9 record then exit else test 
000012F6  B03C 0038                404           CMP.B    #'8',D0           for S8 terminator. Fall through to 
000012FA  662A                     405           BNE.S    LOAD6             exit on S8 else continue search 
000012FC  =000012FC                406  LOAD3    EQU      *                 Exit point from LOAD 
000012FC  2D5F 0056                407           MOVE.L   (A7)+,CN_IVEC(A6) Clean up by restoring input device 
00001300  2D5F 005A                408           MOVE.L   (A7)+,CN_OVEC(A6) and output device name 
00001304  422E 0050                409           CLR.B    ECHO(A6)          Restore input character echo 
00001308  0807 0000                410           BTST     #0,D7             Test for input errors 
0000130C  6708                     411           BEQ.S    LOAD4             If no I/P error then look at checksum 
0000130E  49FA 0957                412           LEA.L    ERMES1(PC),A4     Else point to error message 
00001312  6100 FD72                413           BSR      PSTRING           Print it 
00001316  0807 0003                414  LOAD4    BTST     #3,D7             Test for checksum error 
0000131A  6708                     415           BEQ.S    LOAD5             If clear then exit 
0000131C  49FA 0979                416           LEA.L    ERMES3(PC),A4     Else point to error message 
00001320  6100 FD64                417           BSR      PSTRING           Print it and return 
00001324  4E75                     418  LOAD5    RTS 
00001326                           419  * 
00001326  B03C 0031                420  LOAD6    CMP.B    #'1',D0           Test for S1 record 
0000132A  671E                     421           BEQ.S    LOAD6A            If S1 record then read it 
0000132C  B03C 0032                422           CMP.B    #'2',D0           Else test for S2 record 
00001330  66B0                     423           BNE.S    LOAD2             Repeat until valid header found 
00001332  4203                     424           CLR.B    D3                Read the S2 byte count and address, 
00001334  613C                     425           BSR.S    LOAD8             clear the checksum 
00001336  5900                     426           SUB.B    #4,D0             Calculate size of data field 
00001338  1400                     427           MOVE.B   D0,D2             D2 contains data bytes to read 
0000133A  4280                     428           CLR.L    D0                Clear address accumulator 
0000133C  6134                     429           BSR.S    LOAD8             Read most sig byte of address 
0000133E  E180                     430           ASL.L    #8,D0             Move it one byte left 
00001340  6130                     431           BSR.S    LOAD8             Read the middle byte of address 
00001342  E180                     432           ASL.L    #8,D0             Move it one byte left 
00001344  612C                     433           BSR.S    LOAD8             Read least sig byte of address 
00001346  2440                     434           MOVE.L   D0,A2             A2 points to destination of record 
00001348  6012                     435           BRA.S    LOAD7             Skip past S1 header loader 
0000134A  4203                     436  LOAD6A   CLR.B    D3                S1 record found - clear checksum 
0000134C  6124                     437           BSR.S    LOAD8             Get byte and update checksum 
0000134E  5700                     438           SUB.B    #3,D0             Subtract 3 from record length 
00001350  1400                     439           MOVE.B   D0,D2             Save byte count in D2 
00001352  4280                     440           CLR.L    D0                Clear address accumulator 
00001354  611C                     441           BSR.S    LOAD8             Get MS byte of load address 
00001356  E180                     442           ASL.L    #8,D0             Move it to MS position 
00001358  6118                     443           BSR.S    LOAD8             Get LS byte in D2 
0000135A  2440                     444           MOVE.L   D0,A2             A2 points to destination of data 
0000135C  6114                     445  LOAD7    BSR.S    LOAD8             Get byte of data for loading 
0000135E  14C0                     446           MOVE.B   D0,(A2)+          Store it 
00001360  5302                     447           SUB.B    #1,D2             Decrement byte counter 
00001362  66F8                     448           BNE      LOAD7             Repeat until count = 0 
00001364  610C                     449           BSR.S    LOAD8             Read checksum 
00001366  5203                     450           ADD.B    #1,D3             Add 1 to total checksum 
00001368  6700 FF78                451           BEQ      LOAD2             If zero then start next record 
0000136C  8E3C 0008                452           OR.B     #%00001000,D7     Else set checksum error bit, 
00001370  608A                     453           BRA      LOAD3             restore I/O devices and return 
00001372                           454  * 
00001372  6100 FE2A                455  LOAD8    BSR     BYTE               Get a byte 
00001376  D600                     456           ADD.B   D0,D3              Update checksum 
00001378  4E75                     457           RTS                         and return 
0000137A                           458  * 
0000137A                           459  ************************************************************************* 
0000137A                           460  * 
0000137A                           461  *  DUMP   Transmit S1 formatted records to host computer 
0000137A                           462  *         A3 = Starting address of data block 
0000137A                           463  *         A2 = End address of data block 
0000137A                           464  *         D1 = Checksum, D2 = current record length 
0000137A                           465  * 
0000137A  6100 0096                466  DUMP     BSR      RANGE             Get start and end address 
0000137E  4A07                     467           TST.B    D7                Test for input error 
00001380  6708                     468           BEQ.S    DUMP1             If no error then continue 
00001382  49FA 08E3                469           LEA.L    ERMES1(PC),A4     Else point to error message, 
00001386  6000 FCFE                470           BRA      PSTRING           print it and return 
0000138A  B08B                     471  DUMP1    CMP.L    A3,D0             Compare start and end addresses 
0000138C  6A08                     472           BPL.S    DUMP2             If positive then start < end 
0000138E  49FA 098D                473           LEA.L    ERMES7(PC),A4     Else print error message 
00001392  6000 FCF2                474           BRA      PSTRING           and return 
00001396  2F2E 005A                475  DUMP2    MOVE.L   CN_OVEC(A6),-(A7) Save name of current output device 
0000139A  2D7C 00001E82 005A       476           MOVE.L   #DCB4,CN_OVEC(A6) Set up Port 2 as output device 
000013A2  6100 FCD2                477           BSR      NEWLINE           Send newline to host and wait 
000013A6  617A                     478           BSR.S    DELAY 
000013A8  286E 0048                479           MOVE.L   BUFFPT(A6),A4     Before dumping, send any string 
000013AC  101C                     480  DUMP3    MOVE.B   (A4)+,D0          in the input buffer to the host 
000013AE  6100 01A4                481           BSR      PUTCHAR           Repeat 
000013B2  B03C 000D                482           CMP.B    #CR,D0            Transmit char from buffer to host 
000013B6  66F4                     483           BNE      DUMP3             Until char = C/R 
000013B8  6100 FCBC                484           BSR      NEWLINE 
000013BC  6164                     485           BSR.S    DELAY             Allow time for host to settle 
000013BE  528A                     486           ADDQ.L   #1,A2             A2 contains length of record + 1 
000013C0  240A                     487  DUMP4    MOVE.L   A2,D2             D2 points to end address 
000013C2  948B                     488           SUB.L    A3,D2             D2 contains bytes left to print 
000013C4  B4BC 00000011            489           CMP.L    #17,D2            If this is not a full record of 16 
000013CA  6502                     490           BCS.S    DUMP5             then load D2 with record size 
000013CC  7410                     491           MOVEQ    #16,D2            Else preset byte count to 16 
000013CE  49FA 07D2                492  DUMP5    LEA.L    HEADER(PC),A4     Point to record header 
000013D2  6100 FCB2                493           BSR      PSTRING           Print header 
000013D6  4201                     494           CLR.B    D1                Clear checksum 
000013D8  1002                     495           MOVE.B   D2,D0             Move record length to output register 
000013DA  5600                     496           ADD.B    #3,D0             Length includes address + count 
000013DC  612E                     497           BSR.S    DUMP7             Print number of bytes in record 
000013DE  200B                     498           MOVE.L   A3,D0             Get start address to be printed 
000013E0  E158                     499           ROL.W    #8,D0             Get MS byte in LS position 
000013E2  6128                     500           BSR.S    DUMP7             Print MS byte of address 
000013E4  E058                     501           ROR.W    #8,D0             Restore LS byte 
000013E6  6124                     502           BSR.S    DUMP7             Print LS byte of address 
000013E8  101B                     503  DUMP6    MOVE.B   (A3)+,D0          Get data byte to be printed 
000013EA  6120                     504           BSR.S    DUMP7             Print it 
000013EC  5302                     505           SUB.B    #1,D2             Decrement byte count 
000013EE  66F8                     506           BNE      DUMP6             Repeat until all this record printed 
000013F0  4601                     507           NOT.B    D1                Complement checksum 
000013F2  1001                     508           MOVE.B   D1,D0             Move to output register 
000013F4  6116                     509           BSR.S    DUMP7             Print checksum 
000013F6  6100 FC7E                510           BSR      NEWLINE 
000013FA  B7CA                     511           CMP.L    A2,A3             Have all records been printed? 
000013FC  66C2                     512           BNE      DUMP4             Repeat until all done 
000013FE  49FA 07A8                513           LEA.L    TAIL(PC),A4       Point to message tail (S9 record) 
00001402  6100 FC82                514           BSR      PSTRING           Print it 
00001406  2D5F 005A                515           MOVE.L   (A7)+,CN_OVEC(A6) Restore name of output device 
0000140A  4E75                     516           RTS                        and return 
0000140C                           517  * 
0000140C  D200                     518  DUMP7    ADD.B    D0,D1             Update checksum, transmit byte 
0000140E  6000 FE08                519           BRA      OUT2X             to host and return 
00001412                           520  * 
00001412  =00001412                521  RANGE    EQU      *                 Get the range of addresses to be 
00001412  4207                     522           CLR.B    D7                transmitted from the buffer 
00001414  6100 FDA4                523           BSR      PARAM             Get starting address 
00001418  2640                     524           MOVE.L   D0,A3             Set up start address in A3 
0000141A  6100 FD9E                525           BSR      PARAM             Get end address 
0000141E  2440                     526           MOVE.L   D0,A2             Set up end address in A2 
00001420  4E75                     527           RTS 
00001422                           528  * 
00001422  =00001422                529  DELAY    EQU       *                Provide a time delay for the host 
00001422  48E7 8008                530           MOVEM.L   D0/A4,-(A7)      to settle. Save working registers 
00001426  203C 00004000            531           MOVE.L    #$4000,D0        Set up delay constant 
0000142C  5380                     532  DELAY1   SUB.L     #1,D0            Count down         (8 clk cycles) 
0000142E  66FC                     533           BNE       DELAY1           Repeat until zero  (10 clk cycles) 
00001430  4CDF 1001                534           MOVEM.L   (A7)+,D0/A4      Restore working registers 
00001434  4E75                     535           RTS 
00001436                           536  * 
00001436                           537  ************************************************************************* 
00001436                           538  * 
00001436                           539  *  TM  Enter transparant mode (All communication to go from terminal to 
00001436                           540  *  the host processor until escape sequence entered). End sequence 
00001436                           541  *  = ESC, E. A newline is sent to the host to "clear it down". 
00001436                           542  * 
00001436  13FC 0055 00008001       543  TM       MOVE.B    #$55,ACIA_1      Force RTS* high to re-route data 
0000143E  522E 0050                544           ADD.B     #1,ECHO(A6)      Turn off character echo 
00001442  6100 00E0                545  TM1      BSR       GETCHAR          Get character 
00001446  B03C 001B                546           CMP.B     #ESC,D0          Test for end of TM mode 
0000144A  66F6                     547           BNE       TM1              Repeat until first escape character 
0000144C  6100 00D6                548           BSR       GETCHAR          Get second character 
00001450  B03C 0045                549           CMP.B     #'E',D0          If second char = E then exit TM 
00001454  66EC                     550           BNE       TM1              Else continue 
00001456  2F2E 005A                551           MOVE.L    CN_OVEC(A6),-(A7) Save output port device name 
0000145A  2D7C 00001E82 005A       552           MOVE.L    #DCB4,CN_OVEC(A6) Get name of host port (aux port) 
00001462  6100 FC12                553           BSR       NEWLINE          Send newline to host to clear it 
00001466  2D5F 005A                554           MOVE.L    (A7)+,CN_OVEC(A6) Restore output device port name 
0000146A  422E 0050                555           CLR.B     ECHO(A6)         Restore echo mode 
0000146E  13FC 0015 00008001       556           MOVE.B    #$15,ACIA_1      Restore normal ACIA mode (RTS* low) 
00001476  4E75                     557           RTS 
00001478                           558  * 
00001478                           559  ************************************************************************* 
00001478                           560  * 
00001478                           561  *  This routine sets up the system DCBs in RAM using the information 
00001478                           562  *  stored in ROM at address DCB_LST. This is called at initialization. 
00001478                           563  *  CN_IVEC contains the name "DCB1" and IO_VEC the name "DCB2" 
00001478                           564  * 
00001478  48E7 F0F0                565  SET_DCB  MOVEM.L A0-A3/D0-D3,-(A7) Save all working registers 
0000147C  41EE 00D8                566           LEA.L   FIRST(A6),A0    Pointer to first DCB destination in RAM 
00001480  43FA 09CA                567           LEA.L   DCB_LST(PC),A1  A1 points to DCB info block in ROM 
00001484  303C 0005                568           MOVE.W  #5,D0           6 DCBs to set up 
00001488  323C 000F                569  ST_DCB1  MOVE.W  #15,D1          16 bytes to move per DCB header 
0000148C  10D9                     570  ST_DCB2  MOVE.B  (A1)+,(A0)+     Move the 16 bytes of a DCB header 
0000148E  51C9 FFFC                571           DBRA    D1,ST_DCB2      from ROM to RAM 
00001492  3619                     572           MOVE.W  (A1)+,D3        Get size of parameter block (bytes) 
00001494  3083                     573           MOVE.W  D3,(A0)         Store size in DCB in RAM 
00001496  41F0 3002                574           LEA.L   2(A0,D3.W),A0   A0 points to tail of DCB in RAM 
0000149A  47E8 0004                575           LEA.L   4(A0),A3        A3 contains address of next DCB in RAM 
0000149E  208B                     576           MOVE.L  A3,(A0)         Store pointer to next DCB in this DCB 
000014A0  41D3                     577           LEA.L   (A3),A0         A0 now points at next DCB in RAM 
000014A2  51C8 FFE4                578           DBRA    D0,ST_DCB1      Repeat until all DCBs set up 
000014A6  47EB FFFC                579           LEA.L   -4(A3),A3       Adjust A3 to point to last DCB pointer 
000014AA  4293                     580           CLR.L   (A3)            and force last pointer to zero 
000014AC  2D7C 00001E4C 0056       581           MOVE.L  #DCB1,CN_IVEC(A6) Set up vector to console input DCB 
000014B4  2D7C 00001E5E 005A       582           MOVE.L  #DCB2,CN_OVEC(A6) Set up vector to console output DCB 
000014BC  4CDF 0F0F                583           MOVEM.L (A7)+,A0-A3/D0-D3 Restore registers 
000014C0  4E75                     584           RTS 
000014C2                           585  * 
000014C2                           586  ************************************************************************* 
000014C2                           587  * 
000014C2                           588  *  IO_REQ handles all input/output transactions. A0 points to DCB on 
000014C2                           589  *  entry. IO_REQ calls the device driver whose address is in the DCB. 
000014C2                           590  * 
000014C2  48E7 00C0                591  IO_REQ   MOVEM.L A0-A1,-(A7)     Save working registers 
000014C6  43E8 0008                592           LEA.L   8(A0),A1        A1 points to device handler field in DCB 
000014CA  2251                     593           MOVE.L  (A1),A1         A1 contains device handler address 
000014CC  4E91                     594           JSR     (A1)            Call device handler 
000014CE  4CDF 0300                595           MOVEM.L (A7)+,A0-A1     Restore working registers 
000014D2  4E75                     596           RTS 
000014D4                           597  * 
000014D4                           598  ************************************************************************* 
000014D4                           599  * 
000014D4                           600  *  CON_IN handles input from the console device 
000014D4                           601  *  Exit with input in D0 
000014D4                           602  * 
000014D4  48E7 4000                603  CON_IN   MOVEM.L D1,-(A7)         Save working registers 
000014D8  4228 0013                604      CLR.B    19(A0)
000014DC  103C 0005                605           MOVE.B    #5,D0             Read input from ACIA
000014E0  4E4F                     606      TRAP     #15
000014E2  1001                     607      MOVE.B  D1,D0
000014E4  4CDF 0002                608           MOVEM.L (A7)+,D1     `   Restore working registers 
000014E8  4E75                     609           RTS 
000014EA                           610  * 
000014EA                           611  ************************************************************************* 
000014EA                           612  * 
000014EA                           613  *   This is the CON_OUT device driver. Output in D0  
000014EA                           614  * 
000014EA  48E7 4000                615  CON_OUT  MOVEM.L D1,-(A7)  Save working registers 
000014EE  4228 0013                616      CLR.B    19(A0)
000014F2  1200                     617           MOVE.B    D0,D1
000014F4  103C 0006                618           MOVE.B    #6,D0
000014F8  4E4F                     619           TRAP   #15
000014FA  4CDF 0002                620           MOVEM.L (A7)+,D1  Restore working registers 
000014FE  4E75                     621           RTS 
00001500                           622  * 
00001500                           623  ************************************************************************* 
00001500                           624  * 
00001500                           625  *  AUX_IN and AUX_OUT are simplified versions of CON_IN and 
00001500                           626  *  CON_OUT for use with the port to the host processor 
00001500                           627  * 
00001500  43E8 000C                628  AUX_IN   LEA.L   12(A0),A1       Get pointer to aux ACIA from DCB 
00001504  2251                     629           MOVE.L  (A1),A1         Get address of aux ACIA 
00001506  0811 0000                630  AUX_IN1  BTST.B  #0,(A1)         Test for data ready 
0000150A  67FA                     631           BEQ     AUX_IN1         Repeat until ready 
0000150C  1029 0002                632           MOVE.B  2(A1),D0        Read input 
00001510  4E75                     633           RTS 
00001512                           634  * 
00001512  43E8 000C                635  AUX_OUT  LEA.L   12(A0),A1       Get pointer to aux ACIA from DCB 
00001516  2251                     636           MOVE.L  (A1),A1         Get address of aux ACIA 
00001518  0811 0001                637  AUX_OT1  BTST.B  #1,(A1)         Test for ready to transmit 
0000151C  67FA                     638           BEQ     AUX_OT1         Repeat until transmitter ready 
0000151E  1340 0002                639           MOVE.B  D0,2(A1)        Transmit data 
00001522  4E75                     640           RTS 
00001524                           641  * 
00001524                           642  ************************************************************************* 
00001524                           643  * 
00001524                           644  *  GETCHAR gets a character from the console device 
00001524                           645  *  This is the main input routine and uses the device whose name  
00001524                           646  *  is stored in CN_IVEC. Changing this name redirects input. 
00001524                           647  * 
00001524  2F08                     648  GETCHAR  MOVE.L  A0,-(A7)        Save working register 
00001526  206E 0056                649           MOVE.L  CN_IVEC(A6),A0  A0 points to name of console DCB 
0000152A  6156                     650           BSR.S   IO_OPEN         Open console (get DCB address in A0) 
0000152C  0807 0003                651           BTST    #3,D7           D7(3) set if open error 
00001530  661E                     652           BNE.S   GETCH3          If error then exit now 
00001532  618E                     653           BSR     IO_REQ          Else execute I/O transaction 
00001534  C03C 007F                654           AND.B   #$7F,D0         Strip msb of input 
00001538  4A2E 0051                655           TST.B   U_CASE(A6)      Test for upper -> lower case conversion 
0000153C  660A                     656           BNE.S   GETCH2          If flag not zero do not convert case 
0000153E  0800 0006                657           BTST    #6,D0             Test input for lower case 
00001542  6704                     658           BEQ.S   GETCH2          If upper case then skip conversion 
00001544  C03C 00DF                659           AND.B   #%11011111,D0   Else clear bit 5 for upper case conv 
00001548  4A2E 0050                660  GETCH2   TST.B   ECHO(A6)        Do we need to echo the input? 
0000154C  6602                     661           BNE.S   GETCH3          If ECHO not zero then no echo 
0000154E  6104                     662           BSR.S   PUTCHAR         Else echo the input 
00001550  205F                     663  GETCH3   MOVE.L  (A7)+,A0        Restore working register 
00001552  4E75                     664           RTS                     and return 
00001554                           665  * 
00001554                           666  ************************************************************************* 
00001554                           667  * 
00001554                           668  *  PUTCHAR sends a character to the console device 
00001554                           669  *  The name of the output device is in CN_OVEC. 
00001554                           670  * 
00001554  BC3C 0001                671  PUTCHAR  CMP.B   #1,D6
00001558                           672           *BEQ     PUTASK
00001558  2F08                     673           MOVE.L  A0,-(A7)        Save working register
0000155A  206E 005A                674           MOVE.L  CN_OVEC(A6),A0  A0 points to name of console output 
0000155E  6122                     675           BSR.S   IO_OPEN         Open console (Get address of DCB) 
00001560  6100 FF60                676           BSR     IO_REQ          Perform output with DCB pointed at by A0 
00001564  205F                     677           MOVE.L  (A7)+,A0        Restore working register 
00001566  4E75                     678           RTS 
00001568                           679  
00001568                           680  *PUTASK   MOVE    D0,-(A5)
00001568                           681  *         MOVE    #'*',D0
00001568                           682  *         MOVE.L  A0,-(A7)        Save working register
00001568                           683  *         MOVE.L  CN_OVEC(A6),A0  A0 points to name of console output 
00001568                           684  *         BSR.S   IO_OPEN         Open console (Get address of DCB) 
00001568                           685  *         BSR     IO_REQ          Perform output with DCB pointed at by A0 
00001568                           686  *         MOVE.L  (A7)+,A0        Restore working register
00001568                           687  *         MOVE    (A5)+,D0
00001568                           688  *         RTS 
00001568                           689  * 
00001568                           690  ************************************************************************* 
00001568                           691  * 
00001568                           692  *  BUFF_IN and BUFF_OUT are two rudimentary input and output routines 
00001568                           693  *  which input data from and output data to a buffer in RAM. These are 
00001568                           694  *  used by DCB5 and DCB6, respectively. 
00001568                           695  * 
00001568  43E8 000C                696  BUFF_IN  LEA.L   12(A0),A1       A1 points to I/P buffer 
0000156C  2451                     697           MOVE.L  (A1),A2         A2 gets I/P pointer from buffer 
0000156E  1022                     698           MOVE.B  -(A2),D0        Read char from buffer and adjust A2 
00001570  228A                     699           MOVE.L  A2,(A1)         Restore pointer in buffer 
00001572  4E75                     700           RTS 
00001574                           701  * 
00001574  43E8 000C                702  BUFF_OT  LEA.L   12(A0),A1       A1 points to O/P buffer 
00001578  2469 0004                703           MOVE.L  4(A1),A2        A2 gets O/P pointer from buffer 
0000157C  14C0                     704           MOVE.B  D0,(A2)+        Store char in buffer and adjust A2 
0000157E  228A                     705           MOVE.L  A2,(A1)         Restore pointer in buffer 
00001580  4E75                     706           RTS 
00001582                           707  * 
00001582                           708  ************************************************************************* 
00001582                           709  * 
00001582                           710  *  Open - opens a DCB for input or output. IO_OPEN converts the 
00001582                           711  *  name pointed at by A0 into the address of the DCB pointed at 
00001582                           712  *  by A0. Bit 3 of D7 is set to zero if DCB not found 
00001582                           713  * 
00001582  48E7 F870                714  IO_OPEN  MOVEM.L  A1-A3/D0-D4,-(A7) Save working registers 
00001586  43EE 00D8                715           LEA.L    FIRST(A6),A1   A1 points to first DCB in chain in RAM 
0000158A  45D1                     716  OPEN1    LEA.L    (A1),A2        A2 = temp copy of pointer to DCB 
0000158C  47D0                     717           LEA.L    (A0),A3        A3 = temp copy of pointer to DCB name 
0000158E  303C 0007                718           MOVE.W   #7,D0          Up to 8 chars of DCB name to match 
00001592  181A                     719  OPEN2    MOVE.B   (A2)+,D4       Compare DCB name with string 
00001594  B81B                     720           CMP.B    (A3)+,D4 
00001596  6608                     721           BNE.S    OPEN3          If no match try next DCB 
00001598  51C8 FFF8                722           DBRA     D0,OPEN2       Else repeat until all chars matched 
0000159C  41D1                     723           LEA.L    (A1),A0        Success - move this DCB address to A0 
0000159E  6016                     724           BRA.S    OPEN4          and return 
000015A0  =000015A0                725  OPEN3    EQU      *              Fail - calculate address of next DCB 
000015A0  3229 0010                726           MOVE.W   16(A1),D1      Get parameter block size of DCB 
000015A4  43F1 1012                727           LEA.L    18(A1,D1.W),A1 A1 points to pointer to next DCB 
000015A8  2251                     728           MOVE.L   (A1),A1        A1 now points to next DCB 
000015AA  B3FC 00000000            729           CMP.L    #0,A1          Test for end of DCB chain 
000015B0  66D8                     730           BNE      OPEN1          If not end of chain then try next DCB 
000015B2  8E3C 0008                731           OR.B     #8,D7          Else set error flag and return 
000015B6  4CDF 0E1F                732  OPEN4    MOVEM.L  (A7)+,A1-A3/D0-D4 Restore working registers 
000015BA  4E75                     733           RTS 
000015BC                           734  * 
000015BC                           735  ************************************************************************* 
000015BC                           736  * 
000015BC                           737  *  Exception vector table initialization routine 
000015BC                           738  *  All vectors not setup are loaded with uninitialized routine vector 
000015BC                           739  * 
000015BC  303C 0007                740  X_SET   MOVE.W  #7,D0             Now clear the breakpoint table 
000015C0  41EE 00A8                741          LEA.L   BP_TAB(A6),A0     Point to table 
000015C4  4298                     742  X_SET2  CLR.L   (A0)+             Clear an address entry 
000015C6  4258                     743          CLR.W   (A0)+             Clear the corresponding data 
000015C8  51C8 FFFA                744          DBRA    D0,X_SET2         Repeat until all 8 cleared 
000015CC  4E75                     745          RTS 
000015CE                           746  * 
000015CE                           747  ************************************************************************* 
000015CE                           748  * 
000015CE  =000015CE                749  TRAP_0  EQU     *                 User links to  TS2BUG via TRAP #0 
000015CE  B23C 0000                750          CMP.B   #0,D1             D1 = 0 = Get character 
000015D2  6606                     751          BNE.S   FOO1           
000015D4  6100 FF4E                752          BSR     GETCHAR 
000015D8  4E73                     753          RTE 
000015DA  B23C 0001                754  FOO1    CMP.B   #1,D1             D1 = 1 = Print character 
000015DE  6606                     755          BNE.S   FOO2 
000015E0  6100 FF72                756          BSR     PUTCHAR 
000015E4  4E73                     757          RTE 
000015E6  B23C 0002                758  FOO2    CMP.B   #2,D1             D1 = 2 = Newline 
000015EA  6606                     759          BNE.S   FOO3 
000015EC  6100 FA88                760          BSR     NEWLINE 
000015F0  4E73                     761          RTE 
000015F2  B23C 0003                762  FOO3    CMP.B   #3,D1             D1 = 3 = Get parameter from buffer 
000015F6  6606                     763          BNE.S   FOO4 
000015F8  6100 FBC0                764          BSR     PARAM 
000015FC  4E73                     765          RTE 
000015FE  B23C 0004                766  FOO4    CMP.B   #4,D1             D1 = 4 = Print string pointed at by A4 
00001602  6606                     767          BNE.S   FOO5 
00001604  6100 FA80                768          BSR     PSTRING 
00001608  4E73                     769          RTE 
0000160A  B23C 0005                770  FOO5    CMP.B   #5,D1             D1 = 5 = Get a hex character 
0000160E  6606                     771          BNE.S   FOO6 
00001610  6100 FB6E                772          BSR     HEX 
00001614  4E73                     773          RTE 
00001616  B23C 0006                774  FOO6    CMP.B   #6,D1             D1 = 6 = Get a hex byte 
0000161A  6606                     775          BNE.S   FOO7 
0000161C  6100 FB80                776          BSR     BYTE 
00001620  4E73                     777          RTE 
00001622  B23C 0007                778  FOO7    CMP.B   #7,D1             D1 = 7 = Get a word 
00001626  6606                     779          BNE.S   FOO8 
00001628  6100 FB84                780          BSR     WORD 
0000162C  4E73                     781          RTE 
0000162E  B23C 0008                782  FOO8    CMP.B   #8,D1             D1 = 8 = Get a longword 
00001632  6606                     783          BNE.S   FOO9 
00001634  6100 FB7E                784          BSR     LONGWD 
00001638  4E73                     785          RTE 
0000163A  B23C 0009                786  FOO9    CMP.B   #9,D1             D1 = 9 = Output hex byte 
0000163E  6606                     787          BNE.S   FOO10  
00001640  6100 FBD6                788          BSR     OUT2X 
00001644  4E73                     789          RTE 
00001646  B23C 000A                790  FOO10   CMP.B   #10,D1            D1 = 10 = Output hex word 
0000164A  6606                     791          BNE.S   FOO11 
0000164C  6100 FBD2                792          BSR     OUT4X 
00001650  4E73                     793          RTE 
00001652  B23C 000B                794  FOO11   CMP.B   #11,D1            D1 = 11 = Output hex longword 
00001656  6606                     795          BNE.S   FOO12 
00001658  6100 FBCE                796          BSR     OUT8X 
0000165C  4E73                     797          RTE 
0000165E  B23C 000C                798  FOO12   CMP.B   #12,D1            D1 = 12 = Print a space 
00001662  6606                     799          BNE.S   FOO13 
00001664  6100 FC32                800          BSR     PSPACE 
00001668  4E73                     801          RTE 
0000166A  B23C 000D                802  FOO13   CMP.B   #13,D1            D1 = 13 = Get a line of text into 
0000166E  6606                     803          BNE.S   FOO14            the line buffer 
00001670  6100 FA2A                804          BSR     GETLINE 
00001674  4E73                     805          RTE 
00001676  B23C 000E                806  FOO14   CMP.B   #14,D1            D1 = 14 = Tidy up the line in the 
0000167A  6606                     807          BNE.S   FOO15            line buffer by removing leading 
0000167C  6100 FA54                808          BSR     TIDY              leading and multiple embeded spaces 
00001680  4E73                     809          RTE 
00001682  B23C 000F                810  FOO15   CMP.B   #15,D1            D1 = 15 = Execute the command in 
00001686  6606                     811          BNE.S   FOO16            the line buffer 
00001688  6100 FA8A                812          BSR     EXECUTE 
0000168C  4E73                     813          RTE 
0000168E  B23C 0010                814  FOO16   CMP.B   #16,D1            D1 = 16 = Call RESTORE to transfer 
00001692  6606                     815          BNE.S   FOO17            the registers in TSK_T to the 68000 
00001694  6100 02C4                816          BSR     RESTORE           and therefore execute a program 
00001698  4E73                     817          RTE 
0000169A  4E73                     818  FOO17   RTE 
0000169C                           819  * 
0000169C                           820  ************************************************************************* 
0000169C                           821  * 
0000169C                           822  *  Display exception frame (D0 - D7, A0 - A6, USP, SSP, SR, PC) 
0000169C                           823  *  EX_DIS prints registers saved after a breakpoint or exception 
0000169C                           824  *  The registers are saved in TSK_T 
0000169C                           825  * 
0000169C  4BEE 005E                826  EX_DIS  LEA.L   TSK_T(A6),A5      A5 points to display frame 
000016A0  49FA 0527                827          LEA.L   MES3(PC),A4       Point to heading 
000016A4  6100 F9F0                828          BSR     HEADING           and print it 
000016A8  3C3C 0007                829          MOVE.W  #7,D6             8 pairs of registers to display 
000016AC  4205                     830          CLR.B   D5                D5 is the line counter 
000016AE  1005                     831  EX_D1   MOVE.B  D5,D0             Put current register number in D0 
000016B0  6100 FB4C                832          BSR     OUT1X             and print it 
000016B4  6100 FBE2                833          BSR     PSPACE            and a space 
000016B8  5205                     834          ADD.B   #1,D5             Update counter for next pair 
000016BA  2015                     835          MOVE.L  (A5),D0           Get data register to be displayed 
000016BC  6100 FB6A                836          BSR     OUT8X             from the frame and print it 
000016C0  49FA 0525                837          LEA.L   MES4(PC),A4       Print string of spaces 
000016C4  6100 F9C0                838          BSR.L   PSTRING           between data and address registers 
000016C8  202D 0020                839          MOVE.L  32(A5),D0         Get address register to be displayed 
000016CC  6100 FB5A                840          BSR     OUT8X             which is 32 bytes on from data reg 
000016D0  6100 F9A4                841          BSR     NEWLINE 
000016D4  4BED 0004                842          LEA.L   4(A5),A5          Point to next pair (ie Di, Ai) 
000016D8  51CE FFD4                843          DBRA    D6,EX_D1          Repeat until all displayed 
000016DC  4BED 0020                844          LEA.L   32(A5),A5         Adjust pointer by 8 longwords 
000016E0  6100 F994                845          BSR     NEWLINE           to point to SSP 
000016E4  49FA 04DA                846          LEA.L   MES2A(PC),A4      Point to "SS =" 
000016E8  6100 F99C                847          BSR     PSTRING           Print it 
000016EC  201D                     848          MOVE.L  (A5)+,D0          Get SSP from frame 
000016EE  6100 FB38                849          BSR     OUT8X             and display it 
000016F2  6100 F982                850          BSR     NEWLINE 
000016F6  49FA 04B6                851          LEA.L   MES1(PC),A4       Point to 'SR =' 
000016FA  6100 F98A                852          BSR     PSTRING           Print it 
000016FE  301D                     853          MOVE.W  (A5)+,D0          Get status register 
00001700  6100 FB1E                854          BSR     OUT4X             Display status 
00001704  6100 F970                855          BSR     NEWLINE 
00001708  49FA 04AD                856          LEA.L   MES2(PC),A4       Point to 'PC =' 
0000170C  6100 F978                857          BSR     PSTRING           Print it 
00001710  201D                     858          MOVE.L  (A5)+,D0          Get PC 
00001712  6100 FB14                859          BSR     OUT8X             Display PC 
00001716  6000 F95E                860          BRA     NEWLINE           Newline and return 
0000171A                           861  * 
0000171A                           862  ************************************************************************* 
0000171A                           863  
0000171A  49F9 00001CE7            864  HELP     LEA.L    JUMPHELP,A4
00001720  6100 F964                865           BSR.W    PSTRING
00001724  6100 F950                866           BSR.W    NEWLINE
00001728  4E75                     867           RTS
0000172A                           868           
0000172A                           869  *************************************************************************
0000172A  B83C 0003                870  LOGIN    CMP.B    #3,D4
0000172E  6700 00C2                871           BEQ      QUIT
00001732  49F9 00001D38            872           LEA.L    LOGINM1,A4
00001738  6100 F94C                873           BSR.W    PSTRING           
0000173C  6100 F938                874           BSR.W    NEWLINE
00001740  6100 F95A                875           BSR      GETLINE
00001744  49F9 00001D2A            876           LEA.L    UNAME,A4
0000174A  1A19                     877  LOGIN1   MOVE.B   (A1)+,D5
0000174C  BA1C                     878           CMP.B    (A4)+,D5
0000174E  67FA                     879           BEQ      LOGIN1            iterate through checking each char
00001750  0C21 000D                880           CMP.B    #CR,-(A1)         check for carriage return
00001754  6600 006A                881           BNE      WRONG             if not then wrong input
00001758  0C24 0000                882           CMP.B    #NUL,-(A4)        check for end of stored string
0000175C  6600 0062                883           BNE      WRONG             if not then wrong input
00001760  49F9 00001D6D            884           LEA.L    USRSUC,A4         print success
00001766  6100 F91E                885           BSR.W    PSTRING
0000176A  6100 F90A                886           BSR.W    NEWLINE
0000176E  49F9 00001D49            887           LEA.L    LOGINM2,A4
00001774  6100 F910                888           BSR.W    PSTRING
00001778  6100 F8FC                889           BSR.W    NEWLINE
0000177C  1C3C 0001                890           MOVE.B   #1,D6
00001780  6100 F91A                891           BSR.W    GETLINE
00001784  1C3C 0000                892           MOVE.B   #0,D6
00001788  49F9 00001D2F            893           LEA.L    PWORD,A4
0000178E  1A19                     894  LOGIN2   MOVE.B   (A1)+,D5
00001790  BA1C                     895           CMP.B    (A4)+,D5
00001792  67FA                     896           BEQ      LOGIN2            iterate through checking each char
00001794  0C21 000D                897           CMP.B    #CR,-(A1)          check for carriage return
00001798  6600 0026                898           BNE      WRONG             if not then wrong input
0000179C  0C24 0000                899           CMP.B    #NUL,-(A4)            check for end of stored string
000017A0  6600 0032                900           BNE      WRONGPW             if not then wrong input
000017A4  49F9 00001D91            901           LEA.L    PWSUC,A4
000017AA  6000 F8DA                902           BRA      PSTRING
000017AE  49F9 00001D38            903           LEA.L    LOGINM1,A4
000017B4  6100 F8D0                904           BSR.W    PSTRING           print success
000017B8  6100 F8BC                905           BSR.W    NEWLINE
000017BC  6000 F8A8                906           BRA      WARM
000017C0                           907  
000017C0  49F9 00001D5A            908  WRONG    LEA.L    USRERR,A4   
000017C6  6100 F8BE                909           BSR.W    PSTRING
000017CA  6100 F8AA                910           BSR.W    NEWLINE
000017CE  5204                     911           ADD.B    #1,D4
000017D0  6000 FF58                912           BRA      LOGIN
000017D4                           913  
000017D4  49F9 00001D7E            914  WRONGPW  LEA.L    PWERR,A4   
000017DA  6100 F8AA                915           BSR.W    PSTRING
000017DE  6100 F896                916           BSR.W    NEWLINE
000017E2  5204                     917           ADD.B    #1,D4
000017E4  6000 FF44                918           BRA      LOGIN
000017E8                           919  
000017E8  49F9 00001D6D            920  UPASS    LEA.L    USRSUC,A4
000017EE  6000 F896                921           BRA      PSTRING  
000017F2                           922  
000017F2  4EF8 17F2                923  QUIT     JMP      QUIT
000017F6                           924  *
000017F6                           925  ************************************************************************* 
000017F6  2878 03D8                926  TV       MOVE.L   MIN_RAM,A4
000017FA  323C 0000                927  LOOPRAM  MOVE.W   #0,D1
000017FE  3881                     928           MOVE.W   D1,(A4)
00001800  49EC 0002                929           LEA.L    2(A4),A4          Point to next address to display
00001804  B9F8 03DC                930           CMP.L    MAX_RAM,A4
00001808  66F0                     931           BNE      LOOPRAM
0000180A  2878 03D8                932           MOVE.L   MIN_RAM,A4
0000180E  3214                     933  CHECK1   MOVE.W   (A4),D1
00001810  B27C 0000                934           CMP.W    #0,D1
00001814  6600 003A                935           BNE      MEMFAIL
00001818  49EC 0002                936  CHECK2   LEA.L    2(A4),A4          Point to next address to read
0000181C  B9F8 03DC                937           CMP.L    MAX_RAM,A4
00001820  66EC                     938           BNE      CHECK1
00001822  2878 03D8                939           MOVE.L   MIN_RAM,A4
00001826  323C FFFE                940  LOOPRAM1 MOVE.W   #65534,D1
0000182A  3881                     941           MOVE.W   D1,(A4)
0000182C  49EC 0002                942           LEA.L    2(A4),A4          Point to next address to display
00001830  B9F8 03DC                943           CMP.L    MAX_RAM,A4
00001834  66F0                     944           BNE      LOOPRAM1
00001836  2878 03D8                945           MOVE.L   MIN_RAM,A4
0000183A  3214                     946  CHECK3   MOVE.W   (A4),D1
0000183C  B27C FFFF                947           CMP.W    #65535,D1
00001840  6600 0028                948           BNE      MEMFAIL2
00001844  49EC 0002                949  CHECK4   LEA.L    2(A4),A4          Point to next address to read
00001848  B9F8 03DC                950           CMP.L    MAX_RAM,A4
0000184C  66EC                     951           BNE      CHECK3
0000184E  4E75                     952           RTS
00001850                           953  
00001850  2F0C                     954  MEMFAIL  MOVE.L  A4,-(A7)          Save A4 
00001852  6100 F822                955           BSR.W   NEWLINE
00001856  49F9 00001DA2            956           LEA.L   MEMFMSG,A4
0000185C  6100 F828                957           BSR.W   PSTRING
00001860  285F                     958           MOVE.L  (A7)+,A4          Restore A4
00001862  200C                     959           MOVE.L  A4,D0
00001864  6100 F9C2                960           BSR.W    OUT8X 
00001868  60AE                     961           BRA     CHECK2
0000186A                           962  
0000186A  2F0C                     963  MEMFAIL2  MOVE.L  A4,-(A7)          Save A4 
0000186C  6100 F808                964           BSR.W   NEWLINE
00001870  49F9 00001DA2            965           LEA.L   MEMFMSG,A4
00001876  6100 F80E                966           BSR.W   PSTRING
0000187A  285F                     967           MOVE.L  (A7)+,A4          Restore A4
0000187C  200C                     968           MOVE.L  A4,D0
0000187E  6100 F9A8                969           BSR.W    OUT8X 
00001882  60C0                     970           BRA     CHECK4         
00001884                           971  
00001884                           972  *************************************************************************         
00001884                           973  * 
00001884                           974  *  Exception handling routines 
00001884                           975  * 
00001884  =00001884                976  IL_ER   EQU      *                Illegal instruction exception 
00001884  2F0C                     977          MOVE.L  A4,-(A7)          Save A4 
00001886  49FA 0389                978          LEA.L   MES10(PC),A4      Point to heading 
0000188A  6100 F80A                979          BSR     HEADING           Print it 
0000188E  285F                     980          MOVE.L  (A7)+,A4          Restore A4 
00001890  6176                     981          BSR.S   GROUP2            Save registers in display frame 
00001892  6100 FE08                982          BSR     EX_DIS            Display registers saved in frame 
00001896  6000 F7CE                983          BRA     WARM              Abort from illegal instruction 
0000189A                           984  * 
0000189A  =0000189A                985  BUS_ER  EQU     *                 Bus error (group 1) exception 
0000189A  2F0C                     986          MOVE.L  A4,-(A7)          Save A4 
0000189C  49FA 0353                987          LEA.L   MES8(PC),A4       Point to heading 
000018A0  6100 F7F4                988          BSR     HEADING           Print it 
000018A4  285F                     989          MOVE.L  (A7)+,A4          Restore A4 
000018A6  602C                     990          BRA.S   GROUP1            Deal with group 1 exception 
000018A8                           991  * 
000018A8  =000018A8                992  ADD_ER  EQU     *                 Address error (group 1) exception 
000018A8  2F0C                     993          MOVE.L  A4,-(A7)          Save A4 
000018AA  49FA 0353                994          LEA.L   MES9(PC),A4       Point to heading 
000018AE  6100 F7E6                995          BSR     HEADING           Print it 
000018B2  285F                     996          MOVE.L  (A7)+,A4          Restore A4 
000018B4  601E                     997          BRA.S   GROUP1            Deal with group 1 exception 
000018B6                           998  * 
000018B6  =000018B6                999  BRKPT   EQU     *                   Deal with breakpoint 
000018B6  48E7 FFFE               1000          MOVEM.L D0-D7/A0-A6,-(A7)   Save all registers 
000018BA  6100 0180               1001          BSR     BR_CLR              Clear breakpoints in code 
000018BE  4CDF 7FFF               1002          MOVEM.L (A7)+,D0-D7/A0-A6   Restore registers 
000018C2  6144                    1003          BSR.S   GROUP2            Treat as group 2 exception 
000018C4  49FA 0361               1004          LEA.L   MES11(PC),A4      Point to heading 
000018C8  6100 F7CC               1005          BSR     HEADING           Print it 
000018CC  6100 FDCE               1006          BSR     EX_DIS            Display saved registers 
000018D0  6000 F794               1007          BRA     WARM              Return to monitor 
000018D4                          1008  * 
000018D4                          1009  *       GROUP1 is called by address and bus error exceptions 
000018D4                          1010  *       These are "turned into group 2" exceptions (eg TRAP) 
000018D4                          1011  *       by modifying the stack frame saved by a group 1 exception 
000018D4                          1012  * 
000018D4  48E7 8080               1013  GROUP1  MOVEM.L D0/A0,-(A7)       Save working registers 
000018D8  206F 0012               1014          MOVE.L  18(A7),A0         Get PC from group 1 stack frame 
000018DC  302F 000E               1015          MOVE.W  14(A7),D0         Get instruction from stack frame 
000018E0  B060                    1016          CMP.W   -(A0),D0          Now backtrack to find the "correct PC" 
000018E2  670E                    1017          BEQ.S   GROUP1A           by matching the op-code on the stack 
000018E4  B060                    1018          CMP.W   -(A0),D0          with the code in the region of the 
000018E6  670A                    1019          BEQ.S   GROUP1A           PC on the stack 
000018E8  B060                    1020          CMP.W   -(A0),D0 
000018EA  6706                    1021          BEQ.S   GROUP1A 
000018EC  B060                    1022          CMP.W   -(A0),D0 
000018EE  6702                    1023          BEQ.S   GROUP1A 
000018F0  5588                    1024          SUBQ.L  #2,A0 
000018F2  2F48 0012               1025  GROUP1A MOVE.L  A0,18(A7)          Restore modified PC to stack frame 
000018F6  4CDF 0101               1026          MOVEM.L (A7)+,D0/A0        Restore working registers 
000018FA  4FEF 0008               1027          LEA.L   8(A7),A7           Adjust stack pointer to group 1 type 
000018FE  6108                    1028          BSR.S   GROUP2             Now treat as group 1 exception 
00001900  6100 FD9A               1029          BSR     EX_DIS             Display contents of exception frame 
00001904  6000 F760               1030          BRA     WARM               Exit to monitor - no RTE from group 2 
00001908                          1031  * 
00001908  =00001908               1032  GROUP2  EQU     *                 Deal with group 2 exceptions 
00001908  48E7 FFFF               1033          MOVEM.L A0-A7/D0-D7,-(A7) Save all registers on the stack 
0000190C  303C 000E               1034          MOVE.W  #14,D0            Transfer D0 - D7, A0 - A6 from 
00001910  41EE 005E               1035          LEA.L   TSK_T(A6),A0      the stack to the display frame 
00001914  20DF                    1036  GROUP2A MOVE.L  (A7)+,(A0)+       Move a register from stack to frame 
00001916  51C8 FFFC               1037          DBRA    D0,GROUP2A        and repeat until D0-D7/A0-A6 moved 
0000191A  4E6A                    1038          MOVE.L  USP,A2            Get the user stack pointer and put it 
0000191C  20CA                    1039          MOVE.L  A2,(A0)+          in the A7 position in the frame 
0000191E  201F                    1040          MOVE.L  (A7)+,D0          Now transfer the SSP to the frame, 
00001920  0480 0000000A           1041          SUB.L   #10,D0            remembering to account for the 
00001926  20C0                    1042          MOVE.L  D0,(A0)+          data pushed on the stack to this point 
00001928  225F                    1043          MOVE.L  (A7)+,A1          Copy TOS (return address) to A1 
0000192A  30DF                    1044          MOVE.W  (A7)+,(A0)+       Move SR to display frame 
0000192C  201F                    1045          MOVE.L  (A7)+,D0          Get PC in D0 
0000192E  5580                    1046          SUBQ.L  #2,D0             Move back to current instruction 
00001930  20C0                    1047          MOVE.L  D0,(A0)+          Put adjusted PC in display frame 
00001932  4ED1                    1048          JMP     (A1)              Return from subroutine 
00001934                          1049  * 
00001934                          1050  ************************************************************************* 
00001934                          1051  * 
00001934                          1052  *  GO executes a program either from a supplied address or 
00001934                          1053  *  by using the data in the display frame 
00001934  6100 F884               1054  GO       BSR     PARAM               Get entry address (if any) 
00001938  4A07                    1055           TST.B   D7                  Test for error in input 
0000193A  6708                    1056           BEQ.S   GO1                 If D7 zero then OK 
0000193C  49FA 0329               1057           LEA.L   ERMES1(PC),A4       Else point to error message, 
00001940  6000 F744               1058           BRA     PSTRING             print it and return 
00001944  4A80                    1059  GO1      TST.L   D0                  If no address entered then get 
00001946  670A                    1060           BEQ.S   GO2                 address from display frame 
00001948  2D40 00A4               1061           MOVE.L  D0,TSK_T+70(A6)     Else save address in display frame 
0000194C  3D7C 0700 00A2          1062           MOVE.W  #$0700,TSK_T+68(A6) Store dummy status in frame 
00001952  6006                    1063  GO2      BRA.S   RESTORE             Restore volatile environment and go 
00001954                          1064  * 
00001954  6100 007A               1065  GB       BSR     BR_SET              Same as go but presets breakpoints 
00001958  60DA                    1066           BRA.S   GO                  Execute program 
0000195A                          1067  * 
0000195A                          1068  *        RESTORE moves the volatile environment from the display 
0000195A                          1069  *        frame and transfers it to the 68000's registers. This 
0000195A                          1070  *        re-runs a program suspended after an exception 
0000195A                          1071  * 
0000195A  47EE 005E               1072  RESTORE  LEA.L   TSK_T(A6),A3        A3 points to display frame 
0000195E  47EB 004A               1073           LEA.L   74(A3),A3           A3 now points to end of frame + 4 
00001962  4FEF 0004               1074           LEA.L   4(A7),A7            Remove return address from stack 
00001966  303C 0024               1075           MOVE.W  #36,D0              Counter for 37 words to be moved 
0000196A  3F23                    1076  REST1    MOVE.W  -(A3),-(A7)         Move word from display frame to stack 
0000196C  51C8 FFFC               1077           DBRA    D0,REST1            Repeat until entire frame moved 
00001970  4CDF 00FF               1078           MOVEM.L (A7)+,D0-D7         Restore old data registers from stack 
00001974  4CDF 7F00               1079           MOVEM.L (A7)+,A0-A6         Restore old address registers 
00001978  4FEF 0008               1080           LEA.L   8(A7),A7            Except SSP/USP - so adjust stack 
0000197C  4E73                    1081           RTE                         Return from exception to run program 
0000197E                          1082  * 
0000197E  =0000197E               1083  TRACE    EQU     *                   TRACE exception (rudimentary version) 
0000197E  287A 02B5               1084           MOVE.L  MES12(PC),A4        Point to heading 
00001982  6100 F712               1085           BSR     HEADING             Print it 
00001986  6100 FF4C               1086           BSR     GROUP1              Save volatile environment 
0000198A  6100 FD10               1087           BSR     EX_DIS              Display it 
0000198E  6000 F6D6               1088           BRA     WARM                Return to monitor 
00001992                          1089  * 
00001992                          1090  ************************************************************************* 
00001992                          1091  *  Breakpoint routines: BR_GET gets the address of a breakpoint and 
00001992                          1092  *  puts it in the breakpoint table. It does not plant it in the code. 
00001992                          1093  *  BR_SET plants all breakpoints in the code. NOBR removes one or all 
00001992                          1094  *  breakpoints from the table. KILL removes breakpoints from the code. 
00001992                          1095  * 
00001992  6100 F826               1096  BR_GET   BSR     PARAM               Get breakpoint address in table 
00001996  4A07                    1097           TST.B   D7                  Test for input error 
00001998  6708                    1098           BEQ.S   BR_GET1             If no error then continue 
0000199A  49FA 02CB               1099           LEA.L   ERMES1(PC),A4       Else display error 
0000199E  6000 F6E6               1100           BRA     PSTRING             and return 
000019A2  47EE 00A8               1101  BR_GET1  LEA.L   BP_TAB(A6),A3       A6 points to breakpoint table 
000019A6  2A40                    1102           MOVE.L  D0,A5               Save new BP address in A5 
000019A8  2C00                    1103           MOVE.L  D0,D6               and in D6 because D0 gets corrupted 
000019AA  3A3C 0007               1104           MOVE.W  #7,D5               Eight entries to test 
000019AE  201B                    1105  BR_GET2  MOVE.L  (A3)+,D0            Read entry from breakpoint table 
000019B0  660C                    1106           BNE.S   BR_GET3             If not zero display existing BP 
000019B2  4A86                    1107           TST.L   D6                  Only store a non-zero breakpoint 
000019B4  6710                    1108           BEQ.S   BR_GET4 
000019B6  274D FFFC               1109           MOVE.L  A5,-4(A3)           Store new breakpoint in table 
000019BA  3695                    1110           MOVE.W  (A5),(A3)           Save code at BP address in table 
000019BC  4286                    1111           CLR.L   D6                  Clear D6 to avoid repetition 
000019BE  6100 F868               1112  BR_GET3  BSR     OUT8X               Display this breakpoint 
000019C2  6100 F6B2               1113           BSR     NEWLINE 
000019C6  47EB 0002               1114  BR_GET4  LEA.L   2(A3),A3            Step past stored op-code 
000019CA  51CD FFE2               1115           DBRA    D5,BR_GET2          Repeat until all entries tested 
000019CE  4E75                    1116           RTS                         Return 
000019D0                          1117  * 
000019D0  =000019D0               1118  BR_SET   EQU     *                   Plant any breakpoints in user code 
000019D0  41EE 00A8               1119           LEA.L   BP_TAB(A6),A0       A0 points to BP table 
000019D4  45EE 00A4               1120           LEA.L   TSK_T+70(A6),A2     A2 points to PC in display frame 
000019D8  2452                    1121           MOVE.L  (A2),A2             Now A2 contains value of PC 
000019DA  303C 0007               1122           MOVE.W  #7,D0               Up to eight entries to plant 
000019DE  2218                    1123  BR_SET1  MOVE.L  (A0)+,D1            Read breakpoint address from table 
000019E0  670A                    1124           BEQ.S   BR_SET2             If zero then skip planting 
000019E2  B28A                    1125           CMP.L   A2,D1               Don't want to plant BP at current PC 
000019E4  6706                    1126           BEQ.S   BR_SET2             location, so skip planting if same 
000019E6  2241                    1127           MOVE.L  D1,A1               Transfer BP address to address reg 
000019E8  32BC 4E4E               1128           MOVE.W  #TRAP_14,(A1)       Plant op-code for TRAP #14 in code 
000019EC  41E8 0002               1129  BR_SET2  LEA.L   2(A0),A0            Skip past op-code field in table 
000019F0  51C8 FFEC               1130           DBRA    D0,BR_SET1          Repeat until all entries tested 
000019F4  4E75                    1131           RTS 
000019F6                          1132  * 
000019F6  =000019F6               1133  NOBR     EQU     *                   Clear one or all breakpoints 
000019F6  6100 F7C2               1134           BSR     PARAM               Get BP address (if any) 
000019FA  4A07                    1135           TST.B   D7                  Test for input error 
000019FC  6708                    1136           BEQ.S   NOBR1               If no error then skip abort 
000019FE  49FA 0267               1137           LEA.L   ERMES1(PC),A4       Point to error message 
00001A02  6000 F682               1138           BRA     PSTRING             Display it and return 
00001A06  4A80                    1139  NOBR1    TST.L   D0                  Test for null address (clear all) 
00001A08  6720                    1140           BEQ.S   NOBR4               If no address then clear all entries 
00001A0A  2240                    1141           MOVE.L  D0,A1               Else just clear breakpoint in A1 
00001A0C  41EE 00A8               1142           LEA.L   BP_TAB(A6),A0       A0 points to BP table 
00001A10  303C 0007               1143           MOVE.W  #7,D0               Up to eight entries to test 
00001A14  2218                    1144  NOBR2    MOVE.L  (A0)+,D1            Get entry and 
00001A16  41E8 0002               1145           LEA.L   2(A0),A0            skip past op-code field 
00001A1A  B289                    1146           CMP.L   A1,D1               Is this the one? 
00001A1C  6706                    1147           BEQ.S   NOBR3               If so go and clear entry 
00001A1E  51C8 FFF4               1148           DBRA    D0,NOBR2            Repeat until all tested 
00001A22  4E75                    1149           RTS 
00001A24  42A8 FFFA               1150  NOBR3    CLR.L   -6(A0)              Clear address in BP table 
00001A28  4E75                    1151           RTS 
00001A2A  41EE 00A8               1152  NOBR4    LEA.L   BP_TAB(A6),A0       Clear all 8 entries in BP table 
00001A2E  303C 0007               1153           MOVE.W  #7,D0               Eight entries to clear 
00001A32  4298                    1154  NOBR5    CLR.L   (A0)+               Clear breakpoint address 
00001A34  4258                    1155           CLR.W   (A0)+               Clear op-code field 
00001A36  51C8 FFFA               1156           DBRA    D0,NOBR5            Repeat until all done 
00001A3A  4E75                    1157           RTS 
00001A3C                          1158  * 
00001A3C  =00001A3C               1159  BR_CLR   EQU     *                   Remove breakpoints from code 
00001A3C  41EE 00A8               1160           LEA.L   BP_TAB(A6),A0       A0 points to breakpoint table 
00001A40  303C 0007               1161           MOVE.W  #7,D0               Up to eight entries to clear 
00001A44  2218                    1162  BR_CLR1  MOVE.L  (A0)+,D1            Get address of BP in D1 
00001A46  2241                    1163           MOVE.L  D1,A1               and put copy in A1 
00001A48  4A81                    1164           TST.L   D1                  Test this breakpoint 
00001A4A  6702                    1165           BEQ.S   BR_CLR2             If zero then skip BP clearing 
00001A4C  3290                    1166           MOVE.W  (A0),(A1)           Else restore op-code 
00001A4E  41E8 0002               1167  BR_CLR2  LEA.L   2(A0),A0            Skip past op-code field 
00001A52  51C8 FFF0               1168           DBRA    D0,BR_CLR1          Repeat until all tested 
00001A56  4E75                    1169           RTS 
00001A58                          1170  * 
00001A58                          1171  *  REG_MOD modifies a register in the display frame. The command 
00001A58                          1172  *  format is REG <reg> <value>. E.g. REG D3 1200 
00001A58                          1173  * 
00001A58  4281                    1174  REG_MOD  CLR.L   D1                  D1 to hold name of register 
00001A5A  41EE 0048               1175           LEA.L   BUFFPT(A6),A0       A0 contains address of buffer pointer 
00001A5E  2050                    1176           MOVE.L  (A0),A0             A0 now points to next char in buffer 
00001A60  1218                    1177           MOVE.B  (A0)+,D1            Put first char of name in D1 
00001A62  E159                    1178           ROL.W   #8,D1               Move char one place left 
00001A64  1218                    1179           MOVE.B  (A0)+,D1            Get second char in D1 
00001A66  41E8 0001               1180           LEA.L   1(A0),A0            Move pointer past space in buffer 
00001A6A  2D48 0048               1181           MOVE.L  A0,BUFFPT(A6)       Update buffer pointer 
00001A6E  4282                    1182           CLR.L   D2                  D2 is the character pair counter 
00001A70  41FA 01CC               1183           LEA.L   REGNAME(PC),A0      A0 points to string of character pairs 
00001A74  43D0                    1184           LEA.L   (A0),A1             A1 also points to string 
00001A76  B258                    1185  REG_MD1  CMP.W   (A0)+,D1            Compare a char pair with input 
00001A78  6712                    1186           BEQ.S   REG_MD2             If match then exit loop 
00001A7A  5282                    1187           ADD.L   #1,D2               Else increment match counter 
00001A7C  B4BC 00000013           1188           CMP.L   #19,D2              Test for end of loop 
00001A82  66F2                    1189           BNE     REG_MD1             Continue until all pairs matched 
00001A84  49FA 01E1               1190           LEA.L   ERMES1(PC),A4       If here then error 
00001A88  6000 F5FC               1191           BRA     PSTRING             Display error and return 
00001A8C  43EE 005E               1192  REG_MD2  LEA.L   TSK_T(A6),A1        A1 points to display frame 
00001A90  E582                    1193           ASL.L   #2,D2               Multiply offset by 4 (4 bytes/entry) 
00001A92  B4BC 00000048           1194           CMP.L   #72,D2              Test for address of PC 
00001A98  6602                    1195           BNE.S   REG_MD3             If not PC then all is OK 
00001A9A  5582                    1196           SUB.L   #2,D2               else dec PC pointer as Sr is a word 
00001A9C  45F1 2000               1197  REG_MD3  LEA.L   (A1,D2),A2          Calculate address of entry in disptable 
00001AA0  2012                    1198           MOVE.L  (A2),D0             Get old contents 
00001AA2  6100 F784               1199           BSR     OUT8X               Display them 
00001AA6  6100 F5CE               1200           BSR     NEWLINE 
00001AAA  6100 F70E               1201           BSR     PARAM               Get new data 
00001AAE  4A07                    1202           TST.B   D7                  Test for input error 
00001AB0  6708                    1203           BEQ.S   REG_MD4             If no error then go and store data 
00001AB2  49FA 01B3               1204           LEA.L   ERMES1(PC),A4       Else point to error message 
00001AB6  6000 F5CE               1205           BRA     PSTRING             print it and return 
00001ABA  B4BC 00000044           1206  REG_MD4  CMP.L   #68,D2              If this address is the SR then 
00001AC0  6704                    1207           BEQ.S   REG_MD5             we have only a word to store 
00001AC2  2480                    1208           MOVE.L  D0,(A2)             Else store new data in display frame 
00001AC4  4E75                    1209           RTS 
00001AC6  3480                    1210  REG_MD5  MOVE.W  D0,(A2)             Store SR (one word) 
00001AC8  4E75                    1211           RTS 
00001ACA                          1212  * 
00001ACA                          1213  ************************************************************************* 
00001ACA                          1214  * 
00001ACA  =00001ACA               1215  X_UN    EQU     *                 Uninitialized exception vector routine 
00001ACA  49FA 0201               1216          LEA.L   ERMES6(PC),A4     Point to error message 
00001ACE  6100 F5B6               1217          BSR     PSTRING           Display it 
00001AD2  6100 FBC8               1218          BSR     EX_DIS            Display registers 
00001AD6  6000 F58E               1219          BRA     WARM              Abort 
00001ADA                          1220  * 
00001ADA                          1221  ************************************************************************* 
00001ADA                          1222  * 
00001ADA                          1223  *  All strings and other fixed parameters here 
00001ADA                          1224  * 
00001ADA= 54 53 42 55 47 20 ...   1225  BANNER   DC.B     'TSBUG 2 Version 23.07.86',0,0
00001AF4= 4D 6F 64 69 66 69 ...   1226  MODIFY    DC.B   'Modified by Eugene A. Rockey Jr. Jan.05.2010',0,0
00001B22= 66 6F 72 20 75 73 ...   1227  WHY      DC.B     'for use with the M68000 Minimal Computer Configuration',0,0 
00001B5A= 55 6E 69 76 65 72 ...   1228  WHERE    DC.B     'University of Louisville',0,0
00001B74= 2A 20 49 4D 50 4F ...   1229  ADDRE  DC.B   '* IMPORTANT, TURN ON CAPS LOCK  *',0,0
00001B97= 0D 0A 54 53 32 4D ...   1230  CRLF     DC.B     CR,LF,'TS2MON >',0 
00001BA2= 0D 0A 53 31 00 00       1231  HEADER   DC.B     CR,LF,'S','1',0,0 
00001BA8= 53 39 20 20 00 00       1232  TAIL     DC.B     'S9  ',0,0 
00001BAE= 20 53 52 20 20 3D ...   1233  MES1     DC.B     ' SR  =  ',0 
00001BB7= 20 50 43 20 20 3D ...   1234  MES2     DC.B     ' PC  =  ',0 
00001BC0= 20 53 53 20 20 3D ...   1235  MES2A    DC.B     ' SS  =  ',0 
00001BC9= 20 20 44 61 74 61 ...   1236  MES3     DC.B     '  Data reg       Address reg',0,0 
00001BE7= 20 20 20 20 20 20 ...   1237  MES4     DC.B     '        ',0,0 
00001BF1= 42 75 73 20 65 72 ...   1238  MES8     DC.B     'Bus error   ',0,0 
00001BFF= 41 64 64 72 65 73 ...   1239  MES9     DC.B     'Address error   ',0,0 
00001C11= 49 6C 6C 65 67 61 ...   1240  MES10    DC.B     'Illegal instruction ',0,0 
00001C27= 42 72 65 61 6B 70 ...   1241  MES11    DC.B     'Breakpoint  ',0,0 
00001C35= 54 72 61 63 65 20 ...   1242  MES12    DC.B     'Trace   ',0 
00001C3E= 44 30 44 31 44 32 ...   1243  REGNAME  DC.B     'D0D1D2D3D4D5D6D7' 
00001C4E= 41 30 41 31 41 32 ...   1244           DC.B     'A0A1A2A3A4A5A6A7' 
00001C5E= 53 53 53 52             1245           DC.B     'SSSR' 
00001C62= 50 43 20 20 00          1246           DC.B     'PC  ',0 
00001C67= 4E 6F 6E 2D 76 61 ...   1247  ERMES1   DC.B     'Non-valid hexadecimal input  ',0 
00001C85= 49 6E 76 61 6C 69 ...   1248  ERMES2   DC.B     'Invalid command  ',0 
00001C97= 4C 6F 61 64 69 6E ...   1249  ERMES3   DC.B     'Loading error',0 
00001CA5= 54 61 62 6C 65 20 ...   1250  ERMES4   DC.B     'Table full  ',0,0 
00001CB3= 42 72 65 61 6B 70 ...   1251  ERMES5   DC.B     'Breakpoint not active   ',0,0 
00001CCD= 55 6E 69 6E 69 74 ...   1252  ERMES6   DC.B     'Uninitialized exception ',0,0 
00001CE7= 4A 55 4D 50 20 3C ...   1253  JUMPHELP DC.B     'JUMP <address> causes execution to begin at <address>',0      
00001D1D= 20 52 61 6E 67 65 ...   1254  ERMES7   DC.B     ' Range error',0
00001D2A= 55 53 45 52 00          1255  UNAME    DC.B     'USER', 0
00001D2F= 50 41 53 53 57 4F ...   1256  PWORD    DC.B     'PASSWORD',0
00001D38= 45 6E 74 65 72 20 ...   1257  LOGINM1  DC.B     'Enter username: ', 0
00001D49= 45 6E 74 65 72 20 ...   1258  LOGINM2  DC.B     'Enter password: ', 0
00001D5A= 49 6E 63 6F 72 72 ...   1259  USRERR   DC.B     'Incorrect username', 0
00001D6D= 43 6F 72 72 65 63 ...   1260  USRSUC   DC.B     'Correct Username', 0
00001D7E= 49 6E 63 6F 72 72 ...   1261  PWERR   DC.B     'Incorrect password', 0
00001D91= 43 6F 72 72 65 63 ...   1262  PWSUC    DC.B     'Correct Password', 0
00001DA2= 4D 45 4D 4F 52 59 ...   1263  MEMFMSG  DC.B     'MEMORY BAD AT: ',0
00001DB2                          1264   
00001DB2                          1265  * 
00001DB2                          1266  *  COMTAB is the built-in command table. All entries are made up of 
00001DB2                          1267  *         a string length + number of characters to match + the string 
00001DB2                          1268  *         plus the address of the command relative to COMTAB 
00001DB2                          1269  * 
00001DB2= 04 04                   1270  COMTAB   DC.B     4,4              JUMP <address> causes execution to 
00001DB4= 4A 55 4D 50             1271           DC.B     'JUMP'           begin at <address> 
00001DB8= FFFFF47E                1272           DC.L     JUMP-COMTAB                                           
00001DBC= 08 03                   1273           DC.B     8,3              MEMORY <address> examines contents of 
00001DBE= 4D 45 4D 4F 52 59 ...   1274           DC.B     'MEMORY  '       <address> and allows them to be changed 
00001DC6= FFFFF494                1275           DC.L     MEMORY-COMTAB 
00001DCA= 04 02                   1276           DC.B     4,2              LOAD <string> loads S1/S2 records 
00001DCC= 4C 4F 41 44             1277           DC.B     'LOAD'           from the host. <string> is sent to host 
00001DD0= FFFFF4F4                1278           DC.L     LOAD-COMTAB 
00001DD4= 04 02                   1279           DC.B     4,2              DUMP <string> sends S1 records to the 
00001DD6= 44 55 4D 50             1280           DC.B     'DUMP'           host and is preceeded by <string>. 
00001DDA= FFFFF5C8                1281           DC.L     DUMP-COMTAB 
00001DDE= 04 03                   1282           DC.B     4,3              TRAN enters the transparant mode 
00001DE0= 54 52 41 4E             1283           DC.B     'TRAN'           and is exited by ESC,E. 
00001DE4= FFFFF684                1284           DC.L     TM-COMTAB 
00001DE8= 04 02                   1285           DC.B     4,2              NOBR <address> removes the breakpoint 
00001DEA= 4E 4F 42 52             1286           DC.B     'NOBR'           at <address> from the BP table. If 
00001DEE= FFFFFC44                1287           DC.L     NOBR-COMTAB      no address is given all BPs are removed. 
00001DF2= 04 02                   1288           DC.B     4,2              DISP displays the contents of the 
00001DF4= 44 49 53 50             1289           DC.B     'DISP'           pseudo registers in TSK_T. 
00001DF8= FFFFF8EA                1290           DC.L     EX_DIS-COMTAB 
00001DFC= 04 02                   1291           DC.B    4,2               GO <address> starts program execution 
00001DFE= 47 4F 20 20             1292           DC.B    'GO  '            at <address> and loads regs from TSK_T 
00001E02= FFFFFB82                1293           DC.L    GO-COMTAB 
00001E06= 04 02                   1294           DC.B    4,2               BRGT puts a breakpoint in the BP 
00001E08= 42 52 47 54             1295           DC.B    'BRGT'            table - but not in the code 
00001E0C= FFFFFBE0                1296           DC.L    BR_GET-COMTAB 
00001E10= 04 02                   1297           DC.B    4,2               PLAN puts the breakpoints in the code 
00001E12= 50 4C 41 4E             1298           DC.B    'PLAN' 
00001E16= FFFFFC1E                1299           DC.L    BR_SET-COMTAB 
00001E1A= 04 04                   1300           DC.B    4,4               KILL removes breakpoints from the code 
00001E1C= 4B 49 4C 4C             1301           DC.B    'KILL' 
00001E20= FFFFFC8A                1302           DC.L    BR_CLR-COMTAB 
00001E24= 04 02                   1303           DC.B    4,2               GB <address> sets breakpoints and 
00001E26= 47 42 20 20             1304           DC.B    'GB  '            then calls GO. 
00001E2A= FFFFFBA2                1305           DC.L    GB-COMTAB 
00001E2E= 04 03                   1306           DC.B    4,3               REG <reg> <value> loads <value> 
00001E30= 52 45 47 20             1307           DC.B    'REG '            into <reg> in TASK_T. Used to preset 
00001E34= FFFFFCA6                1308           DC.L    REG_MOD-COMTAB    registers before a GO or GB 
00001E38= 04 04                   1309           DC.B    4,4               HELP 
00001E3A= 48 45 4C 50             1310           DC.B    'HELP'            
00001E3E= FFFFF968                1311           DC.L    HELP-COMTAB      
00001E42= 02 02                   1312           DC.B    2,2
00001E44= 54 56                   1313           DC.B    'TV'
00001E46= FFFFFA44                1314           DC.L    TV-COMTAB
00001E4A= 00 00                   1315           DC.B    0,0 
00001E4C                          1316  * 
00001E4C                          1317  ************************************************************************* 
00001E4C                          1318  * 
00001E4C                          1319  *  This is a list of the information needed to setup the DCBs 
00001E4C                          1320  * 
00001E4C  =00001E4C               1321  DCB_LST  EQU     * 
00001E4C= 43 4F 4E 5F 49 4E ...   1322  DCB1     DC.B    'CON_IN  '          Device name (8 bytes) 
00001E54= 000014D4 00008001       1323           DC.L    CON_IN,ACIA_1       Address of driver routine, device 
00001E5C= 0002                    1324           DC.W    2                   Number of words in parameter field 
00001E5E= 43 4F 4E 5F 4F 55 ...   1325  DCB2     DC.B    'CON_OUT ' 
00001E66= 000014EA 00008001       1326           DC.L    CON_OUT,ACIA_1 
00001E6E= 0002                    1327           DC.W    2 
00001E70= 41 55 58 5F 49 4E ...   1328  DCB3     DC.B    'AUX_IN  ' 
00001E78= 00001500 00008001       1329           DC.L    AUX_IN,ACIA_2 
00001E80= 0002                    1330           DC.W    2 
00001E82= 41 55 58 5F 4F 55 ...   1331  DCB4     DC.B    'AUX_OUT ' 
00001E8A= 00001512 00008001       1332           DC.L    AUX_OUT,ACIA_2 
00001E92= 0002                    1333           DC.W    2 
00001E94= 42 55 46 46 5F 49 ...   1334  DCB5     DC.B    'BUFF_IN ' 
00001E9C= 00001568 000002D8       1335           DC.L    BUFF_IN,BUFFER 
00001EA4= 0002                    1336           DC.W    2 
00001EA6= 42 55 46 46 5F 4F ...   1337  DCB6     DC.B    'BUFF_OUT' 
00001EAE= 00001574 000002D8       1338           DC.L    BUFF_OT,BUFFER 
00001EB6= 0002                    1339           DC.W    2 
00001EB8                          1340  * 
00001EB8                          1341  ************************************************************************* 
00001EB8                          1342  * 
00001EB8                          1343  *  DCB structure 
00001EB8                          1344  * 
00001EB8                          1345  *              ----------------------- 
00001EB8                          1346  *       0 ->   | DCB  name           | 
00001EB8                          1347  *              |---------------------| 
00001EB8                          1348  *       8 ->   | Device driver       | 
00001EB8                          1349  *              |---------------------| 
00001EB8                          1350  *      12 ->   | Device address      | 
00001EB8                          1351  *              |---------------------| 
00001EB8                          1352  *      16 ->   |Size of param block  | 
00001EB8                          1353  *              |---------------------| --- 
00001EB8                          1354  *      18 ->   |      Status         |   | 
00001EB8                          1355  *              | logical  | physical |   | S 
00001EB8                          1356  *              |---------------------|   | 
00001EB8                          1357  *              .                     .   . 
00001EB8                          1358  *              |---------------------| --- 
00001EB8                          1359  *    18+S ->   | Pointer to next DCB | 
00001EB8                          1360  * 
00001EB8                          1361           END RESET 

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ACIA_1              8001
ACIA_2              8001
ADDRE               1B74
ADD_ER              18A8
ADR_DAT             1284
AUX_IN              1500
AUX_IN1             1506
AUX_OT1             1518
AUX_OUT             1512
BANNER              1ADA
BP_TAB              A8
BRKPT               18B6
BR_CLR              1A3C
BR_CLR1             1A44
BR_CLR2             1A4E
BR_GET              1992
BR_GET1             19A2
BR_GET2             19AE
BR_GET3             19BE
BR_GET4             19C6
BR_SET              19D0
BR_SET1             19DE
BR_SET2             19EC
BS                  8
BUFFEND             47
BUFFER              2D8
BUFFPT              48
BUFF_IN             1568
BUFF_OT             1574
BUS_ER              189A
BYTE                119E
CHECK1              180E
CHECK2              1818
CHECK3              183A
CHECK4              1844
CN_IVEC             56
CN_OVEC             5A
COMTAB              1DB2
CON_IN              14D4
CON_OUT             14EA
CR                  D
CRLF                1B97
CTRL_A              1
DATA                4800
DCB1                1E4C
DCB2                1E5E
DCB3                1E70
DCB4                1E82
DCB5                1E94
DCB6                1EA6
DCB_LST             1E4C
DELAY               1422
DELAY1              142C
DUMP                137A
DUMP1               138A
DUMP2               1396
DUMP3               13AC
DUMP4               13C0
DUMP5               13CE
DUMP6               13E8
DUMP7               140C
ECHO                50
ERMES1              1C67
ERMES2              1C85
ERMES3              1C97
ERMES4              1CA5
ERMES5              1CB3
ERMES6              1CCD
ERMES7              1D1D
ESC                 1B
EXEC1               1126
EXEC2               1136
EXECUTE             1114
EX_D1               16AE
EX_DIS              169C
FIRST               D8
FOO1                15DA
FOO10               1646
FOO11               1652
FOO12               165E
FOO13               166A
FOO14               1676
FOO15               1682
FOO16               168E
FOO17               169A
FOO2                15E6
FOO3                15F2
FOO4                15FE
FOO5                160A
FOO6                1616
FOO7                1622
FOO8                162E
FOO9                163A
GB                  1954
GETCH2              1548
GETCH3              1550
GETCHAR             1524
GETLINE             109C
GETLN2              10A6
GETLN3              10C0
GETLN4              10CA
GETLN5              10CE
GO                  1934
GO1                 1944
GO2                 1952
GROUP1              18D4
GROUP1A             18F2
GROUP2              1908
GROUP2A             1914
HEADER              1BA2
HEADING             1096
HELP                171A
HEX                 1180
HEX_OK              119C
IL_ER               1884
IO_OPEN             1582
IO_REQ              14C2
JUMP                1230
JUMP1               123E
JUMPHELP            1CE7
LF                  A
LNBUFF              8
LOAD                12A6
LOAD1               12D2
LOAD2               12E2
LOAD3               12FC
LOAD4               1316
LOAD5               1324
LOAD6               1326
LOAD6A              134A
LOAD7               135C
LOAD8               1372
LOGIN               172A
LOGIN1              174A
LOGIN2              178E
LOGINM1             1D38
LOGINM2             1D49
LONGWD              11B4
LOOPRAM             17FA
LOOPRAM1            1826
MAXCHR              40
MAX_RAM             3DC
MEM1                1250
MEM2                126E
MEM3                1282
MEMFAIL             1850
MEMFAIL2            186A
MEMFMSG             1DA2
MEMORY              1246
MES1                1BAE
MES10               1C11
MES11               1C27
MES12               1C35
MES2                1BB7
MES2A               1BC0
MES3                1BC9
MES4                1BE7
MES8                1BF1
MES9                1BFF
MIN_RAM             3D8
MODIFY              1AF4
NEWLINE             1076
NOBR                19F6
NOBR1               1A06
NOBR2               1A14
NOBR3               1A24
NOBR4               1A2A
NOBR5               1A32
NOT_HEX             1198
NO_EXT              105C
NUL                 0
OPEN1               158A
OPEN2               1592
OPEN3               15A0
OPEN4               15B6
OUT1X               11FE
OUT1X1              1210
OUT2X               1218
OUT4X               1220
OUT8X               1228
PARAM               11BA
PARAM1              11C2
PARAM3              11E6
PARAM4              11EA
PARAM5              11F6
PARAM6              11FA
PARAMTR             4C
PS1                 1088
PS2                 1092
PSPACE              1298
PSTRING             1086
PUTCHAR             1554
PWERR               1D7E
PWORD               1D2F
PWSUC               1D91
QUIT                17F2
RANGE               1412
REGNAME             1C3E
REG_MD1             1A76
REG_MD2             1A8C
REG_MD3             1A9C
REG_MD4             1ABA
REG_MD5             1AC6
REG_MOD             1A58
RESET               1000
REST1               196A
RESTORE             195A
SEARCH              1140
SET_DCB             1478
SPACE               20
SRCH2               115A
SRCH3               115E
SRCH4               1166
SRCH6               1170
SRCH7               117A
STACK               4400
ST_DCB1             1488
ST_DCB2             148C
TAIL                1BA8
TIDY                10D2
TIDY1               10D8
TIDY2               10E4
TIDY3               10EE
TIDY4               10F8
TIDY5               1102
TIDY6               110E
TM                  1436
TM1                 1442
TRACE               197E
TRAP_0              15CE
TRAP_14             4E4E
TSK_T               5E
TV                  17F6
UNAME               1D2A
UPASS               17E8
USRERR              1D5A
USRSUC              1D6D
UTAB                52
U_CASE              51
WAIT                57
WARM                1066
WHERE               1B5A
WHY                 1B22
WORD                11AE
WRONG               17C0
WRONGPW             17D4
X_BASE              4000
X_SET               15BC
X_SET2              15C4
X_UN                1ACA
