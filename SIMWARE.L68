00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.15.04
Created On: 9/25/15 1:18:25 AM

00000000                             1  *        TSBUG2 - 68000 monitor - version of 05 January 2010 
00000000                             2  
00000000                             3      ORG      $0
00000000= 00004400 00001000 ...      4           DC.L STACK,RESET,BUS_ER,ADD_ER,IL_ER,DIV0_ER,X_UN,X_UN,PRIV_ER,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN
00000040= 00001BEA 00001BEA ...      5           DC.L X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN
Line 6 ERROR: Undefined symbol
00000080= 00001648 00001648 ...      6           DC.L  TRAP_0,TRAP_1,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,TRAP_14,TRAP_15
000000C4= 00001BEA 00001BEA ...      7           DC.L X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN
00000104= 00001BEA 00001BEA ...      8           DC.L X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN
00000144= 00001BEA 00001BEA ...      9           DC.L X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN
00000184= 00001BEA 00001BEA ...     10           DC.L X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN
000001C4= 00001BEA 00001BEA ...     11           DC.L X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN
00000204= 00001BEA 00001BEA ...     12           DC.L X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN
00000244= 00001BEA 00001BEA ...     13           DC.L X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN
00000284= 00001BEA 00001BEA ...     14           DC.L X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN
000002C4= 00001BEA 00001BEA ...     15           DC.L X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN
00000304= 00001BEA 00001BEA ...     16           DC.L X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN
00000344= 00001BEA 00001BEA ...     17           DC.L X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN
00000384= 00001BEA 00001BEA ...     18           DC.L X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN
000003C4= 00001BEA 00001BEA ...     19           DC.L X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN
00000404                            20  *                                   Symbol equates 
00000404  =00000008                 21  BS       EQU      $08               Back_space 
00000404  =0000000D                 22  CR       EQU      $0D               Carriage_return 
00000404  =00000000                 23  NUL      EQU      $00               NUL character
00000404  =0000000A                 24  LF       EQU      $0A               Line_feed 
00000404  =00000020                 25  SPACE    EQU      $20               Space 
00000404  =00000057                 26  WAIT     EQU      'W'               Wait character (to suspend output) 
00000404  =0000001B                 27  ESC      EQU      $1B               ASCII escape character (used by TM) 
00000404  =00000001                 28  CTRL_A   EQU      $01               Control_A forces return to monitor 
00000404                            29  *                                   Device addresses 
00000404  =00004400                 30  STACK    EQU      $4400             Stack_pointer
00000404  =00008001                 31  ACIA_1   EQU      $8001             Console ACIA control 
00000404  =00008001                 32  ACIA_2   EQU      ACIA_1            Auxilary ACIA control 
00000404  =00004000                 33  X_BASE   EQU      $4000             Start of exception vector table 
00000404  =00004E4E                 34  TRAP_16  EQU      $4E4E             Code for TRAP #14 
00000404  =00000040                 35  MAXCHR   EQU      64                Length of input line buffer  
00000404                            36  * 
00000404  =00004800                 37  DATA     EQU      $4800             Data origin 
00000404                            38  LNBUFF   DS.B     MAXCHR            Input line buffer
00000444  =00000443                 39  BUFFEND  EQU      LNBUFF+MAXCHR-1   End of line buffer 
00000444                            40  BUFFPT   DS.L     1                 Pointer to line buffer 
00000448                            41  PARAMTR  DS.L     1                 Last parameter from line buffer 
0000044C                            42  ECHO     DS.B     1                 When clear this enable input echo 
0000044D                            43  U_CASE   DS.B     1                 Flag for upper case conversion 
0000044E                            44  UTAB     DS.L     1                 Pointer to user command table 
00000452                            45  CN_IVEC  DS.L     1                 Pointer to console input DCB 
00000456                            46  CN_OVEC  DS.L     1                 Pointer to console output DCB 
0000045A                            47  TSK_T    DS.W     37                Frame for D0-D7, A0-A6, USP, SSP, SW, PC 
000004A4                            48  BP_TAB   DS.W     24                Breakpoint table 
000004D4                            49  FIRST    DS.B     512               DCB area 
000006D4                            50  BUFFER   DS.B     256               256 bytes for I/O buffer 
000007D4= 00004000                  51  MIN_RAM  DC.L     $004000
000007D8= 00004100                  52  MAX_RAM  DC.L     $004100
000007DC                            53  * 
000007DC                            54  ************************************************************************* 
000007DC                            55  * 
000007DC                            56  *  This is the main program which assembles a command in the line 
000007DC                            57  *  buffer, removes leading/embedded spaces and interprets it by matching 
000007DC                            58  *  it with a command in the user table or the built-in table COMTAB 
000007DC                            59  *  All variables are specified with respect to A6 
000007DC                            60  *
00001000                            61           ORG      $1000             Monitor Origin
00001000  =00001000                 62  RESET:   EQU      *
00001000  4DF8 4800                 63           LEA.L    DATA,A6           A6 points to data area 
00001004  2D4E 0492                 64           MOVE.L    A6,TSK_T+56(A6)   initialize A6 in the regster Frame
00001008  42AE 044E                 65           CLR.L    UTAB(A6)          Reset pointer to user extension table 
0000100C  1D7C 0001 044C            66           MOVE.B   #1,ECHO(A6)       Set automatic character echo 
00001012  422E 044D                 67           CLR.B    U_CASE(A6)        Clear case conversion flag (UC<-LC) 
00001016  6100 05B4                 68           BSR.L     X_SET         what change did i do here
0000101A  6100 046C                 69           BSR.L    SET_DCB           Setup DCB table in RAM
0000101E  6166                      70           BSR.S    NEWLINE
00001020  49FA 0BD8                 71           LEA.L    BANNER(PC),A4    
00001024  6170                      72           BSR.S    PSTRING
00001026  615E                      73           BSR.S    NEWLINE           
00001028  49FA 0BEA                 74           LEA.L     MODIFY(PC),A4
0000102C  6168                      75           BSR.S    PSTRING
0000102E  6156                      76           BSR.S    NEWLINE
00001030  49FA 0C10                 77           LEA.L     WHY(PC),A4
00001034  6160                      78           BSR.S    PSTRING
00001036  614E                      79           BSR.S    NEWLINE
00001038  49FA 0C40                 80           LEA.L     WHERE(PC),A4
0000103C  6158                      81           BSR.S    PSTRING
0000103E  6146                      82           BSR.S    NEWLINE
00001040  207C 00003000             83           MOVE.L   #$3000,A0         A0 points to extension ROM 
00001046  2010                      84           MOVE.L   (A0),D0           Read first longword in extension ROM 
00001048  B0BC 524F4D32             85           CMP.L    #'ROM2',D0        If extension begins with 'ROM2' then 
0000104E  6604                      86           BNE.S    NO_EXT            call the subroutine at EXT_ROM+8 
00001050  4EA8 0008                 87           JSR      8(A0)             else continue 
00001054  4E71                      88  NO_EXT:  NOP                        Two NOPs to allow for a future 
00001056  4E71                      89           NOP                        call to an initialization routine
00001058  383C 0008                 90           MOVE.W   #8,D4
0000105C  3A3C 000A                 91           MOVE.W   #10,D5
00001060  123C 0012                 92           MOVE.B   #18,D1
00001064  4EB9 00001648             93           JSR      TRAP_0
0000106A  1003                      94           MOVE.B   D3,D0
0000106C  6100 01CA                 95           BSR.W    OUT8X
00001070  4EB9 00001808             96           JSR      LOGIN
00001076  4287                      97  WARM:    CLR.L    D7                Warm entry point - clear error flag 
00001078  610C                      98           BSR.S    NEWLINE           Print a newline 
0000107A  6130                      99           BSR.S    GETLINE           Get a command line 
0000107C  6100 0064                100           BSR      TIDY              Tidy up input buffer contents 
00001080  6100 00A2                101           BSR      EXECUTE           Interpret command 
00001084  60F0                     102           BRA      WARM              Repeat indefinitely 
00001086                           103  * 
00001086                           104  ************************************************************************* 
00001086                           105  * 
00001086                           106  *  Some initialization and basic routines 
00001086                           107  * 
00001086                           108  * 
00001086  =00001086                109  NEWLINE  EQU      *                 Move cursor to start of newline 
00001086  48E7 0008                110           MOVEM.L  A4,-(A7)          Save A4 
0000108A  49FA 0C08                111           LEA.L    CRLF(PC),A4       Point to CR/LF string 
0000108E  6106                     112           BSR.S    PSTRING           Print it 
00001090  4CDF 1000                113           MOVEM.L  (A7)+,A4          Restore A4 
00001094  4E75                     114           RTS                        Return 
00001096                           115  * 
00001096  =00001096                116  PSTRING  EQU      *                 Display the string pointed at by A4 
00001096  2F00                     117           MOVE.L   D0,-(A7)          Save D0 
00001098  101C                     118  PS1      MOVE.B   (A4)+,D0          Get character to be printed 
0000109A  6706                     119           BEQ.S    PS2               If null then return 
0000109C  6100 04C6                120           BSR      PUTCHAR           Else print it 
000010A0  60F6                     121           BRA      PS1               Continue 
000010A2  201F                     122  PS2      MOVE.L   (A7)+,D0          Restore D0 and exit 
000010A4  4E75                     123           RTS 
000010A6                           124  * 
000010A6  61DE                     125  HEADING  BSR      NEWLINE           Same as PSTRING but with newline 
000010A8  61EC                     126           BSR      PSTRING 
000010AA  60DA                     127           BRA      NEWLINE 
000010AC                           128  * 
000010AC                           129  ************************************************************************* 
000010AC                           130  * 
000010AC                           131  *  GETLINE  inputs a string of characters into a line buffer 
000010AC                           132  *           A3 points to next free entry in line buffer 
000010AC                           133  *           A2 points to end of buffer 
000010AC                           134  *           A1 points to start of buffer 
000010AC                           135  *           D0 holds character to be stored 
000010AC                           136  * 
000010AC  43EE 0404                137  GETLINE  LEA.L    LNBUFF(A6),A1     A1 points to start of line buffer 
000010B0  47D1                     138           LEA.L    (A1),A3           A3 points to start (initially) 
000010B2  45E9 0040                139           LEA.L    MAXCHR(A1),A2     A2 points to end of buffer 
000010B6  6100 047C                140  GETLN2   BSR      GETCHAR           Get a character 
000010BA  B03C 0001                141           CMP.B    #CTRL_A,D0        If control_A then reject this line 
000010BE  671E                     142           BEQ.S    GETLN5            and get another line 
000010C0  B03C 0008                143           CMP.B    #BS,D0            If back_space then move back pointer 
000010C4  660A                     144           BNE.S    GETLN3            Else skip past wind-back routine 
000010C6  B7C9                     145           CMP.L    A1,A3             First check for empty buffer 
000010C8  67EC                     146           BEQ      GETLN2            If buffer empty then continue 
000010CA  47EB FFFF                147           LEA      -1(A3),A3         Else decrement buffer pointer 
000010CE  60E6                     148           BRA      GETLN2            and continue with next character 
000010D0  16C0                     149  GETLN3   MOVE.B   D0,(A3)+          Store character and update pointer 
000010D2  B03C 000D                150           CMP.B    #CR,D0            Test for command terminator 
000010D6  6602                     151           BNE.S    GETLN4            If not CR then skip past exit 
000010D8  60AC                     152           BRA      NEWLINE           Else new line before next operation 
000010DA  B7CA                     153  GETLN4   CMP.L    A2,A3             Test for buffer overflow 
000010DC  66D8                     154           BNE      GETLN2            If buffer not full then continue 
000010DE  61A6                     155  GETLN5   BSR      NEWLINE           Else move to next line and 
000010E0  60CA                     156           BRA      GETLINE           repeat this routine 
000010E2                           157  * 
000010E2                           158  ************************************************************************* 
000010E2                           159  * 
000010E2                           160  *  TIDY cleans up the line buffer by removing leading spaces and multiple 
000010E2                           161  *       spaces between parameters. At the end of TIDY, BUFFPT points to 
000010E2                           162  *       the first parameter following the command. 
000010E2                           163  *       A0 = pointer to line buffer. A1 = pointer to cleaned up buffer 
000010E2                           164  * 
000010E2  41EE 0404                165  TIDY     LEA.L    LNBUFF(A6),A0     A0 points to line buffer 
000010E6  43D0                     166           LEA.L    (A0),A1           A1 points to start of line buffer 
000010E8  1018                     167  TIDY1    MOVE.B   (A0)+,D0          Read character from line buffer 
000010EA  B03C 0020                168           CMP.B    #SPACE,D0         Repeat until the first non-space 
000010EE  67F8                     169           BEQ      TIDY1             character is found 
000010F0  41E8 FFFF                170           LEA.L    -1(A0),A0         Move pointer back to first char 
000010F4  1018                     171  TIDY2    MOVE.B   (A0)+,D0          Move the string left to remove 
000010F6  12C0                     172           MOVE.B   D0,(A1)+          any leading spaces 
000010F8  B03C 0020                173           CMP.B    #SPACE,D0         Test for embedded space 
000010FC  660A                     174           BNE.S    TIDY4             If not space then test for EOL 
000010FE  0C18 0020                175  TIDY3    CMP.B    #SPACE,(A0)+      If space skip multiple embedded 
00001102  67FA                     176           BEQ      TIDY3             spaces 
00001104  41E8 FFFF                177           LEA.L    -1(A0),A0         Move back pointer 
00001108  B03C 000D                178  TIDY4    CMP.B    #CR,D0            Test for end_of_line (EOL) 
0000110C  66E6                     179           BNE      TIDY2             If not EOL then read next char 
0000110E  41EE 0404                180           LEA.L    LNBUFF(A6),A0     Restore buffer pointer 
00001112  0C10 000D                181  TIDY5    CMP.B    #CR,(A0)          Test for EOL 
00001116  6706                     182           BEQ.S    TIDY6             If EOL then exit 
00001118  0C18 0020                183           CMP.B    #SPACE,(A0)+      Test for delimiter 
0000111C  66F4                     184           BNE      TIDY5             Repeat until delimiter or EOL 
0000111E  2D48 0444                185  TIDY6    MOVE.L   A0,BUFFPT(A6)     Update buffer pointer 
00001122  4E75                     186           RTS 
00001124                           187  * 
00001124                           188  ************************************************************************* 
00001124                           189  * 
00001124                           190  *  EXECUTE matches the first command in the line buffer with the 
00001124                           191  *  commands in a command table. An external table pointed at by 
00001124                           192  *  UTAB is searched first and then the built-in table, COMTAB. 
00001124                           193  * 
00001124  4AAE 044E                194  EXECUTE  TST.L    UTAB(A6)          Test pointer to user table 
00001128  670C                     195           BEQ.S    EXEC1             If clear then try built-in table 
0000112A  266E 044E                196           MOVE.L   UTAB(A6),A3       Else pick up pointer to user table 
0000112E  6120                     197           BSR.S    SEARCH            Look for command in user table 
00001130  6404                     198           BCC.S    EXEC1             If not found then try internal table 
00001132  2653                     199           MOVE.L   (A3),A3           Else get absolute address of command 
00001134  4ED3                     200           JMP      (A3)              from user table and execute it 
00001136                           201  * 
00001136  47FA 0EC8                202  EXEC1    LEA.L    COMTAB(PC),A3     Try built-in command table 
0000113A  6114                     203           BSR.S    SEARCH            Look for command in built-in table 
0000113C  6508                     204           BCS.S    EXEC2             If found then execute command 
0000113E  49FA 0C67                205           LEA.L    ERMES2(PC),A4     Else print "invalid command" 
00001142  6000 FF52                206           BRA.L    PSTRING           and return 
00001146  2653                     207  EXEC2    MOVE.L   (A3),A3           Get the relative command address 
00001148  49FA 0EB6                208           LEA.L    COMTAB(PC),A4     pointed at by A3 and add it to 
0000114C  D7CC                     209           ADD.L    A4,A3             the PC to generate the actual 
0000114E  4ED3                     210           JMP      (A3)              command address. Then execute it. 
00001150                           211  * 
00001150  =00001150                212  SEARCH   EQU      *                 Match the command in the line buffer 
00001150  4280                     213           CLR.L    D0                with command table pointed at by A3 
00001152  1013                     214           MOVE.B   (A3),D0           Get the first character in the 
00001154  6734                     215           BEQ.S    SRCH7             current entry. If zero then exit 
00001156  49F3 0006                216           LEA.L    6(A3,D0.W),A4     Else calculate address of next entry 
0000115A  122B 0001                217           MOVE.B   1(A3),D1          Get number of characters to match 
0000115E  4BEE 0404                218           LEA.L    LNBUFF(A6),A5     A5 points to command in line buffer 
00001162  142B 0002                219           MOVE.B   2(A3),D2          Get first character in this entry 
00001166  B41D                     220           CMP.B    (A5)+,D2          from the table and match with buffer 
00001168  6704                     221           BEQ.S    SRCH3             If match then try rest of string 
0000116A  264C                     222  SRCH2    MOVE.L   A4,A3             Else get address of next entry 
0000116C  60E2                     223           BRA      SEARCH            and try the next entry in the table 
0000116E  5301                     224  SRCH3    SUB.B    #1,D1             One less character to match 
00001170  670E                     225           BEQ.S    SRCH6             If match counter zero then all done 
00001172  47EB 0003                226           LEA.L    3(A3),A3          Else point to next character in table 
00001176  141B                     227  SRCH4    MOVE.B   (A3)+,D2          Now match a pair of characters 
00001178  B41D                     228           CMP.B    (A5)+,D2 
0000117A  66EE                     229           BNE      SRCH2             If no match then try next entry 
0000117C  5301                     230           SUB.B    #1,D1             Else decrement match counter and 
0000117E  66F6                     231           BNE      SRCH4             repeat until no chars left to match 
00001180  47EC FFFC                232  SRCH6    LEA.L    -4(A4),A3         Calculate address of command entry 
00001184  003C 0001                233           OR.B     #1,CCR            point. Mark carry flag as success 
00001188  4E75                     234           RTS                        and return 
0000118A  023C 00FE                235  SRCH7    AND.B    #$FE,CCR          Fail - clear carry to indicate 
0000118E  4E75                     236           RTS                        command not found and return 
00001190                           237  * 
00001190                           238  ************************************************************************* 
00001190                           239  * 
00001190                           240  *  Basic input routines 
00001190                           241  *  HEX    =  Get one   hexadecimal character  into D0 
00001190                           242  *  BYTE   =  Get two   hexadecimal characters into D0 
00001190                           243  *  WORD   =  Get four  hexadecimal characters into D0 
00001190                           244  *  LONGWD =  Get eight hexadecimal characters into D0 
00001190                           245  *  PARAM  =  Get a longword from the line buffer into D0 
00001190                           246  *  Bit 0 of D7 is set to indicate a hexadecimal input error 
00001190                           247  * 
00001190  6100 03A2                248  HEX      BSR      GETCHAR           Get a character from input device 
00001194  0400 0030                249           SUB.B    #$30,D0           Convert to binary 
00001198  6B0E                     250           BMI.S    NOT_HEX           If less than $30 then exit with error 
0000119A  B03C 0009                251           CMP.B    #$09,D0           Else test for number (0 to 9) 
0000119E  6F0C                     252           BLE.S    HEX_OK            If number then exit - success 
000011A0  5F00                     253           SUB.B    #$07,D0           Else convert letter to hex 
000011A2  B03C 000F                254           CMP.B    #$0F,D0           If character in range "A" to "F" 
000011A6  6F04                     255           BLE.S    HEX_OK            then exit successfully 
000011A8  8E3C 0001                256  NOT_HEX  OR.B     #1,D7             Else set error flag 
000011AC  4E75                     257  HEX_OK   RTS                        and return 
000011AE                           258  * 
000011AE  2F01                     259  BYTE     MOVE.L   D1,-(A7)          Save D1 
000011B0  61DE                     260           BSR      HEX               Get first hex character 
000011B2  E900                     261           ASL.B    #4,D0             Move it to MS nybble position 
000011B4  1200                     262           MOVE.B   D0,D1             Save MS nybble in D1 
000011B6  61D8                     263           BSR      HEX               Get second hex character 
000011B8  D001                     264           ADD.B    D1,D0             Merge MS and LS nybbles 
000011BA  221F                     265           MOVE.L   (A7)+,D1          Restore D1 
000011BC  4E75                     266           RTS 
000011BE                           267  * 
000011BE  61EE                     268  WORD     BSR      BYTE              Get upper order byte 
000011C0  E140                     269           ASL.W    #8,D0             Move it to MS position 
000011C2  60EA                     270           BRA      BYTE              Get LS byte and return 
000011C4                           271  * 
000011C4  61F8                     272  LONGWD   BSR      WORD              Get upper order word 
000011C6  4840                     273           SWAP     D0                Move it to MS position 
000011C8  60F4                     274           BRA      WORD              Get lower order word and return 
000011CA                           275  * 
000011CA                           276  *  PARAM reads a parameter from the line buffer and puts it in both 
000011CA                           277  *  PARAMTR(A6) and D0. Bit 1 of D7 is set on error. 
000011CA                           278  * 
000011CA  2F01                     279  PARAM    MOVE.L   D1,-(A7)          Save D1 
000011CC  4281                     280           CLR.L    D1                Clear input accumulator 
000011CE  206E 0444                281           MOVE.L   BUFFPT(A6),A0     A0 points to parameter in buffer 
000011D2  1018                     282  PARAM1   MOVE.B   (A0)+,D0          Read character from line buffer 
000011D4  B03C 0020                283           CMP.B    #SPACE,D0         Test for delimiter 
000011D8  6720                     284           BEQ.S    PARAM4            The permitted delimiter is a 
000011DA  B03C 000D                285           CMP.B    #CR,D0            space or a carriage return 
000011DE  671A                     286           BEQ.S    PARAM4            Exit on either space or C/R 
000011E0  E981                     287           ASL.L    #4,D1             Shift accumulated result 4 bits left 
000011E2  0400 0030                288           SUB.B    #$30,D0           Convert new character to hex 
000011E6  6B1E                     289           BMI.S    PARAM5            If less than $30 then not-hex 
000011E8  B03C 0009                290           CMP.B    #$09,D0           If less than 10 
000011EC  6F08                     291           BLE.S    PARAM3            then continue 
000011EE  5F00                     292           SUB.B    #$07,D0           Else assume $A - $F 
000011F0  B03C 000F                293           CMP.B    #$0F,D0           If more than $F 
000011F4  6E10                     294           BGT.S    PARAM5            then exit to error on not-hex 
000011F6  D200                     295  PARAM3   ADD.B    D0,D1             Add latest nybble to total in D1 
000011F8  60D8                     296           BRA      PARAM1            Repeat until delimiter found 
000011FA  2D48 0444                297  PARAM4   MOVE.L   A0,BUFFPT(A6)     Save pointer in memory 
000011FE  2D41 0448                298           MOVE.L   D1,PARAMTR(A6)    Save parameter in memory 
00001202  2001                     299           MOVE.L   D1,D0             Put parameter in D0 for return 
00001204  6004                     300           BRA.S    PARAM6            Return without error 
00001206  8E3C 0002                301  PARAM5   OR.B     #2,D7             Set error flag before return 
0000120A  221F                     302  PARAM6   MOVE.L   (A7)+,D1          Restore working register 
0000120C  4E75                     303           RTS                        Return with error 
0000120E                           304  * 
0000120E                           305  ************************************************************************* 
0000120E                           306  * 
0000120E                           307  *  Output routines 
0000120E                           308  *  OUT1X   = print one   hexadecimal character 
0000120E                           309  *  OUT2X   = print two   hexadecimal characters 
0000120E                           310  *  OUT4X   = print four  hexadecimal characters 
0000120E                           311  *  OUT8X   = print eight hexadecimal characters 
0000120E                           312  *  In each case, the data to be printed is in D0 
0000120E                           313  * 
0000120E  3F00                     314  OUT1X    MOVE.W   D0,-(A7)          Save D0 
00001210  C03C 000F                315           AND.B    #$0F,D0           Mask off MS nybble 
00001214  0600 0030                316           ADD.B    #$30,D0           Convert to ASCII 
00001218  B03C 0039                317           CMP.B    #$39,D0           ASCII = HEX + $30 
0000121C  6302                     318           BLS.S    OUT1X1            If ASCII <= $39 then print and exit 
0000121E  5E00                     319           ADD.B    #$07,D0           Else ASCII := HEX + 7 
00001220  6100 0342                320  OUT1X1   BSR      PUTCHAR           Print the character 
00001224  301F                     321           MOVE.W   (A7)+,D0          Restore D0 
00001226  4E75                     322           RTS 
00001228                           323  * 
00001228  E818                     324  OUT2X    ROR.B    #4,D0             Get MS nybble in LS position 
0000122A  61E2                     325           BSR      OUT1X             Print MS nybble 
0000122C  E918                     326           ROL.B    #4,D0             Restore LS nybble 
0000122E  60DE                     327           BRA      OUT1X             Print LS nybble and return 
00001230                           328  * 
00001230  E058                     329  OUT4X    ROR.W    #8,D0             Get MS byte in LS position 
00001232  61F4                     330           BSR      OUT2X             Print MS byte 
00001234  E158                     331           ROL.W    #8,D0             Restore LS byte 
00001236  60F0                     332           BRA      OUT2X             Print LS byte and return 
00001238                           333  * 
00001238  4840                     334  OUT8X    SWAP     D0                Get MS word in LS position 
0000123A  61F4                     335           BSR      OUT4X             Print MS word 
0000123C  4840                     336           SWAP     D0                Restore LS word 
0000123E  60F0                     337           BRA      OUT4X             Print LS word and return 
00001240                           338  * 
00001240                           339  ************************************************************************* 
00001240                           340  * 
00001240                           341  * JUMP causes execution to begin at the address in the line buffer 
00001240                           342  * 
00001240  6188                     343  JUMP     BSR     PARAM              Get address from buffer 
00001242  4A07                     344           TST.B   D7                 Test for input error 
00001244  6608                     345           BNE.S   JUMP1              If error flag not zero then exit 
00001246  4A80                     346           TST.L   D0                 Else test for missing address 
00001248  6704                     347           BEQ.S   JUMP1              field. If no address then exit 
0000124A  2040                     348           MOVE.L  D0,A0              Put jump address in A0 and call the 
0000124C  4ED0                     349           JMP     (A0)               subroutine. User to supply RTS!! 
0000124E  49FA 0B39                350  JUMP1    LEA.L   ERMES1(PC),A4      Here for error - display error 
00001252  6000 FE42                351           BRA     PSTRING            message and return 
00001256                           352  * 
00001256                           353  ************************************************************************* 
00001256                           354  * 
00001256                           355  *  Display the contents of a memory location and modify it 
00001256                           356  * 
00001256  6100 FF72                357  MEMORY   BSR      PARAM             Get start address from line buffer 
0000125A  4A07                     358           TST.B    D7                Test for input error 
0000125C  6634                     359           BNE.S    MEM3              If error then exit 
0000125E  2640                     360           MOVE.L   D0,A3             A3 points to location to be opened 
00001260  6100 FE24                361  MEM1     BSR      NEWLINE 
00001264  612E                     362           BSR.S    ADR_DAT           Print current address and contents 
00001266  6140                     363           BSR.S    PSPACE             update pointer, A3, and O/P space 
00001268  6100 02CA                364           BSR      GETCHAR           Input char to decide next action 
0000126C  B03C 000D                365           CMP.B    #CR,D0            If carriage return then exit 
00001270  6720                     366           BEQ.S    MEM3              Exit 
00001272  B03C 002D                367           CMP.B    #'-',D0           If "-" then move back 
00001276  6606                     368           BNE.S    MEM2              Else skip wind-back procedure 
00001278  47EB FFFC                369           LEA.L    -4(A3),A3         Move pointer back 2+2 
0000127C  60E2                     370           BRA      MEM1              Repeat until carriage return 
0000127E  B03C 0020                371  MEM2     CMP.B    #SPACE,D0         Test for space (= new entry) 
00001282  66DC                     372           BNE.S    MEM1              If not space then repeat 
00001284  6100 FF38                373           BSR      WORD              Else get new word to store 
00001288  4A07                     374           TST.B    D7                Test for input error 
0000128A  6606                     375           BNE.S    MEM3              If error then exit 
0000128C  3740 FFFE                376           MOVE.W   D0,-2(A3)         Store new word 
00001290  60CE                     377           BRA      MEM1              Repeat until carriage return 
00001292  4E75                     378  MEM3     RTS 
00001294                           379  * 
00001294  2F00                     380  ADR_DAT  MOVE.L   D0,-(A7)          Print the contents of A3 and the 
00001296  200B                     381           MOVE.L   A3,D0             word pointed at by A3. 
00001298  619E                     382           BSR      OUT8X              and print current address 
0000129A  610C                     383           BSR.S    PSPACE            Insert delimiter 
0000129C  3013                     384           MOVE.W   (A3),D0           Get data at this address in D0 
0000129E  6190                     385           BSR      OUT4X              and print it 
000012A0  47EB 0002                386           LEA.L    2(A3),A3          Point to next address to display 
000012A4  201F                     387           MOVE.L   (A7)+,D0          Restore D0 
000012A6  4E75                     388           RTS 
000012A8                           389  * 
000012A8  1F00                     390  PSPACE   MOVE.B   D0,-(A7)          Print a single space 
000012AA  103C 0020                391           MOVE.B   #SPACE,D0 
000012AE  6100 02B4                392           BSR      PUTCHAR 
000012B2  101F                     393           MOVE.B   (A7)+,D0 
000012B4  4E75                     394           RTS 
000012B6                           395  * 
000012B6                           396  ************************************************************************* 
000012B6                           397  * 
000012B6                           398  *  LOAD  Loads data formatted in hexadecimal "S" format from Port 2 
000012B6                           399  *        NOTE - I/O is automatically redirected to the aux port for 
000012B6                           400  *        loader functions. S1 or S2 records accepted 
000012B6                           401  * 
000012B6  2F2E 0456                402  LOAD     MOVE.L   CN_OVEC(A6),-(A7) Save current output device name 
000012BA  2F2E 0452                403           MOVE.L   CN_IVEC(A6),-(A7) Save current input device name 
000012BE  2D7C 0000206C 0456       404           MOVE.L   #DCB4,CN_OVEC(A6) Set up aux ACIA as output 
000012C6  2D7C 0000205A 0452       405           MOVE.L   #DCB3,CN_IVEC(A6) Set up aux ACIA as input 
000012CE  522E 044C                406           ADD.B    #1,ECHO(A6)       Turn off character echo 
000012D2  6100 FDB2                407           BSR      NEWLINE           Send newline to host 
000012D6  6100 015A                408           BSR      DELAY             Wait for host to "settle" 
000012DA  6100 0156                409           BSR      DELAY 
000012DE  286E 0444                410           MOVE.L   BUFFPT(A6),A4     Any string in the line buffer is 
000012E2  101C                     411  LOAD1    MOVE.B   (A4)+,D0          transmitted to the host computer 
000012E4  6100 027E                412           BSR      PUTCHAR           before the loading begins 
000012E8  B03C 000D                413           CMP.B    #CR,D0            Read from the buffer until EOL 
000012EC  66F4                     414           BNE      LOAD1 
000012EE  6100 FD96                415           BSR      NEWLINE           Send newline before loading 
000012F2  6100 0240                416  LOAD2    BSR      GETCHAR           Records from the host must begin 
000012F6  B03C 0053                417           CMP.B    #'S',D0           with S1/S2 (data) or S9/S8 (term) 
000012FA  66F6                     418           BNE.S    LOAD2             Repeat GETCHAR until char = "S" 
000012FC  6100 0236                419           BSR      GETCHAR           Get character after "S" 
00001300  B03C 0039                420           CMP.B    #'9',D0           Test for the two terminators S9/S8 
00001304  6706                     421           BEQ.S    LOAD3             If S9 record then exit else test 
00001306  B03C 0038                422           CMP.B    #'8',D0           for S8 terminator. Fall through to 
0000130A  662A                     423           BNE.S    LOAD6             exit on S8 else continue search 
0000130C  =0000130C                424  LOAD3    EQU      *                 Exit point from LOAD 
0000130C  2D5F 0452                425           MOVE.L   (A7)+,CN_IVEC(A6) Clean up by restoring input device 
00001310  2D5F 0456                426           MOVE.L   (A7)+,CN_OVEC(A6) and output device name 
00001314  422E 044C                427           CLR.B    ECHO(A6)          Restore input character echo 
00001318  0807 0000                428           BTST     #0,D7             Test for input errors 
0000131C  6708                     429           BEQ.S    LOAD4             If no I/P error then look at checksum 
0000131E  49FA 0A69                430           LEA.L    ERMES1(PC),A4     Else point to error message 
00001322  6100 FD72                431           BSR      PSTRING           Print it 
00001326  0807 0003                432  LOAD4    BTST     #3,D7             Test for checksum error 
0000132A  6708                     433           BEQ.S    LOAD5             If clear then exit 
0000132C  49FA 0A8B                434           LEA.L    ERMES3(PC),A4     Else point to error message 
00001330  6100 FD64                435           BSR      PSTRING           Print it and return 
00001334  4E75                     436  LOAD5    RTS 
00001336                           437  * 
00001336  B03C 0031                438  LOAD6    CMP.B    #'1',D0           Test for S1 record 
0000133A  671E                     439           BEQ.S    LOAD6A            If S1 record then read it 
0000133C  B03C 0032                440           CMP.B    #'2',D0           Else test for S2 record 
00001340  66B0                     441           BNE.S    LOAD2             Repeat until valid header found 
00001342  4203                     442           CLR.B    D3                Read the S2 byte count and address, 
00001344  613C                     443           BSR.S    LOAD8             clear the checksum 
00001346  5900                     444           SUB.B    #4,D0             Calculate size of data field 
00001348  1400                     445           MOVE.B   D0,D2             D2 contains data bytes to read 
0000134A  4280                     446           CLR.L    D0                Clear address accumulator 
0000134C  6134                     447           BSR.S    LOAD8             Read most sig byte of address 
0000134E  E180                     448           ASL.L    #8,D0             Move it one byte left 
00001350  6130                     449           BSR.S    LOAD8             Read the middle byte of address 
00001352  E180                     450           ASL.L    #8,D0             Move it one byte left 
00001354  612C                     451           BSR.S    LOAD8             Read least sig byte of address 
00001356  2440                     452           MOVE.L   D0,A2             A2 points to destination of record 
00001358  6012                     453           BRA.S    LOAD7             Skip past S1 header loader 
0000135A  4203                     454  LOAD6A   CLR.B    D3                S1 record found - clear checksum 
0000135C  6124                     455           BSR.S    LOAD8             Get byte and update checksum 
0000135E  5700                     456           SUB.B    #3,D0             Subtract 3 from record length 
00001360  1400                     457           MOVE.B   D0,D2             Save byte count in D2 
00001362  4280                     458           CLR.L    D0                Clear address accumulator 
00001364  611C                     459           BSR.S    LOAD8             Get MS byte of load address 
00001366  E180                     460           ASL.L    #8,D0             Move it to MS position 
00001368  6118                     461           BSR.S    LOAD8             Get LS byte in D2 
0000136A  2440                     462           MOVE.L   D0,A2             A2 points to destination of data 
0000136C  6114                     463  LOAD7    BSR.S    LOAD8             Get byte of data for loading 
0000136E  14C0                     464           MOVE.B   D0,(A2)+          Store it 
00001370  5302                     465           SUB.B    #1,D2             Decrement byte counter 
00001372  66F8                     466           BNE      LOAD7             Repeat until count = 0 
00001374  610C                     467           BSR.S    LOAD8             Read checksum 
00001376  5203                     468           ADD.B    #1,D3             Add 1 to total checksum 
00001378  6700 FF78                469           BEQ      LOAD2             If zero then start next record 
0000137C  8E3C 0008                470           OR.B     #%00001000,D7     Else set checksum error bit, 
00001380  608A                     471           BRA      LOAD3             restore I/O devices and return 
00001382                           472  * 
00001382  6100 FE2A                473  LOAD8    BSR     BYTE               Get a byte 
00001386  D600                     474           ADD.B   D0,D3              Update checksum 
00001388  4E75                     475           RTS                         and return 
0000138A                           476  * 
0000138A                           477  ************************************************************************* 
0000138A                           478  * 
0000138A                           479  *  DUMP   Transmit S1 formatted records to host computer 
0000138A                           480  *         A3 = Starting address of data block 
0000138A                           481  *         A2 = End address of data block 
0000138A                           482  *         D1 = Checksum, D2 = current record length 
0000138A                           483  * 
0000138A  6100 0096                484  DUMP     BSR      RANGE             Get start and end address 
0000138E  4A07                     485           TST.B    D7                Test for input error 
00001390  6708                     486           BEQ.S    DUMP1             If no error then continue 
00001392  49FA 09F5                487           LEA.L    ERMES1(PC),A4     Else point to error message, 
00001396  6000 FCFE                488           BRA      PSTRING           print it and return 
0000139A  B08B                     489  DUMP1    CMP.L    A3,D0             Compare start and end addresses 
0000139C  6A08                     490           BPL.S    DUMP2             If positive then start < end 
0000139E  49FA 0B88                491           LEA.L    ERMES7(PC),A4     Else print error message 
000013A2  6000 FCF2                492           BRA      PSTRING           and return 
000013A6  2F2E 0456                493  DUMP2    MOVE.L   CN_OVEC(A6),-(A7) Save name of current output device 
000013AA  2D7C 0000206C 0456       494           MOVE.L   #DCB4,CN_OVEC(A6) Set up Port 2 as output device 
000013B2  6100 FCD2                495           BSR      NEWLINE           Send newline to host and wait 
000013B6  617A                     496           BSR.S    DELAY 
000013B8  286E 0444                497           MOVE.L   BUFFPT(A6),A4     Before dumping, send any string 
000013BC  101C                     498  DUMP3    MOVE.B   (A4)+,D0          in the input buffer to the host 
000013BE  6100 01A4                499           BSR      PUTCHAR           Repeat 
000013C2  B03C 000D                500           CMP.B    #CR,D0            Transmit char from buffer to host 
000013C6  66F4                     501           BNE      DUMP3             Until char = C/R 
000013C8  6100 FCBC                502           BSR      NEWLINE 
000013CC  6164                     503           BSR.S    DELAY             Allow time for host to settle 
000013CE  528A                     504           ADDQ.L   #1,A2             A2 contains length of record + 1 
000013D0  240A                     505  DUMP4    MOVE.L   A2,D2             D2 points to end address 
000013D2  948B                     506           SUB.L    A3,D2             D2 contains bytes left to print 
000013D4  B4BC 00000011            507           CMP.L    #17,D2            If this is not a full record of 16 
000013DA  6502                     508           BCS.S    DUMP5             then load D2 with record size 
000013DC  7410                     509           MOVEQ    #16,D2            Else preset byte count to 16 
000013DE  49FA 08BF                510  DUMP5    LEA.L    HEADER(PC),A4     Point to record header 
000013E2  6100 FCB2                511           BSR      PSTRING           Print header 
000013E6  4201                     512           CLR.B    D1                Clear checksum 
000013E8  1002                     513           MOVE.B   D2,D0             Move record length to output register 
000013EA  5600                     514           ADD.B    #3,D0             Length includes address + count 
000013EC  612E                     515           BSR.S    DUMP7             Print number of bytes in record 
000013EE  200B                     516           MOVE.L   A3,D0             Get start address to be printed 
000013F0  E158                     517           ROL.W    #8,D0             Get MS byte in LS position 
000013F2  6128                     518           BSR.S    DUMP7             Print MS byte of address 
000013F4  E058                     519           ROR.W    #8,D0             Restore LS byte 
000013F6  6124                     520           BSR.S    DUMP7             Print LS byte of address 
000013F8  101B                     521  DUMP6    MOVE.B   (A3)+,D0          Get data byte to be printed 
000013FA  6120                     522           BSR.S    DUMP7             Print it 
000013FC  5302                     523           SUB.B    #1,D2             Decrement byte count 
000013FE  66F8                     524           BNE      DUMP6             Repeat until all this record printed 
00001400  4601                     525           NOT.B    D1                Complement checksum 
00001402  1001                     526           MOVE.B   D1,D0             Move to output register 
00001404  6116                     527           BSR.S    DUMP7             Print checksum 
00001406  6100 FC7E                528           BSR      NEWLINE 
0000140A  B7CA                     529           CMP.L    A2,A3             Have all records been printed? 
0000140C  66C2                     530           BNE      DUMP4             Repeat until all done 
0000140E  49FA 0895                531           LEA.L    TAIL(PC),A4       Point to message tail (S9 record) 
00001412  6100 FC82                532           BSR      PSTRING           Print it 
00001416  2D5F 0456                533           MOVE.L   (A7)+,CN_OVEC(A6) Restore name of output device 
0000141A  4E75                     534           RTS                        and return 
0000141C                           535  * 
0000141C  D200                     536  DUMP7    ADD.B    D0,D1             Update checksum, transmit byte 
0000141E  6000 FE08                537           BRA      OUT2X             to host and return 
00001422                           538  * 
00001422  =00001422                539  RANGE    EQU      *                 Get the range of addresses to be 
00001422  4207                     540           CLR.B    D7                transmitted from the buffer 
00001424  6100 FDA4                541           BSR      PARAM             Get starting address 
00001428  2640                     542           MOVE.L   D0,A3             Set up start address in A3 
0000142A  6100 FD9E                543           BSR      PARAM             Get end address 
0000142E  2440                     544           MOVE.L   D0,A2             Set up end address in A2 
00001430  4E75                     545           RTS 
00001432                           546  * 
00001432  =00001432                547  DELAY    EQU       *                Provide a time delay for the host 
00001432  48E7 8008                548           MOVEM.L   D0/A4,-(A7)      to settle. Save working registers 
00001436  203C 00004000            549           MOVE.L    #$4000,D0        Set up delay constant 
0000143C  5380                     550  DELAY1   SUB.L     #1,D0            Count down         (8 clk cycles) 
0000143E  66FC                     551           BNE       DELAY1           Repeat until zero  (10 clk cycles) 
00001440  4CDF 1001                552           MOVEM.L   (A7)+,D0/A4      Restore working registers 
00001444  4E75                     553           RTS 
00001446                           554  * 
00001446                           555  ************************************************************************* 
00001446                           556  * 
00001446                           557  *  TM  Enter transparant mode (All communication to go from terminal to 
00001446                           558  *  the host processor until escape sequence entered). End sequence 
00001446                           559  *  = ESC, E. A newline is sent to the host to "clear it down". 
00001446                           560  * 
00001446  13FC 0055 00008001       561  TM       MOVE.B    #$55,ACIA_1      Force RTS* high to re-route data 
0000144E  522E 044C                562           ADD.B     #1,ECHO(A6)      Turn off character echo 
00001452  6100 00E0                563  TM1      BSR       GETCHAR          Get character 
00001456  B03C 001B                564           CMP.B     #ESC,D0          Test for end of TM mode 
0000145A  66F6                     565           BNE       TM1              Repeat until first escape character 
0000145C  6100 00D6                566           BSR       GETCHAR          Get second character 
00001460  B03C 0045                567           CMP.B     #'E',D0          If second char = E then exit TM 
00001464  66EC                     568           BNE       TM1              Else continue 
00001466  2F2E 0456                569           MOVE.L    CN_OVEC(A6),-(A7) Save output port device name 
0000146A  2D7C 0000206C 0456       570           MOVE.L    #DCB4,CN_OVEC(A6) Get name of host port (aux port) 
00001472  6100 FC12                571           BSR       NEWLINE          Send newline to host to clear it 
00001476  2D5F 0456                572           MOVE.L    (A7)+,CN_OVEC(A6) Restore output device port name 
0000147A  422E 044C                573           CLR.B     ECHO(A6)         Restore echo mode 
0000147E  13FC 0015 00008001       574           MOVE.B    #$15,ACIA_1      Restore normal ACIA mode (RTS* low) 
00001486  4E75                     575           RTS 
00001488                           576  * 
00001488                           577  ************************************************************************* 
00001488                           578  * 
00001488                           579  *  This routine sets up the system DCBs in RAM using the information 
00001488                           580  *  stored in ROM at address DCB_LST. This is called at initialization. 
00001488                           581  *  CN_IVEC contains the name "DCB1" and IO_VEC the name "DCB2" 
00001488                           582  * 
00001488  48E7 F0F0                583  SET_DCB  MOVEM.L A0-A3/D0-D3,-(A7) Save all working registers 
0000148C  41EE 04D4                584           LEA.L   FIRST(A6),A0    Pointer to first DCB destination in RAM 
00001490  43FA 0BA4                585           LEA.L   DCB_LST(PC),A1  A1 points to DCB info block in ROM 
00001494  303C 0005                586           MOVE.W  #5,D0           6 DCBs to set up 
00001498  323C 000F                587  ST_DCB1  MOVE.W  #15,D1          16 bytes to move per DCB header 
0000149C  10D9                     588  ST_DCB2  MOVE.B  (A1)+,(A0)+     Move the 16 bytes of a DCB header 
0000149E  51C9 FFFC                589           DBRA    D1,ST_DCB2      from ROM to RAM 
000014A2  3619                     590           MOVE.W  (A1)+,D3        Get size of parameter block (bytes) 
000014A4  3083                     591           MOVE.W  D3,(A0)         Store size in DCB in RAM 
000014A6  41F0 3002                592           LEA.L   2(A0,D3.W),A0   A0 points to tail of DCB in RAM 
000014AA  47E8 0004                593           LEA.L   4(A0),A3        A3 contains address of next DCB in RAM 
000014AE  208B                     594           MOVE.L  A3,(A0)         Store pointer to next DCB in this DCB 
000014B0  41D3                     595           LEA.L   (A3),A0         A0 now points at next DCB in RAM 
000014B2  51C8 FFE4                596           DBRA    D0,ST_DCB1      Repeat until all DCBs set up 
000014B6  47EB FFFC                597           LEA.L   -4(A3),A3       Adjust A3 to point to last DCB pointer 
000014BA  4293                     598           CLR.L   (A3)            and force last pointer to zero 
000014BC  2D7C 00002036 0452       599           MOVE.L  #DCB1,CN_IVEC(A6) Set up vector to console input DCB 
000014C4  2D7C 00002048 0456       600           MOVE.L  #DCB2,CN_OVEC(A6) Set up vector to console output DCB 
000014CC  4CDF 0F0F                601           MOVEM.L (A7)+,A0-A3/D0-D3 Restore registers 
000014D0  4E75                     602           RTS 
000014D2                           603  * 
000014D2                           604  ************************************************************************* 
000014D2                           605  * 
000014D2                           606  *  IO_REQ handles all input/output transactions. A0 points to DCB on 
000014D2                           607  *  entry. IO_REQ calls the device driver whose address is in the DCB. 
000014D2                           608  * 
000014D2  48E7 00C0                609  IO_REQ   MOVEM.L A0-A1,-(A7)     Save working registers 
000014D6  43E8 0008                610           LEA.L   8(A0),A1        A1 points to device handler field in DCB 
000014DA  2251                     611           MOVE.L  (A1),A1         A1 contains device handler address 
000014DC  4E91                     612           JSR     (A1)            Call device handler 
000014DE  4CDF 0300                613           MOVEM.L (A7)+,A0-A1     Restore working registers 
000014E2  4E75                     614           RTS 
000014E4                           615  * 
000014E4                           616  ************************************************************************* 
000014E4                           617  * 
000014E4                           618  *  CON_IN handles input from the console device 
000014E4                           619  *  Exit with input in D0 
000014E4                           620  * 
000014E4  48E7 4000                621  CON_IN   MOVEM.L D1,-(A7)         Save working registers 
000014E8  4228 0013                622      CLR.B    19(A0)
000014EC  103C 0005                623           MOVE.B    #5,D0             Read input from ACIA
000014F0  4E4F                     624      TRAP     #15
000014F2  1001                     625      MOVE.B  D1,D0
000014F4  4CDF 0002                626           MOVEM.L (A7)+,D1     `   Restore working registers 
000014F8  4E75                     627           RTS 
000014FA                           628  * 
000014FA                           629  ************************************************************************* 
000014FA                           630  * 
000014FA                           631  *   This is the CON_OUT device driver. Output in D0  
000014FA                           632  * 
000014FA  48E7 4000                633  CON_OUT  MOVEM.L D1,-(A7)  Save working registers 
000014FE  4228 0013                634      CLR.B    19(A0)
00001502  1200                     635           MOVE.B    D0,D1
00001504  103C 0006                636           MOVE.B    #6,D0
00001508  4E4F                     637           TRAP   #15
0000150A  4CDF 0002                638           MOVEM.L (A7)+,D1  Restore working registers 
0000150E  4E75                     639           RTS 
00001510                           640  * 
00001510                           641  ************************************************************************* 
00001510                           642  * 
00001510                           643  *  AUX_IN and AUX_OUT are simplified versions of CON_IN and 
00001510                           644  *  CON_OUT for use with the port to the host processor 
00001510                           645  * 
00001510  43E8 000C                646  AUX_IN   LEA.L   12(A0),A1       Get pointer to aux ACIA from DCB 
00001514  2251                     647           MOVE.L  (A1),A1         Get address of aux ACIA 
00001516  0811 0000                648  AUX_IN1  BTST.B  #0,(A1)         Test for data ready 
0000151A  67FA                     649           BEQ     AUX_IN1         Repeat until ready 
0000151C  1029 0002                650           MOVE.B  2(A1),D0        Read input 
00001520  4E75                     651           RTS 
00001522                           652  * 
00001522  43E8 000C                653  AUX_OUT  LEA.L   12(A0),A1       Get pointer to aux ACIA from DCB 
00001526  2251                     654           MOVE.L  (A1),A1         Get address of aux ACIA 
00001528  0811 0001                655  AUX_OT1  BTST.B  #1,(A1)         Test for ready to transmit 
0000152C  67FA                     656           BEQ     AUX_OT1         Repeat until transmitter ready 
0000152E  1340 0002                657           MOVE.B  D0,2(A1)        Transmit data 
00001532  4E75                     658           RTS 
00001534                           659  * 
00001534                           660  ************************************************************************* 
00001534                           661  * 
00001534                           662  *  GETCHAR gets a character from the console device 
00001534                           663  *  This is the main input routine and uses the device whose name  
00001534                           664  *  is stored in CN_IVEC. Changing this name redirects input. 
00001534                           665  * 
00001534  2F08                     666  GETCHAR  MOVE.L  A0,-(A7)        Save working register 
00001536  206E 0452                667           MOVE.L  CN_IVEC(A6),A0  A0 points to name of console DCB 
0000153A  6156                     668           BSR.S   IO_OPEN         Open console (get DCB address in A0) 
0000153C  0807 0003                669           BTST    #3,D7           D7(3) set if open error 
00001540  661E                     670           BNE.S   GETCH3          If error then exit now 
00001542  618E                     671           BSR     IO_REQ          Else execute I/O transaction 
00001544  C03C 007F                672           AND.B   #$7F,D0         Strip msb of input 
00001548  4A2E 044D                673           TST.B   U_CASE(A6)      Test for upper -> lower case conversion 
0000154C  660A                     674           BNE.S   GETCH2          If flag not zero do not convert case 
0000154E  0800 0006                675           BTST    #6,D0             Test input for lower case 
00001552  6704                     676           BEQ.S   GETCH2          If upper case then skip conversion 
00001554  C03C 00DF                677           AND.B   #%11011111,D0   Else clear bit 5 for upper case conv 
00001558  4A2E 044C                678  GETCH2   TST.B   ECHO(A6)        Do we need to echo the input? 
0000155C  6602                     679           BNE.S   GETCH3          If ECHO not zero then no echo 
0000155E  6104                     680           BSR.S   PUTCHAR         Else echo the input 
00001560  205F                     681  GETCH3   MOVE.L  (A7)+,A0        Restore working register 
00001562  4E75                     682           RTS                     and return 
00001564                           683  * 
00001564                           684  ************************************************************************* 
00001564                           685  * 
00001564                           686  *  PUTCHAR sends a character to the console device 
00001564                           687  *  The name of the output device is in CN_OVEC. 
00001564                           688  * 
00001564  BC3C 0001                689  PUTCHAR  CMP.B   #1,D6
00001568                           690           *BEQ     PUTASK
00001568  2F08                     691           MOVE.L  A0,-(A7)        Save working register
0000156A  206E 0456                692           MOVE.L  CN_OVEC(A6),A0  A0 points to name of console output 
0000156E  6122                     693           BSR.S   IO_OPEN         Open console (Get address of DCB) 
00001570  6100 FF60                694           BSR     IO_REQ          Perform output with DCB pointed at by A0 
00001574  205F                     695           MOVE.L  (A7)+,A0        Restore working register 
00001576  4E75                     696           RTS 
00001578                           697  
00001578                           698  *PUTASK   MOVE    D0,-(A5)
00001578                           699  *         MOVE    #'*',D0
00001578                           700  *         MOVE.L  A0,-(A7)        Save working register
00001578                           701  *         MOVE.L  CN_OVEC(A6),A0  A0 points to name of console output 
00001578                           702  *         BSR.S   IO_OPEN         Open console (Get address of DCB) 
00001578                           703  *         BSR     IO_REQ          Perform output with DCB pointed at by A0 
00001578                           704  *         MOVE.L  (A7)+,A0        Restore working register
00001578                           705  *         MOVE    (A5)+,D0
00001578                           706  *         RTS 
00001578                           707  * 
00001578                           708  ************************************************************************* 
00001578                           709  * 
00001578                           710  *  BUFF_IN and BUFF_OUT are two rudimentary input and output routines 
00001578                           711  *  which input data from and output data to a buffer in RAM. These are 
00001578                           712  *  used by DCB5 and DCB6, respectively. 
00001578                           713  * 
00001578  43E8 000C                714  BUFF_IN  LEA.L   12(A0),A1       A1 points to I/P buffer 
0000157C  2451                     715           MOVE.L  (A1),A2         A2 gets I/P pointer from buffer 
0000157E  1022                     716           MOVE.B  -(A2),D0        Read char from buffer and adjust A2 
00001580  228A                     717           MOVE.L  A2,(A1)         Restore pointer in buffer 
00001582  4E75                     718           RTS 
00001584                           719  * 
00001584  43E8 000C                720  BUFF_OT  LEA.L   12(A0),A1       A1 points to O/P buffer 
00001588  2469 0004                721           MOVE.L  4(A1),A2        A2 gets O/P pointer from buffer 
0000158C  14C0                     722           MOVE.B  D0,(A2)+        Store char in buffer and adjust A2 
0000158E  228A                     723           MOVE.L  A2,(A1)         Restore pointer in buffer 
00001590  4E75                     724           RTS 
00001592                           725  * 
00001592                           726  ************************************************************************* 
00001592                           727  * 
00001592                           728  *  Open - opens a DCB for input or output. IO_OPEN converts the 
00001592                           729  *  name pointed at by A0 into the address of the DCB pointed at 
00001592                           730  *  by A0. Bit 3 of D7 is set to zero if DCB not found 
00001592                           731  * 
00001592  48E7 F870                732  IO_OPEN  MOVEM.L  A1-A3/D0-D4,-(A7) Save working registers 
00001596  43EE 04D4                733           LEA.L    FIRST(A6),A1   A1 points to first DCB in chain in RAM 
0000159A  45D1                     734  OPEN1    LEA.L    (A1),A2        A2 = temp copy of pointer to DCB 
0000159C  47D0                     735           LEA.L    (A0),A3        A3 = temp copy of pointer to DCB name 
0000159E  303C 0007                736           MOVE.W   #7,D0          Up to 8 chars of DCB name to match 
000015A2  181A                     737  OPEN2    MOVE.B   (A2)+,D4       Compare DCB name with string 
000015A4  B81B                     738           CMP.B    (A3)+,D4 
000015A6  6608                     739           BNE.S    OPEN3          If no match try next DCB 
000015A8  51C8 FFF8                740           DBRA     D0,OPEN2       Else repeat until all chars matched 
000015AC  41D1                     741           LEA.L    (A1),A0        Success - move this DCB address to A0 
000015AE  6016                     742           BRA.S    OPEN4          and return 
000015B0  =000015B0                743  OPEN3    EQU      *              Fail - calculate address of next DCB 
000015B0  3229 0010                744           MOVE.W   16(A1),D1      Get parameter block size of DCB 
000015B4  43F1 1012                745           LEA.L    18(A1,D1.W),A1 A1 points to pointer to next DCB 
000015B8  2251                     746           MOVE.L   (A1),A1        A1 now points to next DCB 
000015BA  B3FC 00000000            747           CMP.L    #0,A1          Test for end of DCB chain 
000015C0  66D8                     748           BNE      OPEN1          If not end of chain then try next DCB 
000015C2  8E3C 0008                749           OR.B     #8,D7          Else set error flag and return 
000015C6  4CDF 0E1F                750  OPEN4    MOVEM.L  (A7)+,A1-A3/D0-D4 Restore working registers 
000015CA  4E75                     751           RTS 
000015CC                           752  * 
000015CC                           753  ************************************************************************* 
000015CC                           754  * 
000015CC                           755  *  Exception vector table initialization routine 
000015CC                           756  *  All vectors not setup are loaded with uninitialized routine vector 
000015CC                           757  * 
000015CC  303C 0007                758  X_SET   MOVE.W  #7,D0             Now clear the breakpoint table 
000015D0  41EE 04A4                759          LEA.L   BP_TAB(A6),A0     Point to table 
000015D4  4298                     760  X_SET2  CLR.L   (A0)+             Clear an address entry 
000015D6  4258                     761          CLR.W   (A0)+             Clear the corresponding data 
000015D8  51C8 FFFA                762          DBRA    D0,X_SET2         Repeat until all 8 cleared 
000015DC  4E75                     763          RTS 
000015DE                           764  * 
000015DE                           765  *************************************************************************
000015DE  DA04                     766  ADD_0   ADD.B     D4,D5
000015E0  1605                     767          MOVE.B    D5,D3
000015E2  183C 0000                768          MOVE.B    #0,D4           resetting neg flag
000015E6  6B00 0040                769          BMI       SETNEG
000015EA  4E75                     770          RTS
000015EC                           771  
000015EC  9A04                     772  SUB_0   SUB.B     D4,D5
000015EE  183C 0000                773          MOVE.B    #0,D4           resetting neg flag
000015F2  1605                     774          MOVE.B    D5,D3
000015F4  6B00 0032                775          BMI       SETNEG
000015F8  4E75                     776          RTS
000015FA                           777          
000015FA  CBC4                     778  MUL_0   MULS      D4,D5
000015FC  383C 0000                779          MOVE.W    #0,D4           resetting neg flag
00001600  2605                     780          MOVE.L    D5,D3
00001602  6B00 0034                781          BMI       MULNEG
00001606  4E75                     782          RTS
00001608                           783  
00001608  8BC4                     784  DIV_0   DIVS      D4,D5
0000160A  183C 0000                785          MOVE.B    #0,D4           resetting neg flag
0000160E  1605                     786          MOVE.B    D5,D3
00001610  4603                     787          NOT.B     D3
00001612  C63C 007F                788          AND.B     #%01111111,D3
00001616  5203                     789          ADD.B     #1,D3
00001618  BA7C 007F                790          CMP.W     #127,D5
0000161C  6500 0004                791          BCS       DIVNEG
00001620  4E75                     792          RTS
00001622                           793  
00001622  183C 0001                794  DIVNEG  MOVE.B    #1,D4
00001626  4E75                     795          RTS
00001628                           796  
00001628  183C 00FF                797  SETNEG  MOVE.B    #255,D4
0000162C  9803                     798          SUB.B     D3,D4
0000162E  1604                     799          MOVE.B    D4,D3
00001630  5203                     800          ADD.B     #1,D3
00001632  183C 0001                801          MOVE.B    #1,D4
00001636  4E75                     802          RTS
00001638                           803  
00001638  183C 0001                804  MULNEG  MOVE.B    #1,D4
0000163C  4683                     805          NOT.L     D3
0000163E  C6BC 7FFFFFFF            806          AND.L     #%01111111111111111111111111111111,D3
00001644  5203                     807          ADD.B     #1,D3
00001646  4E75                     808          RTS
00001648                           809  
00001648                           810  * 
00001648                           811  ************************************************************************* 
00001648                           812  * 
00001648  =00001648                813  TRAP_0  EQU     *                 User links to  TS2BUG via TRAP #0 
00001648  B23C 0000                814          CMP.B   #0,D1             D1 = 0 = Get character 
0000164C  6606                     815          BNE.S   FOO1           
0000164E  6100 FEE4                816          BSR     GETCHAR 
00001652  4E73                     817          RTE 
00001654  B23C 0001                818  FOO1    CMP.B   #1,D1             D1 = 1 = Print character 
00001658  6606                     819          BNE.S   FOO2 
0000165A  6100 FF08                820          BSR     PUTCHAR 
0000165E  4E73                     821          RTE 
00001660  B23C 0002                822  FOO2    CMP.B   #2,D1             D1 = 2 = Newline 
00001664  6606                     823          BNE.S   FOO3 
00001666  6100 FA1E                824          BSR     NEWLINE 
0000166A  4E73                     825          RTE 
0000166C  B23C 0003                826  FOO3    CMP.B   #3,D1             D1 = 3 = Get parameter from buffer 
00001670  6606                     827          BNE.S   FOO4 
00001672  6100 FB56                828          BSR     PARAM 
00001676  4E73                     829          RTE 
00001678  B23C 0004                830  FOO4    CMP.B   #4,D1             D1 = 4 = Print string pointed at by A4 
0000167C  6606                     831          BNE.S   FOO5 
0000167E  6100 FA16                832          BSR     PSTRING 
00001682  4E73                     833          RTE 
00001684  B23C 0005                834  FOO5    CMP.B   #5,D1             D1 = 5 = Get a hex character 
00001688  6606                     835          BNE.S   FOO6 
0000168A  6100 FB04                836          BSR     HEX 
0000168E  4E73                     837          RTE 
00001690  B23C 0006                838  FOO6    CMP.B   #6,D1             D1 = 6 = Get a hex byte 
00001694  6606                     839          BNE.S   FOO7 
00001696  6100 FB16                840          BSR     BYTE 
0000169A  4E73                     841          RTE 
0000169C  B23C 0007                842  FOO7    CMP.B   #7,D1             D1 = 7 = Get a word 
000016A0  6606                     843          BNE.S   FOO8 
000016A2  6100 FB1A                844          BSR     WORD 
000016A6  4E73                     845          RTE 
000016A8  B23C 0008                846  FOO8    CMP.B   #8,D1             D1 = 8 = Get a longword 
000016AC  6606                     847          BNE.S   FOO9 
000016AE  6100 FB14                848          BSR     LONGWD 
000016B2  4E73                     849          RTE 
000016B4  B23C 0009                850  FOO9    CMP.B   #9,D1             D1 = 9 = Output hex byte 
000016B8  6606                     851          BNE.S   FOO10  
000016BA  6100 FB6C                852          BSR     OUT2X 
000016BE  4E73                     853          RTE 
000016C0  B23C 000A                854  FOO10   CMP.B   #10,D1            D1 = 10 = Output hex word 
000016C4  6606                     855          BNE.S   FOO11 
000016C6  6100 FB68                856          BSR     OUT4X 
000016CA  4E73                     857          RTE 
000016CC  B23C 000B                858  FOO11   CMP.B   #11,D1            D1 = 11 = Output hex longword 
000016D0  6606                     859          BNE.S   FOO12 
000016D2  6100 FB64                860          BSR     OUT8X 
000016D6  4E73                     861          RTE 
000016D8  B23C 000C                862  FOO12   CMP.B   #12,D1            D1 = 12 = Print a space 
000016DC  6606                     863          BNE.S   FOO13 
000016DE  6100 FBC8                864          BSR     PSPACE 
000016E2  4E73                     865          RTE 
000016E4  B23C 000D                866  FOO13   CMP.B   #13,D1            D1 = 13 = Get a line of text into 
000016E8  6606                     867          BNE.S   FOO14            the line buffer 
000016EA  6100 F9C0                868          BSR     GETLINE 
000016EE  4E73                     869          RTE 
000016F0  B23C 000E                870  FOO14   CMP.B   #14,D1            D1 = 14 = Tidy up the line in the 
000016F4  6606                     871          BNE.S   FOO15            line buffer by removing leading 
000016F6  6100 F9EA                872          BSR     TIDY              leading and multiple embeded spaces 
000016FA  4E73                     873          RTE 
000016FC  B23C 000F                874  FOO15   CMP.B   #15,D1            D1 = 15 = Execute the command in 
00001700  6606                     875          BNE.S   FOO16            the line buffer 
00001702  6100 FA20                876          BSR     EXECUTE 
00001706  4E73                     877          RTE 
00001708  B23C 0010                878  FOO16   CMP.B   #16,D1            D1 = 16 = Call RESTORE to transfer 
0000170C  6606                     879          BNE.S   FOO17            the registers in TSK_T to the 68000 
0000170E  6100 036A                880          BSR     RESTORE           and therefore execute a program 
00001712  4E73                     881          RTE 
00001714  B23C 0011                882  FOO17   CMP.B   #17,D1            D1 = 17 = Call ADD_0
00001718  6606                     883          BNE.S   FOO18            
0000171A  6100 FEC2                884          BSR     ADD_0            
0000171E  4E73                     885          RTE 
00001720  B23C 0012                886  FOO18   CMP.B   #18,D1            D1 = 18 = Call SUB_0
00001724  6606                     887          BNE.S   FOO19            
00001726  6100 FEC4                888          BSR     SUB_0            
0000172A  4E73                     889          RTE 
0000172C  B23C 0013                890  FOO19   CMP.B   #19,D1            D1 = 19 = Call MUL_0
00001730  6606                     891          BNE.S   FOO20            
00001732  6100 FEC6                892          BSR     MUL_0            
00001736  4E73                     893          RTE 
00001738  B23C 0014                894  FOO20   CMP.B   #20,D1            D1 = 20 = Call DIV_0
0000173C  6606                     895          BNE.S   FOO21            
0000173E  6100 FEC8                896          BSR     DIV_0            
00001742  4E73                     897          RTE
00001744  4E73                     898  FOO21   RTE         
00001746                           899  * 
00001746                           900  ************************************************************************* 
00001746  =00001746                901  TRAP_14  EQU     *
00001746  4EB9 000019D6            902           JSR     BRKPT            User application breakpoint
0000174C  4E73                     903           RTE
0000174E                           904  *
0000174E                           905  ************************************************************************* 
0000174E  4EF8 1076                906  TRAP_15  JMP     WARM              
00001752  4E73                     907           RTE
00001754                           908  *
00001754                           909  ************************************************************************* 
00001754                           910  * 
00001754                           911  *  Display exception frame (D0 - D7, A0 - A6, USP, SSP, SR, PC) 
00001754                           912  *  EX_DIS prints registers saved after a breakpoint or exception 
00001754                           913  *  The registers are saved in TSK_T 
00001754                           914  * 
00001754  4BEE 045A                915  EX_DIS  LEA.L   TSK_T(A6),A5      A5 points to display frame 
00001758  49FA 056C                916          LEA.L   MES3(PC),A4       Point to heading 
0000175C  6100 F948                917          BSR     HEADING           and print it 
00001760  3C3C 0007                918          MOVE.W  #7,D6             8 pairs of registers to display 
00001764  4205                     919          CLR.B   D5                D5 is the line counter 
00001766  1005                     920  EX_D1   MOVE.B  D5,D0             Put current register number in D0 
00001768  6100 FAA4                921          BSR     OUT1X             and print it 
0000176C  6100 FB3A                922          BSR     PSPACE            and a space 
00001770  5205                     923          ADD.B   #1,D5             Update counter for next pair 
00001772  2015                     924          MOVE.L  (A5),D0           Get data register to be displayed 
00001774  6100 FAC2                925          BSR     OUT8X             from the frame and print it 
00001778  49FA 056A                926          LEA.L   MES4(PC),A4       Print string of spaces 
0000177C  6100 F918                927          BSR.L   PSTRING           between data and address registers 
00001780  202D 0020                928          MOVE.L  32(A5),D0         Get address register to be displayed 
00001784  6100 FAB2                929          BSR     OUT8X             which is 32 bytes on from data reg 
00001788  6100 F8FC                930          BSR     NEWLINE 
0000178C  4BED 0004                931          LEA.L   4(A5),A5          Point to next pair (ie Di, Ai) 
00001790  51CE FFD4                932          DBRA    D6,EX_D1          Repeat until all displayed 
00001794  4BED 0020                933          LEA.L   32(A5),A5         Adjust pointer by 8 longwords 
00001798  6100 F8EC                934          BSR     NEWLINE           to point to SSP 
0000179C  49FA 051F                935          LEA.L   MES2A(PC),A4      Point to "SS =" 
000017A0  6100 F8F4                936          BSR     PSTRING           Print it 
000017A4  201D                     937          MOVE.L  (A5)+,D0          Get SSP from frame 
000017A6  6100 FA90                938          BSR     OUT8X             and display it 
000017AA  6100 F8DA                939          BSR     NEWLINE 
000017AE  49FA 04FB                940          LEA.L   MES1(PC),A4       Point to 'SR =' 
000017B2  6100 F8E2                941          BSR     PSTRING           Print it 
000017B6  301D                     942          MOVE.W  (A5)+,D0          Get status register 
000017B8  6100 FA76                943          BSR     OUT4X             Display status 
000017BC  6100 F8C8                944          BSR     NEWLINE 
000017C0  49FA 04F2                945          LEA.L   MES2(PC),A4       Point to 'PC =' 
000017C4  6100 F8D0                946          BSR     PSTRING           Print it 
000017C8  201D                     947          MOVE.L  (A5)+,D0          Get PC 
000017CA  6100 FA6C                948          BSR     OUT8X             Display PC 
000017CE  6000 F8B6                949          BRA     NEWLINE           Newline and return 
000017D2                           950  * 
000017D2                           951  ************************************************************************* 
000017D2  49F9 00001E09            952  HELP     LEA.L    JUMPHELP,A4
000017D8  6100 F8BC                953           BSR.W    PSTRING
000017DC  6100 F8A8                954           BSR.W    NEWLINE
000017E0  49F9 00001E3F            955           LEA.L    MEMHELP,A4
000017E6  6100 F8AE                956           BSR.W    PSTRING
000017EA  6100 F89A                957           BSR.W    NEWLINE
000017EE  49F9 00001E8C            958           LEA.L    LOADHELP,A4
000017F4  6100 F8A0                959           BSR.W    PSTRING
000017F8  6100 F88C                960           BSR.W    NEWLINE
000017FC  49F9 00001ED6            961           LEA.L    TVHELP,A4
00001802  6100 F892                962           BSR.W    PSTRING
00001806  4E75                     963           RTS
00001808                           964  *      
00001808                           965  *************************************************************************
00001808  B83C 0003                966  LOGIN    CMP.B    #3,D4
0000180C  6700 00C2                967           BEQ      QUIT
00001810  49F9 00001F43            968           LEA.L    LOGINM1,A4
00001816  6100 F87E                969           BSR.W    PSTRING           
0000181A  6100 F86A                970           BSR.W    NEWLINE
0000181E  6100 F88C                971           BSR      GETLINE
00001822  49F9 00001F35            972           LEA.L    UNAME,A4
00001828  1A19                     973  LOGIN1   MOVE.B   (A1)+,D5
0000182A  BA1C                     974           CMP.B    (A4)+,D5
0000182C  67FA                     975           BEQ      LOGIN1            iterate through checking each char
0000182E  0C21 000D                976           CMP.B    #CR,-(A1)         check for carriage return
00001832  6600 006A                977           BNE      WRONG             if not then wrong input
00001836  0C24 0000                978           CMP.B    #NUL,-(A4)        check for end of stored string
0000183A  6600 0062                979           BNE      WRONG             if not then wrong input
0000183E  49F9 00001F78            980           LEA.L    USRSUC,A4         print success
00001844  6100 F850                981           BSR.W    PSTRING
00001848  6100 F83C                982           BSR.W    NEWLINE
0000184C  49F9 00001F54            983           LEA.L    LOGINM2,A4
00001852  6100 F842                984           BSR.W    PSTRING
00001856  6100 F82E                985           BSR.W    NEWLINE
0000185A  1C3C 0001                986           MOVE.B   #1,D6
0000185E  6100 F84C                987           BSR.W    GETLINE
00001862  1C3C 0000                988           MOVE.B   #0,D6
00001866  49F9 00001F3A            989           LEA.L    PWORD,A4
0000186C  1A19                     990  LOGIN2   MOVE.B   (A1)+,D5
0000186E  BA1C                     991           CMP.B    (A4)+,D5
00001870  67FA                     992           BEQ      LOGIN2            iterate through checking each char
00001872  0C21 000D                993           CMP.B    #CR,-(A1)          check for carriage return
00001876  6600 0026                994           BNE      WRONG             if not then wrong input
0000187A  0C24 0000                995           CMP.B    #NUL,-(A4)            check for end of stored string
0000187E  6600 0032                996           BNE      WRONGPW             if not then wrong input
00001882  49F9 00001F9C            997           LEA.L    PWSUC,A4
00001888  6000 F80C                998           BRA      PSTRING
0000188C  49F9 00001F43            999           LEA.L    LOGINM1,A4
00001892  6100 F802               1000           BSR.W    PSTRING           print success
00001896  6100 F7EE               1001           BSR.W    NEWLINE
0000189A  6000 F7DA               1002           BRA      WARM
0000189E                          1003  
0000189E  49F9 00001F65           1004  WRONG    LEA.L    USRERR,A4   
000018A4  6100 F7F0               1005           BSR.W    PSTRING
000018A8  6100 F7DC               1006           BSR.W    NEWLINE
000018AC  5204                    1007           ADD.B    #1,D4
000018AE  6000 FF58               1008           BRA      LOGIN
000018B2                          1009  
000018B2  49F9 00001F89           1010  WRONGPW  LEA.L    PWERR,A4   
000018B8  6100 F7DC               1011           BSR.W    PSTRING
000018BC  6100 F7C8               1012           BSR.W    NEWLINE
000018C0  5204                    1013           ADD.B    #1,D4
000018C2  6000 FF44               1014           BRA      LOGIN
000018C6                          1015  
000018C6  49F9 00001F78           1016  UPASS    LEA.L    USRSUC,A4
000018CC  6000 F7C8               1017           BRA      PSTRING  
000018D0                          1018  
000018D0  4EF8 18D0               1019  QUIT     JMP      QUIT
000018D4                          1020  *
000018D4                          1021  ************************************************************************* 
000018D4  2878 07D4               1022  TV       MOVE.L   MIN_RAM,A4
000018D8  1C3C 0000               1023           MOVE.B   #0,D6
000018DC  323C 0000               1024  LOOPRAM  MOVE.W   #0,D1
000018E0  3881                    1025           MOVE.W   D1,(A4)
000018E2  49EC 0002               1026           LEA.L    2(A4),A4          Point to next address to display
000018E6  B9F8 07D8               1027           CMP.L    MAX_RAM,A4
000018EA  66F0                    1028           BNE      LOOPRAM
000018EC  2878 07D4               1029           MOVE.L   MIN_RAM,A4
000018F0  3214                    1030  CHECK1   MOVE.W   (A4),D1
000018F2  B27C 0000               1031           CMP.W    #0,D1
000018F6  6600 0042               1032           BNE      MEMFAIL
000018FA  49EC 0002               1033  CHECK2   LEA.L    2(A4),A4          Point to next address to read
000018FE  B9F8 07D8               1034           CMP.L    MAX_RAM,A4
00001902  66EC                    1035           BNE      CHECK1
00001904  2878 07D4               1036           MOVE.L   MIN_RAM,A4
00001908  323C FFFF               1037  LOOPRAM1 MOVE.W   #65535,D1
0000190C  3881                    1038           MOVE.W   D1,(A4)
0000190E  49EC 0002               1039           LEA.L    2(A4),A4          Point to next address to display
00001912  B9F8 07D8               1040           CMP.L    MAX_RAM,A4
00001916  66F0                    1041           BNE      LOOPRAM1
00001918  2878 07D4               1042           MOVE.L   MIN_RAM,A4
0000191C  3214                    1043  CHECK3   MOVE.W   (A4),D1
0000191E  B27C FFFF               1044           CMP.W    #65535,D1
00001922  6600 0032               1045           BNE      MEMFAIL2
00001926  49EC 0002               1046  CHECK4   LEA.L    2(A4),A4          Point to next address to read
0000192A  B9F8 07D8               1047           CMP.L    MAX_RAM,A4
0000192E  66EC                    1048           BNE      CHECK3
00001930  BC3C 0000               1049           CMP.B    #0,D6
00001934  6700 003C               1050           BEQ      MEMGOOD
00001938  4E75                    1051           RTS
0000193A                          1052  
0000193A  2F0C                    1053  MEMFAIL  MOVE.L  A4,-(A7)          Save A4 
0000193C  7C01                    1054           MOVE.L  #1,D6
0000193E  6100 F746               1055           BSR.W   NEWLINE
00001942  49F9 00001FAD           1056           LEA.L   MEMFMSG,A4
00001948  6100 F74C               1057           BSR.W   PSTRING
0000194C  285F                    1058           MOVE.L  (A7)+,A4          Restore A4
0000194E  200C                    1059           MOVE.L  A4,D0
00001950  6100 F8E6               1060           BSR.W    OUT8X 
00001954  60A4                    1061           BRA     CHECK2
00001956                          1062  
00001956  2F0C                    1063  MEMFAIL2 MOVE.L  A4,-(A7)          Save A4 
00001958  7C01                    1064           MOVE.L  #1,D6
0000195A  6100 F72A               1065           BSR.W   NEWLINE
0000195E  49F9 00001FAD           1066           LEA.L   MEMFMSG,A4
00001964  6100 F730               1067           BSR.W   PSTRING
00001968  285F                    1068           MOVE.L  (A7)+,A4          Restore A4
0000196A  200C                    1069           MOVE.L  A4,D0
0000196C  6100 F8CA               1070           BSR.W    OUT8X 
00001970  60B4                    1071           BRA     CHECK4         
00001972                          1072   
00001972  49F9 00001FBD           1073  MEMGOOD  LEA.L  MEMGMSG,A4
00001978  6100 F71C               1074           BSR.W  PSTRING
0000197C  4E75                    1075           RTS
0000197E                          1076  
0000197E                          1077  *************************************************************************         
0000197E                          1078  * 
0000197E                          1079  *  Exception handling routines 
0000197E                          1080  * 
0000197E  =0000197E               1081  IL_ER   EQU      *                Illegal instruction exception 
0000197E  2F0C                    1082          MOVE.L  A4,-(A7)          Save A4 
00001980  49FA 038C               1083          LEA.L   MES10(PC),A4      Point to heading 
00001984  6100 F720               1084          BSR     HEADING           Print it 
00001988  285F                    1085          MOVE.L  (A7)+,A4          Restore A4 
0000198A  6100 009C               1086          BSR.W   GROUP2            Save registers in display frame 
0000198E  6100 FDC4               1087          BSR     EX_DIS            Display registers saved in frame 
00001992  6000 F6E2               1088          BRA     WARM              Abort from illegal instruction 
00001996                          1089  * 
00001996  =00001996               1090  BUS_ER  EQU     *                 Bus error (group 1) exception 
00001996  2F0C                    1091          MOVE.L  A4,-(A7)          Save A4 
00001998  49FA 0354               1092          LEA.L   MES8(PC),A4       Point to heading 
0000199C  6100 F708               1093          BSR     HEADING           Print it 
000019A0  285F                    1094          MOVE.L  (A7)+,A4          Restore A4 
000019A2  6050                    1095          BRA.S   GROUP1            Deal with group 1 exception 
000019A4                          1096  * 
000019A4  =000019A4               1097  ADD_ER  EQU     *                 Address error (group 1) exception 
000019A4  2F0C                    1098          MOVE.L  A4,-(A7)          Save A4 
000019A6  49FA 0354               1099          LEA.L   MES9(PC),A4       Point to heading 
000019AA  6100 F6FA               1100          BSR     HEADING           Print it 
000019AE  285F                    1101          MOVE.L  (A7)+,A4          Restore A4 
000019B0  6042                    1102          BRA.S   GROUP1            Deal with group 1 exception 
000019B2                          1103  * 
000019B2  =000019B2               1104  DIV0_ER  EQU     *                   Divide By Zero Exception
000019B2  2F0C                    1105          MOVE.L  A4,-(A7)          Save A4 
000019B4  49FA 0385               1106          LEA.L   MES13(PC),A4       Point to heading 
000019B8  6100 F6EC               1107          BSR     HEADING           Print it 
000019BC  285F                    1108          MOVE.L  (A7)+,A4          Restore A4 
000019BE  6034                    1109          BRA.S   GROUP1            Deal with group 1 exception 
000019C0                          1110  *
000019C0  =000019C0               1111  PRIV_ER   EQU     *                 Privilege Violation Exception
000019C0  2F0C                    1112          MOVE.L  A4,-(A7)          Save A4 
000019C2  49FA 038C               1113          LEA.L   MES14(PC),A4      Point to heading 
000019C6  6100 F6DE               1114          BSR     HEADING           Print it 
000019CA  285F                    1115          MOVE.L  (A7)+,A4          Restore A4
000019CC  6100 FD86               1116          BSR     EX_dis
000019D0  6000 F6A4               1117          BRA     WARM
000019D4  601E                    1118          BRA.S   GROUP1            Deal with group 1 exception 
000019D6                          1119  * 
000019D6  =000019D6               1120  BRKPT   EQU     *                   Deal with breakpoint 
000019D6  48E7 FFFE               1121          MOVEM.L D0-D7/A0-A6,-(A7)   Save all registers 
000019DA  6100 0180               1122          BSR     BR_CLR              Clear breakpoints in code 
000019DE  4CDF 7FFF               1123          MOVEM.L (A7)+,D0-D7/A0-A6   Restore registers 
000019E2  6144                    1124          BSR.S   GROUP2            Treat as group 2 exception 
000019E4  49FA 033E               1125          LEA.L   MES11(PC),A4      Point to heading 
000019E8  6100 F6BC               1126          BSR     HEADING           Print it 
000019EC  6100 FD66               1127          BSR     EX_DIS            Display saved registers 
000019F0  6000 F684               1128          BRA     WARM              Return to monitor 
000019F4                          1129  
000019F4                          1130  * 
000019F4                          1131  *       GROUP1 is called by address and bus error exceptions 
000019F4                          1132  *       These are "turned into group 2" exceptions (eg TRAP) 
000019F4                          1133  *       by modifying the stack frame saved by a group 1 exception 
000019F4                          1134  * 
000019F4  48E7 8080               1135  GROUP1  MOVEM.L D0/A0,-(A7)       Save working registers 
000019F8  206F 0012               1136          MOVE.L  18(A7),A0         Get PC from group 1 stack frame 
000019FC  302F 000E               1137          MOVE.W  14(A7),D0         Get instruction from stack frame 
00001A00  B060                    1138          CMP.W   -(A0),D0          Now backtrack to find the "correct PC" 
00001A02  670E                    1139          BEQ.S   GROUP1A           by matching the op-code on the stack 
00001A04  B060                    1140          CMP.W   -(A0),D0          with the code in the region of the 
00001A06  670A                    1141          BEQ.S   GROUP1A           PC on the stack 
00001A08  B060                    1142          CMP.W   -(A0),D0 
00001A0A  6706                    1143          BEQ.S   GROUP1A 
00001A0C  B060                    1144          CMP.W   -(A0),D0 
00001A0E  6702                    1145          BEQ.S   GROUP1A 
00001A10  5588                    1146          SUBQ.L  #2,A0 
00001A12  2F48 0012               1147  GROUP1A MOVE.L  A0,18(A7)          Restore modified PC to stack frame 
00001A16  4CDF 0101               1148          MOVEM.L (A7)+,D0/A0        Restore working registers 
00001A1A  4FEF 0008               1149          LEA.L   8(A7),A7           Adjust stack pointer to group 1 type 
00001A1E  6108                    1150          BSR.S   GROUP2             Now treat as group 1 exception 
00001A20  6100 FD32               1151          BSR     EX_DIS             Display contents of exception frame 
00001A24  6000 F650               1152          BRA     WARM               Exit to monitor - no RTE from group 2 
00001A28                          1153  * 
00001A28  =00001A28               1154  GROUP2  EQU     *                 Deal with group 2 exceptions 
00001A28  48E7 FFFF               1155          MOVEM.L A0-A7/D0-D7,-(A7) Save all registers on the stack 
00001A2C  303C 000E               1156          MOVE.W  #14,D0            Transfer D0 - D7, A0 - A6 from 
00001A30  41EE 045A               1157          LEA.L   TSK_T(A6),A0      the stack to the display frame 
00001A34  20DF                    1158  GROUP2A MOVE.L  (A7)+,(A0)+       Move a register from stack to frame 
00001A36  51C8 FFFC               1159          DBRA    D0,GROUP2A        and repeat until D0-D7/A0-A6 moved 
00001A3A  4E6A                    1160          MOVE.L  USP,A2            Get the user stack pointer and put it 
00001A3C  20CA                    1161          MOVE.L  A2,(A0)+          in the A7 position in the frame 
00001A3E  201F                    1162          MOVE.L  (A7)+,D0          Now transfer the SSP to the frame, 
00001A40  0480 0000000A           1163          SUB.L   #10,D0            remembering to account for the 
00001A46  20C0                    1164          MOVE.L  D0,(A0)+          data pushed on the stack to this point 
00001A48  225F                    1165          MOVE.L  (A7)+,A1          Copy TOS (return address) to A1 
00001A4A  30DF                    1166          MOVE.W  (A7)+,(A0)+       Move SR to display frame 
00001A4C  201F                    1167          MOVE.L  (A7)+,D0          Get PC in D0 
00001A4E  5580                    1168          SUBQ.L  #2,D0             Move back to current instruction 
00001A50  20C0                    1169          MOVE.L  D0,(A0)+          Put adjusted PC in display frame 
00001A52  4ED1                    1170          JMP     (A1)              Return from subroutine 
00001A54                          1171  * 
00001A54                          1172  ************************************************************************* 
00001A54                          1173  * 
00001A54                          1174  *  GO executes a program either from a supplied address or 
00001A54                          1175  *  by using the data in the display frame 
00001A54  6100 F774               1176  GO       BSR     PARAM               Get entry address (if any) 
00001A58  4A07                    1177           TST.B   D7                  Test for error in input 
00001A5A  6708                    1178           BEQ.S   GO1                 If D7 zero then OK 
00001A5C  49FA 032B               1179           LEA.L   ERMES1(PC),A4       Else point to error message, 
00001A60  6000 F634               1180           BRA     PSTRING             print it and return 
00001A64  4A80                    1181  GO1      TST.L   D0                  If no address entered then get 
00001A66  670A                    1182           BEQ.S   GO2                 address from display frame 
00001A68  2D40 04A0               1183           MOVE.L  D0,TSK_T+70(A6)     Else save address in display frame 
00001A6C  3D7C 0700 049E          1184           MOVE.W  #$0700,TSK_T+68(A6) Store dummy status in frame 
00001A72  6006                    1185  GO2      BRA.S   RESTORE             Restore volatile environment and go 
00001A74                          1186  * 
00001A74  6100 007A               1187  GB       BSR     BR_SET              Same as go but presets breakpoints 
00001A78  60DA                    1188           BRA.S   GO                  Execute program 
00001A7A                          1189  * 
00001A7A                          1190  *        RESTORE moves the volatile environment from the display 
00001A7A                          1191  *        frame and transfers it to the 68000's registers. This 
00001A7A                          1192  *        re-runs a program suspended after an exception 
00001A7A                          1193  * 
00001A7A  47EE 045A               1194  RESTORE  LEA.L   TSK_T(A6),A3        A3 points to display frame 
00001A7E  47EB 004A               1195           LEA.L   74(A3),A3           A3 now points to end of frame + 4 
00001A82  4FEF 0004               1196           LEA.L   4(A7),A7            Remove return address from stack 
00001A86  303C 0024               1197           MOVE.W  #36,D0              Counter for 37 words to be moved 
00001A8A  3F23                    1198  REST1    MOVE.W  -(A3),-(A7)         Move word from display frame to stack 
00001A8C  51C8 FFFC               1199           DBRA    D0,REST1            Repeat until entire frame moved 
00001A90  4CDF 00FF               1200           MOVEM.L (A7)+,D0-D7         Restore old data registers from stack 
00001A94  4CDF 7F00               1201           MOVEM.L (A7)+,A0-A6         Restore old address registers 
00001A98  4FEF 0008               1202           LEA.L   8(A7),A7            Except SSP/USP - so adjust stack 
00001A9C  4E73                    1203           RTE                         Return from exception to run program 
00001A9E                          1204  * 
00001A9E  =00001A9E               1205  TRACE    EQU     *                   TRACE exception (rudimentary version) 
00001A9E  287A 0292               1206           MOVE.L  MES12(PC),A4        Point to heading 
00001AA2  6100 F602               1207           BSR     HEADING             Print it 
00001AA6  6100 FF4C               1208           BSR     GROUP1              Save volatile environment 
00001AAA  6100 FCA8               1209           BSR     EX_DIS              Display it 
00001AAE  6000 F5C6               1210           BRA     WARM                Return to monitor 
00001AB2                          1211  * 
00001AB2                          1212  ************************************************************************* 
00001AB2                          1213  *  Breakpoint routines: BR_GET gets the address of a breakpoint and 
00001AB2                          1214  *  puts it in the breakpoint table. It does not plant it in the code. 
00001AB2                          1215  *  BR_SET plants all breakpoints in the code. NOBR removes one or all 
00001AB2                          1216  *  breakpoints from the table. KILL removes breakpoints from the code. 
00001AB2                          1217  * 
00001AB2  6100 F716               1218  BR_GET   BSR     PARAM               Get breakpoint address in table 
00001AB6  4A07                    1219           TST.B   D7                  Test for input error 
00001AB8  6708                    1220           BEQ.S   BR_GET1             If no error then continue 
00001ABA  49FA 02CD               1221           LEA.L   ERMES1(PC),A4       Else display error 
00001ABE  6000 F5D6               1222           BRA     PSTRING             and return 
00001AC2  47EE 04A4               1223  BR_GET1  LEA.L   BP_TAB(A6),A3       A6 points to breakpoint table 
00001AC6  2A40                    1224           MOVE.L  D0,A5               Save new BP address in A5 
00001AC8  2C00                    1225           MOVE.L  D0,D6               and in D6 because D0 gets corrupted 
00001ACA  3A3C 0007               1226           MOVE.W  #7,D5               Eight entries to test 
00001ACE  201B                    1227  BR_GET2  MOVE.L  (A3)+,D0            Read entry from breakpoint table 
00001AD0  660C                    1228           BNE.S   BR_GET3             If not zero display existing BP 
00001AD2  4A86                    1229           TST.L   D6                  Only store a non-zero breakpoint 
00001AD4  6710                    1230           BEQ.S   BR_GET4 
00001AD6  274D FFFC               1231           MOVE.L  A5,-4(A3)           Store new breakpoint in table 
00001ADA  3695                    1232           MOVE.W  (A5),(A3)           Save code at BP address in table 
00001ADC  4286                    1233           CLR.L   D6                  Clear D6 to avoid repetition 
00001ADE  6100 F758               1234  BR_GET3  BSR     OUT8X               Display this breakpoint 
00001AE2  6100 F5A2               1235           BSR     NEWLINE 
00001AE6  47EB 0002               1236  BR_GET4  LEA.L   2(A3),A3            Step past stored op-code 
00001AEA  51CD FFE2               1237           DBRA    D5,BR_GET2          Repeat until all entries tested 
00001AEE  4E75                    1238           RTS                         Return 
00001AF0                          1239  * 
00001AF0  =00001AF0               1240  BR_SET   EQU     *                   Plant any breakpoints in user code 
00001AF0  41EE 04A4               1241           LEA.L   BP_TAB(A6),A0       A0 points to BP table 
00001AF4  45EE 04A0               1242           LEA.L   TSK_T+70(A6),A2     A2 points to PC in display frame 
00001AF8  2452                    1243           MOVE.L  (A2),A2             Now A2 contains value of PC 
00001AFA  303C 0007               1244           MOVE.W  #7,D0               Up to eight entries to plant 
00001AFE  2218                    1245  BR_SET1  MOVE.L  (A0)+,D1            Read breakpoint address from table 
00001B00  670A                    1246           BEQ.S   BR_SET2             If zero then skip planting 
00001B02  B28A                    1247           CMP.L   A2,D1               Don't want to plant BP at current PC 
00001B04  6706                    1248           BEQ.S   BR_SET2             location, so skip planting if same 
00001B06  2241                    1249           MOVE.L  D1,A1               Transfer BP address to address reg 
00001B08  32BC 4E4E               1250           MOVE.W  #TRAP_16,(A1)       Plant op-code for TRAP #14 in code 
00001B0C  41E8 0002               1251  BR_SET2  LEA.L   2(A0),A0            Skip past op-code field in table 
00001B10  51C8 FFEC               1252           DBRA    D0,BR_SET1          Repeat until all entries tested 
00001B14  4E75                    1253           RTS 
00001B16                          1254  * 
00001B16  =00001B16               1255  NOBR     EQU     *                   Clear one or all breakpoints 
00001B16  6100 F6B2               1256           BSR     PARAM               Get BP address (if any) 
00001B1A  4A07                    1257           TST.B   D7                  Test for input error 
00001B1C  6708                    1258           BEQ.S   NOBR1               If no error then skip abort 
00001B1E  49FA 0269               1259           LEA.L   ERMES1(PC),A4       Point to error message 
00001B22  6000 F572               1260           BRA     PSTRING             Display it and return 
00001B26  4A80                    1261  NOBR1    TST.L   D0                  Test for null address (clear all) 
00001B28  6720                    1262           BEQ.S   NOBR4               If no address then clear all entries 
00001B2A  2240                    1263           MOVE.L  D0,A1               Else just clear breakpoint in A1 
00001B2C  41EE 04A4               1264           LEA.L   BP_TAB(A6),A0       A0 points to BP table 
00001B30  303C 0007               1265           MOVE.W  #7,D0               Up to eight entries to test 
00001B34  2218                    1266  NOBR2    MOVE.L  (A0)+,D1            Get entry and 
00001B36  41E8 0002               1267           LEA.L   2(A0),A0            skip past op-code field 
00001B3A  B289                    1268           CMP.L   A1,D1               Is this the one? 
00001B3C  6706                    1269           BEQ.S   NOBR3               If so go and clear entry 
00001B3E  51C8 FFF4               1270           DBRA    D0,NOBR2            Repeat until all tested 
00001B42  4E75                    1271           RTS 
00001B44  42A8 FFFA               1272  NOBR3    CLR.L   -6(A0)              Clear address in BP table 
00001B48  4E75                    1273           RTS 
00001B4A  41EE 04A4               1274  NOBR4    LEA.L   BP_TAB(A6),A0       Clear all 8 entries in BP table 
00001B4E  303C 0007               1275           MOVE.W  #7,D0               Eight entries to clear 
00001B52  4298                    1276  NOBR5    CLR.L   (A0)+               Clear breakpoint address 
00001B54  4258                    1277           CLR.W   (A0)+               Clear op-code field 
00001B56  51C8 FFFA               1278           DBRA    D0,NOBR5            Repeat until all done 
00001B5A  4E75                    1279           RTS 
00001B5C                          1280  * 
00001B5C  =00001B5C               1281  BR_CLR   EQU     *                   Remove breakpoints from code 
00001B5C  41EE 04A4               1282           LEA.L   BP_TAB(A6),A0       A0 points to breakpoint table 
00001B60  303C 0007               1283           MOVE.W  #7,D0               Up to eight entries to clear 
00001B64  2218                    1284  BR_CLR1  MOVE.L  (A0)+,D1            Get address of BP in D1 
00001B66  2241                    1285           MOVE.L  D1,A1               and put copy in A1 
00001B68  4A81                    1286           TST.L   D1                  Test this breakpoint 
00001B6A  6702                    1287           BEQ.S   BR_CLR2             If zero then skip BP clearing 
00001B6C  3290                    1288           MOVE.W  (A0),(A1)           Else restore op-code 
00001B6E  41E8 0002               1289  BR_CLR2  LEA.L   2(A0),A0            Skip past op-code field 
00001B72  51C8 FFF0               1290           DBRA    D0,BR_CLR1          Repeat until all tested 
00001B76  4E75                    1291           RTS 
00001B78                          1292  * 
00001B78                          1293  *  REG_MOD modifies a register in the display frame. The command 
00001B78                          1294  *  format is REG <reg> <value>. E.g. REG D3 1200 
00001B78                          1295  * 
00001B78  4281                    1296  REG_MOD  CLR.L   D1                  D1 to hold name of register 
00001B7A  41EE 0444               1297           LEA.L   BUFFPT(A6),A0       A0 contains address of buffer pointer 
00001B7E  2050                    1298           MOVE.L  (A0),A0             A0 now points to next char in buffer 
00001B80  1218                    1299           MOVE.B  (A0)+,D1            Put first char of name in D1 
00001B82  E159                    1300           ROL.W   #8,D1               Move char one place left 
00001B84  1218                    1301           MOVE.B  (A0)+,D1            Get second char in D1 
00001B86  41E8 0001               1302           LEA.L   1(A0),A0            Move pointer past space in buffer 
00001B8A  2D48 0444               1303           MOVE.L  A0,BUFFPT(A6)       Update buffer pointer 
00001B8E  4282                    1304           CLR.L   D2                  D2 is the character pair counter 
00001B90  41FA 01CE               1305           LEA.L   REGNAME(PC),A0      A0 points to string of character pairs 
00001B94  43D0                    1306           LEA.L   (A0),A1             A1 also points to string 
00001B96  B258                    1307  REG_MD1  CMP.W   (A0)+,D1            Compare a char pair with input 
00001B98  6712                    1308           BEQ.S   REG_MD2             If match then exit loop 
00001B9A  5282                    1309           ADD.L   #1,D2               Else increment match counter 
00001B9C  B4BC 00000013           1310           CMP.L   #19,D2              Test for end of loop 
00001BA2  66F2                    1311           BNE     REG_MD1             Continue until all pairs matched 
00001BA4  49FA 01E3               1312           LEA.L   ERMES1(PC),A4       If here then error 
00001BA8  6000 F4EC               1313           BRA     PSTRING             Display error and return 
00001BAC  43EE 045A               1314  REG_MD2  LEA.L   TSK_T(A6),A1        A1 points to display frame 
00001BB0  E582                    1315           ASL.L   #2,D2               Multiply offset by 4 (4 bytes/entry) 
00001BB2  B4BC 00000048           1316           CMP.L   #72,D2              Test for address of PC 
00001BB8  6602                    1317           BNE.S   REG_MD3             If not PC then all is OK 
00001BBA  5582                    1318           SUB.L   #2,D2               else dec PC pointer as Sr is a word 
00001BBC  45F1 2000               1319  REG_MD3  LEA.L   (A1,D2),A2          Calculate address of entry in disptable 
00001BC0  2012                    1320           MOVE.L  (A2),D0             Get old contents 
00001BC2  6100 F674               1321           BSR     OUT8X               Display them 
00001BC6  6100 F4BE               1322           BSR     NEWLINE 
00001BCA  6100 F5FE               1323           BSR     PARAM               Get new data 
00001BCE  4A07                    1324           TST.B   D7                  Test for input error 
00001BD0  6708                    1325           BEQ.S   REG_MD4             If no error then go and store data 
00001BD2  49FA 01B5               1326           LEA.L   ERMES1(PC),A4       Else point to error message 
00001BD6  6000 F4BE               1327           BRA     PSTRING             print it and return 
00001BDA  B4BC 00000044           1328  REG_MD4  CMP.L   #68,D2              If this address is the SR then 
00001BE0  6704                    1329           BEQ.S   REG_MD5             we have only a word to store 
00001BE2  2480                    1330           MOVE.L  D0,(A2)             Else store new data in display frame 
00001BE4  4E75                    1331           RTS 
00001BE6  3480                    1332  REG_MD5  MOVE.W  D0,(A2)             Store SR (one word) 
00001BE8  4E75                    1333           RTS 
00001BEA                          1334  * 
00001BEA                          1335  ************************************************************************* 
00001BEA                          1336  * 
00001BEA  =00001BEA               1337  X_UN    EQU     *                 Uninitialized exception vector routine 
00001BEA  49FA 0203               1338          LEA.L   ERMES6(PC),A4     Point to error message 
00001BEE  6100 F4A6               1339          BSR     PSTRING           Display it 
00001BF2  6100 FB60               1340          BSR     EX_DIS            Display registers 
00001BF6  6000 F47E               1341          BRA     WARM              Abort 
00001BFA                          1342  * 
00001BFA                          1343  ************************************************************************* 
00001BFA                          1344  * 
00001BFA                          1345  *  All strings and other fixed parameters here 
00001BFA                          1346  * 
00001BFA= 54 53 42 55 47 20 ...   1347  BANNER   DC.B     'TSBUG 2 Version 23.07.86',0,0
00001C14= 4D 6F 64 69 66 69 ...   1348  MODIFY    DC.B   'Modified by Eugene A. Rockey Jr. Jan.05.2010',0,0
00001C42= 66 6F 72 20 75 73 ...   1349  WHY      DC.B     'for use with the M68000 Minimal Computer Configuration',0,0 
00001C7A= 55 6E 69 76 65 72 ...   1350  WHERE    DC.B     'University of Louisville',0,0
00001C94= 0D 0A 54 53 32 4D ...   1351  CRLF     DC.B     CR,LF,'TS2MON >',0 
00001C9F= 0D 0A 53 31 00 00       1352  HEADER   DC.B     CR,LF,'S','1',0,0 
00001CA5= 53 39 20 20 00 00       1353  TAIL     DC.B     'S9  ',0,0 
00001CAB= 20 53 52 20 20 3D ...   1354  MES1     DC.B     ' SR  =  ',0 
00001CB4= 20 50 43 20 20 3D ...   1355  MES2     DC.B     ' PC  =  ',0 
00001CBD= 20 53 53 20 20 3D ...   1356  MES2A    DC.B     ' SS  =  ',0 
00001CC6= 20 20 44 61 74 61 ...   1357  MES3     DC.B     '  Data reg       Address reg',0,0 
00001CE4= 20 20 20 20 20 20 ...   1358  MES4     DC.B     '        ',0,0 
00001CEE= 42 75 73 20 65 72 ...   1359  MES8     DC.B     'Bus error   ',0,0 
00001CFC= 41 64 64 72 65 73 ...   1360  MES9     DC.B     'Address error   ',0,0 
00001D0E= 49 6C 6C 65 67 61 ...   1361  MES10    DC.B     'Illegal instruction ',0,0 
00001D24= 42 72 65 61 6B 70 ...   1362  MES11    DC.B     'Breakpoint  ',0,0 
00001D32= 54 72 61 63 65 20 ...   1363  MES12    DC.B     'Trace   ',0 
00001D3B= 44 69 76 69 64 65 ...   1364  MES13    DC.B     'Divide by zero error', 0
00001D50= 50 72 69 76 69 6C ...   1365  MES14    DC.B     'Privilege error', 0
00001D60= 44 30 44 31 44 32 ...   1366  REGNAME  DC.B     'D0D1D2D3D4D5D6D7' 
00001D70= 41 30 41 31 41 32 ...   1367           DC.B     'A0A1A2A3A4A5A6A7' 
00001D80= 53 53 53 52             1368           DC.B     'SSSR' 
00001D84= 50 43 20 20 00          1369           DC.B     'PC  ',0 
00001D89= 4E 6F 6E 2D 76 61 ...   1370  ERMES1   DC.B     'Non-valid hexadecimal input  ',0 
00001DA7= 49 6E 76 61 6C 69 ...   1371  ERMES2   DC.B     'Invalid command  ',0 
00001DB9= 4C 6F 61 64 69 6E ...   1372  ERMES3   DC.B     'Loading error',0 
00001DC7= 54 61 62 6C 65 20 ...   1373  ERMES4   DC.B     'Table full  ',0,0 
00001DD5= 42 72 65 61 6B 70 ...   1374  ERMES5   DC.B     'Breakpoint not active   ',0,0 
00001DEF= 55 6E 69 6E 69 74 ...   1375  ERMES6   DC.B     'Uninitialized exception ',0,0 
00001E09= 4A 55 4D 50 20 3C ...   1376  JUMPHELP DC.B     'JUMP <address> causes execution to begin at <address>',0   
00001E3F= 4D 45 4D 4F 52 59 ...   1377  MEMHELP  DC.B     'MEMORY <address> examines contents of address> and allows them to be changed', 0   
00001E8C= 4C 4F 41 44 20 3C ...   1378  LOADHELP DC.B     'LOAD <string> loads S1/S2 records from the host. <string> is sent to host', 0
00001ED6= 54 56 20 63 68 65 ...   1379  TVHELP   DC.B     'TV checks all RAM addresses from $4000 to $40FE. Reports corrupt memory addresses', 0
00001F28= 20 52 61 6E 67 65 ...   1380  ERMES7   DC.B     ' Range error',0
00001F35= 55 53 45 52 00          1381  UNAME    DC.B     'USER', 0
00001F3A= 50 41 53 53 57 4F ...   1382  PWORD    DC.B     'PASSWORD',0
00001F43= 45 6E 74 65 72 20 ...   1383  LOGINM1  DC.B     'Enter username: ', 0
00001F54= 45 6E 74 65 72 20 ...   1384  LOGINM2  DC.B     'Enter password: ', 0
00001F65= 49 6E 63 6F 72 72 ...   1385  USRERR   DC.B     'Incorrect username', 0
00001F78= 43 6F 72 72 65 63 ...   1386  USRSUC   DC.B     'Correct Username', 0
00001F89= 49 6E 63 6F 72 72 ...   1387  PWERR   DC.B     'Incorrect password', 0
00001F9C= 43 6F 72 72 65 63 ...   1388  PWSUC    DC.B     'Correct Password', 0
00001FAD= 4D 45 4D 4F 52 59 ...   1389  MEMFMSG  DC.B     'MEMORY BAD AT: ',0
00001FBD= 41 4C 4C 20 52 41 ...   1390  MEMGMSG  DC.B      'ALL RAM GOOD', 0
00001FCA= 48 45 4C 4C 4F 00       1391  HELLO    DC.B      'HELLO',0
00001FD0                          1392   
00001FD0                          1393  * 
00001FD0                          1394  *  COMTAB is the built-in command table. All entries are made up of 
00001FD0                          1395  *         a string length + number of characters to match + the string 
00001FD0                          1396  *         plus the address of the command relative to COMTAB 
00001FD0                          1397  * 
00002000                          1398           ORG      $2000
00002000= 04 04                   1399  COMTAB   DC.B     4,4              JUMP <address> causes execution to 
00002002= 4A 55 4D 50             1400           DC.B     'JUMP'           begin at <address> 
00002006= FFFFF240                1401           DC.L     JUMP-COMTAB                                           
0000200A= 08 03                   1402           DC.B     8,3              MEMORY <address> examines contents of 
0000200C= 4D 45 4D 4F 52 59 ...   1403           DC.B     'MEMORY  '       <address> and allows them to be changed 
00002014= FFFFF256                1404           DC.L     MEMORY-COMTAB 
00002018= 04 02                   1405           DC.B     4,2              LOAD <string> loads S1/S2 records 
0000201A= 4C 4F 41 44             1406           DC.B     'LOAD'           from the host. <string> is sent to host 
0000201E= FFFFF2B6                1407           DC.L     LOAD-COMTAB 
00002022= 04 04                   1408           DC.B    4,4               HELP 
00002024= 48 45 4C 50             1409           DC.B    'HELP'            
00002028= FFFFF7D2                1410           DC.L    HELP-COMTAB      
0000202C= 02 02                   1411           DC.B    2,2
0000202E= 54 56                   1412           DC.B    'TV'
00002030= FFFFF8D4                1413           DC.L    TV-COMTAB
00002034= 00 00                   1414           DC.B    0,0 
00002036                          1415  * 
00002036                          1416  ************************************************************************* 
00002036                          1417  * 
00002036                          1418  *  This is a list of the information needed to setup the DCBs 
00002036                          1419  * 
00002036  =00002036               1420  DCB_LST  EQU     * 
00002036= 43 4F 4E 5F 49 4E ...   1421  DCB1     DC.B    'CON_IN  '          Device name (8 bytes) 
0000203E= 000014E4 00008001       1422           DC.L    CON_IN,ACIA_1       Address of driver routine, device 
00002046= 0002                    1423           DC.W    2                   Number of words in parameter field 
00002048= 43 4F 4E 5F 4F 55 ...   1424  DCB2     DC.B    'CON_OUT ' 
00002050= 000014FA 00008001       1425           DC.L    CON_OUT,ACIA_1 
00002058= 0002                    1426           DC.W    2 
0000205A= 41 55 58 5F 49 4E ...   1427  DCB3     DC.B    'AUX_IN  ' 
00002062= 00001510 00008001       1428           DC.L    AUX_IN,ACIA_2 
0000206A= 0002                    1429           DC.W    2 
0000206C= 41 55 58 5F 4F 55 ...   1430  DCB4     DC.B    'AUX_OUT ' 
00002074= 00001522 00008001       1431           DC.L    AUX_OUT,ACIA_2 
0000207C= 0002                    1432           DC.W    2 
0000207E= 42 55 46 46 5F 49 ...   1433  DCB5     DC.B    'BUFF_IN ' 
00002086= 00001578 000006D4       1434           DC.L    BUFF_IN,BUFFER 
0000208E= 0002                    1435           DC.W    2 
00002090= 42 55 46 46 5F 4F ...   1436  DCB6     DC.B    'BUFF_OUT' 
00002098= 00001584 000006D4       1437           DC.L    BUFF_OT,BUFFER 
000020A0= 0002                    1438           DC.W    2 
000020A2                          1439  * 
000020A2                          1440  ************************************************************************* 
000020A2                          1441  * 
000020A2                          1442  *  DCB structure 
000020A2                          1443  * 
000020A2                          1444  *              ----------------------- 
000020A2                          1445  *       0 ->   | DCB  name           | 
000020A2                          1446  *              |---------------------| 
000020A2                          1447  *       8 ->   | Device driver       | 
000020A2                          1448  *              |---------------------| 
000020A2                          1449  *      12 ->   | Device address      | 
000020A2                          1450  *              |---------------------| 
000020A2                          1451  *      16 ->   |Size of param block  | 
000020A2                          1452  *              |---------------------| --- 
000020A2                          1453  *      18 ->   |      Status         |   | 
000020A2                          1454  *              | logical  | physical |   | S 
000020A2                          1455  *              |---------------------|   | 
000020A2                          1456  *              .                     .   . 
000020A2                          1457  *              |---------------------| --- 
000020A2                          1458  *    18+S ->   | Pointer to next DCB | 
000020A2                          1459  * 
000020A2                          1460           END RESET 

1 error detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ACIA_1              8001
ACIA_2              8001
ADD_0               15DE
ADD_ER              19A4
ADR_DAT             1294
AUX_IN              1510
AUX_IN1             1516
AUX_OT1             1528
AUX_OUT             1522
BANNER              1BFA
BP_TAB              4A4
BRKPT               19D6
BR_CLR              1B5C
BR_CLR1             1B64
BR_CLR2             1B6E
BR_GET              1AB2
BR_GET1             1AC2
BR_GET2             1ACE
BR_GET3             1ADE
BR_GET4             1AE6
BR_SET              1AF0
BR_SET1             1AFE
BR_SET2             1B0C
BS                  8
BUFFEND             443
BUFFER              6D4
BUFFPT              444
BUFF_IN             1578
BUFF_OT             1584
BUS_ER              1996
BYTE                11AE
CHECK1              18F0
CHECK2              18FA
CHECK3              191C
CHECK4              1926
CN_IVEC             452
CN_OVEC             456
COMTAB              2000
CON_IN              14E4
CON_OUT             14FA
CR                  D
CRLF                1C94
CTRL_A              1
DATA                4800
DCB1                2036
DCB2                2048
DCB3                205A
DCB4                206C
DCB5                207E
DCB6                2090
DCB_LST             2036
DELAY               1432
DELAY1              143C
DIV0_ER             19B2
DIVNEG              1622
DIV_0               1608
DUMP                138A
DUMP1               139A
DUMP2               13A6
DUMP3               13BC
DUMP4               13D0
DUMP5               13DE
DUMP6               13F8
DUMP7               141C
ECHO                44C
ERMES1              1D89
ERMES2              1DA7
ERMES3              1DB9
ERMES4              1DC7
ERMES5              1DD5
ERMES6              1DEF
ERMES7              1F28
ESC                 1B
EXEC1               1136
EXEC2               1146
EXECUTE             1124
EX_D1               1766
EX_DIS              1754
FIRST               4D4
FOO1                1654
FOO10               16C0
FOO11               16CC
FOO12               16D8
FOO13               16E4
FOO14               16F0
FOO15               16FC
FOO16               1708
FOO17               1714
FOO18               1720
FOO19               172C
FOO2                1660
FOO20               1738
FOO21               1744
FOO3                166C
FOO4                1678
FOO5                1684
FOO6                1690
FOO7                169C
FOO8                16A8
FOO9                16B4
GB                  1A74
GETCH2              1558
GETCH3              1560
GETCHAR             1534
GETLINE             10AC
GETLN2              10B6
GETLN3              10D0
GETLN4              10DA
GETLN5              10DE
GO                  1A54
GO1                 1A64
GO2                 1A72
GROUP1              19F4
GROUP1A             1A12
GROUP2              1A28
GROUP2A             1A34
HEADER              1C9F
HEADING             10A6
HELLO               1FCA
HELP                17D2
HEX                 1190
HEX_OK              11AC
IL_ER               197E
IO_OPEN             1592
IO_REQ              14D2
JUMP                1240
JUMP1               124E
JUMPHELP            1E09
LF                  A
LNBUFF              404
LOAD                12B6
LOAD1               12E2
LOAD2               12F2
LOAD3               130C
LOAD4               1326
LOAD5               1334
LOAD6               1336
LOAD6A              135A
LOAD7               136C
LOAD8               1382
LOADHELP            1E8C
LOGIN               1808
LOGIN1              1828
LOGIN2              186C
LOGINM1             1F43
LOGINM2             1F54
LONGWD              11C4
LOOPRAM             18DC
LOOPRAM1            1908
MAXCHR              40
MAX_RAM             7D8
MEM1                1260
MEM2                127E
MEM3                1292
MEMFAIL             193A
MEMFAIL2            1956
MEMFMSG             1FAD
MEMGMSG             1FBD
MEMGOOD             1972
MEMHELP             1E3F
MEMORY              1256
MES1                1CAB
MES10               1D0E
MES11               1D24
MES12               1D32
MES13               1D3B
MES14               1D50
MES2                1CB4
MES2A               1CBD
MES3                1CC6
MES4                1CE4
MES8                1CEE
MES9                1CFC
MIN_RAM             7D4
MODIFY              1C14
MULNEG              1638
MUL_0               15FA
NEWLINE             1086
NOBR                1B16
NOBR1               1B26
NOBR2               1B34
NOBR3               1B44
NOBR4               1B4A
NOBR5               1B52
NOT_HEX             11A8
NO_EXT              1054
NUL                 0
OPEN1               159A
OPEN2               15A2
OPEN3               15B0
OPEN4               15C6
OUT1X               120E
OUT1X1              1220
OUT2X               1228
OUT4X               1230
OUT8X               1238
PARAM               11CA
PARAM1              11D2
PARAM3              11F6
PARAM4              11FA
PARAM5              1206
PARAM6              120A
PARAMTR             448
PRIV_ER             19C0
PS1                 1098
PS2                 10A2
PSPACE              12A8
PSTRING             1096
PUTCHAR             1564
PWERR               1F89
PWORD               1F3A
PWSUC               1F9C
QUIT                18D0
RANGE               1422
REGNAME             1D60
REG_MD1             1B96
REG_MD2             1BAC
REG_MD3             1BBC
REG_MD4             1BDA
REG_MD5             1BE6
REG_MOD             1B78
RESET               1000
REST1               1A8A
RESTORE             1A7A
SEARCH              1150
SETNEG              1628
SET_DCB             1488
SPACE               20
SRCH2               116A
SRCH3               116E
SRCH4               1176
SRCH6               1180
SRCH7               118A
STACK               4400
ST_DCB1             1498
ST_DCB2             149C
SUB_0               15EC
TAIL                1CA5
TIDY                10E2
TIDY1               10E8
TIDY2               10F4
TIDY3               10FE
TIDY4               1108
TIDY5               1112
TIDY6               111E
TM                  1446
TM1                 1452
TRACE               1A9E
TRAP_0              1648
TRAP_14             1746
TRAP_15             174E
TRAP_16             4E4E
TSK_T               45A
TV                  18D4
TVHELP              1ED6
UNAME               1F35
UPASS               18C6
USRERR              1F65
USRSUC              1F78
UTAB                44E
U_CASE              44D
WAIT                57
WARM                1076
WHERE               1C7A
WHY                 1C42
WORD                11BE
WRONG               189E
WRONGPW             18B2
X_BASE              4000
X_SET               15CC
X_SET2              15D4
X_UN                1BEA
