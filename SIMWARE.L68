00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.15.04
Created On: 9/22/15 10:57:12 PM

00000000                             1  *        TSBUG2 - 68000 monitor - version of 05 January 2010 
00000000                             2  
00000000                             3      ORG      $0
00000000= 00004400 00001000          4           DC.L     STACK,RESET
00000008                             5  *                                   Symbol equates 
00000008  =00000008                  6  BS       EQU      $08               Back_space 
00000008  =0000000D                  7  CR       EQU      $0D               Carriage_return 
00000008  =00000000                  8  NUL      EQU      $00               NUL character
00000008  =0000000A                  9  LF       EQU      $0A               Line_feed 
00000008  =00000020                 10  SPACE    EQU      $20               Space 
00000008  =00000057                 11  WAIT     EQU      'W'               Wait character (to suspend output) 
00000008  =0000001B                 12  ESC      EQU      $1B               ASCII escape character (used by TM) 
00000008  =00000001                 13  CTRL_A   EQU      $01               Control_A forces return to monitor 
00000008                            14  *                                   Device addresses 
00000008  =00004400                 15  STACK    EQU      $4400             Stack_pointer
00000008  =00008001                 16  ACIA_1   EQU      $8001             Console ACIA control 
00000008  =00008001                 17  ACIA_2   EQU      ACIA_1            Auxilary ACIA control 
00000008  =00004000                 18  X_BASE   EQU      $4000             Start of exception vector table 
00000008  =00004E4E                 19  TRAP_14  EQU      $4E4E             Code for TRAP #14 
00000008  =00000040                 20  MAXCHR   EQU      64                Length of input line buffer  
00000008                            21  * 
00000008  =00004800                 22  DATA     EQU      $4800             Data origin 
00000008                            23  LNBUFF   DS.B     MAXCHR            Input line buffer
00000048  =00000047                 24  BUFFEND  EQU      LNBUFF+MAXCHR-1   End of line buffer 
00000048                            25  BUFFPT   DS.L     1                 Pointer to line buffer 
0000004C                            26  PARAMTR  DS.L     1                 Last parameter from line buffer 
00000050                            27  ECHO     DS.B     1                 When clear this enable input echo 
00000051                            28  U_CASE   DS.B     1                 Flag for upper case conversion 
00000052                            29  UTAB     DS.L     1                 Pointer to user command table 
00000056                            30  CN_IVEC  DS.L     1                 Pointer to console input DCB 
0000005A                            31  CN_OVEC  DS.L     1                 Pointer to console output DCB 
0000005E                            32  TSK_T    DS.W     37                Frame for D0-D7, A0-A6, USP, SSP, SW, PC 
000000A8                            33  BP_TAB   DS.W     24                Breakpoint table 
000000D8                            34  FIRST    DS.B     512               DCB area 
000002D8                            35  BUFFER   DS.B     256               256 bytes for I/O buffer 
000003D8                            36  * 
000003D8                            37  ************************************************************************* 
000003D8                            38  * 
000003D8                            39  *  This is the main program which assembles a command in the line 
000003D8                            40  *  buffer, removes leading/embedded spaces and interprets it by matching 
000003D8                            41  *  it with a command in the user table or the built-in table COMTAB 
000003D8                            42  *  All variables are specified with respect to A6 
000003D8                            43  *
00001000                            44           ORG      $1000             Monitor Origin
00001000  =00001000                 45  RESET:   EQU      *
00001000  4DF8 4800                 46           LEA.L    DATA,A6           A6 points to data area 
00001004  2D4E 0096                 47      MOVE.L    A6,TSK_T+56(A6)   initialize A6 in the regster Frame
00001008  42AE 0052                 48           CLR.L    UTAB(A6)          Reset pointer to user extension table 
0000100C  1D7C 0001 0050            49           MOVE.B   #1,ECHO(A6)       Set automatic character echo 
00001012  422E 0051                 50           CLR.B    U_CASE(A6)        Clear case conversion flag (UC<-LC) 
00001016  6100 05C0                 51      BSR.L     X_SET         what change did i do here
0000101A  6100 045C                 52           BSR.L    SET_DCB           Setup DCB table in RAM
0000101E  6156                      53           BSR.S    NEWLINE
00001020  49FA 0A1E                 54           LEA.L    BANNER(PC),A4    
00001024  6160                      55           BSR.S    PSTRING
00001026  614E                      56           BSR.S    NEWLINE           
00001028  49FA 0A30                 57      LEA.L     MODIFY(PC),A4
0000102C  6158                      58           BSR.S    PSTRING
0000102E  6146                      59           BSR.S    NEWLINE
00001030  49FA 0A56                 60      LEA.L     WHY(PC),A4
00001034  6150                      61           BSR.S    PSTRING
00001036  613E                      62           BSR.S    NEWLINE
00001038  49FA 0A86                 63      LEA.L     WHERE(PC),A4
0000103C  6148                      64           BSR.S    PSTRING
0000103E  6136                      65           BSR.S    NEWLINE
00001040  49FA 0A98                 66      LEA.L     ADDRE(PC),A4
00001044  6140                      67           BSR.S    PSTRING
00001046  612E                      68           BSR.S    NEWLINE
00001048  207C 00003000             69           MOVE.L   #$3000,A0         A0 points to extension ROM 
0000104E  2010                      70           MOVE.L   (A0),D0           Read first longword in extension ROM 
00001050  B0BC 524F4D32             71           CMP.L    #'ROM2',D0        If extension begins with 'ROM2' then 
00001056  6604                      72           BNE.S    NO_EXT            call the subroutine at EXT_ROM+8 
00001058  4EA8 0008                 73           JSR      8(A0)             else continue 
0000105C  4E71                      74  NO_EXT:  NOP                        Two NOPs to allow for a future 
0000105E  4E71                      75           NOP                        call to an initialization routine 
00001060  4287                      76  WARM:    CLR.L    D7                Warm entry point - clear error flag 
00001062  4EB9 00001746             77           JSR      LOGIN
00001068  610C                      78           BSR.S    NEWLINE           Print a newline 
0000106A  6130                      79           BSR.S    GETLINE           Get a command line 
0000106C  6100 0064                 80           BSR      TIDY              Tidy up input buffer contents 
00001070  6100 00A2                 81           BSR      EXECUTE           Interpret command 
00001074  60EA                      82           BRA      WARM              Repeat indefinitely 
00001076                            83  * 
00001076                            84  ************************************************************************* 
00001076                            85  * 
00001076                            86  *  Some initialization and basic routines 
00001076                            87  * 
00001076                            88  * 
00001076  =00001076                 89  NEWLINE  EQU      *                 Move cursor to start of newline 
00001076  48E7 0008                 90           MOVEM.L  A4,-(A7)          Save A4 
0000107A  49FA 0A81                 91           LEA.L    CRLF(PC),A4       Point to CR/LF string 
0000107E  6106                      92           BSR.S    PSTRING           Print it 
00001080  4CDF 1000                 93           MOVEM.L  (A7)+,A4          Restore A4 
00001084  4E75                      94           RTS                        Return 
00001086                            95  * 
00001086  =00001086                 96  PSTRING  EQU      *                 Display the string pointed at by A4 
00001086  2F00                      97           MOVE.L   D0,-(A7)          Save D0 
00001088  101C                      98  PS1      MOVE.B   (A4)+,D0          Get character to be printed 
0000108A  6706                      99           BEQ.S    PS2               If null then return 
0000108C  6100 04C6                100           BSR      PUTCHAR           Else print it 
00001090  60F6                     101           BRA      PS1               Continue 
00001092  201F                     102  PS2      MOVE.L   (A7)+,D0          Restore D0 and exit 
00001094  4E75                     103           RTS 
00001096                           104  * 
00001096  61DE                     105  HEADING  BSR      NEWLINE           Same as PSTRING but with newline 
00001098  61EC                     106           BSR      PSTRING 
0000109A  60DA                     107           BRA      NEWLINE 
0000109C                           108  * 
0000109C                           109  ************************************************************************* 
0000109C                           110  * 
0000109C                           111  *  GETLINE  inputs a string of characters into a line buffer 
0000109C                           112  *           A3 points to next free entry in line buffer 
0000109C                           113  *           A2 points to end of buffer 
0000109C                           114  *           A1 points to start of buffer 
0000109C                           115  *           D0 holds character to be stored 
0000109C                           116  * 
0000109C  43EE 0008                117  GETLINE  LEA.L    LNBUFF(A6),A1     A1 points to start of line buffer 
000010A0  47D1                     118           LEA.L    (A1),A3           A3 points to start (initially) 
000010A2  45E9 0040                119           LEA.L    MAXCHR(A1),A2     A2 points to end of buffer 
000010A6  6100 047C                120  GETLN2   BSR      GETCHAR           Get a character 
000010AA  B03C 0001                121           CMP.B    #CTRL_A,D0        If control_A then reject this line 
000010AE  671E                     122           BEQ.S    GETLN5            and get another line 
000010B0  B03C 0008                123           CMP.B    #BS,D0            If back_space then move back pointer 
000010B4  660A                     124           BNE.S    GETLN3            Else skip past wind-back routine 
000010B6  B7C9                     125           CMP.L    A1,A3             First check for empty buffer 
000010B8  67EC                     126           BEQ      GETLN2            If buffer empty then continue 
000010BA  47EB FFFF                127           LEA      -1(A3),A3         Else decrement buffer pointer 
000010BE  60E6                     128           BRA      GETLN2            and continue with next character 
000010C0  16C0                     129  GETLN3   MOVE.B   D0,(A3)+          Store character and update pointer 
000010C2  B03C 000D                130           CMP.B    #CR,D0            Test for command terminator 
000010C6  6602                     131           BNE.S    GETLN4            If not CR then skip past exit 
000010C8  60AC                     132           BRA      NEWLINE           Else new line before next operation 
000010CA  B7CA                     133  GETLN4   CMP.L    A2,A3             Test for buffer overflow 
000010CC  66D8                     134           BNE      GETLN2            If buffer not full then continue 
000010CE  61A6                     135  GETLN5   BSR      NEWLINE           Else move to next line and 
000010D0  60CA                     136           BRA      GETLINE           repeat this routine 
000010D2                           137  * 
000010D2                           138  ************************************************************************* 
000010D2                           139  * 
000010D2                           140  *  TIDY cleans up the line buffer by removing leading spaces and multiple 
000010D2                           141  *       spaces between parameters. At the end of TIDY, BUFFPT points to 
000010D2                           142  *       the first parameter following the command. 
000010D2                           143  *       A0 = pointer to line buffer. A1 = pointer to cleaned up buffer 
000010D2                           144  * 
000010D2  41EE 0008                145  TIDY     LEA.L    LNBUFF(A6),A0     A0 points to line buffer 
000010D6  43D0                     146           LEA.L    (A0),A1           A1 points to start of line buffer 
000010D8  1018                     147  TIDY1    MOVE.B   (A0)+,D0          Read character from line buffer 
000010DA  B03C 0020                148           CMP.B    #SPACE,D0         Repeat until the first non-space 
000010DE  67F8                     149           BEQ      TIDY1             character is found 
000010E0  41E8 FFFF                150           LEA.L    -1(A0),A0         Move pointer back to first char 
000010E4  1018                     151  TIDY2    MOVE.B   (A0)+,D0          Move the string left to remove 
000010E6  12C0                     152           MOVE.B   D0,(A1)+          any leading spaces 
000010E8  B03C 0020                153           CMP.B    #SPACE,D0         Test for embedded space 
000010EC  660A                     154           BNE.S    TIDY4             If not space then test for EOL 
000010EE  0C18 0020                155  TIDY3    CMP.B    #SPACE,(A0)+      If space skip multiple embedded 
000010F2  67FA                     156           BEQ      TIDY3             spaces 
000010F4  41E8 FFFF                157           LEA.L    -1(A0),A0         Move back pointer 
000010F8  B03C 000D                158  TIDY4    CMP.B    #CR,D0            Test for end_of_line (EOL) 
000010FC  66E6                     159           BNE      TIDY2             If not EOL then read next char 
000010FE  41EE 0008                160           LEA.L    LNBUFF(A6),A0     Restore buffer pointer 
00001102  0C10 000D                161  TIDY5    CMP.B    #CR,(A0)          Test for EOL 
00001106  6706                     162           BEQ.S    TIDY6             If EOL then exit 
00001108  0C18 0020                163           CMP.B    #SPACE,(A0)+      Test for delimiter 
0000110C  66F4                     164           BNE      TIDY5             Repeat until delimiter or EOL 
0000110E  2D48 0048                165  TIDY6    MOVE.L   A0,BUFFPT(A6)     Update buffer pointer 
00001112  4E75                     166           RTS 
00001114                           167  * 
00001114                           168  ************************************************************************* 
00001114                           169  * 
00001114                           170  *  EXECUTE matches the first command in the line buffer with the 
00001114                           171  *  commands in a command table. An external table pointed at by 
00001114                           172  *  UTAB is searched first and then the built-in table, COMTAB. 
00001114                           173  * 
00001114  4AAE 0052                174  EXECUTE  TST.L    UTAB(A6)          Test pointer to user table 
00001118  670C                     175           BEQ.S    EXEC1             If clear then try built-in table 
0000111A  266E 0052                176           MOVE.L   UTAB(A6),A3       Else pick up pointer to user table 
0000111E  6120                     177           BSR.S    SEARCH            Look for command in user table 
00001120  6404                     178           BCC.S    EXEC1             If not found then try internal table 
00001122  2653                     179           MOVE.L   (A3),A3           Else get absolute address of command 
00001124  4ED3                     180           JMP      (A3)              from user table and execute it 
00001126                           181  * 
00001126  47FA 0BE0                182  EXEC1    LEA.L    COMTAB(PC),A3     Try built-in command table 
0000112A  6114                     183           BSR.S    SEARCH            Look for command in built-in table 
0000112C  6508                     184           BCS.S    EXEC2             If found then execute command 
0000112E  49FA 0ABB                185           LEA.L    ERMES2(PC),A4     Else print "invalid command" 
00001132  6000 FF52                186           BRA.L    PSTRING           and return 
00001136  2653                     187  EXEC2    MOVE.L   (A3),A3           Get the relative command address 
00001138  49FA 0BCE                188           LEA.L    COMTAB(PC),A4     pointed at by A3 and add it to 
0000113C  D7CC                     189           ADD.L    A4,A3             the PC to generate the actual 
0000113E  4ED3                     190           JMP      (A3)              command address. Then execute it. 
00001140                           191  * 
00001140  =00001140                192  SEARCH   EQU      *                 Match the command in the line buffer 
00001140  4280                     193           CLR.L    D0                with command table pointed at by A3 
00001142  1013                     194           MOVE.B   (A3),D0           Get the first character in the 
00001144  6734                     195           BEQ.S    SRCH7             current entry. If zero then exit 
00001146  49F3 0006                196           LEA.L    6(A3,D0.W),A4     Else calculate address of next entry 
0000114A  122B 0001                197           MOVE.B   1(A3),D1          Get number of characters to match 
0000114E  4BEE 0008                198           LEA.L    LNBUFF(A6),A5     A5 points to command in line buffer 
00001152  142B 0002                199           MOVE.B   2(A3),D2          Get first character in this entry 
00001156  B41D                     200           CMP.B    (A5)+,D2          from the table and match with buffer 
00001158  6704                     201           BEQ.S    SRCH3             If match then try rest of string 
0000115A  264C                     202  SRCH2    MOVE.L   A4,A3             Else get address of next entry 
0000115C  60E2                     203           BRA      SEARCH            and try the next entry in the table 
0000115E  5301                     204  SRCH3    SUB.B    #1,D1             One less character to match 
00001160  670E                     205           BEQ.S    SRCH6             If match counter zero then all done 
00001162  47EB 0003                206           LEA.L    3(A3),A3          Else point to next character in table 
00001166  141B                     207  SRCH4    MOVE.B   (A3)+,D2          Now match a pair of characters 
00001168  B41D                     208           CMP.B    (A5)+,D2 
0000116A  66EE                     209           BNE      SRCH2             If no match then try next entry 
0000116C  5301                     210           SUB.B    #1,D1             Else decrement match counter and 
0000116E  66F6                     211           BNE      SRCH4             repeat until no chars left to match 
00001170  47EC FFFC                212  SRCH6    LEA.L    -4(A4),A3         Calculate address of command entry 
00001174  003C 0001                213           OR.B     #1,CCR            point. Mark carry flag as success 
00001178  4E75                     214           RTS                        and return 
0000117A  023C 00FE                215  SRCH7    AND.B    #$FE,CCR          Fail - clear carry to indicate 
0000117E  4E75                     216           RTS                        command not found and return 
00001180                           217  * 
00001180                           218  ************************************************************************* 
00001180                           219  * 
00001180                           220  *  Basic input routines 
00001180                           221  *  HEX    =  Get one   hexadecimal character  into D0 
00001180                           222  *  BYTE   =  Get two   hexadecimal characters into D0 
00001180                           223  *  WORD   =  Get four  hexadecimal characters into D0 
00001180                           224  *  LONGWD =  Get eight hexadecimal characters into D0 
00001180                           225  *  PARAM  =  Get a longword from the line buffer into D0 
00001180                           226  *  Bit 0 of D7 is set to indicate a hexadecimal input error 
00001180                           227  * 
00001180  6100 03A2                228  HEX      BSR      GETCHAR           Get a character from input device 
00001184  0400 0030                229           SUB.B    #$30,D0           Convert to binary 
00001188  6B0E                     230           BMI.S    NOT_HEX           If less than $30 then exit with error 
0000118A  B03C 0009                231           CMP.B    #$09,D0           Else test for number (0 to 9) 
0000118E  6F0C                     232           BLE.S    HEX_OK            If number then exit - success 
00001190  5F00                     233           SUB.B    #$07,D0           Else convert letter to hex 
00001192  B03C 000F                234           CMP.B    #$0F,D0           If character in range "A" to "F" 
00001196  6F04                     235           BLE.S    HEX_OK            then exit successfully 
00001198  8E3C 0001                236  NOT_HEX  OR.B     #1,D7             Else set error flag 
0000119C  4E75                     237  HEX_OK   RTS                        and return 
0000119E                           238  * 
0000119E  2F01                     239  BYTE     MOVE.L   D1,-(A7)          Save D1 
000011A0  61DE                     240           BSR      HEX               Get first hex character 
000011A2  E900                     241           ASL.B    #4,D0             Move it to MS nybble position 
000011A4  1200                     242           MOVE.B   D0,D1             Save MS nybble in D1 
000011A6  61D8                     243           BSR      HEX               Get second hex character 
000011A8  D001                     244           ADD.B    D1,D0             Merge MS and LS nybbles 
000011AA  221F                     245           MOVE.L   (A7)+,D1          Restore D1 
000011AC  4E75                     246           RTS 
000011AE                           247  * 
000011AE  61EE                     248  WORD     BSR      BYTE              Get upper order byte 
000011B0  E140                     249           ASL.W    #8,D0             Move it to MS position 
000011B2  60EA                     250           BRA      BYTE              Get LS byte and return 
000011B4                           251  * 
000011B4  61F8                     252  LONGWD   BSR      WORD              Get upper order word 
000011B6  4840                     253           SWAP     D0                Move it to MS position 
000011B8  60F4                     254           BRA      WORD              Get lower order word and return 
000011BA                           255  * 
000011BA                           256  *  PARAM reads a parameter from the line buffer and puts it in both 
000011BA                           257  *  PARAMTR(A6) and D0. Bit 1 of D7 is set on error. 
000011BA                           258  * 
000011BA  2F01                     259  PARAM    MOVE.L   D1,-(A7)          Save D1 
000011BC  4281                     260           CLR.L    D1                Clear input accumulator 
000011BE  206E 0048                261           MOVE.L   BUFFPT(A6),A0     A0 points to parameter in buffer 
000011C2  1018                     262  PARAM1   MOVE.B   (A0)+,D0          Read character from line buffer 
000011C4  B03C 0020                263           CMP.B    #SPACE,D0         Test for delimiter 
000011C8  6720                     264           BEQ.S    PARAM4            The permitted delimiter is a 
000011CA  B03C 000D                265           CMP.B    #CR,D0            space or a carriage return 
000011CE  671A                     266           BEQ.S    PARAM4            Exit on either space or C/R 
000011D0  E981                     267           ASL.L    #4,D1             Shift accumulated result 4 bits left 
000011D2  0400 0030                268           SUB.B    #$30,D0           Convert new character to hex 
000011D6  6B1E                     269           BMI.S    PARAM5            If less than $30 then not-hex 
000011D8  B03C 0009                270           CMP.B    #$09,D0           If less than 10 
000011DC  6F08                     271           BLE.S    PARAM3            then continue 
000011DE  5F00                     272           SUB.B    #$07,D0           Else assume $A - $F 
000011E0  B03C 000F                273           CMP.B    #$0F,D0           If more than $F 
000011E4  6E10                     274           BGT.S    PARAM5            then exit to error on not-hex 
000011E6  D200                     275  PARAM3   ADD.B    D0,D1             Add latest nybble to total in D1 
000011E8  60D8                     276           BRA      PARAM1            Repeat until delimiter found 
000011EA  2D48 0048                277  PARAM4   MOVE.L   A0,BUFFPT(A6)     Save pointer in memory 
000011EE  2D41 004C                278           MOVE.L   D1,PARAMTR(A6)    Save parameter in memory 
000011F2  2001                     279           MOVE.L   D1,D0             Put parameter in D0 for return 
000011F4  6004                     280           BRA.S    PARAM6            Return without error 
000011F6  8E3C 0002                281  PARAM5   OR.B     #2,D7             Set error flag before return 
000011FA  221F                     282  PARAM6   MOVE.L   (A7)+,D1          Restore working register 
000011FC  4E75                     283           RTS                        Return with error 
000011FE                           284  * 
000011FE                           285  ************************************************************************* 
000011FE                           286  * 
000011FE                           287  *  Output routines 
000011FE                           288  *  OUT1X   = print one   hexadecimal character 
000011FE                           289  *  OUT2X   = print two   hexadecimal characters 
000011FE                           290  *  OUT4X   = print four  hexadecimal characters 
000011FE                           291  *  OUT8X   = print eight hexadecimal characters 
000011FE                           292  *  In each case, the data to be printed is in D0 
000011FE                           293  * 
000011FE  3F00                     294  OUT1X    MOVE.W   D0,-(A7)          Save D0 
00001200  C03C 000F                295           AND.B    #$0F,D0           Mask off MS nybble 
00001204  0600 0030                296           ADD.B    #$30,D0           Convert to ASCII 
00001208  B03C 0039                297           CMP.B    #$39,D0           ASCII = HEX + $30 
0000120C  6302                     298           BLS.S    OUT1X1            If ASCII <= $39 then print and exit 
0000120E  5E00                     299           ADD.B    #$07,D0           Else ASCII := HEX + 7 
00001210  6100 0342                300  OUT1X1   BSR      PUTCHAR           Print the character 
00001214  301F                     301           MOVE.W   (A7)+,D0          Restore D0 
00001216  4E75                     302           RTS 
00001218                           303  * 
00001218  E818                     304  OUT2X    ROR.B    #4,D0             Get MS nybble in LS position 
0000121A  61E2                     305           BSR      OUT1X             Print MS nybble 
0000121C  E918                     306           ROL.B    #4,D0             Restore LS nybble 
0000121E  60DE                     307           BRA      OUT1X             Print LS nybble and return 
00001220                           308  * 
00001220  E058                     309  OUT4X    ROR.W    #8,D0             Get MS byte in LS position 
00001222  61F4                     310           BSR      OUT2X             Print MS byte 
00001224  E158                     311           ROL.W    #8,D0             Restore LS byte 
00001226  60F0                     312           BRA      OUT2X             Print LS byte and return 
00001228                           313  * 
00001228  4840                     314  OUT8X    SWAP     D0                Get MS word in LS position 
0000122A  61F4                     315           BSR      OUT4X             Print MS word 
0000122C  4840                     316           SWAP     D0                Restore LS word 
0000122E  60F0                     317           BRA      OUT4X             Print LS word and return 
00001230                           318  * 
00001230                           319  ************************************************************************* 
00001230                           320  * 
00001230                           321  * JUMP causes execution to begin at the address in the line buffer 
00001230                           322  * 
00001230  6188                     323  JUMP     BSR     PARAM              Get address from buffer 
00001232  4A07                     324           TST.B   D7                 Test for input error 
00001234  6608                     325           BNE.S   JUMP1              If error flag not zero then exit 
00001236  4A80                     326           TST.L   D0                 Else test for missing address 
00001238  6704                     327           BEQ.S   JUMP1              field. If no address then exit 
0000123A  2040                     328           MOVE.L  D0,A0              Put jump address in A0 and call the 
0000123C  4ED0                     329           JMP     (A0)               subroutine. User to supply RTS!! 
0000123E  49FA 098D                330  JUMP1    LEA.L   ERMES1(PC),A4      Here for error - display error 
00001242  6000 FE42                331           BRA     PSTRING            message and return 
00001246                           332  * 
00001246                           333  ************************************************************************* 
00001246                           334  * 
00001246                           335  *  Display the contents of a memory location and modify it 
00001246                           336  * 
00001246  6100 FF72                337  MEMORY   BSR      PARAM             Get start address from line buffer 
0000124A  4A07                     338           TST.B    D7                Test for input error 
0000124C  6634                     339           BNE.S    MEM3              If error then exit 
0000124E  2640                     340           MOVE.L   D0,A3             A3 points to location to be opened 
00001250  6100 FE24                341  MEM1     BSR      NEWLINE 
00001254  612E                     342           BSR.S    ADR_DAT           Print current address and contents 
00001256  6140                     343           BSR.S    PSPACE             update pointer, A3, and O/P space 
00001258  6100 02CA                344           BSR      GETCHAR           Input char to decide next action 
0000125C  B03C 000D                345           CMP.B    #CR,D0            If carriage return then exit 
00001260  6720                     346           BEQ.S    MEM3              Exit 
00001262  B03C 002D                347           CMP.B    #'-',D0           If "-" then move back 
00001266  6606                     348           BNE.S    MEM2              Else skip wind-back procedure 
00001268  47EB FFFC                349           LEA.L    -4(A3),A3         Move pointer back 2+2 
0000126C  60E2                     350           BRA      MEM1              Repeat until carriage return 
0000126E  B03C 0020                351  MEM2     CMP.B    #SPACE,D0         Test for space (= new entry) 
00001272  66DC                     352           BNE.S    MEM1              If not space then repeat 
00001274  6100 FF38                353           BSR      WORD              Else get new word to store 
00001278  4A07                     354           TST.B    D7                Test for input error 
0000127A  6606                     355           BNE.S    MEM3              If error then exit 
0000127C  3740 FFFE                356           MOVE.W   D0,-2(A3)         Store new word 
00001280  60CE                     357           BRA      MEM1              Repeat until carriage return 
00001282  4E75                     358  MEM3     RTS 
00001284                           359  * 
00001284  2F00                     360  ADR_DAT  MOVE.L   D0,-(A7)          Print the contents of A3 and the 
00001286  200B                     361           MOVE.L   A3,D0             word pointed at by A3. 
00001288  619E                     362           BSR      OUT8X              and print current address 
0000128A  610C                     363           BSR.S    PSPACE            Insert delimiter 
0000128C  3013                     364           MOVE.W   (A3),D0           Get data at this address in D0 
0000128E  6190                     365           BSR      OUT4X              and print it 
00001290  47EB 0002                366           LEA.L    2(A3),A3          Point to next address to display 
00001294  201F                     367           MOVE.L   (A7)+,D0          Restore D0 
00001296  4E75                     368           RTS 
00001298                           369  * 
00001298  1F00                     370  PSPACE   MOVE.B   D0,-(A7)          Print a single space 
0000129A  103C 0020                371           MOVE.B   #SPACE,D0 
0000129E  6100 02B4                372           BSR      PUTCHAR 
000012A2  101F                     373           MOVE.B   (A7)+,D0 
000012A4  4E75                     374           RTS 
000012A6                           375  * 
000012A6                           376  ************************************************************************* 
000012A6                           377  * 
000012A6                           378  *  LOAD  Loads data formatted in hexadecimal "S" format from Port 2 
000012A6                           379  *        NOTE - I/O is automatically redirected to the aux port for 
000012A6                           380  *        loader functions. S1 or S2 records accepted 
000012A6                           381  * 
000012A6  2F2E 005A                382  LOAD     MOVE.L   CN_OVEC(A6),-(A7) Save current output device name 
000012AA  2F2E 0056                383           MOVE.L   CN_IVEC(A6),-(A7) Save current input device name 
000012AE  2D7C 00001DD0 005A       384           MOVE.L   #DCB4,CN_OVEC(A6) Set up aux ACIA as output 
000012B6  2D7C 00001DBE 0056       385           MOVE.L   #DCB3,CN_IVEC(A6) Set up aux ACIA as input 
000012BE  522E 0050                386           ADD.B    #1,ECHO(A6)       Turn off character echo 
000012C2  6100 FDB2                387           BSR      NEWLINE           Send newline to host 
000012C6  6100 015A                388           BSR      DELAY             Wait for host to "settle" 
000012CA  6100 0156                389           BSR      DELAY 
000012CE  286E 0048                390           MOVE.L   BUFFPT(A6),A4     Any string in the line buffer is 
000012D2  101C                     391  LOAD1    MOVE.B   (A4)+,D0          transmitted to the host computer 
000012D4  6100 027E                392           BSR      PUTCHAR           before the loading begins 
000012D8  B03C 000D                393           CMP.B    #CR,D0            Read from the buffer until EOL 
000012DC  66F4                     394           BNE      LOAD1 
000012DE  6100 FD96                395           BSR      NEWLINE           Send newline before loading 
000012E2  6100 0240                396  LOAD2    BSR      GETCHAR           Records from the host must begin 
000012E6  B03C 0053                397           CMP.B    #'S',D0           with S1/S2 (data) or S9/S8 (term) 
000012EA  66F6                     398           BNE.S    LOAD2             Repeat GETCHAR until char = "S" 
000012EC  6100 0236                399           BSR      GETCHAR           Get character after "S" 
000012F0  B03C 0039                400           CMP.B    #'9',D0           Test for the two terminators S9/S8 
000012F4  6706                     401           BEQ.S    LOAD3             If S9 record then exit else test 
000012F6  B03C 0038                402           CMP.B    #'8',D0           for S8 terminator. Fall through to 
000012FA  662A                     403           BNE.S    LOAD6             exit on S8 else continue search 
000012FC  =000012FC                404  LOAD3    EQU      *                 Exit point from LOAD 
000012FC  2D5F 0056                405           MOVE.L   (A7)+,CN_IVEC(A6) Clean up by restoring input device 
00001300  2D5F 005A                406           MOVE.L   (A7)+,CN_OVEC(A6) and output device name 
00001304  422E 0050                407           CLR.B    ECHO(A6)          Restore input character echo 
00001308  0807 0000                408           BTST     #0,D7             Test for input errors 
0000130C  6708                     409           BEQ.S    LOAD4             If no I/P error then look at checksum 
0000130E  49FA 08BD                410           LEA.L    ERMES1(PC),A4     Else point to error message 
00001312  6100 FD72                411           BSR      PSTRING           Print it 
00001316  0807 0003                412  LOAD4    BTST     #3,D7             Test for checksum error 
0000131A  6708                     413           BEQ.S    LOAD5             If clear then exit 
0000131C  49FA 08DF                414           LEA.L    ERMES3(PC),A4     Else point to error message 
00001320  6100 FD64                415           BSR      PSTRING           Print it and return 
00001324  4E75                     416  LOAD5    RTS 
00001326                           417  * 
00001326  B03C 0031                418  LOAD6    CMP.B    #'1',D0           Test for S1 record 
0000132A  671E                     419           BEQ.S    LOAD6A            If S1 record then read it 
0000132C  B03C 0032                420           CMP.B    #'2',D0           Else test for S2 record 
00001330  66B0                     421           BNE.S    LOAD2             Repeat until valid header found 
00001332  4203                     422           CLR.B    D3                Read the S2 byte count and address, 
00001334  613C                     423           BSR.S    LOAD8             clear the checksum 
00001336  5900                     424           SUB.B    #4,D0             Calculate size of data field 
00001338  1400                     425           MOVE.B   D0,D2             D2 contains data bytes to read 
0000133A  4280                     426           CLR.L    D0                Clear address accumulator 
0000133C  6134                     427           BSR.S    LOAD8             Read most sig byte of address 
0000133E  E180                     428           ASL.L    #8,D0             Move it one byte left 
00001340  6130                     429           BSR.S    LOAD8             Read the middle byte of address 
00001342  E180                     430           ASL.L    #8,D0             Move it one byte left 
00001344  612C                     431           BSR.S    LOAD8             Read least sig byte of address 
00001346  2440                     432           MOVE.L   D0,A2             A2 points to destination of record 
00001348  6012                     433           BRA.S    LOAD7             Skip past S1 header loader 
0000134A  4203                     434  LOAD6A   CLR.B    D3                S1 record found - clear checksum 
0000134C  6124                     435           BSR.S    LOAD8             Get byte and update checksum 
0000134E  5700                     436           SUB.B    #3,D0             Subtract 3 from record length 
00001350  1400                     437           MOVE.B   D0,D2             Save byte count in D2 
00001352  4280                     438           CLR.L    D0                Clear address accumulator 
00001354  611C                     439           BSR.S    LOAD8             Get MS byte of load address 
00001356  E180                     440           ASL.L    #8,D0             Move it to MS position 
00001358  6118                     441           BSR.S    LOAD8             Get LS byte in D2 
0000135A  2440                     442           MOVE.L   D0,A2             A2 points to destination of data 
0000135C  6114                     443  LOAD7    BSR.S    LOAD8             Get byte of data for loading 
0000135E  14C0                     444           MOVE.B   D0,(A2)+          Store it 
00001360  5302                     445           SUB.B    #1,D2             Decrement byte counter 
00001362  66F8                     446           BNE      LOAD7             Repeat until count = 0 
00001364  610C                     447           BSR.S    LOAD8             Read checksum 
00001366  5203                     448           ADD.B    #1,D3             Add 1 to total checksum 
00001368  6700 FF78                449           BEQ      LOAD2             If zero then start next record 
0000136C  8E3C 0008                450           OR.B     #%00001000,D7     Else set checksum error bit, 
00001370  608A                     451           BRA      LOAD3             restore I/O devices and return 
00001372                           452  * 
00001372  6100 FE2A                453  LOAD8    BSR     BYTE               Get a byte 
00001376  D600                     454           ADD.B   D0,D3              Update checksum 
00001378  4E75                     455           RTS                         and return 
0000137A                           456  * 
0000137A                           457  ************************************************************************* 
0000137A                           458  * 
0000137A                           459  *  DUMP   Transmit S1 formatted records to host computer 
0000137A                           460  *         A3 = Starting address of data block 
0000137A                           461  *         A2 = End address of data block 
0000137A                           462  *         D1 = Checksum, D2 = current record length 
0000137A                           463  * 
0000137A  6100 0096                464  DUMP     BSR      RANGE             Get start and end address 
0000137E  4A07                     465           TST.B    D7                Test for input error 
00001380  6708                     466           BEQ.S    DUMP1             If no error then continue 
00001382  49FA 0849                467           LEA.L    ERMES1(PC),A4     Else point to error message, 
00001386  6000 FCFE                468           BRA      PSTRING           print it and return 
0000138A  B08B                     469  DUMP1    CMP.L    A3,D0             Compare start and end addresses 
0000138C  6A08                     470           BPL.S    DUMP2             If positive then start < end 
0000138E  49FA 08F3                471           LEA.L    ERMES7(PC),A4     Else print error message 
00001392  6000 FCF2                472           BRA      PSTRING           and return 
00001396  2F2E 005A                473  DUMP2    MOVE.L   CN_OVEC(A6),-(A7) Save name of current output device 
0000139A  2D7C 00001DD0 005A       474           MOVE.L   #DCB4,CN_OVEC(A6) Set up Port 2 as output device 
000013A2  6100 FCD2                475           BSR      NEWLINE           Send newline to host and wait 
000013A6  617A                     476           BSR.S    DELAY 
000013A8  286E 0048                477           MOVE.L   BUFFPT(A6),A4     Before dumping, send any string 
000013AC  101C                     478  DUMP3    MOVE.B   (A4)+,D0          in the input buffer to the host 
000013AE  6100 01A4                479           BSR      PUTCHAR           Repeat 
000013B2  B03C 000D                480           CMP.B    #CR,D0            Transmit char from buffer to host 
000013B6  66F4                     481           BNE      DUMP3             Until char = C/R 
000013B8  6100 FCBC                482           BSR      NEWLINE 
000013BC  6164                     483           BSR.S    DELAY             Allow time for host to settle 
000013BE  528A                     484           ADDQ.L   #1,A2             A2 contains length of record + 1 
000013C0  240A                     485  DUMP4    MOVE.L   A2,D2             D2 points to end address 
000013C2  948B                     486           SUB.L    A3,D2             D2 contains bytes left to print 
000013C4  B4BC 00000011            487           CMP.L    #17,D2            If this is not a full record of 16 
000013CA  6502                     488           BCS.S    DUMP5             then load D2 with record size 
000013CC  7410                     489           MOVEQ    #16,D2            Else preset byte count to 16 
000013CE  49FA 0738                490  DUMP5    LEA.L    HEADER(PC),A4     Point to record header 
000013D2  6100 FCB2                491           BSR      PSTRING           Print header 
000013D6  4201                     492           CLR.B    D1                Clear checksum 
000013D8  1002                     493           MOVE.B   D2,D0             Move record length to output register 
000013DA  5600                     494           ADD.B    #3,D0             Length includes address + count 
000013DC  612E                     495           BSR.S    DUMP7             Print number of bytes in record 
000013DE  200B                     496           MOVE.L   A3,D0             Get start address to be printed 
000013E0  E158                     497           ROL.W    #8,D0             Get MS byte in LS position 
000013E2  6128                     498           BSR.S    DUMP7             Print MS byte of address 
000013E4  E058                     499           ROR.W    #8,D0             Restore LS byte 
000013E6  6124                     500           BSR.S    DUMP7             Print LS byte of address 
000013E8  101B                     501  DUMP6    MOVE.B   (A3)+,D0          Get data byte to be printed 
000013EA  6120                     502           BSR.S    DUMP7             Print it 
000013EC  5302                     503           SUB.B    #1,D2             Decrement byte count 
000013EE  66F8                     504           BNE      DUMP6             Repeat until all this record printed 
000013F0  4601                     505           NOT.B    D1                Complement checksum 
000013F2  1001                     506           MOVE.B   D1,D0             Move to output register 
000013F4  6116                     507           BSR.S    DUMP7             Print checksum 
000013F6  6100 FC7E                508           BSR      NEWLINE 
000013FA  B7CA                     509           CMP.L    A2,A3             Have all records been printed? 
000013FC  66C2                     510           BNE      DUMP4             Repeat until all done 
000013FE  49FA 070E                511           LEA.L    TAIL(PC),A4       Point to message tail (S9 record) 
00001402  6100 FC82                512           BSR      PSTRING           Print it 
00001406  2D5F 005A                513           MOVE.L   (A7)+,CN_OVEC(A6) Restore name of output device 
0000140A  4E75                     514           RTS                        and return 
0000140C                           515  * 
0000140C  D200                     516  DUMP7    ADD.B    D0,D1             Update checksum, transmit byte 
0000140E  6000 FE08                517           BRA      OUT2X             to host and return 
00001412                           518  * 
00001412  =00001412                519  RANGE    EQU      *                 Get the range of addresses to be 
00001412  4207                     520           CLR.B    D7                transmitted from the buffer 
00001414  6100 FDA4                521           BSR      PARAM             Get starting address 
00001418  2640                     522           MOVE.L   D0,A3             Set up start address in A3 
0000141A  6100 FD9E                523           BSR      PARAM             Get end address 
0000141E  2440                     524           MOVE.L   D0,A2             Set up end address in A2 
00001420  4E75                     525           RTS 
00001422                           526  * 
00001422  =00001422                527  DELAY    EQU       *                Provide a time delay for the host 
00001422  48E7 8008                528           MOVEM.L   D0/A4,-(A7)      to settle. Save working registers 
00001426  203C 00004000            529           MOVE.L    #$4000,D0        Set up delay constant 
0000142C  5380                     530  DELAY1   SUB.L     #1,D0            Count down         (8 clk cycles) 
0000142E  66FC                     531           BNE       DELAY1           Repeat until zero  (10 clk cycles) 
00001430  4CDF 1001                532           MOVEM.L   (A7)+,D0/A4      Restore working registers 
00001434  4E75                     533           RTS 
00001436                           534  * 
00001436                           535  ************************************************************************* 
00001436                           536  * 
00001436                           537  *  TM  Enter transparant mode (All communication to go from terminal to 
00001436                           538  *  the host processor until escape sequence entered). End sequence 
00001436                           539  *  = ESC, E. A newline is sent to the host to "clear it down". 
00001436                           540  * 
00001436  13FC 0055 00008001       541  TM       MOVE.B    #$55,ACIA_1      Force RTS* high to re-route data 
0000143E  522E 0050                542           ADD.B     #1,ECHO(A6)      Turn off character echo 
00001442  6100 00E0                543  TM1      BSR       GETCHAR          Get character 
00001446  B03C 001B                544           CMP.B     #ESC,D0          Test for end of TM mode 
0000144A  66F6                     545           BNE       TM1              Repeat until first escape character 
0000144C  6100 00D6                546           BSR       GETCHAR          Get second character 
00001450  B03C 0045                547           CMP.B     #'E',D0          If second char = E then exit TM 
00001454  66EC                     548           BNE       TM1              Else continue 
00001456  2F2E 005A                549           MOVE.L    CN_OVEC(A6),-(A7) Save output port device name 
0000145A  2D7C 00001DD0 005A       550           MOVE.L    #DCB4,CN_OVEC(A6) Get name of host port (aux port) 
00001462  6100 FC12                551           BSR       NEWLINE          Send newline to host to clear it 
00001466  2D5F 005A                552           MOVE.L    (A7)+,CN_OVEC(A6) Restore output device port name 
0000146A  422E 0050                553           CLR.B     ECHO(A6)         Restore echo mode 
0000146E  13FC 0015 00008001       554           MOVE.B    #$15,ACIA_1      Restore normal ACIA mode (RTS* low) 
00001476  4E75                     555           RTS 
00001478                           556  * 
00001478                           557  ************************************************************************* 
00001478                           558  * 
00001478                           559  *  This routine sets up the system DCBs in RAM using the information 
00001478                           560  *  stored in ROM at address DCB_LST. This is called at initialization. 
00001478                           561  *  CN_IVEC contains the name "DCB1" and IO_VEC the name "DCB2" 
00001478                           562  * 
00001478  48E7 F0F0                563  SET_DCB  MOVEM.L A0-A3/D0-D3,-(A7) Save all working registers 
0000147C  41EE 00D8                564           LEA.L   FIRST(A6),A0    Pointer to first DCB destination in RAM 
00001480  43FA 0918                565           LEA.L   DCB_LST(PC),A1  A1 points to DCB info block in ROM 
00001484  303C 0005                566           MOVE.W  #5,D0           6 DCBs to set up 
00001488  323C 000F                567  ST_DCB1  MOVE.W  #15,D1          16 bytes to move per DCB header 
0000148C  10D9                     568  ST_DCB2  MOVE.B  (A1)+,(A0)+     Move the 16 bytes of a DCB header 
0000148E  51C9 FFFC                569           DBRA    D1,ST_DCB2      from ROM to RAM 
00001492  3619                     570           MOVE.W  (A1)+,D3        Get size of parameter block (bytes) 
00001494  3083                     571           MOVE.W  D3,(A0)         Store size in DCB in RAM 
00001496  41F0 3002                572           LEA.L   2(A0,D3.W),A0   A0 points to tail of DCB in RAM 
0000149A  47E8 0004                573           LEA.L   4(A0),A3        A3 contains address of next DCB in RAM 
0000149E  208B                     574           MOVE.L  A3,(A0)         Store pointer to next DCB in this DCB 
000014A0  41D3                     575           LEA.L   (A3),A0         A0 now points at next DCB in RAM 
000014A2  51C8 FFE4                576           DBRA    D0,ST_DCB1      Repeat until all DCBs set up 
000014A6  47EB FFFC                577           LEA.L   -4(A3),A3       Adjust A3 to point to last DCB pointer 
000014AA  4293                     578           CLR.L   (A3)            and force last pointer to zero 
000014AC  2D7C 00001D9A 0056       579           MOVE.L  #DCB1,CN_IVEC(A6) Set up vector to console input DCB 
000014B4  2D7C 00001DAC 005A       580           MOVE.L  #DCB2,CN_OVEC(A6) Set up vector to console output DCB 
000014BC  4CDF 0F0F                581           MOVEM.L (A7)+,A0-A3/D0-D3 Restore registers 
000014C0  4E75                     582           RTS 
000014C2                           583  * 
000014C2                           584  ************************************************************************* 
000014C2                           585  * 
000014C2                           586  *  IO_REQ handles all input/output transactions. A0 points to DCB on 
000014C2                           587  *  entry. IO_REQ calls the device driver whose address is in the DCB. 
000014C2                           588  * 
000014C2  48E7 00C0                589  IO_REQ   MOVEM.L A0-A1,-(A7)     Save working registers 
000014C6  43E8 0008                590           LEA.L   8(A0),A1        A1 points to device handler field in DCB 
000014CA  2251                     591           MOVE.L  (A1),A1         A1 contains device handler address 
000014CC  4E91                     592           JSR     (A1)            Call device handler 
000014CE  4CDF 0300                593           MOVEM.L (A7)+,A0-A1     Restore working registers 
000014D2  4E75                     594           RTS 
000014D4                           595  * 
000014D4                           596  ************************************************************************* 
000014D4                           597  * 
000014D4                           598  *  CON_IN handles input from the console device 
000014D4                           599  *  Exit with input in D0 
000014D4                           600  * 
000014D4  48E7 4000                601  CON_IN   MOVEM.L D1,-(A7)         Save working registers 
000014D8  4228 0013                602      CLR.B    19(A0)
000014DC  103C 0005                603           MOVE.B    #5,D0             Read input from ACIA
000014E0  4E4F                     604      TRAP     #15
000014E2  1001                     605      MOVE.B  D1,D0
000014E4  4CDF 0002                606           MOVEM.L (A7)+,D1     `   Restore working registers 
000014E8  4E75                     607           RTS 
000014EA                           608  * 
000014EA                           609  ************************************************************************* 
000014EA                           610  * 
000014EA                           611  *   This is the CON_OUT device driver. Output in D0  
000014EA                           612  * 
000014EA  48E7 4000                613  CON_OUT  MOVEM.L D1,-(A7)  Save working registers 
000014EE  4228 0013                614      CLR.B    19(A0)
000014F2  1200                     615           MOVE.B    D0,D1
000014F4  103C 0006                616           MOVE.B    #6,D0
000014F8  4E4F                     617           TRAP   #15
000014FA  4CDF 0002                618           MOVEM.L (A7)+,D1  Restore working registers 
000014FE  4E75                     619           RTS 
00001500                           620  * 
00001500                           621  ************************************************************************* 
00001500                           622  * 
00001500                           623  *  AUX_IN and AUX_OUT are simplified versions of CON_IN and 
00001500                           624  *  CON_OUT for use with the port to the host processor 
00001500                           625  * 
00001500  43E8 000C                626  AUX_IN   LEA.L   12(A0),A1       Get pointer to aux ACIA from DCB 
00001504  2251                     627           MOVE.L  (A1),A1         Get address of aux ACIA 
00001506  0811 0000                628  AUX_IN1  BTST.B  #0,(A1)         Test for data ready 
0000150A  67FA                     629           BEQ     AUX_IN1         Repeat until ready 
0000150C  1029 0002                630           MOVE.B  2(A1),D0        Read input 
00001510  4E75                     631           RTS 
00001512                           632  * 
00001512  43E8 000C                633  AUX_OUT  LEA.L   12(A0),A1       Get pointer to aux ACIA from DCB 
00001516  2251                     634           MOVE.L  (A1),A1         Get address of aux ACIA 
00001518  0811 0001                635  AUX_OT1  BTST.B  #1,(A1)         Test for ready to transmit 
0000151C  67FA                     636           BEQ     AUX_OT1         Repeat until transmitter ready 
0000151E  1340 0002                637           MOVE.B  D0,2(A1)        Transmit data 
00001522  4E75                     638           RTS 
00001524                           639  * 
00001524                           640  ************************************************************************* 
00001524                           641  * 
00001524                           642  *  GETCHAR gets a character from the console device 
00001524                           643  *  This is the main input routine and uses the device whose name  
00001524                           644  *  is stored in CN_IVEC. Changing this name redirects input. 
00001524                           645  * 
00001524  2F08                     646  GETCHAR  MOVE.L  A0,-(A7)        Save working register 
00001526  206E 0056                647           MOVE.L  CN_IVEC(A6),A0  A0 points to name of console DCB 
0000152A  6172                     648           BSR.S   IO_OPEN         Open console (get DCB address in A0) 
0000152C  0807 0003                649           BTST    #3,D7           D7(3) set if open error 
00001530  661E                     650           BNE.S   GETCH3          If error then exit now 
00001532  618E                     651           BSR     IO_REQ          Else execute I/O transaction 
00001534  C03C 007F                652           AND.B   #$7F,D0         Strip msb of input 
00001538  4A2E 0051                653           TST.B   U_CASE(A6)      Test for upper -> lower case conversion 
0000153C  660A                     654           BNE.S   GETCH2          If flag not zero do not convert case 
0000153E  0800 0006                655           BTST    #6,D0             Test input for lower case 
00001542  6704                     656           BEQ.S   GETCH2          If upper case then skip conversion 
00001544  C03C 00DF                657           AND.B   #%11011111,D0   Else clear bit 5 for upper case conv 
00001548  4A2E 0050                658  GETCH2   TST.B   ECHO(A6)        Do we need to echo the input? 
0000154C  6602                     659           BNE.S   GETCH3          If ECHO not zero then no echo 
0000154E  6104                     660           BSR.S   PUTCHAR         Else echo the input 
00001550  205F                     661  GETCH3   MOVE.L  (A7)+,A0        Restore working register 
00001552  4E75                     662           RTS                     and return 
00001554                           663  * 
00001554                           664  ************************************************************************* 
00001554                           665  * 
00001554                           666  *  PUTCHAR sends a character to the console device 
00001554                           667  *  The name of the output device is in CN_OVEC. 
00001554                           668  * 
00001554  BC3C 0001                669  PUTCHAR  CMP.B   #1,D6
00001558  6700 0012                670           BEQ     PUTASK
0000155C  2F08                     671           MOVE.L  A0,-(A7)        Save working register
0000155E  206E 005A                672           MOVE.L  CN_OVEC(A6),A0  A0 points to name of console output 
00001562  613A                     673           BSR.S   IO_OPEN         Open console (Get address of DCB) 
00001564  6100 FF5C                674           BSR     IO_REQ          Perform output with DCB pointed at by A0 
00001568  205F                     675           MOVE.L  (A7)+,A0        Restore working register 
0000156A  4E75                     676           RTS 
0000156C                           677  
0000156C  3B00                     678  PUTASK   MOVE    D0,-(A5)
0000156E  303C 002A                679           MOVE    #'*',D0
00001572  2F08                     680           MOVE.L  A0,-(A7)        Save working register
00001574  206E 005A                681           MOVE.L  CN_OVEC(A6),A0  A0 points to name of console output 
00001578  6124                     682           BSR.S   IO_OPEN         Open console (Get address of DCB) 
0000157A  6100 FF46                683           BSR     IO_REQ          Perform output with DCB pointed at by A0 
0000157E  205F                     684           MOVE.L  (A7)+,A0        Restore working register
00001580  301D                     685           MOVE    (A5)+,D0
00001582  4E75                     686           RTS 
00001584                           687  * 
00001584                           688  ************************************************************************* 
00001584                           689  * 
00001584                           690  *  BUFF_IN and BUFF_OUT are two rudimentary input and output routines 
00001584                           691  *  which input data from and output data to a buffer in RAM. These are 
00001584                           692  *  used by DCB5 and DCB6, respectively. 
00001584                           693  * 
00001584  43E8 000C                694  BUFF_IN  LEA.L   12(A0),A1       A1 points to I/P buffer 
00001588  2451                     695           MOVE.L  (A1),A2         A2 gets I/P pointer from buffer 
0000158A  1022                     696           MOVE.B  -(A2),D0        Read char from buffer and adjust A2 
0000158C  228A                     697           MOVE.L  A2,(A1)         Restore pointer in buffer 
0000158E  4E75                     698           RTS 
00001590                           699  * 
00001590  43E8 000C                700  BUFF_OT  LEA.L   12(A0),A1       A1 points to O/P buffer 
00001594  2469 0004                701           MOVE.L  4(A1),A2        A2 gets O/P pointer from buffer 
00001598  14C0                     702           MOVE.B  D0,(A2)+        Store char in buffer and adjust A2 
0000159A  228A                     703           MOVE.L  A2,(A1)         Restore pointer in buffer 
0000159C  4E75                     704           RTS 
0000159E                           705  * 
0000159E                           706  ************************************************************************* 
0000159E                           707  * 
0000159E                           708  *  Open - opens a DCB for input or output. IO_OPEN converts the 
0000159E                           709  *  name pointed at by A0 into the address of the DCB pointed at 
0000159E                           710  *  by A0. Bit 3 of D7 is set to zero if DCB not found 
0000159E                           711  * 
0000159E  48E7 F870                712  IO_OPEN  MOVEM.L  A1-A3/D0-D4,-(A7) Save working registers 
000015A2  43EE 00D8                713           LEA.L    FIRST(A6),A1   A1 points to first DCB in chain in RAM 
000015A6  45D1                     714  OPEN1    LEA.L    (A1),A2        A2 = temp copy of pointer to DCB 
000015A8  47D0                     715           LEA.L    (A0),A3        A3 = temp copy of pointer to DCB name 
000015AA  303C 0007                716           MOVE.W   #7,D0          Up to 8 chars of DCB name to match 
000015AE  181A                     717  OPEN2    MOVE.B   (A2)+,D4       Compare DCB name with string 
000015B0  B81B                     718           CMP.B    (A3)+,D4 
000015B2  6608                     719           BNE.S    OPEN3          If no match try next DCB 
000015B4  51C8 FFF8                720           DBRA     D0,OPEN2       Else repeat until all chars matched 
000015B8  41D1                     721           LEA.L    (A1),A0        Success - move this DCB address to A0 
000015BA  6016                     722           BRA.S    OPEN4          and return 
000015BC  =000015BC                723  OPEN3    EQU      *              Fail - calculate address of next DCB 
000015BC  3229 0010                724           MOVE.W   16(A1),D1      Get parameter block size of DCB 
000015C0  43F1 1012                725           LEA.L    18(A1,D1.W),A1 A1 points to pointer to next DCB 
000015C4  2251                     726           MOVE.L   (A1),A1        A1 now points to next DCB 
000015C6  B3FC 00000000            727           CMP.L    #0,A1          Test for end of DCB chain 
000015CC  66D8                     728           BNE      OPEN1          If not end of chain then try next DCB 
000015CE  8E3C 0008                729           OR.B     #8,D7          Else set error flag and return 
000015D2  4CDF 0E1F                730  OPEN4    MOVEM.L  (A7)+,A1-A3/D0-D4 Restore working registers 
000015D6  4E75                     731           RTS 
000015D8                           732  * 
000015D8                           733  ************************************************************************* 
000015D8                           734  * 
000015D8                           735  *  Exception vector table initialization routine 
000015D8                           736  *  All vectors not setup are loaded with uninitialized routine vector 
000015D8                           737  * 
000015D8  303C 0007                738  X_SET   MOVE.W  #7,D0             Now clear the breakpoint table 
000015DC  41EE 00A8                739          LEA.L   BP_TAB(A6),A0     Point to table 
000015E0  4298                     740  X_SET2  CLR.L   (A0)+             Clear an address entry 
000015E2  4258                     741          CLR.W   (A0)+             Clear the corresponding data 
000015E4  51C8 FFFA                742          DBRA    D0,X_SET2         Repeat until all 8 cleared 
000015E8  4E75                     743          RTS 
000015EA                           744  * 
000015EA                           745  ************************************************************************* 
000015EA                           746  * 
000015EA  =000015EA                747  TRAP_0  EQU     *                 User links to  TS2BUG via TRAP #0 
000015EA  B23C 0000                748          CMP.B   #0,D1             D1 = 0 = Get character 
000015EE  6606                     749          BNE.S   FOO1           
000015F0  6100 FF32                750          BSR     GETCHAR 
000015F4  4E73                     751          RTE 
000015F6  B23C 0001                752  FOO1    CMP.B   #1,D1             D1 = 1 = Print character 
000015FA  6606                     753          BNE.S   FOO2 
000015FC  6100 FF56                754          BSR     PUTCHAR 
00001600  4E73                     755          RTE 
00001602  B23C 0002                756  FOO2    CMP.B   #2,D1             D1 = 2 = Newline 
00001606  6606                     757          BNE.S   FOO3 
00001608  6100 FA6C                758          BSR     NEWLINE 
0000160C  4E73                     759          RTE 
0000160E  B23C 0003                760  FOO3    CMP.B   #3,D1             D1 = 3 = Get parameter from buffer 
00001612  6606                     761          BNE.S   FOO4 
00001614  6100 FBA4                762          BSR     PARAM 
00001618  4E73                     763          RTE 
0000161A  B23C 0004                764  FOO4    CMP.B   #4,D1             D1 = 4 = Print string pointed at by A4 
0000161E  6606                     765          BNE.S   FOO5 
00001620  6100 FA64                766          BSR     PSTRING 
00001624  4E73                     767          RTE 
00001626  B23C 0005                768  FOO5    CMP.B   #5,D1             D1 = 5 = Get a hex character 
0000162A  6606                     769          BNE.S   FOO6 
0000162C  6100 FB52                770          BSR     HEX 
00001630  4E73                     771          RTE 
00001632  B23C 0006                772  FOO6    CMP.B   #6,D1             D1 = 6 = Get a hex byte 
00001636  6606                     773          BNE.S   FOO7 
00001638  6100 FB64                774          BSR     BYTE 
0000163C  4E73                     775          RTE 
0000163E  B23C 0007                776  FOO7    CMP.B   #7,D1             D1 = 7 = Get a word 
00001642  6606                     777          BNE.S   FOO8 
00001644  6100 FB68                778          BSR     WORD 
00001648  4E73                     779          RTE 
0000164A  B23C 0008                780  FOO8    CMP.B   #8,D1             D1 = 8 = Get a longword 
0000164E  6606                     781          BNE.S   FOO9 
00001650  6100 FB62                782          BSR     LONGWD 
00001654  4E73                     783          RTE 
00001656  B23C 0009                784  FOO9    CMP.B   #9,D1             D1 = 9 = Output hex byte 
0000165A  6606                     785          BNE.S   FOO10  
0000165C  6100 FBBA                786          BSR     OUT2X 
00001660  4E73                     787          RTE 
00001662  B23C 000A                788  FOO10   CMP.B   #10,D1            D1 = 10 = Output hex word 
00001666  6606                     789          BNE.S   FOO11 
00001668  6100 FBB6                790          BSR     OUT4X 
0000166C  4E73                     791          RTE 
0000166E  B23C 000B                792  FOO11   CMP.B   #11,D1            D1 = 11 = Output hex longword 
00001672  6606                     793          BNE.S   FOO12 
00001674  6100 FBB2                794          BSR     OUT8X 
00001678  4E73                     795          RTE 
0000167A  B23C 000C                796  FOO12   CMP.B   #12,D1            D1 = 12 = Print a space 
0000167E  6606                     797          BNE.S   FOO13 
00001680  6100 FC16                798          BSR     PSPACE 
00001684  4E73                     799          RTE 
00001686  B23C 000D                800  FOO13   CMP.B   #13,D1            D1 = 13 = Get a line of text into 
0000168A  6606                     801          BNE.S   FOO14            the line buffer 
0000168C  6100 FA0E                802          BSR     GETLINE 
00001690  4E73                     803          RTE 
00001692  B23C 000E                804  FOO14   CMP.B   #14,D1            D1 = 14 = Tidy up the line in the 
00001696  6606                     805          BNE.S   FOO15            line buffer by removing leading 
00001698  6100 FA38                806          BSR     TIDY              leading and multiple embeded spaces 
0000169C  4E73                     807          RTE 
0000169E  B23C 000F                808  FOO15   CMP.B   #15,D1            D1 = 15 = Execute the command in 
000016A2  6606                     809          BNE.S   FOO16            the line buffer 
000016A4  6100 FA6E                810          BSR     EXECUTE 
000016A8  4E73                     811          RTE 
000016AA  B23C 0010                812  FOO16   CMP.B   #16,D1            D1 = 16 = Call RESTORE to transfer 
000016AE  6606                     813          BNE.S   FOO17            the registers in TSK_T to the 68000 
000016B0  6100 020E                814          BSR     RESTORE           and therefore execute a program 
000016B4  4E73                     815          RTE 
000016B6  4E73                     816  FOO17   RTE 
000016B8                           817  * 
000016B8                           818  ************************************************************************* 
000016B8                           819  * 
000016B8                           820  *  Display exception frame (D0 - D7, A0 - A6, USP, SSP, SR, PC) 
000016B8                           821  *  EX_DIS prints registers saved after a breakpoint or exception 
000016B8                           822  *  The registers are saved in TSK_T 
000016B8                           823  * 
000016B8  4BEE 005E                824  EX_DIS  LEA.L   TSK_T(A6),A5      A5 points to display frame 
000016BC  49FA 0471                825          LEA.L   MES3(PC),A4       Point to heading 
000016C0  6100 F9D4                826          BSR     HEADING           and print it 
000016C4  3C3C 0007                827          MOVE.W  #7,D6             8 pairs of registers to display 
000016C8  4205                     828          CLR.B   D5                D5 is the line counter 
000016CA  1005                     829  EX_D1   MOVE.B  D5,D0             Put current register number in D0 
000016CC  6100 FB30                830          BSR     OUT1X             and print it 
000016D0  6100 FBC6                831          BSR     PSPACE            and a space 
000016D4  5205                     832          ADD.B   #1,D5             Update counter for next pair 
000016D6  2015                     833          MOVE.L  (A5),D0           Get data register to be displayed 
000016D8  6100 FB4E                834          BSR     OUT8X             from the frame and print it 
000016DC  49FA 046F                835          LEA.L   MES4(PC),A4       Print string of spaces 
000016E0  6100 F9A4                836          BSR.L   PSTRING           between data and address registers 
000016E4  202D 0020                837          MOVE.L  32(A5),D0         Get address register to be displayed 
000016E8  6100 FB3E                838          BSR     OUT8X             which is 32 bytes on from data reg 
000016EC  6100 F988                839          BSR     NEWLINE 
000016F0  4BED 0004                840          LEA.L   4(A5),A5          Point to next pair (ie Di, Ai) 
000016F4  51CE FFD4                841          DBRA    D6,EX_D1          Repeat until all displayed 
000016F8  4BED 0020                842          LEA.L   32(A5),A5         Adjust pointer by 8 longwords 
000016FC  6100 F978                843          BSR     NEWLINE           to point to SSP 
00001700  49FA 0424                844          LEA.L   MES2A(PC),A4      Point to "SS =" 
00001704  6100 F980                845          BSR     PSTRING           Print it 
00001708  201D                     846          MOVE.L  (A5)+,D0          Get SSP from frame 
0000170A  6100 FB1C                847          BSR     OUT8X             and display it 
0000170E  6100 F966                848          BSR     NEWLINE 
00001712  49FA 0400                849          LEA.L   MES1(PC),A4       Point to 'SR =' 
00001716  6100 F96E                850          BSR     PSTRING           Print it 
0000171A  301D                     851          MOVE.W  (A5)+,D0          Get status register 
0000171C  6100 FB02                852          BSR     OUT4X             Display status 
00001720  6100 F954                853          BSR     NEWLINE 
00001724  49FA 03F7                854          LEA.L   MES2(PC),A4       Point to 'PC =' 
00001728  6100 F95C                855          BSR     PSTRING           Print it 
0000172C  201D                     856          MOVE.L  (A5)+,D0          Get PC 
0000172E  6100 FAF8                857          BSR     OUT8X             Display PC 
00001732  6000 F942                858          BRA     NEWLINE           Newline and return 
00001736                           859  * 
00001736                           860  ************************************************************************* 
00001736                           861  
00001736  49F9 00001C4D            862  HELP     LEA.L    JUMPHELP,A4
0000173C  6100 F948                863           BSR.W    PSTRING
00001740  6100 F934                864           BSR.W    NEWLINE
00001744  4E75                     865           RTS
00001746                           866           
00001746                           867  *************************************************************************
00001746  49F9 00001C9E            868  LOGIN    LEA.L    LOGINM1,A4
0000174C  6100 F938                869           BSR.W    PSTRING           
00001750  6100 F924                870           BSR.W    NEWLINE
00001754  6100 F946                871           BSR      GETLINE
00001758  49F9 00001C90            872           LEA.L    UNAME,A4
0000175E  1A19                     873  LOGIN1   MOVE.B   (A1)+,D5
00001760  BA1C                     874           CMP.B    (A4)+,D5
00001762  67FA                     875           BEQ      LOGIN1            iterate through checking each char
00001764  0C21 000D                876           CMP.B    #CR,-(A1)          check for carriage return
00001768  6600 0062                877           BNE      WRONG             if not then wrong input
0000176C  0C24 0000                878           CMP.B    #NUL,-(A4)            check for end of stored string
00001770  6600 005A                879           BNE      WRONG             if not then wrong input
00001774  49F9 00001CD3            880           LEA.L    USRSUC,A4         print success
0000177A  6100 F90A                881           BSR.W    PSTRING
0000177E  6100 F8F6                882           BSR.W    NEWLINE
00001782  49F9 00001CAF            883           LEA.L    LOGINM2,A4
00001788  6100 F8FC                884           BSR.W    PSTRING
0000178C  6100 F8E8                885           BSR.W    NEWLINE
00001790  1C3C 0001                886           MOVE.B   #1,D6
00001794  6100 F906                887           BSR.W    GETLINE
00001798  49F9 00001C95            888           LEA.L    PWORD,A4
0000179E  1A19                     889  LOGIN2   MOVE.B   (A1)+,D5
000017A0  BA1C                     890           CMP.B    (A4)+,D5
000017A2  67FA                     891           BEQ      LOGIN2            iterate through checking each char
000017A4  0C21 000D                892           CMP.B    #CR,-(A1)          check for carriage return
000017A8  6600 0022                893           BNE      WRONG             if not then wrong input
000017AC  0C24 0000                894           CMP.B    #NUL,-(A4)            check for end of stored string
000017B0  6600 0024                895           BNE      WRONGPW             if not then wrong input
000017B4  49F9 00001CF7            896           LEA.L    PWSUC,A4
000017BA  6000 F8CA                897           BRA      PSTRING
000017BE  49F9 00001C9E            898           LEA.L    LOGINM1,A4
000017C4  6100 F8C0                899           BSR.W    PSTRING           print success
000017C8  6100 F8AC                900           BSR.W    NEWLINE
000017CC                           901  
000017CC                           902  
000017CC                           903  
000017CC  49F9 00001CC0            904  WRONG    LEA.L    USRERR,A4   
000017D2  6000 F8B2                905           BRA      PSTRING
000017D6                           906  
000017D6  49F9 00001CE4            907  WRONGPW  LEA.L    PWERR,A4   
000017DC  6000 F8A8                908           BRA      PSTRING
000017E0                           909  
000017E0                           910  
000017E0  49F9 00001CD3            911  UPASS    LEA.L    USRSUC,A4
000017E6  6000 F89E                912           BRA      PSTRING  
000017EA                           913  
000017EA                           914  *************************************************************************         
000017EA                           915  * 
000017EA                           916  *  Exception handling routines 
000017EA                           917  * 
000017EA  =000017EA                918  IL_ER   EQU      *                Illegal instruction exception 
000017EA  2F0C                     919          MOVE.L  A4,-(A7)          Save A4 
000017EC  49FA 0389                920          LEA.L   MES10(PC),A4      Point to heading 
000017F0  6100 F8A4                921          BSR     HEADING           Print it 
000017F4  285F                     922          MOVE.L  (A7)+,A4          Restore A4 
000017F6  6176                     923          BSR.S   GROUP2            Save registers in display frame 
000017F8  6100 FEBE                924          BSR     EX_DIS            Display registers saved in frame 
000017FC  6000 F862                925          BRA     WARM              Abort from illegal instruction 
00001800                           926  * 
00001800  =00001800                927  BUS_ER  EQU     *                 Bus error (group 1) exception 
00001800  2F0C                     928          MOVE.L  A4,-(A7)          Save A4 
00001802  49FA 0353                929          LEA.L   MES8(PC),A4       Point to heading 
00001806  6100 F88E                930          BSR     HEADING           Print it 
0000180A  285F                     931          MOVE.L  (A7)+,A4          Restore A4 
0000180C  602C                     932          BRA.S   GROUP1            Deal with group 1 exception 
0000180E                           933  * 
0000180E  =0000180E                934  ADD_ER  EQU     *                 Address error (group 1) exception 
0000180E  2F0C                     935          MOVE.L  A4,-(A7)          Save A4 
00001810  49FA 0353                936          LEA.L   MES9(PC),A4       Point to heading 
00001814  6100 F880                937          BSR     HEADING           Print it 
00001818  285F                     938          MOVE.L  (A7)+,A4          Restore A4 
0000181A  601E                     939          BRA.S   GROUP1            Deal with group 1 exception 
0000181C                           940  * 
0000181C  =0000181C                941  BRKPT   EQU     *                   Deal with breakpoint 
0000181C  48E7 FFFE                942          MOVEM.L D0-D7/A0-A6,-(A7)   Save all registers 
00001820  6100 0180                943          BSR     BR_CLR              Clear breakpoints in code 
00001824  4CDF 7FFF                944          MOVEM.L (A7)+,D0-D7/A0-A6   Restore registers 
00001828  6144                     945          BSR.S   GROUP2            Treat as group 2 exception 
0000182A  49FA 0361                946          LEA.L   MES11(PC),A4      Point to heading 
0000182E  6100 F866                947          BSR     HEADING           Print it 
00001832  6100 FE84                948          BSR     EX_DIS            Display saved registers 
00001836  6000 F828                949          BRA     WARM              Return to monitor 
0000183A                           950  * 
0000183A                           951  *       GROUP1 is called by address and bus error exceptions 
0000183A                           952  *       These are "turned into group 2" exceptions (eg TRAP) 
0000183A                           953  *       by modifying the stack frame saved by a group 1 exception 
0000183A                           954  * 
0000183A  48E7 8080                955  GROUP1  MOVEM.L D0/A0,-(A7)       Save working registers 
0000183E  206F 0012                956          MOVE.L  18(A7),A0         Get PC from group 1 stack frame 
00001842  302F 000E                957          MOVE.W  14(A7),D0         Get instruction from stack frame 
00001846  B060                     958          CMP.W   -(A0),D0          Now backtrack to find the "correct PC" 
00001848  670E                     959          BEQ.S   GROUP1A           by matching the op-code on the stack 
0000184A  B060                     960          CMP.W   -(A0),D0          with the code in the region of the 
0000184C  670A                     961          BEQ.S   GROUP1A           PC on the stack 
0000184E  B060                     962          CMP.W   -(A0),D0 
00001850  6706                     963          BEQ.S   GROUP1A 
00001852  B060                     964          CMP.W   -(A0),D0 
00001854  6702                     965          BEQ.S   GROUP1A 
00001856  5588                     966          SUBQ.L  #2,A0 
00001858  2F48 0012                967  GROUP1A MOVE.L  A0,18(A7)          Restore modified PC to stack frame 
0000185C  4CDF 0101                968          MOVEM.L (A7)+,D0/A0        Restore working registers 
00001860  4FEF 0008                969          LEA.L   8(A7),A7           Adjust stack pointer to group 1 type 
00001864  6108                     970          BSR.S   GROUP2             Now treat as group 1 exception 
00001866  6100 FE50                971          BSR     EX_DIS             Display contents of exception frame 
0000186A  6000 F7F4                972          BRA     WARM               Exit to monitor - no RTE from group 2 
0000186E                           973  * 
0000186E  =0000186E                974  GROUP2  EQU     *                 Deal with group 2 exceptions 
0000186E  48E7 FFFF                975          MOVEM.L A0-A7/D0-D7,-(A7) Save all registers on the stack 
00001872  303C 000E                976          MOVE.W  #14,D0            Transfer D0 - D7, A0 - A6 from 
00001876  41EE 005E                977          LEA.L   TSK_T(A6),A0      the stack to the display frame 
0000187A  20DF                     978  GROUP2A MOVE.L  (A7)+,(A0)+       Move a register from stack to frame 
0000187C  51C8 FFFC                979          DBRA    D0,GROUP2A        and repeat until D0-D7/A0-A6 moved 
00001880  4E6A                     980          MOVE.L  USP,A2            Get the user stack pointer and put it 
00001882  20CA                     981          MOVE.L  A2,(A0)+          in the A7 position in the frame 
00001884  201F                     982          MOVE.L  (A7)+,D0          Now transfer the SSP to the frame, 
00001886  0480 0000000A            983          SUB.L   #10,D0            remembering to account for the 
0000188C  20C0                     984          MOVE.L  D0,(A0)+          data pushed on the stack to this point 
0000188E  225F                     985          MOVE.L  (A7)+,A1          Copy TOS (return address) to A1 
00001890  30DF                     986          MOVE.W  (A7)+,(A0)+       Move SR to display frame 
00001892  201F                     987          MOVE.L  (A7)+,D0          Get PC in D0 
00001894  5580                     988          SUBQ.L  #2,D0             Move back to current instruction 
00001896  20C0                     989          MOVE.L  D0,(A0)+          Put adjusted PC in display frame 
00001898  4ED1                     990          JMP     (A1)              Return from subroutine 
0000189A                           991  * 
0000189A                           992  ************************************************************************* 
0000189A                           993  * 
0000189A                           994  *  GO executes a program either from a supplied address or 
0000189A                           995  *  by using the data in the display frame 
0000189A  6100 F91E                996  GO       BSR     PARAM               Get entry address (if any) 
0000189E  4A07                     997           TST.B   D7                  Test for error in input 
000018A0  6708                     998           BEQ.S   GO1                 If D7 zero then OK 
000018A2  49FA 0329                999           LEA.L   ERMES1(PC),A4       Else point to error message, 
000018A6  6000 F7DE               1000           BRA     PSTRING             print it and return 
000018AA  4A80                    1001  GO1      TST.L   D0                  If no address entered then get 
000018AC  670A                    1002           BEQ.S   GO2                 address from display frame 
000018AE  2D40 00A4               1003           MOVE.L  D0,TSK_T+70(A6)     Else save address in display frame 
000018B2  3D7C 0700 00A2          1004           MOVE.W  #$0700,TSK_T+68(A6) Store dummy status in frame 
000018B8  6006                    1005  GO2      BRA.S   RESTORE             Restore volatile environment and go 
000018BA                          1006  * 
000018BA  6100 007A               1007  GB       BSR     BR_SET              Same as go but presets breakpoints 
000018BE  60DA                    1008           BRA.S   GO                  Execute program 
000018C0                          1009  * 
000018C0                          1010  *        RESTORE moves the volatile environment from the display 
000018C0                          1011  *        frame and transfers it to the 68000's registers. This 
000018C0                          1012  *        re-runs a program suspended after an exception 
000018C0                          1013  * 
000018C0  47EE 005E               1014  RESTORE  LEA.L   TSK_T(A6),A3        A3 points to display frame 
000018C4  47EB 004A               1015           LEA.L   74(A3),A3           A3 now points to end of frame + 4 
000018C8  4FEF 0004               1016           LEA.L   4(A7),A7            Remove return address from stack 
000018CC  303C 0024               1017           MOVE.W  #36,D0              Counter for 37 words to be moved 
000018D0  3F23                    1018  REST1    MOVE.W  -(A3),-(A7)         Move word from display frame to stack 
000018D2  51C8 FFFC               1019           DBRA    D0,REST1            Repeat until entire frame moved 
000018D6  4CDF 00FF               1020           MOVEM.L (A7)+,D0-D7         Restore old data registers from stack 
000018DA  4CDF 7F00               1021           MOVEM.L (A7)+,A0-A6         Restore old address registers 
000018DE  4FEF 0008               1022           LEA.L   8(A7),A7            Except SSP/USP - so adjust stack 
000018E2  4E73                    1023           RTE                         Return from exception to run program 
000018E4                          1024  * 
000018E4  =000018E4               1025  TRACE    EQU     *                   TRACE exception (rudimentary version) 
000018E4  287A 02B5               1026           MOVE.L  MES12(PC),A4        Point to heading 
000018E8  6100 F7AC               1027           BSR     HEADING             Print it 
000018EC  6100 FF4C               1028           BSR     GROUP1              Save volatile environment 
000018F0  6100 FDC6               1029           BSR     EX_DIS              Display it 
000018F4  6000 F76A               1030           BRA     WARM                Return to monitor 
000018F8                          1031  * 
000018F8                          1032  ************************************************************************* 
000018F8                          1033  *  Breakpoint routines: BR_GET gets the address of a breakpoint and 
000018F8                          1034  *  puts it in the breakpoint table. It does not plant it in the code. 
000018F8                          1035  *  BR_SET plants all breakpoints in the code. NOBR removes one or all 
000018F8                          1036  *  breakpoints from the table. KILL removes breakpoints from the code. 
000018F8                          1037  * 
000018F8  6100 F8C0               1038  BR_GET   BSR     PARAM               Get breakpoint address in table 
000018FC  4A07                    1039           TST.B   D7                  Test for input error 
000018FE  6708                    1040           BEQ.S   BR_GET1             If no error then continue 
00001900  49FA 02CB               1041           LEA.L   ERMES1(PC),A4       Else display error 
00001904  6000 F780               1042           BRA     PSTRING             and return 
00001908  47EE 00A8               1043  BR_GET1  LEA.L   BP_TAB(A6),A3       A6 points to breakpoint table 
0000190C  2A40                    1044           MOVE.L  D0,A5               Save new BP address in A5 
0000190E  2C00                    1045           MOVE.L  D0,D6               and in D6 because D0 gets corrupted 
00001910  3A3C 0007               1046           MOVE.W  #7,D5               Eight entries to test 
00001914  201B                    1047  BR_GET2  MOVE.L  (A3)+,D0            Read entry from breakpoint table 
00001916  660C                    1048           BNE.S   BR_GET3             If not zero display existing BP 
00001918  4A86                    1049           TST.L   D6                  Only store a non-zero breakpoint 
0000191A  6710                    1050           BEQ.S   BR_GET4 
0000191C  274D FFFC               1051           MOVE.L  A5,-4(A3)           Store new breakpoint in table 
00001920  3695                    1052           MOVE.W  (A5),(A3)           Save code at BP address in table 
00001922  4286                    1053           CLR.L   D6                  Clear D6 to avoid repetition 
00001924  6100 F902               1054  BR_GET3  BSR     OUT8X               Display this breakpoint 
00001928  6100 F74C               1055           BSR     NEWLINE 
0000192C  47EB 0002               1056  BR_GET4  LEA.L   2(A3),A3            Step past stored op-code 
00001930  51CD FFE2               1057           DBRA    D5,BR_GET2          Repeat until all entries tested 
00001934  4E75                    1058           RTS                         Return 
00001936                          1059  * 
00001936  =00001936               1060  BR_SET   EQU     *                   Plant any breakpoints in user code 
00001936  41EE 00A8               1061           LEA.L   BP_TAB(A6),A0       A0 points to BP table 
0000193A  45EE 00A4               1062           LEA.L   TSK_T+70(A6),A2     A2 points to PC in display frame 
0000193E  2452                    1063           MOVE.L  (A2),A2             Now A2 contains value of PC 
00001940  303C 0007               1064           MOVE.W  #7,D0               Up to eight entries to plant 
00001944  2218                    1065  BR_SET1  MOVE.L  (A0)+,D1            Read breakpoint address from table 
00001946  670A                    1066           BEQ.S   BR_SET2             If zero then skip planting 
00001948  B28A                    1067           CMP.L   A2,D1               Don't want to plant BP at current PC 
0000194A  6706                    1068           BEQ.S   BR_SET2             location, so skip planting if same 
0000194C  2241                    1069           MOVE.L  D1,A1               Transfer BP address to address reg 
0000194E  32BC 4E4E               1070           MOVE.W  #TRAP_14,(A1)       Plant op-code for TRAP #14 in code 
00001952  41E8 0002               1071  BR_SET2  LEA.L   2(A0),A0            Skip past op-code field in table 
00001956  51C8 FFEC               1072           DBRA    D0,BR_SET1          Repeat until all entries tested 
0000195A  4E75                    1073           RTS 
0000195C                          1074  * 
0000195C  =0000195C               1075  NOBR     EQU     *                   Clear one or all breakpoints 
0000195C  6100 F85C               1076           BSR     PARAM               Get BP address (if any) 
00001960  4A07                    1077           TST.B   D7                  Test for input error 
00001962  6708                    1078           BEQ.S   NOBR1               If no error then skip abort 
00001964  49FA 0267               1079           LEA.L   ERMES1(PC),A4       Point to error message 
00001968  6000 F71C               1080           BRA     PSTRING             Display it and return 
0000196C  4A80                    1081  NOBR1    TST.L   D0                  Test for null address (clear all) 
0000196E  6720                    1082           BEQ.S   NOBR4               If no address then clear all entries 
00001970  2240                    1083           MOVE.L  D0,A1               Else just clear breakpoint in A1 
00001972  41EE 00A8               1084           LEA.L   BP_TAB(A6),A0       A0 points to BP table 
00001976  303C 0007               1085           MOVE.W  #7,D0               Up to eight entries to test 
0000197A  2218                    1086  NOBR2    MOVE.L  (A0)+,D1            Get entry and 
0000197C  41E8 0002               1087           LEA.L   2(A0),A0            skip past op-code field 
00001980  B289                    1088           CMP.L   A1,D1               Is this the one? 
00001982  6706                    1089           BEQ.S   NOBR3               If so go and clear entry 
00001984  51C8 FFF4               1090           DBRA    D0,NOBR2            Repeat until all tested 
00001988  4E75                    1091           RTS 
0000198A  42A8 FFFA               1092  NOBR3    CLR.L   -6(A0)              Clear address in BP table 
0000198E  4E75                    1093           RTS 
00001990  41EE 00A8               1094  NOBR4    LEA.L   BP_TAB(A6),A0       Clear all 8 entries in BP table 
00001994  303C 0007               1095           MOVE.W  #7,D0               Eight entries to clear 
00001998  4298                    1096  NOBR5    CLR.L   (A0)+               Clear breakpoint address 
0000199A  4258                    1097           CLR.W   (A0)+               Clear op-code field 
0000199C  51C8 FFFA               1098           DBRA    D0,NOBR5            Repeat until all done 
000019A0  4E75                    1099           RTS 
000019A2                          1100  * 
000019A2  =000019A2               1101  BR_CLR   EQU     *                   Remove breakpoints from code 
000019A2  41EE 00A8               1102           LEA.L   BP_TAB(A6),A0       A0 points to breakpoint table 
000019A6  303C 0007               1103           MOVE.W  #7,D0               Up to eight entries to clear 
000019AA  2218                    1104  BR_CLR1  MOVE.L  (A0)+,D1            Get address of BP in D1 
000019AC  2241                    1105           MOVE.L  D1,A1               and put copy in A1 
000019AE  4A81                    1106           TST.L   D1                  Test this breakpoint 
000019B0  6702                    1107           BEQ.S   BR_CLR2             If zero then skip BP clearing 
000019B2  3290                    1108           MOVE.W  (A0),(A1)           Else restore op-code 
000019B4  41E8 0002               1109  BR_CLR2  LEA.L   2(A0),A0            Skip past op-code field 
000019B8  51C8 FFF0               1110           DBRA    D0,BR_CLR1          Repeat until all tested 
000019BC  4E75                    1111           RTS 
000019BE                          1112  * 
000019BE                          1113  *  REG_MOD modifies a register in the display frame. The command 
000019BE                          1114  *  format is REG <reg> <value>. E.g. REG D3 1200 
000019BE                          1115  * 
000019BE  4281                    1116  REG_MOD  CLR.L   D1                  D1 to hold name of register 
000019C0  41EE 0048               1117           LEA.L   BUFFPT(A6),A0       A0 contains address of buffer pointer 
000019C4  2050                    1118           MOVE.L  (A0),A0             A0 now points to next char in buffer 
000019C6  1218                    1119           MOVE.B  (A0)+,D1            Put first char of name in D1 
000019C8  E159                    1120           ROL.W   #8,D1               Move char one place left 
000019CA  1218                    1121           MOVE.B  (A0)+,D1            Get second char in D1 
000019CC  41E8 0001               1122           LEA.L   1(A0),A0            Move pointer past space in buffer 
000019D0  2D48 0048               1123           MOVE.L  A0,BUFFPT(A6)       Update buffer pointer 
000019D4  4282                    1124           CLR.L   D2                  D2 is the character pair counter 
000019D6  41FA 01CC               1125           LEA.L   REGNAME(PC),A0      A0 points to string of character pairs 
000019DA  43D0                    1126           LEA.L   (A0),A1             A1 also points to string 
000019DC  B258                    1127  REG_MD1  CMP.W   (A0)+,D1            Compare a char pair with input 
000019DE  6712                    1128           BEQ.S   REG_MD2             If match then exit loop 
000019E0  5282                    1129           ADD.L   #1,D2               Else increment match counter 
000019E2  B4BC 00000013           1130           CMP.L   #19,D2              Test for end of loop 
000019E8  66F2                    1131           BNE     REG_MD1             Continue until all pairs matched 
000019EA  49FA 01E1               1132           LEA.L   ERMES1(PC),A4       If here then error 
000019EE  6000 F696               1133           BRA     PSTRING             Display error and return 
000019F2  43EE 005E               1134  REG_MD2  LEA.L   TSK_T(A6),A1        A1 points to display frame 
000019F6  E582                    1135           ASL.L   #2,D2               Multiply offset by 4 (4 bytes/entry) 
000019F8  B4BC 00000048           1136           CMP.L   #72,D2              Test for address of PC 
000019FE  6602                    1137           BNE.S   REG_MD3             If not PC then all is OK 
00001A00  5582                    1138           SUB.L   #2,D2               else dec PC pointer as Sr is a word 
00001A02  45F1 2000               1139  REG_MD3  LEA.L   (A1,D2),A2          Calculate address of entry in disptable 
00001A06  2012                    1140           MOVE.L  (A2),D0             Get old contents 
00001A08  6100 F81E               1141           BSR     OUT8X               Display them 
00001A0C  6100 F668               1142           BSR     NEWLINE 
00001A10  6100 F7A8               1143           BSR     PARAM               Get new data 
00001A14  4A07                    1144           TST.B   D7                  Test for input error 
00001A16  6708                    1145           BEQ.S   REG_MD4             If no error then go and store data 
00001A18  49FA 01B3               1146           LEA.L   ERMES1(PC),A4       Else point to error message 
00001A1C  6000 F668               1147           BRA     PSTRING             print it and return 
00001A20  B4BC 00000044           1148  REG_MD4  CMP.L   #68,D2              If this address is the SR then 
00001A26  6704                    1149           BEQ.S   REG_MD5             we have only a word to store 
00001A28  2480                    1150           MOVE.L  D0,(A2)             Else store new data in display frame 
00001A2A  4E75                    1151           RTS 
00001A2C  3480                    1152  REG_MD5  MOVE.W  D0,(A2)             Store SR (one word) 
00001A2E  4E75                    1153           RTS 
00001A30                          1154  * 
00001A30                          1155  ************************************************************************* 
00001A30                          1156  * 
00001A30  =00001A30               1157  X_UN    EQU     *                 Uninitialized exception vector routine 
00001A30  49FA 0201               1158          LEA.L   ERMES6(PC),A4     Point to error message 
00001A34  6100 F650               1159          BSR     PSTRING           Display it 
00001A38  6100 FC7E               1160          BSR     EX_DIS            Display registers 
00001A3C  6000 F622               1161          BRA     WARM              Abort 
00001A40                          1162  * 
00001A40                          1163  ************************************************************************* 
00001A40                          1164  * 
00001A40                          1165  *  All strings and other fixed parameters here 
00001A40                          1166  * 
00001A40= 54 53 42 55 47 20 ...   1167  BANNER   DC.B     'TSBUG 2 Version 23.07.86',0,0
00001A5A= 4D 6F 64 69 66 69 ...   1168  MODIFY    DC.B   'Modified by Eugene A. Rockey Jr. Jan.05.2010',0,0
00001A88= 66 6F 72 20 75 73 ...   1169  WHY      DC.B     'for use with the M68000 Minimal Computer Configuration',0,0 
00001AC0= 55 6E 69 76 65 72 ...   1170  WHERE    DC.B     'University of Louisville',0,0
00001ADA= 2A 20 49 4D 50 4F ...   1171  ADDRE  DC.B   '* IMPORTANT, TURN ON CAPS LOCK  *',0,0
00001AFD= 0D 0A 54 53 32 4D ...   1172  CRLF     DC.B     CR,LF,'TS2MON >',0 
00001B08= 0D 0A 53 31 00 00       1173  HEADER   DC.B     CR,LF,'S','1',0,0 
00001B0E= 53 39 20 20 00 00       1174  TAIL     DC.B     'S9  ',0,0 
00001B14= 20 53 52 20 20 3D ...   1175  MES1     DC.B     ' SR  =  ',0 
00001B1D= 20 50 43 20 20 3D ...   1176  MES2     DC.B     ' PC  =  ',0 
00001B26= 20 53 53 20 20 3D ...   1177  MES2A    DC.B     ' SS  =  ',0 
00001B2F= 20 20 44 61 74 61 ...   1178  MES3     DC.B     '  Data reg       Address reg',0,0 
00001B4D= 20 20 20 20 20 20 ...   1179  MES4     DC.B     '        ',0,0 
00001B57= 42 75 73 20 65 72 ...   1180  MES8     DC.B     'Bus error   ',0,0 
00001B65= 41 64 64 72 65 73 ...   1181  MES9     DC.B     'Address error   ',0,0 
00001B77= 49 6C 6C 65 67 61 ...   1182  MES10    DC.B     'Illegal instruction ',0,0 
00001B8D= 42 72 65 61 6B 70 ...   1183  MES11    DC.B     'Breakpoint  ',0,0 
00001B9B= 54 72 61 63 65 20 ...   1184  MES12    DC.B     'Trace   ',0 
00001BA4= 44 30 44 31 44 32 ...   1185  REGNAME  DC.B     'D0D1D2D3D4D5D6D7' 
00001BB4= 41 30 41 31 41 32 ...   1186           DC.B     'A0A1A2A3A4A5A6A7' 
00001BC4= 53 53 53 52             1187           DC.B     'SSSR' 
00001BC8= 50 43 20 20 00          1188           DC.B     'PC  ',0 
00001BCD= 4E 6F 6E 2D 76 61 ...   1189  ERMES1   DC.B     'Non-valid hexadecimal input  ',0 
00001BEB= 49 6E 76 61 6C 69 ...   1190  ERMES2   DC.B     'Invalid command  ',0 
00001BFD= 4C 6F 61 64 69 6E ...   1191  ERMES3   DC.B     'Loading error',0 
00001C0B= 54 61 62 6C 65 20 ...   1192  ERMES4   DC.B     'Table full  ',0,0 
00001C19= 42 72 65 61 6B 70 ...   1193  ERMES5   DC.B     'Breakpoint not active   ',0,0 
00001C33= 55 6E 69 6E 69 74 ...   1194  ERMES6   DC.B     'Uninitialized exception ',0,0 
00001C4D= 4A 55 4D 50 20 3C ...   1195  JUMPHELP DC.B     'JUMP <address> causes execution to begin at <address>',0      
00001C83= 20 52 61 6E 67 65 ...   1196  ERMES7   DC.B     ' Range error',0
00001C90= 55 53 45 52 00          1197  UNAME    DC.B     'USER', 0
00001C95= 50 41 53 53 57 4F ...   1198  PWORD    DC.B     'PASSWORD',0
00001C9E= 45 6E 74 65 72 20 ...   1199  LOGINM1  DC.B     'Enter username: ', 0
00001CAF= 45 6E 74 65 72 20 ...   1200  LOGINM2  DC.B     'Enter password: ', 0
00001CC0= 49 6E 63 6F 72 72 ...   1201  USRERR   DC.B     'Incorrect username', 0
00001CD3= 43 6F 72 72 65 63 ...   1202  USRSUC   DC.B     'Correct Username', 0
00001CE4= 49 6E 63 6F 72 72 ...   1203  PWERR   DC.B     'Incorrect password', 0
00001CF7= 43 6F 72 72 65 63 ...   1204  PWSUC    DC.B     'Correct Password', 0
00001D08                          1205   
00001D08                          1206  * 
00001D08                          1207  *  COMTAB is the built-in command table. All entries are made up of 
00001D08                          1208  *         a string length + number of characters to match + the string 
00001D08                          1209  *         plus the address of the command relative to COMTAB 
00001D08                          1210  * 
00001D08= 04 04                   1211  COMTAB   DC.B     4,4              JUMP <address> causes execution to 
00001D0A= 4A 55 4D 50             1212           DC.B     'JUMP'           begin at <address> 
00001D0E= FFFFF528                1213           DC.L     JUMP-COMTAB                                           
00001D12= 08 03                   1214           DC.B     8,3              MEMORY <address> examines contents of 
00001D14= 4D 45 4D 4F 52 59 ...   1215           DC.B     'MEMORY  '       <address> and allows them to be changed 
00001D1C= FFFFF53E                1216           DC.L     MEMORY-COMTAB 
00001D20= 04 02                   1217           DC.B     4,2              LOAD <string> loads S1/S2 records 
00001D22= 4C 4F 41 44             1218           DC.B     'LOAD'           from the host. <string> is sent to host 
00001D26= FFFFF59E                1219           DC.L     LOAD-COMTAB 
00001D2A= 04 02                   1220           DC.B     4,2              DUMP <string> sends S1 records to the 
00001D2C= 44 55 4D 50             1221           DC.B     'DUMP'           host and is preceeded by <string>. 
00001D30= FFFFF672                1222           DC.L     DUMP-COMTAB 
00001D34= 04 03                   1223           DC.B     4,3              TRAN enters the transparant mode 
00001D36= 54 52 41 4E             1224           DC.B     'TRAN'           and is exited by ESC,E. 
00001D3A= FFFFF72E                1225           DC.L     TM-COMTAB 
00001D3E= 04 02                   1226           DC.B     4,2              NOBR <address> removes the breakpoint 
00001D40= 4E 4F 42 52             1227           DC.B     'NOBR'           at <address> from the BP table. If 
00001D44= FFFFFC54                1228           DC.L     NOBR-COMTAB      no address is given all BPs are removed. 
00001D48= 04 02                   1229           DC.B     4,2              DISP displays the contents of the 
00001D4A= 44 49 53 50             1230           DC.B     'DISP'           pseudo registers in TSK_T. 
00001D4E= FFFFF9B0                1231           DC.L     EX_DIS-COMTAB 
00001D52= 04 02                   1232           DC.B    4,2               GO <address> starts program execution 
00001D54= 47 4F 20 20             1233           DC.B    'GO  '            at <address> and loads regs from TSK_T 
00001D58= FFFFFB92                1234           DC.L    GO-COMTAB 
00001D5C= 04 02                   1235           DC.B    4,2               BRGT puts a breakpoint in the BP 
00001D5E= 42 52 47 54             1236           DC.B    'BRGT'            table - but not in the code 
00001D62= FFFFFBF0                1237           DC.L    BR_GET-COMTAB 
00001D66= 04 02                   1238           DC.B    4,2               PLAN puts the breakpoints in the code 
00001D68= 50 4C 41 4E             1239           DC.B    'PLAN' 
00001D6C= FFFFFC2E                1240           DC.L    BR_SET-COMTAB 
00001D70= 04 04                   1241           DC.B    4,4               KILL removes breakpoints from the code 
00001D72= 4B 49 4C 4C             1242           DC.B    'KILL' 
00001D76= FFFFFC9A                1243           DC.L    BR_CLR-COMTAB 
00001D7A= 04 02                   1244           DC.B    4,2               GB <address> sets breakpoints and 
00001D7C= 47 42 20 20             1245           DC.B    'GB  '            then calls GO. 
00001D80= FFFFFBB2                1246           DC.L    GB-COMTAB 
00001D84= 04 03                   1247           DC.B    4,3               REG <reg> <value> loads <value> 
00001D86= 52 45 47 20             1248           DC.B    'REG '            into <reg> in TASK_T. Used to preset 
00001D8A= FFFFFCB6                1249           DC.L    REG_MOD-COMTAB    registers before a GO or GB 
00001D8E= 04 04                   1250           DC.B    4,4               REG <reg> <value> loads <value> 
00001D90= 48 45 4C 50             1251           DC.B    'HELP'            into <reg> in TASK_T. Used to preset 
00001D94= FFFFFA2E                1252           DC.L    HELP-COMTAB       registers before a GO or GB 
00001D98= 00 00                   1253           DC.B    0,0 
00001D9A                          1254  * 
00001D9A                          1255  ************************************************************************* 
00001D9A                          1256  * 
00001D9A                          1257  *  This is a list of the information needed to setup the DCBs 
00001D9A                          1258  * 
00001D9A  =00001D9A               1259  DCB_LST  EQU     * 
00001D9A= 43 4F 4E 5F 49 4E ...   1260  DCB1     DC.B    'CON_IN  '          Device name (8 bytes) 
00001DA2= 000014D4 00008001       1261           DC.L    CON_IN,ACIA_1       Address of driver routine, device 
00001DAA= 0002                    1262           DC.W    2                   Number of words in parameter field 
00001DAC= 43 4F 4E 5F 4F 55 ...   1263  DCB2     DC.B    'CON_OUT ' 
00001DB4= 000014EA 00008001       1264           DC.L    CON_OUT,ACIA_1 
00001DBC= 0002                    1265           DC.W    2 
00001DBE= 41 55 58 5F 49 4E ...   1266  DCB3     DC.B    'AUX_IN  ' 
00001DC6= 00001500 00008001       1267           DC.L    AUX_IN,ACIA_2 
00001DCE= 0002                    1268           DC.W    2 
00001DD0= 41 55 58 5F 4F 55 ...   1269  DCB4     DC.B    'AUX_OUT ' 
00001DD8= 00001512 00008001       1270           DC.L    AUX_OUT,ACIA_2 
00001DE0= 0002                    1271           DC.W    2 
00001DE2= 42 55 46 46 5F 49 ...   1272  DCB5     DC.B    'BUFF_IN ' 
00001DEA= 00001584 000002D8       1273           DC.L    BUFF_IN,BUFFER 
00001DF2= 0002                    1274           DC.W    2 
00001DF4= 42 55 46 46 5F 4F ...   1275  DCB6     DC.B    'BUFF_OUT' 
00001DFC= 00001590 000002D8       1276           DC.L    BUFF_OT,BUFFER 
00001E04= 0002                    1277           DC.W    2 
00001E06                          1278  * 
00001E06                          1279  ************************************************************************* 
00001E06                          1280  * 
00001E06                          1281  *  DCB structure 
00001E06                          1282  * 
00001E06                          1283  *              ----------------------- 
00001E06                          1284  *       0 ->   | DCB  name           | 
00001E06                          1285  *              |---------------------| 
00001E06                          1286  *       8 ->   | Device driver       | 
00001E06                          1287  *              |---------------------| 
00001E06                          1288  *      12 ->   | Device address      | 
00001E06                          1289  *              |---------------------| 
00001E06                          1290  *      16 ->   |Size of param block  | 
00001E06                          1291  *              |---------------------| --- 
00001E06                          1292  *      18 ->   |      Status         |   | 
00001E06                          1293  *              | logical  | physical |   | S 
00001E06                          1294  *              |---------------------|   | 
00001E06                          1295  *              .                     .   . 
00001E06                          1296  *              |---------------------| --- 
00001E06                          1297  *    18+S ->   | Pointer to next DCB | 
00001E06                          1298  * 
00001E06                          1299           END RESET 

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ACIA_1              8001
ACIA_2              8001
ADDRE               1ADA
ADD_ER              180E
ADR_DAT             1284
AUX_IN              1500
AUX_IN1             1506
AUX_OT1             1518
AUX_OUT             1512
BANNER              1A40
BP_TAB              A8
BRKPT               181C
BR_CLR              19A2
BR_CLR1             19AA
BR_CLR2             19B4
BR_GET              18F8
BR_GET1             1908
BR_GET2             1914
BR_GET3             1924
BR_GET4             192C
BR_SET              1936
BR_SET1             1944
BR_SET2             1952
BS                  8
BUFFEND             47
BUFFER              2D8
BUFFPT              48
BUFF_IN             1584
BUFF_OT             1590
BUS_ER              1800
BYTE                119E
CN_IVEC             56
CN_OVEC             5A
COMTAB              1D08
CON_IN              14D4
CON_OUT             14EA
CR                  D
CRLF                1AFD
CTRL_A              1
DATA                4800
DCB1                1D9A
DCB2                1DAC
DCB3                1DBE
DCB4                1DD0
DCB5                1DE2
DCB6                1DF4
DCB_LST             1D9A
DELAY               1422
DELAY1              142C
DUMP                137A
DUMP1               138A
DUMP2               1396
DUMP3               13AC
DUMP4               13C0
DUMP5               13CE
DUMP6               13E8
DUMP7               140C
ECHO                50
ERMES1              1BCD
ERMES2              1BEB
ERMES3              1BFD
ERMES4              1C0B
ERMES5              1C19
ERMES6              1C33
ERMES7              1C83
ESC                 1B
EXEC1               1126
EXEC2               1136
EXECUTE             1114
EX_D1               16CA
EX_DIS              16B8
FIRST               D8
FOO1                15F6
FOO10               1662
FOO11               166E
FOO12               167A
FOO13               1686
FOO14               1692
FOO15               169E
FOO16               16AA
FOO17               16B6
FOO2                1602
FOO3                160E
FOO4                161A
FOO5                1626
FOO6                1632
FOO7                163E
FOO8                164A
FOO9                1656
GB                  18BA
GETCH2              1548
GETCH3              1550
GETCHAR             1524
GETLINE             109C
GETLN2              10A6
GETLN3              10C0
GETLN4              10CA
GETLN5              10CE
GO                  189A
GO1                 18AA
GO2                 18B8
GROUP1              183A
GROUP1A             1858
GROUP2              186E
GROUP2A             187A
HEADER              1B08
HEADING             1096
HELP                1736
HEX                 1180
HEX_OK              119C
IL_ER               17EA
IO_OPEN             159E
IO_REQ              14C2
JUMP                1230
JUMP1               123E
JUMPHELP            1C4D
LF                  A
LNBUFF              8
LOAD                12A6
LOAD1               12D2
LOAD2               12E2
LOAD3               12FC
LOAD4               1316
LOAD5               1324
LOAD6               1326
LOAD6A              134A
LOAD7               135C
LOAD8               1372
LOGIN               1746
LOGIN1              175E
LOGIN2              179E
LOGINM1             1C9E
LOGINM2             1CAF
LONGWD              11B4
MAXCHR              40
MEM1                1250
MEM2                126E
MEM3                1282
MEMORY              1246
MES1                1B14
MES10               1B77
MES11               1B8D
MES12               1B9B
MES2                1B1D
MES2A               1B26
MES3                1B2F
MES4                1B4D
MES8                1B57
MES9                1B65
MODIFY              1A5A
NEWLINE             1076
NOBR                195C
NOBR1               196C
NOBR2               197A
NOBR3               198A
NOBR4               1990
NOBR5               1998
NOT_HEX             1198
NO_EXT              105C
NUL                 0
OPEN1               15A6
OPEN2               15AE
OPEN3               15BC
OPEN4               15D2
OUT1X               11FE
OUT1X1              1210
OUT2X               1218
OUT4X               1220
OUT8X               1228
PARAM               11BA
PARAM1              11C2
PARAM3              11E6
PARAM4              11EA
PARAM5              11F6
PARAM6              11FA
PARAMTR             4C
PS1                 1088
PS2                 1092
PSPACE              1298
PSTRING             1086
PUTASK              156C
PUTCHAR             1554
PWERR               1CE4
PWORD               1C95
PWSUC               1CF7
RANGE               1412
REGNAME             1BA4
REG_MD1             19DC
REG_MD2             19F2
REG_MD3             1A02
REG_MD4             1A20
REG_MD5             1A2C
REG_MOD             19BE
RESET               1000
REST1               18D0
RESTORE             18C0
SEARCH              1140
SET_DCB             1478
SPACE               20
SRCH2               115A
SRCH3               115E
SRCH4               1166
SRCH6               1170
SRCH7               117A
STACK               4400
ST_DCB1             1488
ST_DCB2             148C
TAIL                1B0E
TIDY                10D2
TIDY1               10D8
TIDY2               10E4
TIDY3               10EE
TIDY4               10F8
TIDY5               1102
TIDY6               110E
TM                  1436
TM1                 1442
TRACE               18E4
TRAP_0              15EA
TRAP_14             4E4E
TSK_T               5E
UNAME               1C90
UPASS               17E0
USRERR              1CC0
USRSUC              1CD3
UTAB                52
U_CASE              51
WAIT                57
WARM                1060
WHERE               1AC0
WHY                 1A88
WORD                11AE
WRONG               17CC
WRONGPW             17D6
X_BASE              4000
X_SET               15D8
X_SET2              15E0
X_UN                1A30
