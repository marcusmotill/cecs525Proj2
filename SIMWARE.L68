00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.15.04
Created On: 9/24/15 6:50:46 PM

00000000                             1  *        TSBUG2 - 68000 monitor - version of 05 January 2010 
00000000                             2  
00000000                             3      ORG      $0
00000000= 00004400 00001000 ...      4           DC.L STACK,RESET,BUS_ER,ADD_ER,IL_ER,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN
00000040= 00001B04 00001B04 ...      5           DC.L X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN
00000080= 000015C6 00001B04 ...      6           DC.L  TRAP_0,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN
000000C4= 00001B04 00001B04 ...      7           DC.L X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN
00000104= 00001B04 00001B04 ...      8           DC.L X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN
00000144= 00001B04 00001B04 ...      9           DC.L X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN
00000184= 00001B04 00001B04 ...     10           DC.L X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN
000001C4= 00001B04 00001B04 ...     11           DC.L X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN
00000204= 00001B04 00001B04 ...     12           DC.L X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN
00000244= 00001B04 00001B04 ...     13           DC.L X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN
00000284= 00001B04 00001B04 ...     14           DC.L X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN
000002C4= 00001B04 00001B04 ...     15           DC.L X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN
00000304= 00001B04 00001B04 ...     16           DC.L X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN
00000344= 00001B04 00001B04 ...     17           DC.L X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN
00000384= 00001B04 00001B04 ...     18           DC.L X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN
000003C4= 00001B04 00001B04 ...     19           DC.L X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN
00000404                            20  *                                   Symbol equates 
00000404  =00000008                 21  BS       EQU      $08               Back_space 
00000404  =0000000D                 22  CR       EQU      $0D               Carriage_return 
00000404  =00000000                 23  NUL      EQU      $00               NUL character
00000404  =0000000A                 24  LF       EQU      $0A               Line_feed 
00000404  =00000020                 25  SPACE    EQU      $20               Space 
00000404  =00000057                 26  WAIT     EQU      'W'               Wait character (to suspend output) 
00000404  =0000001B                 27  ESC      EQU      $1B               ASCII escape character (used by TM) 
00000404  =00000001                 28  CTRL_A   EQU      $01               Control_A forces return to monitor 
00000404                            29  *                                   Device addresses 
00000404  =00004400                 30  STACK    EQU      $4400             Stack_pointer
00000404  =00008001                 31  ACIA_1   EQU      $8001             Console ACIA control 
00000404  =00008001                 32  ACIA_2   EQU      ACIA_1            Auxilary ACIA control 
00000404  =00004000                 33  X_BASE   EQU      $4000             Start of exception vector table 
00000404  =00004E4E                 34  TRAP_16  EQU      $4E4E             Code for TRAP #14 
00000404  =00000040                 35  MAXCHR   EQU      64                Length of input line buffer  
00000404                            36  * 
00000404  =00004800                 37  DATA     EQU      $4800             Data origin 
00000404                            38  LNBUFF   DS.B     MAXCHR            Input line buffer
00000444  =00000443                 39  BUFFEND  EQU      LNBUFF+MAXCHR-1   End of line buffer 
00000444                            40  BUFFPT   DS.L     1                 Pointer to line buffer 
00000448                            41  PARAMTR  DS.L     1                 Last parameter from line buffer 
0000044C                            42  ECHO     DS.B     1                 When clear this enable input echo 
0000044D                            43  U_CASE   DS.B     1                 Flag for upper case conversion 
0000044E                            44  UTAB     DS.L     1                 Pointer to user command table 
00000452                            45  CN_IVEC  DS.L     1                 Pointer to console input DCB 
00000456                            46  CN_OVEC  DS.L     1                 Pointer to console output DCB 
0000045A                            47  TSK_T    DS.W     37                Frame for D0-D7, A0-A6, USP, SSP, SW, PC 
000004A4                            48  BP_TAB   DS.W     24                Breakpoint table 
000004D4                            49  FIRST    DS.B     512               DCB area 
000006D4                            50  BUFFER   DS.B     256               256 bytes for I/O buffer 
000007D4= 00004000                  51  MIN_RAM  DC.L     $004000
000007D8= 00004100                  52  MAX_RAM  DC.L     $004100
000007DC                            53  * 
000007DC                            54  ************************************************************************* 
000007DC                            55  * 
000007DC                            56  *  This is the main program which assembles a command in the line 
000007DC                            57  *  buffer, removes leading/embedded spaces and interprets it by matching 
000007DC                            58  *  it with a command in the user table or the built-in table COMTAB 
000007DC                            59  *  All variables are specified with respect to A6 
000007DC                            60  *
00001000                            61           ORG      $1000             Monitor Origin
00001000  =00001000                 62  RESET:   EQU      *
00001000  4DF8 4800                 63           LEA.L    DATA,A6           A6 points to data area 
00001004  2D4E 0492                 64      MOVE.L    A6,TSK_T+56(A6)   initialize A6 in the regster Frame
00001008  42AE 044E                 65           CLR.L    UTAB(A6)          Reset pointer to user extension table 
0000100C  1D7C 0001 044C            66           MOVE.B   #1,ECHO(A6)       Set automatic character echo 
00001012  422E 044D                 67           CLR.B    U_CASE(A6)        Clear case conversion flag (UC<-LC) 
00001016  6100 059C                 68      BSR.L     X_SET         what change did i do here
0000101A  6100 0454                 69           BSR.L    SET_DCB           Setup DCB table in RAM
0000101E  614E                      70           BSR.S    NEWLINE
00001020  49FA 0AF2                 71           LEA.L    BANNER(PC),A4    
00001024  6158                      72           BSR.S    PSTRING
00001026  6146                      73           BSR.S    NEWLINE           
00001028  49FA 0B04                 74      LEA.L     MODIFY(PC),A4
0000102C  6150                      75           BSR.S    PSTRING
0000102E  613E                      76           BSR.S    NEWLINE
00001030  49FA 0B2A                 77      LEA.L     WHY(PC),A4
00001034  6148                      78           BSR.S    PSTRING
00001036  6136                      79           BSR.S    NEWLINE
00001038  49FA 0B5A                 80      LEA.L     WHERE(PC),A4
0000103C  6140                      81           BSR.S    PSTRING
0000103E  612E                      82           BSR.S    NEWLINE
00001040  207C 00003000             83           MOVE.L   #$3000,A0         A0 points to extension ROM 
00001046  2010                      84           MOVE.L   (A0),D0           Read first longword in extension ROM 
00001048  B0BC 524F4D32             85           CMP.L    #'ROM2',D0        If extension begins with 'ROM2' then 
0000104E  6604                      86           BNE.S    NO_EXT            call the subroutine at EXT_ROM+8 
00001050  4EA8 0008                 87           JSR      8(A0)             else continue 
00001054  4E71                      88  NO_EXT:  NOP                        Two NOPs to allow for a future 
00001056  4E71                      89           NOP                        call to an initialization routine 
00001058  4EB9 00001748             90           JSR      LOGIN
0000105E  4287                      91  WARM:    CLR.L    D7                Warm entry point - clear error flag 
00001060  610C                      92           BSR.S    NEWLINE           Print a newline 
00001062  6130                      93           BSR.S    GETLINE           Get a command line 
00001064  6100 0064                 94           BSR      TIDY              Tidy up input buffer contents 
00001068  6100 00A2                 95           BSR      EXECUTE           Interpret command 
0000106C  60F0                      96           BRA      WARM              Repeat indefinitely 
0000106E                            97  * 
0000106E                            98  ************************************************************************* 
0000106E                            99  * 
0000106E                           100  *  Some initialization and basic routines 
0000106E                           101  * 
0000106E                           102  * 
0000106E  =0000106E                103  NEWLINE  EQU      *                 Move cursor to start of newline 
0000106E  48E7 0008                104           MOVEM.L  A4,-(A7)          Save A4 
00001072  49FA 0B3A                105           LEA.L    CRLF(PC),A4       Point to CR/LF string 
00001076  6106                     106           BSR.S    PSTRING           Print it 
00001078  4CDF 1000                107           MOVEM.L  (A7)+,A4          Restore A4 
0000107C  4E75                     108           RTS                        Return 
0000107E                           109  * 
0000107E  =0000107E                110  PSTRING  EQU      *                 Display the string pointed at by A4 
0000107E  2F00                     111           MOVE.L   D0,-(A7)          Save D0 
00001080  101C                     112  PS1      MOVE.B   (A4)+,D0          Get character to be printed 
00001082  6706                     113           BEQ.S    PS2               If null then return 
00001084  6100 04C6                114           BSR      PUTCHAR           Else print it 
00001088  60F6                     115           BRA      PS1               Continue 
0000108A  201F                     116  PS2      MOVE.L   (A7)+,D0          Restore D0 and exit 
0000108C  4E75                     117           RTS 
0000108E                           118  * 
0000108E  61DE                     119  HEADING  BSR      NEWLINE           Same as PSTRING but with newline 
00001090  61EC                     120           BSR      PSTRING 
00001092  60DA                     121           BRA      NEWLINE 
00001094                           122  * 
00001094                           123  ************************************************************************* 
00001094                           124  * 
00001094                           125  *  GETLINE  inputs a string of characters into a line buffer 
00001094                           126  *           A3 points to next free entry in line buffer 
00001094                           127  *           A2 points to end of buffer 
00001094                           128  *           A1 points to start of buffer 
00001094                           129  *           D0 holds character to be stored 
00001094                           130  * 
00001094  43EE 0404                131  GETLINE  LEA.L    LNBUFF(A6),A1     A1 points to start of line buffer 
00001098  47D1                     132           LEA.L    (A1),A3           A3 points to start (initially) 
0000109A  45E9 0040                133           LEA.L    MAXCHR(A1),A2     A2 points to end of buffer 
0000109E  6100 047C                134  GETLN2   BSR      GETCHAR           Get a character 
000010A2  B03C 0001                135           CMP.B    #CTRL_A,D0        If control_A then reject this line 
000010A6  671E                     136           BEQ.S    GETLN5            and get another line 
000010A8  B03C 0008                137           CMP.B    #BS,D0            If back_space then move back pointer 
000010AC  660A                     138           BNE.S    GETLN3            Else skip past wind-back routine 
000010AE  B7C9                     139           CMP.L    A1,A3             First check for empty buffer 
000010B0  67EC                     140           BEQ      GETLN2            If buffer empty then continue 
000010B2  47EB FFFF                141           LEA      -1(A3),A3         Else decrement buffer pointer 
000010B6  60E6                     142           BRA      GETLN2            and continue with next character 
000010B8  16C0                     143  GETLN3   MOVE.B   D0,(A3)+          Store character and update pointer 
000010BA  B03C 000D                144           CMP.B    #CR,D0            Test for command terminator 
000010BE  6602                     145           BNE.S    GETLN4            If not CR then skip past exit 
000010C0  60AC                     146           BRA      NEWLINE           Else new line before next operation 
000010C2  B7CA                     147  GETLN4   CMP.L    A2,A3             Test for buffer overflow 
000010C4  66D8                     148           BNE      GETLN2            If buffer not full then continue 
000010C6  61A6                     149  GETLN5   BSR      NEWLINE           Else move to next line and 
000010C8  60CA                     150           BRA      GETLINE           repeat this routine 
000010CA                           151  * 
000010CA                           152  ************************************************************************* 
000010CA                           153  * 
000010CA                           154  *  TIDY cleans up the line buffer by removing leading spaces and multiple 
000010CA                           155  *       spaces between parameters. At the end of TIDY, BUFFPT points to 
000010CA                           156  *       the first parameter following the command. 
000010CA                           157  *       A0 = pointer to line buffer. A1 = pointer to cleaned up buffer 
000010CA                           158  * 
000010CA  41EE 0404                159  TIDY     LEA.L    LNBUFF(A6),A0     A0 points to line buffer 
000010CE  43D0                     160           LEA.L    (A0),A1           A1 points to start of line buffer 
000010D0  1018                     161  TIDY1    MOVE.B   (A0)+,D0          Read character from line buffer 
000010D2  B03C 0020                162           CMP.B    #SPACE,D0         Repeat until the first non-space 
000010D6  67F8                     163           BEQ      TIDY1             character is found 
000010D8  41E8 FFFF                164           LEA.L    -1(A0),A0         Move pointer back to first char 
000010DC  1018                     165  TIDY2    MOVE.B   (A0)+,D0          Move the string left to remove 
000010DE  12C0                     166           MOVE.B   D0,(A1)+          any leading spaces 
000010E0  B03C 0020                167           CMP.B    #SPACE,D0         Test for embedded space 
000010E4  660A                     168           BNE.S    TIDY4             If not space then test for EOL 
000010E6  0C18 0020                169  TIDY3    CMP.B    #SPACE,(A0)+      If space skip multiple embedded 
000010EA  67FA                     170           BEQ      TIDY3             spaces 
000010EC  41E8 FFFF                171           LEA.L    -1(A0),A0         Move back pointer 
000010F0  B03C 000D                172  TIDY4    CMP.B    #CR,D0            Test for end_of_line (EOL) 
000010F4  66E6                     173           BNE      TIDY2             If not EOL then read next char 
000010F6  41EE 0404                174           LEA.L    LNBUFF(A6),A0     Restore buffer pointer 
000010FA  0C10 000D                175  TIDY5    CMP.B    #CR,(A0)          Test for EOL 
000010FE  6706                     176           BEQ.S    TIDY6             If EOL then exit 
00001100  0C18 0020                177           CMP.B    #SPACE,(A0)+      Test for delimiter 
00001104  66F4                     178           BNE      TIDY5             Repeat until delimiter or EOL 
00001106  2D48 0444                179  TIDY6    MOVE.L   A0,BUFFPT(A6)     Update buffer pointer 
0000110A  4E75                     180           RTS 
0000110C                           181  * 
0000110C                           182  ************************************************************************* 
0000110C                           183  * 
0000110C                           184  *  EXECUTE matches the first command in the line buffer with the 
0000110C                           185  *  commands in a command table. An external table pointed at by 
0000110C                           186  *  UTAB is searched first and then the built-in table, COMTAB. 
0000110C                           187  * 
0000110C  4AAE 044E                188  EXECUTE  TST.L    UTAB(A6)          Test pointer to user table 
00001110  670C                     189           BEQ.S    EXEC1             If clear then try built-in table 
00001112  266E 044E                190           MOVE.L   UTAB(A6),A3       Else pick up pointer to user table 
00001116  6120                     191           BSR.S    SEARCH            Look for command in user table 
00001118  6404                     192           BCC.S    EXEC1             If not found then try internal table 
0000111A  2653                     193           MOVE.L   (A3),A3           Else get absolute address of command 
0000111C  4ED3                     194           JMP      (A3)              from user table and execute it 
0000111E                           195  * 
0000111E  47FA 0EE0                196  EXEC1    LEA.L    COMTAB(PC),A3     Try built-in command table 
00001122  6114                     197           BSR.S    SEARCH            Look for command in built-in table 
00001124  6508                     198           BCS.S    EXEC2             If found then execute command 
00001126  49FA 0B74                199           LEA.L    ERMES2(PC),A4     Else print "invalid command" 
0000112A  6000 FF52                200           BRA.L    PSTRING           and return 
0000112E  2653                     201  EXEC2    MOVE.L   (A3),A3           Get the relative command address 
00001130  49FA 0ECE                202           LEA.L    COMTAB(PC),A4     pointed at by A3 and add it to 
00001134  D7CC                     203           ADD.L    A4,A3             the PC to generate the actual 
00001136  4ED3                     204           JMP      (A3)              command address. Then execute it. 
00001138                           205  * 
00001138  =00001138                206  SEARCH   EQU      *                 Match the command in the line buffer 
00001138  4280                     207           CLR.L    D0                with command table pointed at by A3 
0000113A  1013                     208           MOVE.B   (A3),D0           Get the first character in the 
0000113C  6734                     209           BEQ.S    SRCH7             current entry. If zero then exit 
0000113E  49F3 0006                210           LEA.L    6(A3,D0.W),A4     Else calculate address of next entry 
00001142  122B 0001                211           MOVE.B   1(A3),D1          Get number of characters to match 
00001146  4BEE 0404                212           LEA.L    LNBUFF(A6),A5     A5 points to command in line buffer 
0000114A  142B 0002                213           MOVE.B   2(A3),D2          Get first character in this entry 
0000114E  B41D                     214           CMP.B    (A5)+,D2          from the table and match with buffer 
00001150  6704                     215           BEQ.S    SRCH3             If match then try rest of string 
00001152  264C                     216  SRCH2    MOVE.L   A4,A3             Else get address of next entry 
00001154  60E2                     217           BRA      SEARCH            and try the next entry in the table 
00001156  5301                     218  SRCH3    SUB.B    #1,D1             One less character to match 
00001158  670E                     219           BEQ.S    SRCH6             If match counter zero then all done 
0000115A  47EB 0003                220           LEA.L    3(A3),A3          Else point to next character in table 
0000115E  141B                     221  SRCH4    MOVE.B   (A3)+,D2          Now match a pair of characters 
00001160  B41D                     222           CMP.B    (A5)+,D2 
00001162  66EE                     223           BNE      SRCH2             If no match then try next entry 
00001164  5301                     224           SUB.B    #1,D1             Else decrement match counter and 
00001166  66F6                     225           BNE      SRCH4             repeat until no chars left to match 
00001168  47EC FFFC                226  SRCH6    LEA.L    -4(A4),A3         Calculate address of command entry 
0000116C  003C 0001                227           OR.B     #1,CCR            point. Mark carry flag as success 
00001170  4E75                     228           RTS                        and return 
00001172  023C 00FE                229  SRCH7    AND.B    #$FE,CCR          Fail - clear carry to indicate 
00001176  4E75                     230           RTS                        command not found and return 
00001178                           231  * 
00001178                           232  ************************************************************************* 
00001178                           233  * 
00001178                           234  *  Basic input routines 
00001178                           235  *  HEX    =  Get one   hexadecimal character  into D0 
00001178                           236  *  BYTE   =  Get two   hexadecimal characters into D0 
00001178                           237  *  WORD   =  Get four  hexadecimal characters into D0 
00001178                           238  *  LONGWD =  Get eight hexadecimal characters into D0 
00001178                           239  *  PARAM  =  Get a longword from the line buffer into D0 
00001178                           240  *  Bit 0 of D7 is set to indicate a hexadecimal input error 
00001178                           241  * 
00001178  6100 03A2                242  HEX      BSR      GETCHAR           Get a character from input device 
0000117C  0400 0030                243           SUB.B    #$30,D0           Convert to binary 
00001180  6B0E                     244           BMI.S    NOT_HEX           If less than $30 then exit with error 
00001182  B03C 0009                245           CMP.B    #$09,D0           Else test for number (0 to 9) 
00001186  6F0C                     246           BLE.S    HEX_OK            If number then exit - success 
00001188  5F00                     247           SUB.B    #$07,D0           Else convert letter to hex 
0000118A  B03C 000F                248           CMP.B    #$0F,D0           If character in range "A" to "F" 
0000118E  6F04                     249           BLE.S    HEX_OK            then exit successfully 
00001190  8E3C 0001                250  NOT_HEX  OR.B     #1,D7             Else set error flag 
00001194  4E75                     251  HEX_OK   RTS                        and return 
00001196                           252  * 
00001196  2F01                     253  BYTE     MOVE.L   D1,-(A7)          Save D1 
00001198  61DE                     254           BSR      HEX               Get first hex character 
0000119A  E900                     255           ASL.B    #4,D0             Move it to MS nybble position 
0000119C  1200                     256           MOVE.B   D0,D1             Save MS nybble in D1 
0000119E  61D8                     257           BSR      HEX               Get second hex character 
000011A0  D001                     258           ADD.B    D1,D0             Merge MS and LS nybbles 
000011A2  221F                     259           MOVE.L   (A7)+,D1          Restore D1 
000011A4  4E75                     260           RTS 
000011A6                           261  * 
000011A6  61EE                     262  WORD     BSR      BYTE              Get upper order byte 
000011A8  E140                     263           ASL.W    #8,D0             Move it to MS position 
000011AA  60EA                     264           BRA      BYTE              Get LS byte and return 
000011AC                           265  * 
000011AC  61F8                     266  LONGWD   BSR      WORD              Get upper order word 
000011AE  4840                     267           SWAP     D0                Move it to MS position 
000011B0  60F4                     268           BRA      WORD              Get lower order word and return 
000011B2                           269  * 
000011B2                           270  *  PARAM reads a parameter from the line buffer and puts it in both 
000011B2                           271  *  PARAMTR(A6) and D0. Bit 1 of D7 is set on error. 
000011B2                           272  * 
000011B2  2F01                     273  PARAM    MOVE.L   D1,-(A7)          Save D1 
000011B4  4281                     274           CLR.L    D1                Clear input accumulator 
000011B6  206E 0444                275           MOVE.L   BUFFPT(A6),A0     A0 points to parameter in buffer 
000011BA  1018                     276  PARAM1   MOVE.B   (A0)+,D0          Read character from line buffer 
000011BC  B03C 0020                277           CMP.B    #SPACE,D0         Test for delimiter 
000011C0  6720                     278           BEQ.S    PARAM4            The permitted delimiter is a 
000011C2  B03C 000D                279           CMP.B    #CR,D0            space or a carriage return 
000011C6  671A                     280           BEQ.S    PARAM4            Exit on either space or C/R 
000011C8  E981                     281           ASL.L    #4,D1             Shift accumulated result 4 bits left 
000011CA  0400 0030                282           SUB.B    #$30,D0           Convert new character to hex 
000011CE  6B1E                     283           BMI.S    PARAM5            If less than $30 then not-hex 
000011D0  B03C 0009                284           CMP.B    #$09,D0           If less than 10 
000011D4  6F08                     285           BLE.S    PARAM3            then continue 
000011D6  5F00                     286           SUB.B    #$07,D0           Else assume $A - $F 
000011D8  B03C 000F                287           CMP.B    #$0F,D0           If more than $F 
000011DC  6E10                     288           BGT.S    PARAM5            then exit to error on not-hex 
000011DE  D200                     289  PARAM3   ADD.B    D0,D1             Add latest nybble to total in D1 
000011E0  60D8                     290           BRA      PARAM1            Repeat until delimiter found 
000011E2  2D48 0444                291  PARAM4   MOVE.L   A0,BUFFPT(A6)     Save pointer in memory 
000011E6  2D41 0448                292           MOVE.L   D1,PARAMTR(A6)    Save parameter in memory 
000011EA  2001                     293           MOVE.L   D1,D0             Put parameter in D0 for return 
000011EC  6004                     294           BRA.S    PARAM6            Return without error 
000011EE  8E3C 0002                295  PARAM5   OR.B     #2,D7             Set error flag before return 
000011F2  221F                     296  PARAM6   MOVE.L   (A7)+,D1          Restore working register 
000011F4  4E75                     297           RTS                        Return with error 
000011F6                           298  * 
000011F6                           299  ************************************************************************* 
000011F6                           300  * 
000011F6                           301  *  Output routines 
000011F6                           302  *  OUT1X   = print one   hexadecimal character 
000011F6                           303  *  OUT2X   = print two   hexadecimal characters 
000011F6                           304  *  OUT4X   = print four  hexadecimal characters 
000011F6                           305  *  OUT8X   = print eight hexadecimal characters 
000011F6                           306  *  In each case, the data to be printed is in D0 
000011F6                           307  * 
000011F6  3F00                     308  OUT1X    MOVE.W   D0,-(A7)          Save D0 
000011F8  C03C 000F                309           AND.B    #$0F,D0           Mask off MS nybble 
000011FC  0600 0030                310           ADD.B    #$30,D0           Convert to ASCII 
00001200  B03C 0039                311           CMP.B    #$39,D0           ASCII = HEX + $30 
00001204  6302                     312           BLS.S    OUT1X1            If ASCII <= $39 then print and exit 
00001206  5E00                     313           ADD.B    #$07,D0           Else ASCII := HEX + 7 
00001208  6100 0342                314  OUT1X1   BSR      PUTCHAR           Print the character 
0000120C  301F                     315           MOVE.W   (A7)+,D0          Restore D0 
0000120E  4E75                     316           RTS 
00001210                           317  * 
00001210  E818                     318  OUT2X    ROR.B    #4,D0             Get MS nybble in LS position 
00001212  61E2                     319           BSR      OUT1X             Print MS nybble 
00001214  E918                     320           ROL.B    #4,D0             Restore LS nybble 
00001216  60DE                     321           BRA      OUT1X             Print LS nybble and return 
00001218                           322  * 
00001218  E058                     323  OUT4X    ROR.W    #8,D0             Get MS byte in LS position 
0000121A  61F4                     324           BSR      OUT2X             Print MS byte 
0000121C  E158                     325           ROL.W    #8,D0             Restore LS byte 
0000121E  60F0                     326           BRA      OUT2X             Print LS byte and return 
00001220                           327  * 
00001220  4840                     328  OUT8X    SWAP     D0                Get MS word in LS position 
00001222  61F4                     329           BSR      OUT4X             Print MS word 
00001224  4840                     330           SWAP     D0                Restore LS word 
00001226  60F0                     331           BRA      OUT4X             Print LS word and return 
00001228                           332  * 
00001228                           333  ************************************************************************* 
00001228                           334  * 
00001228                           335  * JUMP causes execution to begin at the address in the line buffer 
00001228                           336  * 
00001228  6188                     337  JUMP     BSR     PARAM              Get address from buffer 
0000122A  4A07                     338           TST.B   D7                 Test for input error 
0000122C  6608                     339           BNE.S   JUMP1              If error flag not zero then exit 
0000122E  4A80                     340           TST.L   D0                 Else test for missing address 
00001230  6704                     341           BEQ.S   JUMP1              field. If no address then exit 
00001232  2040                     342           MOVE.L  D0,A0              Put jump address in A0 and call the 
00001234  4ED0                     343           JMP     (A0)               subroutine. User to supply RTS!! 
00001236  49FA 0A46                344  JUMP1    LEA.L   ERMES1(PC),A4      Here for error - display error 
0000123A  6000 FE42                345           BRA     PSTRING            message and return 
0000123E                           346  * 
0000123E                           347  ************************************************************************* 
0000123E                           348  * 
0000123E                           349  *  Display the contents of a memory location and modify it 
0000123E                           350  * 
0000123E  6100 FF72                351  MEMORY   BSR      PARAM             Get start address from line buffer 
00001242  4A07                     352           TST.B    D7                Test for input error 
00001244  6634                     353           BNE.S    MEM3              If error then exit 
00001246  2640                     354           MOVE.L   D0,A3             A3 points to location to be opened 
00001248  6100 FE24                355  MEM1     BSR      NEWLINE 
0000124C  612E                     356           BSR.S    ADR_DAT           Print current address and contents 
0000124E  6140                     357           BSR.S    PSPACE             update pointer, A3, and O/P space 
00001250  6100 02CA                358           BSR      GETCHAR           Input char to decide next action 
00001254  B03C 000D                359           CMP.B    #CR,D0            If carriage return then exit 
00001258  6720                     360           BEQ.S    MEM3              Exit 
0000125A  B03C 002D                361           CMP.B    #'-',D0           If "-" then move back 
0000125E  6606                     362           BNE.S    MEM2              Else skip wind-back procedure 
00001260  47EB FFFC                363           LEA.L    -4(A3),A3         Move pointer back 2+2 
00001264  60E2                     364           BRA      MEM1              Repeat until carriage return 
00001266  B03C 0020                365  MEM2     CMP.B    #SPACE,D0         Test for space (= new entry) 
0000126A  66DC                     366           BNE.S    MEM1              If not space then repeat 
0000126C  6100 FF38                367           BSR      WORD              Else get new word to store 
00001270  4A07                     368           TST.B    D7                Test for input error 
00001272  6606                     369           BNE.S    MEM3              If error then exit 
00001274  3740 FFFE                370           MOVE.W   D0,-2(A3)         Store new word 
00001278  60CE                     371           BRA      MEM1              Repeat until carriage return 
0000127A  4E75                     372  MEM3     RTS 
0000127C                           373  * 
0000127C  2F00                     374  ADR_DAT  MOVE.L   D0,-(A7)          Print the contents of A3 and the 
0000127E  200B                     375           MOVE.L   A3,D0             word pointed at by A3. 
00001280  619E                     376           BSR      OUT8X              and print current address 
00001282  610C                     377           BSR.S    PSPACE            Insert delimiter 
00001284  3013                     378           MOVE.W   (A3),D0           Get data at this address in D0 
00001286  6190                     379           BSR      OUT4X              and print it 
00001288  47EB 0002                380           LEA.L    2(A3),A3          Point to next address to display 
0000128C  201F                     381           MOVE.L   (A7)+,D0          Restore D0 
0000128E  4E75                     382           RTS 
00001290                           383  * 
00001290  1F00                     384  PSPACE   MOVE.B   D0,-(A7)          Print a single space 
00001292  103C 0020                385           MOVE.B   #SPACE,D0 
00001296  6100 02B4                386           BSR      PUTCHAR 
0000129A  101F                     387           MOVE.B   (A7)+,D0 
0000129C  4E75                     388           RTS 
0000129E                           389  * 
0000129E                           390  ************************************************************************* 
0000129E                           391  * 
0000129E                           392  *  LOAD  Loads data formatted in hexadecimal "S" format from Port 2 
0000129E                           393  *        NOTE - I/O is automatically redirected to the aux port for 
0000129E                           394  *        loader functions. S1 or S2 records accepted 
0000129E                           395  * 
0000129E  2F2E 0456                396  LOAD     MOVE.L   CN_OVEC(A6),-(A7) Save current output device name 
000012A2  2F2E 0452                397           MOVE.L   CN_IVEC(A6),-(A7) Save current input device name 
000012A6  2D7C 0000206C 0456       398           MOVE.L   #DCB4,CN_OVEC(A6) Set up aux ACIA as output 
000012AE  2D7C 0000205A 0452       399           MOVE.L   #DCB3,CN_IVEC(A6) Set up aux ACIA as input 
000012B6  522E 044C                400           ADD.B    #1,ECHO(A6)       Turn off character echo 
000012BA  6100 FDB2                401           BSR      NEWLINE           Send newline to host 
000012BE  6100 015A                402           BSR      DELAY             Wait for host to "settle" 
000012C2  6100 0156                403           BSR      DELAY 
000012C6  286E 0444                404           MOVE.L   BUFFPT(A6),A4     Any string in the line buffer is 
000012CA  101C                     405  LOAD1    MOVE.B   (A4)+,D0          transmitted to the host computer 
000012CC  6100 027E                406           BSR      PUTCHAR           before the loading begins 
000012D0  B03C 000D                407           CMP.B    #CR,D0            Read from the buffer until EOL 
000012D4  66F4                     408           BNE      LOAD1 
000012D6  6100 FD96                409           BSR      NEWLINE           Send newline before loading 
000012DA  6100 0240                410  LOAD2    BSR      GETCHAR           Records from the host must begin 
000012DE  B03C 0053                411           CMP.B    #'S',D0           with S1/S2 (data) or S9/S8 (term) 
000012E2  66F6                     412           BNE.S    LOAD2             Repeat GETCHAR until char = "S" 
000012E4  6100 0236                413           BSR      GETCHAR           Get character after "S" 
000012E8  B03C 0039                414           CMP.B    #'9',D0           Test for the two terminators S9/S8 
000012EC  6706                     415           BEQ.S    LOAD3             If S9 record then exit else test 
000012EE  B03C 0038                416           CMP.B    #'8',D0           for S8 terminator. Fall through to 
000012F2  662A                     417           BNE.S    LOAD6             exit on S8 else continue search 
000012F4  =000012F4                418  LOAD3    EQU      *                 Exit point from LOAD 
000012F4  2D5F 0452                419           MOVE.L   (A7)+,CN_IVEC(A6) Clean up by restoring input device 
000012F8  2D5F 0456                420           MOVE.L   (A7)+,CN_OVEC(A6) and output device name 
000012FC  422E 044C                421           CLR.B    ECHO(A6)          Restore input character echo 
00001300  0807 0000                422           BTST     #0,D7             Test for input errors 
00001304  6708                     423           BEQ.S    LOAD4             If no I/P error then look at checksum 
00001306  49FA 0976                424           LEA.L    ERMES1(PC),A4     Else point to error message 
0000130A  6100 FD72                425           BSR      PSTRING           Print it 
0000130E  0807 0003                426  LOAD4    BTST     #3,D7             Test for checksum error 
00001312  6708                     427           BEQ.S    LOAD5             If clear then exit 
00001314  49FA 0998                428           LEA.L    ERMES3(PC),A4     Else point to error message 
00001318  6100 FD64                429           BSR      PSTRING           Print it and return 
0000131C  4E75                     430  LOAD5    RTS 
0000131E                           431  * 
0000131E  B03C 0031                432  LOAD6    CMP.B    #'1',D0           Test for S1 record 
00001322  671E                     433           BEQ.S    LOAD6A            If S1 record then read it 
00001324  B03C 0032                434           CMP.B    #'2',D0           Else test for S2 record 
00001328  66B0                     435           BNE.S    LOAD2             Repeat until valid header found 
0000132A  4203                     436           CLR.B    D3                Read the S2 byte count and address, 
0000132C  613C                     437           BSR.S    LOAD8             clear the checksum 
0000132E  5900                     438           SUB.B    #4,D0             Calculate size of data field 
00001330  1400                     439           MOVE.B   D0,D2             D2 contains data bytes to read 
00001332  4280                     440           CLR.L    D0                Clear address accumulator 
00001334  6134                     441           BSR.S    LOAD8             Read most sig byte of address 
00001336  E180                     442           ASL.L    #8,D0             Move it one byte left 
00001338  6130                     443           BSR.S    LOAD8             Read the middle byte of address 
0000133A  E180                     444           ASL.L    #8,D0             Move it one byte left 
0000133C  612C                     445           BSR.S    LOAD8             Read least sig byte of address 
0000133E  2440                     446           MOVE.L   D0,A2             A2 points to destination of record 
00001340  6012                     447           BRA.S    LOAD7             Skip past S1 header loader 
00001342  4203                     448  LOAD6A   CLR.B    D3                S1 record found - clear checksum 
00001344  6124                     449           BSR.S    LOAD8             Get byte and update checksum 
00001346  5700                     450           SUB.B    #3,D0             Subtract 3 from record length 
00001348  1400                     451           MOVE.B   D0,D2             Save byte count in D2 
0000134A  4280                     452           CLR.L    D0                Clear address accumulator 
0000134C  611C                     453           BSR.S    LOAD8             Get MS byte of load address 
0000134E  E180                     454           ASL.L    #8,D0             Move it to MS position 
00001350  6118                     455           BSR.S    LOAD8             Get LS byte in D2 
00001352  2440                     456           MOVE.L   D0,A2             A2 points to destination of data 
00001354  6114                     457  LOAD7    BSR.S    LOAD8             Get byte of data for loading 
00001356  14C0                     458           MOVE.B   D0,(A2)+          Store it 
00001358  5302                     459           SUB.B    #1,D2             Decrement byte counter 
0000135A  66F8                     460           BNE      LOAD7             Repeat until count = 0 
0000135C  610C                     461           BSR.S    LOAD8             Read checksum 
0000135E  5203                     462           ADD.B    #1,D3             Add 1 to total checksum 
00001360  6700 FF78                463           BEQ      LOAD2             If zero then start next record 
00001364  8E3C 0008                464           OR.B     #%00001000,D7     Else set checksum error bit, 
00001368  608A                     465           BRA      LOAD3             restore I/O devices and return 
0000136A                           466  * 
0000136A  6100 FE2A                467  LOAD8    BSR     BYTE               Get a byte 
0000136E  D600                     468           ADD.B   D0,D3              Update checksum 
00001370  4E75                     469           RTS                         and return 
00001372                           470  * 
00001372                           471  ************************************************************************* 
00001372                           472  * 
00001372                           473  *  DUMP   Transmit S1 formatted records to host computer 
00001372                           474  *         A3 = Starting address of data block 
00001372                           475  *         A2 = End address of data block 
00001372                           476  *         D1 = Checksum, D2 = current record length 
00001372                           477  * 
00001372  6100 0096                478  DUMP     BSR      RANGE             Get start and end address 
00001376  4A07                     479           TST.B    D7                Test for input error 
00001378  6708                     480           BEQ.S    DUMP1             If no error then continue 
0000137A  49FA 0902                481           LEA.L    ERMES1(PC),A4     Else point to error message, 
0000137E  6000 FCFE                482           BRA      PSTRING           print it and return 
00001382  B08B                     483  DUMP1    CMP.L    A3,D0             Compare start and end addresses 
00001384  6A08                     484           BPL.S    DUMP2             If positive then start < end 
00001386  49FA 0A95                485           LEA.L    ERMES7(PC),A4     Else print error message 
0000138A  6000 FCF2                486           BRA      PSTRING           and return 
0000138E  2F2E 0456                487  DUMP2    MOVE.L   CN_OVEC(A6),-(A7) Save name of current output device 
00001392  2D7C 0000206C 0456       488           MOVE.L   #DCB4,CN_OVEC(A6) Set up Port 2 as output device 
0000139A  6100 FCD2                489           BSR      NEWLINE           Send newline to host and wait 
0000139E  617A                     490           BSR.S    DELAY 
000013A0  286E 0444                491           MOVE.L   BUFFPT(A6),A4     Before dumping, send any string 
000013A4  101C                     492  DUMP3    MOVE.B   (A4)+,D0          in the input buffer to the host 
000013A6  6100 01A4                493           BSR      PUTCHAR           Repeat 
000013AA  B03C 000D                494           CMP.B    #CR,D0            Transmit char from buffer to host 
000013AE  66F4                     495           BNE      DUMP3             Until char = C/R 
000013B0  6100 FCBC                496           BSR      NEWLINE 
000013B4  6164                     497           BSR.S    DELAY             Allow time for host to settle 
000013B6  528A                     498           ADDQ.L   #1,A2             A2 contains length of record + 1 
000013B8  240A                     499  DUMP4    MOVE.L   A2,D2             D2 points to end address 
000013BA  948B                     500           SUB.L    A3,D2             D2 contains bytes left to print 
000013BC  B4BC 00000011            501           CMP.L    #17,D2            If this is not a full record of 16 
000013C2  6502                     502           BCS.S    DUMP5             then load D2 with record size 
000013C4  7410                     503           MOVEQ    #16,D2            Else preset byte count to 16 
000013C6  49FA 07F1                504  DUMP5    LEA.L    HEADER(PC),A4     Point to record header 
000013CA  6100 FCB2                505           BSR      PSTRING           Print header 
000013CE  4201                     506           CLR.B    D1                Clear checksum 
000013D0  1002                     507           MOVE.B   D2,D0             Move record length to output register 
000013D2  5600                     508           ADD.B    #3,D0             Length includes address + count 
000013D4  612E                     509           BSR.S    DUMP7             Print number of bytes in record 
000013D6  200B                     510           MOVE.L   A3,D0             Get start address to be printed 
000013D8  E158                     511           ROL.W    #8,D0             Get MS byte in LS position 
000013DA  6128                     512           BSR.S    DUMP7             Print MS byte of address 
000013DC  E058                     513           ROR.W    #8,D0             Restore LS byte 
000013DE  6124                     514           BSR.S    DUMP7             Print LS byte of address 
000013E0  101B                     515  DUMP6    MOVE.B   (A3)+,D0          Get data byte to be printed 
000013E2  6120                     516           BSR.S    DUMP7             Print it 
000013E4  5302                     517           SUB.B    #1,D2             Decrement byte count 
000013E6  66F8                     518           BNE      DUMP6             Repeat until all this record printed 
000013E8  4601                     519           NOT.B    D1                Complement checksum 
000013EA  1001                     520           MOVE.B   D1,D0             Move to output register 
000013EC  6116                     521           BSR.S    DUMP7             Print checksum 
000013EE  6100 FC7E                522           BSR      NEWLINE 
000013F2  B7CA                     523           CMP.L    A2,A3             Have all records been printed? 
000013F4  66C2                     524           BNE      DUMP4             Repeat until all done 
000013F6  49FA 07C7                525           LEA.L    TAIL(PC),A4       Point to message tail (S9 record) 
000013FA  6100 FC82                526           BSR      PSTRING           Print it 
000013FE  2D5F 0456                527           MOVE.L   (A7)+,CN_OVEC(A6) Restore name of output device 
00001402  4E75                     528           RTS                        and return 
00001404                           529  * 
00001404  D200                     530  DUMP7    ADD.B    D0,D1             Update checksum, transmit byte 
00001406  6000 FE08                531           BRA      OUT2X             to host and return 
0000140A                           532  * 
0000140A  =0000140A                533  RANGE    EQU      *                 Get the range of addresses to be 
0000140A  4207                     534           CLR.B    D7                transmitted from the buffer 
0000140C  6100 FDA4                535           BSR      PARAM             Get starting address 
00001410  2640                     536           MOVE.L   D0,A3             Set up start address in A3 
00001412  6100 FD9E                537           BSR      PARAM             Get end address 
00001416  2440                     538           MOVE.L   D0,A2             Set up end address in A2 
00001418  4E75                     539           RTS 
0000141A                           540  * 
0000141A  =0000141A                541  DELAY    EQU       *                Provide a time delay for the host 
0000141A  48E7 8008                542           MOVEM.L   D0/A4,-(A7)      to settle. Save working registers 
0000141E  203C 00004000            543           MOVE.L    #$4000,D0        Set up delay constant 
00001424  5380                     544  DELAY1   SUB.L     #1,D0            Count down         (8 clk cycles) 
00001426  66FC                     545           BNE       DELAY1           Repeat until zero  (10 clk cycles) 
00001428  4CDF 1001                546           MOVEM.L   (A7)+,D0/A4      Restore working registers 
0000142C  4E75                     547           RTS 
0000142E                           548  * 
0000142E                           549  ************************************************************************* 
0000142E                           550  * 
0000142E                           551  *  TM  Enter transparant mode (All communication to go from terminal to 
0000142E                           552  *  the host processor until escape sequence entered). End sequence 
0000142E                           553  *  = ESC, E. A newline is sent to the host to "clear it down". 
0000142E                           554  * 
0000142E  13FC 0055 00008001       555  TM       MOVE.B    #$55,ACIA_1      Force RTS* high to re-route data 
00001436  522E 044C                556           ADD.B     #1,ECHO(A6)      Turn off character echo 
0000143A  6100 00E0                557  TM1      BSR       GETCHAR          Get character 
0000143E  B03C 001B                558           CMP.B     #ESC,D0          Test for end of TM mode 
00001442  66F6                     559           BNE       TM1              Repeat until first escape character 
00001444  6100 00D6                560           BSR       GETCHAR          Get second character 
00001448  B03C 0045                561           CMP.B     #'E',D0          If second char = E then exit TM 
0000144C  66EC                     562           BNE       TM1              Else continue 
0000144E  2F2E 0456                563           MOVE.L    CN_OVEC(A6),-(A7) Save output port device name 
00001452  2D7C 0000206C 0456       564           MOVE.L    #DCB4,CN_OVEC(A6) Get name of host port (aux port) 
0000145A  6100 FC12                565           BSR       NEWLINE          Send newline to host to clear it 
0000145E  2D5F 0456                566           MOVE.L    (A7)+,CN_OVEC(A6) Restore output device port name 
00001462  422E 044C                567           CLR.B     ECHO(A6)         Restore echo mode 
00001466  13FC 0015 00008001       568           MOVE.B    #$15,ACIA_1      Restore normal ACIA mode (RTS* low) 
0000146E  4E75                     569           RTS 
00001470                           570  * 
00001470                           571  ************************************************************************* 
00001470                           572  * 
00001470                           573  *  This routine sets up the system DCBs in RAM using the information 
00001470                           574  *  stored in ROM at address DCB_LST. This is called at initialization. 
00001470                           575  *  CN_IVEC contains the name "DCB1" and IO_VEC the name "DCB2" 
00001470                           576  * 
00001470  48E7 F0F0                577  SET_DCB  MOVEM.L A0-A3/D0-D3,-(A7) Save all working registers 
00001474  41EE 04D4                578           LEA.L   FIRST(A6),A0    Pointer to first DCB destination in RAM 
00001478  43FA 0BBC                579           LEA.L   DCB_LST(PC),A1  A1 points to DCB info block in ROM 
0000147C  303C 0005                580           MOVE.W  #5,D0           6 DCBs to set up 
00001480  323C 000F                581  ST_DCB1  MOVE.W  #15,D1          16 bytes to move per DCB header 
00001484  10D9                     582  ST_DCB2  MOVE.B  (A1)+,(A0)+     Move the 16 bytes of a DCB header 
00001486  51C9 FFFC                583           DBRA    D1,ST_DCB2      from ROM to RAM 
0000148A  3619                     584           MOVE.W  (A1)+,D3        Get size of parameter block (bytes) 
0000148C  3083                     585           MOVE.W  D3,(A0)         Store size in DCB in RAM 
0000148E  41F0 3002                586           LEA.L   2(A0,D3.W),A0   A0 points to tail of DCB in RAM 
00001492  47E8 0004                587           LEA.L   4(A0),A3        A3 contains address of next DCB in RAM 
00001496  208B                     588           MOVE.L  A3,(A0)         Store pointer to next DCB in this DCB 
00001498  41D3                     589           LEA.L   (A3),A0         A0 now points at next DCB in RAM 
0000149A  51C8 FFE4                590           DBRA    D0,ST_DCB1      Repeat until all DCBs set up 
0000149E  47EB FFFC                591           LEA.L   -4(A3),A3       Adjust A3 to point to last DCB pointer 
000014A2  4293                     592           CLR.L   (A3)            and force last pointer to zero 
000014A4  2D7C 00002036 0452       593           MOVE.L  #DCB1,CN_IVEC(A6) Set up vector to console input DCB 
000014AC  2D7C 00002048 0456       594           MOVE.L  #DCB2,CN_OVEC(A6) Set up vector to console output DCB 
000014B4  4CDF 0F0F                595           MOVEM.L (A7)+,A0-A3/D0-D3 Restore registers 
000014B8  4E75                     596           RTS 
000014BA                           597  * 
000014BA                           598  ************************************************************************* 
000014BA                           599  * 
000014BA                           600  *  IO_REQ handles all input/output transactions. A0 points to DCB on 
000014BA                           601  *  entry. IO_REQ calls the device driver whose address is in the DCB. 
000014BA                           602  * 
000014BA  48E7 00C0                603  IO_REQ   MOVEM.L A0-A1,-(A7)     Save working registers 
000014BE  43E8 0008                604           LEA.L   8(A0),A1        A1 points to device handler field in DCB 
000014C2  2251                     605           MOVE.L  (A1),A1         A1 contains device handler address 
000014C4  4E91                     606           JSR     (A1)            Call device handler 
000014C6  4CDF 0300                607           MOVEM.L (A7)+,A0-A1     Restore working registers 
000014CA  4E75                     608           RTS 
000014CC                           609  * 
000014CC                           610  ************************************************************************* 
000014CC                           611  * 
000014CC                           612  *  CON_IN handles input from the console device 
000014CC                           613  *  Exit with input in D0 
000014CC                           614  * 
000014CC  48E7 4000                615  CON_IN   MOVEM.L D1,-(A7)         Save working registers 
000014D0  4228 0013                616      CLR.B    19(A0)
000014D4  103C 0005                617           MOVE.B    #5,D0             Read input from ACIA
000014D8  4E4F                     618      TRAP     #15
000014DA  1001                     619      MOVE.B  D1,D0
000014DC  4CDF 0002                620           MOVEM.L (A7)+,D1     `   Restore working registers 
000014E0  4E75                     621           RTS 
000014E2                           622  * 
000014E2                           623  ************************************************************************* 
000014E2                           624  * 
000014E2                           625  *   This is the CON_OUT device driver. Output in D0  
000014E2                           626  * 
000014E2  48E7 4000                627  CON_OUT  MOVEM.L D1,-(A7)  Save working registers 
000014E6  4228 0013                628      CLR.B    19(A0)
000014EA  1200                     629           MOVE.B    D0,D1
000014EC  103C 0006                630           MOVE.B    #6,D0
000014F0  4E4F                     631           TRAP   #15
000014F2  4CDF 0002                632           MOVEM.L (A7)+,D1  Restore working registers 
000014F6  4E75                     633           RTS 
000014F8                           634  * 
000014F8                           635  ************************************************************************* 
000014F8                           636  * 
000014F8                           637  *  AUX_IN and AUX_OUT are simplified versions of CON_IN and 
000014F8                           638  *  CON_OUT for use with the port to the host processor 
000014F8                           639  * 
000014F8  43E8 000C                640  AUX_IN   LEA.L   12(A0),A1       Get pointer to aux ACIA from DCB 
000014FC  2251                     641           MOVE.L  (A1),A1         Get address of aux ACIA 
000014FE  0811 0000                642  AUX_IN1  BTST.B  #0,(A1)         Test for data ready 
00001502  67FA                     643           BEQ     AUX_IN1         Repeat until ready 
00001504  1029 0002                644           MOVE.B  2(A1),D0        Read input 
00001508  4E75                     645           RTS 
0000150A                           646  * 
0000150A  43E8 000C                647  AUX_OUT  LEA.L   12(A0),A1       Get pointer to aux ACIA from DCB 
0000150E  2251                     648           MOVE.L  (A1),A1         Get address of aux ACIA 
00001510  0811 0001                649  AUX_OT1  BTST.B  #1,(A1)         Test for ready to transmit 
00001514  67FA                     650           BEQ     AUX_OT1         Repeat until transmitter ready 
00001516  1340 0002                651           MOVE.B  D0,2(A1)        Transmit data 
0000151A  4E75                     652           RTS 
0000151C                           653  * 
0000151C                           654  ************************************************************************* 
0000151C                           655  * 
0000151C                           656  *  GETCHAR gets a character from the console device 
0000151C                           657  *  This is the main input routine and uses the device whose name  
0000151C                           658  *  is stored in CN_IVEC. Changing this name redirects input. 
0000151C                           659  * 
0000151C  2F08                     660  GETCHAR  MOVE.L  A0,-(A7)        Save working register 
0000151E  206E 0452                661           MOVE.L  CN_IVEC(A6),A0  A0 points to name of console DCB 
00001522  6156                     662           BSR.S   IO_OPEN         Open console (get DCB address in A0) 
00001524  0807 0003                663           BTST    #3,D7           D7(3) set if open error 
00001528  661E                     664           BNE.S   GETCH3          If error then exit now 
0000152A  618E                     665           BSR     IO_REQ          Else execute I/O transaction 
0000152C  C03C 007F                666           AND.B   #$7F,D0         Strip msb of input 
00001530  4A2E 044D                667           TST.B   U_CASE(A6)      Test for upper -> lower case conversion 
00001534  660A                     668           BNE.S   GETCH2          If flag not zero do not convert case 
00001536  0800 0006                669           BTST    #6,D0             Test input for lower case 
0000153A  6704                     670           BEQ.S   GETCH2          If upper case then skip conversion 
0000153C  C03C 00DF                671           AND.B   #%11011111,D0   Else clear bit 5 for upper case conv 
00001540  4A2E 044C                672  GETCH2   TST.B   ECHO(A6)        Do we need to echo the input? 
00001544  6602                     673           BNE.S   GETCH3          If ECHO not zero then no echo 
00001546  6104                     674           BSR.S   PUTCHAR         Else echo the input 
00001548  205F                     675  GETCH3   MOVE.L  (A7)+,A0        Restore working register 
0000154A  4E75                     676           RTS                     and return 
0000154C                           677  * 
0000154C                           678  ************************************************************************* 
0000154C                           679  * 
0000154C                           680  *  PUTCHAR sends a character to the console device 
0000154C                           681  *  The name of the output device is in CN_OVEC. 
0000154C                           682  * 
0000154C  BC3C 0001                683  PUTCHAR  CMP.B   #1,D6
00001550                           684           *BEQ     PUTASK
00001550  2F08                     685           MOVE.L  A0,-(A7)        Save working register
00001552  206E 0456                686           MOVE.L  CN_OVEC(A6),A0  A0 points to name of console output 
00001556  6122                     687           BSR.S   IO_OPEN         Open console (Get address of DCB) 
00001558  6100 FF60                688           BSR     IO_REQ          Perform output with DCB pointed at by A0 
0000155C  205F                     689           MOVE.L  (A7)+,A0        Restore working register 
0000155E  4E75                     690           RTS 
00001560                           691  
00001560                           692  *PUTASK   MOVE    D0,-(A5)
00001560                           693  *         MOVE    #'*',D0
00001560                           694  *         MOVE.L  A0,-(A7)        Save working register
00001560                           695  *         MOVE.L  CN_OVEC(A6),A0  A0 points to name of console output 
00001560                           696  *         BSR.S   IO_OPEN         Open console (Get address of DCB) 
00001560                           697  *         BSR     IO_REQ          Perform output with DCB pointed at by A0 
00001560                           698  *         MOVE.L  (A7)+,A0        Restore working register
00001560                           699  *         MOVE    (A5)+,D0
00001560                           700  *         RTS 
00001560                           701  * 
00001560                           702  ************************************************************************* 
00001560                           703  * 
00001560                           704  *  BUFF_IN and BUFF_OUT are two rudimentary input and output routines 
00001560                           705  *  which input data from and output data to a buffer in RAM. These are 
00001560                           706  *  used by DCB5 and DCB6, respectively. 
00001560                           707  * 
00001560  43E8 000C                708  BUFF_IN  LEA.L   12(A0),A1       A1 points to I/P buffer 
00001564  2451                     709           MOVE.L  (A1),A2         A2 gets I/P pointer from buffer 
00001566  1022                     710           MOVE.B  -(A2),D0        Read char from buffer and adjust A2 
00001568  228A                     711           MOVE.L  A2,(A1)         Restore pointer in buffer 
0000156A  4E75                     712           RTS 
0000156C                           713  * 
0000156C  43E8 000C                714  BUFF_OT  LEA.L   12(A0),A1       A1 points to O/P buffer 
00001570  2469 0004                715           MOVE.L  4(A1),A2        A2 gets O/P pointer from buffer 
00001574  14C0                     716           MOVE.B  D0,(A2)+        Store char in buffer and adjust A2 
00001576  228A                     717           MOVE.L  A2,(A1)         Restore pointer in buffer 
00001578  4E75                     718           RTS 
0000157A                           719  * 
0000157A                           720  ************************************************************************* 
0000157A                           721  * 
0000157A                           722  *  Open - opens a DCB for input or output. IO_OPEN converts the 
0000157A                           723  *  name pointed at by A0 into the address of the DCB pointed at 
0000157A                           724  *  by A0. Bit 3 of D7 is set to zero if DCB not found 
0000157A                           725  * 
0000157A  48E7 F870                726  IO_OPEN  MOVEM.L  A1-A3/D0-D4,-(A7) Save working registers 
0000157E  43EE 04D4                727           LEA.L    FIRST(A6),A1   A1 points to first DCB in chain in RAM 
00001582  45D1                     728  OPEN1    LEA.L    (A1),A2        A2 = temp copy of pointer to DCB 
00001584  47D0                     729           LEA.L    (A0),A3        A3 = temp copy of pointer to DCB name 
00001586  303C 0007                730           MOVE.W   #7,D0          Up to 8 chars of DCB name to match 
0000158A  181A                     731  OPEN2    MOVE.B   (A2)+,D4       Compare DCB name with string 
0000158C  B81B                     732           CMP.B    (A3)+,D4 
0000158E  6608                     733           BNE.S    OPEN3          If no match try next DCB 
00001590  51C8 FFF8                734           DBRA     D0,OPEN2       Else repeat until all chars matched 
00001594  41D1                     735           LEA.L    (A1),A0        Success - move this DCB address to A0 
00001596  6016                     736           BRA.S    OPEN4          and return 
00001598  =00001598                737  OPEN3    EQU      *              Fail - calculate address of next DCB 
00001598  3229 0010                738           MOVE.W   16(A1),D1      Get parameter block size of DCB 
0000159C  43F1 1012                739           LEA.L    18(A1,D1.W),A1 A1 points to pointer to next DCB 
000015A0  2251                     740           MOVE.L   (A1),A1        A1 now points to next DCB 
000015A2  B3FC 00000000            741           CMP.L    #0,A1          Test for end of DCB chain 
000015A8  66D8                     742           BNE      OPEN1          If not end of chain then try next DCB 
000015AA  8E3C 0008                743           OR.B     #8,D7          Else set error flag and return 
000015AE  4CDF 0E1F                744  OPEN4    MOVEM.L  (A7)+,A1-A3/D0-D4 Restore working registers 
000015B2  4E75                     745           RTS 
000015B4                           746  * 
000015B4                           747  ************************************************************************* 
000015B4                           748  * 
000015B4                           749  *  Exception vector table initialization routine 
000015B4                           750  *  All vectors not setup are loaded with uninitialized routine vector 
000015B4                           751  * 
000015B4  303C 0007                752  X_SET   MOVE.W  #7,D0             Now clear the breakpoint table 
000015B8  41EE 04A4                753          LEA.L   BP_TAB(A6),A0     Point to table 
000015BC  4298                     754  X_SET2  CLR.L   (A0)+             Clear an address entry 
000015BE  4258                     755          CLR.W   (A0)+             Clear the corresponding data 
000015C0  51C8 FFFA                756          DBRA    D0,X_SET2         Repeat until all 8 cleared 
000015C4  4E75                     757          RTS 
000015C6                           758  * 
000015C6                           759  ************************************************************************* 
000015C6                           760  * 
000015C6  =000015C6                761  TRAP_0  EQU     *                 User links to  TS2BUG via TRAP #0 
000015C6  B23C 0000                762          CMP.B   #0,D1             D1 = 0 = Get character 
000015CA  6606                     763          BNE.S   FOO1           
000015CC  6100 FF4E                764          BSR     GETCHAR 
000015D0  4E73                     765          RTE 
000015D2  B23C 0001                766  FOO1    CMP.B   #1,D1             D1 = 1 = Print character 
000015D6  6606                     767          BNE.S   FOO2 
000015D8  6100 FF72                768          BSR     PUTCHAR 
000015DC  4E73                     769          RTE 
000015DE  B23C 0002                770  FOO2    CMP.B   #2,D1             D1 = 2 = Newline 
000015E2  6606                     771          BNE.S   FOO3 
000015E4  6100 FA88                772          BSR     NEWLINE 
000015E8  4E73                     773          RTE 
000015EA  B23C 0003                774  FOO3    CMP.B   #3,D1             D1 = 3 = Get parameter from buffer 
000015EE  6606                     775          BNE.S   FOO4 
000015F0  6100 FBC0                776          BSR     PARAM 
000015F4  4E73                     777          RTE 
000015F6  B23C 0004                778  FOO4    CMP.B   #4,D1             D1 = 4 = Print string pointed at by A4 
000015FA  6606                     779          BNE.S   FOO5 
000015FC  6100 FA80                780          BSR     PSTRING 
00001600  4E73                     781          RTE 
00001602  B23C 0005                782  FOO5    CMP.B   #5,D1             D1 = 5 = Get a hex character 
00001606  6606                     783          BNE.S   FOO6 
00001608  6100 FB6E                784          BSR     HEX 
0000160C  4E73                     785          RTE 
0000160E  B23C 0006                786  FOO6    CMP.B   #6,D1             D1 = 6 = Get a hex byte 
00001612  6606                     787          BNE.S   FOO7 
00001614  6100 FB80                788          BSR     BYTE 
00001618  4E73                     789          RTE 
0000161A  B23C 0007                790  FOO7    CMP.B   #7,D1             D1 = 7 = Get a word 
0000161E  6606                     791          BNE.S   FOO8 
00001620  6100 FB84                792          BSR     WORD 
00001624  4E73                     793          RTE 
00001626  B23C 0008                794  FOO8    CMP.B   #8,D1             D1 = 8 = Get a longword 
0000162A  6606                     795          BNE.S   FOO9 
0000162C  6100 FB7E                796          BSR     LONGWD 
00001630  4E73                     797          RTE 
00001632  B23C 0009                798  FOO9    CMP.B   #9,D1             D1 = 9 = Output hex byte 
00001636  6606                     799          BNE.S   FOO10  
00001638  6100 FBD6                800          BSR     OUT2X 
0000163C  4E73                     801          RTE 
0000163E  B23C 000A                802  FOO10   CMP.B   #10,D1            D1 = 10 = Output hex word 
00001642  6606                     803          BNE.S   FOO11 
00001644  6100 FBD2                804          BSR     OUT4X 
00001648  4E73                     805          RTE 
0000164A  B23C 000B                806  FOO11   CMP.B   #11,D1            D1 = 11 = Output hex longword 
0000164E  6606                     807          BNE.S   FOO12 
00001650  6100 FBCE                808          BSR     OUT8X 
00001654  4E73                     809          RTE 
00001656  B23C 000C                810  FOO12   CMP.B   #12,D1            D1 = 12 = Print a space 
0000165A  6606                     811          BNE.S   FOO13 
0000165C  6100 FC32                812          BSR     PSPACE 
00001660  4E73                     813          RTE 
00001662  B23C 000D                814  FOO13   CMP.B   #13,D1            D1 = 13 = Get a line of text into 
00001666  6606                     815          BNE.S   FOO14            the line buffer 
00001668  6100 FA2A                816          BSR     GETLINE 
0000166C  4E73                     817          RTE 
0000166E  B23C 000E                818  FOO14   CMP.B   #14,D1            D1 = 14 = Tidy up the line in the 
00001672  6606                     819          BNE.S   FOO15            line buffer by removing leading 
00001674  6100 FA54                820          BSR     TIDY              leading and multiple embeded spaces 
00001678  4E73                     821          RTE 
0000167A  B23C 000F                822  FOO15   CMP.B   #15,D1            D1 = 15 = Execute the command in 
0000167E  6606                     823          BNE.S   FOO16            the line buffer 
00001680  6100 FA8A                824          BSR     EXECUTE 
00001684  4E73                     825          RTE 
00001686  B23C 0010                826  FOO16   CMP.B   #16,D1            D1 = 16 = Call RESTORE to transfer 
0000168A  6606                     827          BNE.S   FOO17            the registers in TSK_T to the 68000 
0000168C  6100 0306                828          BSR     RESTORE           and therefore execute a program 
00001690  4E73                     829          RTE 
00001692  4E73                     830  FOO17   RTE 
00001694                           831  * 
00001694                           832  ************************************************************************* 
00001694                           833  * 
00001694                           834  *  Display exception frame (D0 - D7, A0 - A6, USP, SSP, SR, PC) 
00001694                           835  *  EX_DIS prints registers saved after a breakpoint or exception 
00001694                           836  *  The registers are saved in TSK_T 
00001694                           837  * 
00001694  4BEE 045A                838  EX_DIS  LEA.L   TSK_T(A6),A5      A5 points to display frame 
00001698  49FA 0546                839          LEA.L   MES3(PC),A4       Point to heading 
0000169C  6100 F9F0                840          BSR     HEADING           and print it 
000016A0  3C3C 0007                841          MOVE.W  #7,D6             8 pairs of registers to display 
000016A4  4205                     842          CLR.B   D5                D5 is the line counter 
000016A6  1005                     843  EX_D1   MOVE.B  D5,D0             Put current register number in D0 
000016A8  6100 FB4C                844          BSR     OUT1X             and print it 
000016AC  6100 FBE2                845          BSR     PSPACE            and a space 
000016B0  5205                     846          ADD.B   #1,D5             Update counter for next pair 
000016B2  2015                     847          MOVE.L  (A5),D0           Get data register to be displayed 
000016B4  6100 FB6A                848          BSR     OUT8X             from the frame and print it 
000016B8  49FA 0544                849          LEA.L   MES4(PC),A4       Print string of spaces 
000016BC  6100 F9C0                850          BSR.L   PSTRING           between data and address registers 
000016C0  202D 0020                851          MOVE.L  32(A5),D0         Get address register to be displayed 
000016C4  6100 FB5A                852          BSR     OUT8X             which is 32 bytes on from data reg 
000016C8  6100 F9A4                853          BSR     NEWLINE 
000016CC  4BED 0004                854          LEA.L   4(A5),A5          Point to next pair (ie Di, Ai) 
000016D0  51CE FFD4                855          DBRA    D6,EX_D1          Repeat until all displayed 
000016D4  4BED 0020                856          LEA.L   32(A5),A5         Adjust pointer by 8 longwords 
000016D8  6100 F994                857          BSR     NEWLINE           to point to SSP 
000016DC  49FA 04F9                858          LEA.L   MES2A(PC),A4      Point to "SS =" 
000016E0  6100 F99C                859          BSR     PSTRING           Print it 
000016E4  201D                     860          MOVE.L  (A5)+,D0          Get SSP from frame 
000016E6  6100 FB38                861          BSR     OUT8X             and display it 
000016EA  6100 F982                862          BSR     NEWLINE 
000016EE  49FA 04D5                863          LEA.L   MES1(PC),A4       Point to 'SR =' 
000016F2  6100 F98A                864          BSR     PSTRING           Print it 
000016F6  301D                     865          MOVE.W  (A5)+,D0          Get status register 
000016F8  6100 FB1E                866          BSR     OUT4X             Display status 
000016FC  6100 F970                867          BSR     NEWLINE 
00001700  49FA 04CC                868          LEA.L   MES2(PC),A4       Point to 'PC =' 
00001704  6100 F978                869          BSR     PSTRING           Print it 
00001708  201D                     870          MOVE.L  (A5)+,D0          Get PC 
0000170A  6100 FB14                871          BSR     OUT8X             Display PC 
0000170E  6000 F95E                872          BRA     NEWLINE           Newline and return 
00001712                           873  * 
00001712                           874  ************************************************************************* 
00001712                           875  
00001712  49F9 00001CFE            876  HELP     LEA.L    JUMPHELP,A4
00001718  6100 F964                877           BSR.W    PSTRING
0000171C  6100 F950                878           BSR.W    NEWLINE
00001720  49F9 00001D34            879           LEA.L    MEMHELP,A4
00001726  6100 F956                880           BSR.W    PSTRING
0000172A  6100 F942                881           BSR.W    NEWLINE
0000172E  49F9 00001D81            882           LEA.L    LOADHELP,A4
00001734  6100 F948                883           BSR.W    PSTRING
00001738  6100 F934                884           BSR.W    NEWLINE
0000173C  49F9 00001DCB            885           LEA.L    TVHELP,A4
00001742  6100 F93A                886           BSR.W    PSTRING
00001746  4E75                     887           RTS
00001748                           888           
00001748                           889  *************************************************************************
00001748  B83C 0003                890  LOGIN    CMP.B    #3,D4
0000174C  6700 00C2                891           BEQ      QUIT
00001750  49F9 00001E38            892           LEA.L    LOGINM1,A4
00001756  6100 F926                893           BSR.W    PSTRING           
0000175A  6100 F912                894           BSR.W    NEWLINE
0000175E  6100 F934                895           BSR      GETLINE
00001762  49F9 00001E2A            896           LEA.L    UNAME,A4
00001768  1A19                     897  LOGIN1   MOVE.B   (A1)+,D5
0000176A  BA1C                     898           CMP.B    (A4)+,D5
0000176C  67FA                     899           BEQ      LOGIN1            iterate through checking each char
0000176E  0C21 000D                900           CMP.B    #CR,-(A1)         check for carriage return
00001772  6600 006A                901           BNE      WRONG             if not then wrong input
00001776  0C24 0000                902           CMP.B    #NUL,-(A4)        check for end of stored string
0000177A  6600 0062                903           BNE      WRONG             if not then wrong input
0000177E  49F9 00001E6D            904           LEA.L    USRSUC,A4         print success
00001784  6100 F8F8                905           BSR.W    PSTRING
00001788  6100 F8E4                906           BSR.W    NEWLINE
0000178C  49F9 00001E49            907           LEA.L    LOGINM2,A4
00001792  6100 F8EA                908           BSR.W    PSTRING
00001796  6100 F8D6                909           BSR.W    NEWLINE
0000179A  1C3C 0001                910           MOVE.B   #1,D6
0000179E  6100 F8F4                911           BSR.W    GETLINE
000017A2  1C3C 0000                912           MOVE.B   #0,D6
000017A6  49F9 00001E2F            913           LEA.L    PWORD,A4
000017AC  1A19                     914  LOGIN2   MOVE.B   (A1)+,D5
000017AE  BA1C                     915           CMP.B    (A4)+,D5
000017B0  67FA                     916           BEQ      LOGIN2            iterate through checking each char
000017B2  0C21 000D                917           CMP.B    #CR,-(A1)          check for carriage return
000017B6  6600 0026                918           BNE      WRONG             if not then wrong input
000017BA  0C24 0000                919           CMP.B    #NUL,-(A4)            check for end of stored string
000017BE  6600 0032                920           BNE      WRONGPW             if not then wrong input
000017C2  49F9 00001E91            921           LEA.L    PWSUC,A4
000017C8  6000 F8B4                922           BRA      PSTRING
000017CC  49F9 00001E38            923           LEA.L    LOGINM1,A4
000017D2  6100 F8AA                924           BSR.W    PSTRING           print success
000017D6  6100 F896                925           BSR.W    NEWLINE
000017DA  6000 F882                926           BRA      WARM
000017DE                           927  
000017DE  49F9 00001E5A            928  WRONG    LEA.L    USRERR,A4   
000017E4  6100 F898                929           BSR.W    PSTRING
000017E8  6100 F884                930           BSR.W    NEWLINE
000017EC  5204                     931           ADD.B    #1,D4
000017EE  6000 FF58                932           BRA      LOGIN
000017F2                           933  
000017F2  49F9 00001E7E            934  WRONGPW  LEA.L    PWERR,A4   
000017F8  6100 F884                935           BSR.W    PSTRING
000017FC  6100 F870                936           BSR.W    NEWLINE
00001800  5204                     937           ADD.B    #1,D4
00001802  6000 FF44                938           BRA      LOGIN
00001806                           939  
00001806  49F9 00001E6D            940  UPASS    LEA.L    USRSUC,A4
0000180C  6000 F870                941           BRA      PSTRING  
00001810                           942  
00001810  4EF8 1810                943  QUIT     JMP      QUIT
00001814                           944  *
00001814                           945  ************************************************************************* 
00001814  2878 07D4                946  TV       MOVE.L   MIN_RAM,A4
00001818  1C3C 0000                947           MOVE.B   #0,D6
0000181C  323C 0000                948  LOOPRAM  MOVE.W   #0,D1
00001820  3881                     949           MOVE.W   D1,(A4)
00001822  49EC 0002                950           LEA.L    2(A4),A4          Point to next address to display
00001826  B9F8 07D8                951           CMP.L    MAX_RAM,A4
0000182A  66F0                     952           BNE      LOOPRAM
0000182C  2878 07D4                953           MOVE.L   MIN_RAM,A4
00001830  3214                     954  CHECK1   MOVE.W   (A4),D1
00001832  B27C 0000                955           CMP.W    #0,D1
00001836  6600 0042                956           BNE      MEMFAIL
0000183A  49EC 0002                957  CHECK2   LEA.L    2(A4),A4          Point to next address to read
0000183E  B9F8 07D8                958           CMP.L    MAX_RAM,A4
00001842  66EC                     959           BNE      CHECK1
00001844  2878 07D4                960           MOVE.L   MIN_RAM,A4
00001848  323C FFFF                961  LOOPRAM1 MOVE.W   #65535,D1
0000184C  3881                     962           MOVE.W   D1,(A4)
0000184E  49EC 0002                963           LEA.L    2(A4),A4          Point to next address to display
00001852  B9F8 07D8                964           CMP.L    MAX_RAM,A4
00001856  66F0                     965           BNE      LOOPRAM1
00001858  2878 07D4                966           MOVE.L   MIN_RAM,A4
0000185C  3214                     967  CHECK3   MOVE.W   (A4),D1
0000185E  B27C FFFF                968           CMP.W    #65535,D1
00001862  6600 0032                969           BNE      MEMFAIL2
00001866  49EC 0002                970  CHECK4   LEA.L    2(A4),A4          Point to next address to read
0000186A  B9F8 07D8                971           CMP.L    MAX_RAM,A4
0000186E  66EC                     972           BNE      CHECK3
00001870  BC3C 0000                973           CMP.B    #0,D6
00001874  6700 003C                974           BEQ      MEMGOOD
00001878  4E75                     975           RTS
0000187A                           976  
0000187A  2F0C                     977  MEMFAIL  MOVE.L  A4,-(A7)          Save A4 
0000187C  7C01                     978           MOVE.L  #1,D6
0000187E  6100 F7EE                979           BSR.W   NEWLINE
00001882  49F9 00001EA2            980           LEA.L   MEMFMSG,A4
00001888  6100 F7F4                981           BSR.W   PSTRING
0000188C  285F                     982           MOVE.L  (A7)+,A4          Restore A4
0000188E  200C                     983           MOVE.L  A4,D0
00001890  6100 F98E                984           BSR.W    OUT8X 
00001894  60A4                     985           BRA     CHECK2
00001896                           986  
00001896  2F0C                     987  MEMFAIL2 MOVE.L  A4,-(A7)          Save A4 
00001898  7C01                     988           MOVE.L  #1,D6
0000189A  6100 F7D2                989           BSR.W   NEWLINE
0000189E  49F9 00001EA2            990           LEA.L   MEMFMSG,A4
000018A4  6100 F7D8                991           BSR.W   PSTRING
000018A8  285F                     992           MOVE.L  (A7)+,A4          Restore A4
000018AA  200C                     993           MOVE.L  A4,D0
000018AC  6100 F972                994           BSR.W    OUT8X 
000018B0  60B4                     995           BRA     CHECK4         
000018B2                           996   
000018B2  49F9 00001EB2            997  MEMGOOD  LEA.L  MEMGMSG,A4
000018B8  6100 F7C4                998           BSR.W  PSTRING
000018BC  4E75                     999           RTS
000018BE                          1000  
000018BE                          1001  *************************************************************************         
000018BE                          1002  * 
000018BE                          1003  *  Exception handling routines 
000018BE                          1004  * 
000018BE  =000018BE               1005  IL_ER   EQU      *                Illegal instruction exception 
000018BE  2F0C                    1006          MOVE.L  A4,-(A7)          Save A4 
000018C0  49FA 0366               1007          LEA.L   MES10(PC),A4      Point to heading 
000018C4  6100 F7C8               1008          BSR     HEADING           Print it 
000018C8  285F                    1009          MOVE.L  (A7)+,A4          Restore A4 
000018CA  6176                    1010          BSR.S   GROUP2            Save registers in display frame 
000018CC  6100 FDC6               1011          BSR     EX_DIS            Display registers saved in frame 
000018D0  6000 F78C               1012          BRA     WARM              Abort from illegal instruction 
000018D4                          1013  * 
000018D4  =000018D4               1014  BUS_ER  EQU     *                 Bus error (group 1) exception 
000018D4  2F0C                    1015          MOVE.L  A4,-(A7)          Save A4 
000018D6  49FA 0330               1016          LEA.L   MES8(PC),A4       Point to heading 
000018DA  6100 F7B2               1017          BSR     HEADING           Print it 
000018DE  285F                    1018          MOVE.L  (A7)+,A4          Restore A4 
000018E0  602C                    1019          BRA.S   GROUP1            Deal with group 1 exception 
000018E2                          1020  * 
000018E2  =000018E2               1021  ADD_ER  EQU     *                 Address error (group 1) exception 
000018E2  2F0C                    1022          MOVE.L  A4,-(A7)          Save A4 
000018E4  49FA 0330               1023          LEA.L   MES9(PC),A4       Point to heading 
000018E8  6100 F7A4               1024          BSR     HEADING           Print it 
000018EC  285F                    1025          MOVE.L  (A7)+,A4          Restore A4 
000018EE  601E                    1026          BRA.S   GROUP1            Deal with group 1 exception 
000018F0                          1027  * 
000018F0  =000018F0               1028  BRKPT   EQU     *                   Deal with breakpoint 
000018F0  48E7 FFFE               1029          MOVEM.L D0-D7/A0-A6,-(A7)   Save all registers 
000018F4  6100 0180               1030          BSR     BR_CLR              Clear breakpoints in code 
000018F8  4CDF 7FFF               1031          MOVEM.L (A7)+,D0-D7/A0-A6   Restore registers 
000018FC  6144                    1032          BSR.S   GROUP2            Treat as group 2 exception 
000018FE  49FA 033E               1033          LEA.L   MES11(PC),A4      Point to heading 
00001902  6100 F78A               1034          BSR     HEADING           Print it 
00001906  6100 FD8C               1035          BSR     EX_DIS            Display saved registers 
0000190A  6000 F752               1036          BRA     WARM              Return to monitor 
0000190E                          1037  * 
0000190E                          1038  *       GROUP1 is called by address and bus error exceptions 
0000190E                          1039  *       These are "turned into group 2" exceptions (eg TRAP) 
0000190E                          1040  *       by modifying the stack frame saved by a group 1 exception 
0000190E                          1041  * 
0000190E  48E7 8080               1042  GROUP1  MOVEM.L D0/A0,-(A7)       Save working registers 
00001912  206F 0012               1043          MOVE.L  18(A7),A0         Get PC from group 1 stack frame 
00001916  302F 000E               1044          MOVE.W  14(A7),D0         Get instruction from stack frame 
0000191A  B060                    1045          CMP.W   -(A0),D0          Now backtrack to find the "correct PC" 
0000191C  670E                    1046          BEQ.S   GROUP1A           by matching the op-code on the stack 
0000191E  B060                    1047          CMP.W   -(A0),D0          with the code in the region of the 
00001920  670A                    1048          BEQ.S   GROUP1A           PC on the stack 
00001922  B060                    1049          CMP.W   -(A0),D0 
00001924  6706                    1050          BEQ.S   GROUP1A 
00001926  B060                    1051          CMP.W   -(A0),D0 
00001928  6702                    1052          BEQ.S   GROUP1A 
0000192A  5588                    1053          SUBQ.L  #2,A0 
0000192C  2F48 0012               1054  GROUP1A MOVE.L  A0,18(A7)          Restore modified PC to stack frame 
00001930  4CDF 0101               1055          MOVEM.L (A7)+,D0/A0        Restore working registers 
00001934  4FEF 0008               1056          LEA.L   8(A7),A7           Adjust stack pointer to group 1 type 
00001938  6108                    1057          BSR.S   GROUP2             Now treat as group 1 exception 
0000193A  6100 FD58               1058          BSR     EX_DIS             Display contents of exception frame 
0000193E  6000 F71E               1059          BRA     WARM               Exit to monitor - no RTE from group 2 
00001942                          1060  * 
00001942  =00001942               1061  GROUP2  EQU     *                 Deal with group 2 exceptions 
00001942  48E7 FFFF               1062          MOVEM.L A0-A7/D0-D7,-(A7) Save all registers on the stack 
00001946  303C 000E               1063          MOVE.W  #14,D0            Transfer D0 - D7, A0 - A6 from 
0000194A  41EE 045A               1064          LEA.L   TSK_T(A6),A0      the stack to the display frame 
0000194E  20DF                    1065  GROUP2A MOVE.L  (A7)+,(A0)+       Move a register from stack to frame 
00001950  51C8 FFFC               1066          DBRA    D0,GROUP2A        and repeat until D0-D7/A0-A6 moved 
00001954  4E6A                    1067          MOVE.L  USP,A2            Get the user stack pointer and put it 
00001956  20CA                    1068          MOVE.L  A2,(A0)+          in the A7 position in the frame 
00001958  201F                    1069          MOVE.L  (A7)+,D0          Now transfer the SSP to the frame, 
0000195A  0480 0000000A           1070          SUB.L   #10,D0            remembering to account for the 
00001960  20C0                    1071          MOVE.L  D0,(A0)+          data pushed on the stack to this point 
00001962  225F                    1072          MOVE.L  (A7)+,A1          Copy TOS (return address) to A1 
00001964  30DF                    1073          MOVE.W  (A7)+,(A0)+       Move SR to display frame 
00001966  201F                    1074          MOVE.L  (A7)+,D0          Get PC in D0 
00001968  5580                    1075          SUBQ.L  #2,D0             Move back to current instruction 
0000196A  20C0                    1076          MOVE.L  D0,(A0)+          Put adjusted PC in display frame 
0000196C  4ED1                    1077          JMP     (A1)              Return from subroutine 
0000196E                          1078  * 
0000196E                          1079  ************************************************************************* 
0000196E                          1080  * 
0000196E                          1081  *  GO executes a program either from a supplied address or 
0000196E                          1082  *  by using the data in the display frame 
0000196E  6100 F842               1083  GO       BSR     PARAM               Get entry address (if any) 
00001972  4A07                    1084           TST.B   D7                  Test for error in input 
00001974  6708                    1085           BEQ.S   GO1                 If D7 zero then OK 
00001976  49FA 0306               1086           LEA.L   ERMES1(PC),A4       Else point to error message, 
0000197A  6000 F702               1087           BRA     PSTRING             print it and return 
0000197E  4A80                    1088  GO1      TST.L   D0                  If no address entered then get 
00001980  670A                    1089           BEQ.S   GO2                 address from display frame 
00001982  2D40 04A0               1090           MOVE.L  D0,TSK_T+70(A6)     Else save address in display frame 
00001986  3D7C 0700 049E          1091           MOVE.W  #$0700,TSK_T+68(A6) Store dummy status in frame 
0000198C  6006                    1092  GO2      BRA.S   RESTORE             Restore volatile environment and go 
0000198E                          1093  * 
0000198E  6100 007A               1094  GB       BSR     BR_SET              Same as go but presets breakpoints 
00001992  60DA                    1095           BRA.S   GO                  Execute program 
00001994                          1096  * 
00001994                          1097  *        RESTORE moves the volatile environment from the display 
00001994                          1098  *        frame and transfers it to the 68000's registers. This 
00001994                          1099  *        re-runs a program suspended after an exception 
00001994                          1100  * 
00001994  47EE 045A               1101  RESTORE  LEA.L   TSK_T(A6),A3        A3 points to display frame 
00001998  47EB 004A               1102           LEA.L   74(A3),A3           A3 now points to end of frame + 4 
0000199C  4FEF 0004               1103           LEA.L   4(A7),A7            Remove return address from stack 
000019A0  303C 0024               1104           MOVE.W  #36,D0              Counter for 37 words to be moved 
000019A4  3F23                    1105  REST1    MOVE.W  -(A3),-(A7)         Move word from display frame to stack 
000019A6  51C8 FFFC               1106           DBRA    D0,REST1            Repeat until entire frame moved 
000019AA  4CDF 00FF               1107           MOVEM.L (A7)+,D0-D7         Restore old data registers from stack 
000019AE  4CDF 7F00               1108           MOVEM.L (A7)+,A0-A6         Restore old address registers 
000019B2  4FEF 0008               1109           LEA.L   8(A7),A7            Except SSP/USP - so adjust stack 
000019B6  4E73                    1110           RTE                         Return from exception to run program 
000019B8                          1111  * 
000019B8  =000019B8               1112  TRACE    EQU     *                   TRACE exception (rudimentary version) 
000019B8  287A 0292               1113           MOVE.L  MES12(PC),A4        Point to heading 
000019BC  6100 F6D0               1114           BSR     HEADING             Print it 
000019C0  6100 FF4C               1115           BSR     GROUP1              Save volatile environment 
000019C4  6100 FCCE               1116           BSR     EX_DIS              Display it 
000019C8  6000 F694               1117           BRA     WARM                Return to monitor 
000019CC                          1118  * 
000019CC                          1119  ************************************************************************* 
000019CC                          1120  *  Breakpoint routines: BR_GET gets the address of a breakpoint and 
000019CC                          1121  *  puts it in the breakpoint table. It does not plant it in the code. 
000019CC                          1122  *  BR_SET plants all breakpoints in the code. NOBR removes one or all 
000019CC                          1123  *  breakpoints from the table. KILL removes breakpoints from the code. 
000019CC                          1124  * 
000019CC  6100 F7E4               1125  BR_GET   BSR     PARAM               Get breakpoint address in table 
000019D0  4A07                    1126           TST.B   D7                  Test for input error 
000019D2  6708                    1127           BEQ.S   BR_GET1             If no error then continue 
000019D4  49FA 02A8               1128           LEA.L   ERMES1(PC),A4       Else display error 
000019D8  6000 F6A4               1129           BRA     PSTRING             and return 
000019DC  47EE 04A4               1130  BR_GET1  LEA.L   BP_TAB(A6),A3       A6 points to breakpoint table 
000019E0  2A40                    1131           MOVE.L  D0,A5               Save new BP address in A5 
000019E2  2C00                    1132           MOVE.L  D0,D6               and in D6 because D0 gets corrupted 
000019E4  3A3C 0007               1133           MOVE.W  #7,D5               Eight entries to test 
000019E8  201B                    1134  BR_GET2  MOVE.L  (A3)+,D0            Read entry from breakpoint table 
000019EA  660C                    1135           BNE.S   BR_GET3             If not zero display existing BP 
000019EC  4A86                    1136           TST.L   D6                  Only store a non-zero breakpoint 
000019EE  6710                    1137           BEQ.S   BR_GET4 
000019F0  274D FFFC               1138           MOVE.L  A5,-4(A3)           Store new breakpoint in table 
000019F4  3695                    1139           MOVE.W  (A5),(A3)           Save code at BP address in table 
000019F6  4286                    1140           CLR.L   D6                  Clear D6 to avoid repetition 
000019F8  6100 F826               1141  BR_GET3  BSR     OUT8X               Display this breakpoint 
000019FC  6100 F670               1142           BSR     NEWLINE 
00001A00  47EB 0002               1143  BR_GET4  LEA.L   2(A3),A3            Step past stored op-code 
00001A04  51CD FFE2               1144           DBRA    D5,BR_GET2          Repeat until all entries tested 
00001A08  4E75                    1145           RTS                         Return 
00001A0A                          1146  * 
00001A0A  =00001A0A               1147  BR_SET   EQU     *                   Plant any breakpoints in user code 
00001A0A  41EE 04A4               1148           LEA.L   BP_TAB(A6),A0       A0 points to BP table 
00001A0E  45EE 04A0               1149           LEA.L   TSK_T+70(A6),A2     A2 points to PC in display frame 
00001A12  2452                    1150           MOVE.L  (A2),A2             Now A2 contains value of PC 
00001A14  303C 0007               1151           MOVE.W  #7,D0               Up to eight entries to plant 
00001A18  2218                    1152  BR_SET1  MOVE.L  (A0)+,D1            Read breakpoint address from table 
00001A1A  670A                    1153           BEQ.S   BR_SET2             If zero then skip planting 
00001A1C  B28A                    1154           CMP.L   A2,D1               Don't want to plant BP at current PC 
00001A1E  6706                    1155           BEQ.S   BR_SET2             location, so skip planting if same 
00001A20  2241                    1156           MOVE.L  D1,A1               Transfer BP address to address reg 
00001A22  32BC 4E4E               1157           MOVE.W  #TRAP_16,(A1)       Plant op-code for TRAP #14 in code 
00001A26  41E8 0002               1158  BR_SET2  LEA.L   2(A0),A0            Skip past op-code field in table 
00001A2A  51C8 FFEC               1159           DBRA    D0,BR_SET1          Repeat until all entries tested 
00001A2E  4E75                    1160           RTS 
00001A30                          1161  * 
00001A30  =00001A30               1162  NOBR     EQU     *                   Clear one or all breakpoints 
00001A30  6100 F780               1163           BSR     PARAM               Get BP address (if any) 
00001A34  4A07                    1164           TST.B   D7                  Test for input error 
00001A36  6708                    1165           BEQ.S   NOBR1               If no error then skip abort 
00001A38  49FA 0244               1166           LEA.L   ERMES1(PC),A4       Point to error message 
00001A3C  6000 F640               1167           BRA     PSTRING             Display it and return 
00001A40  4A80                    1168  NOBR1    TST.L   D0                  Test for null address (clear all) 
00001A42  6720                    1169           BEQ.S   NOBR4               If no address then clear all entries 
00001A44  2240                    1170           MOVE.L  D0,A1               Else just clear breakpoint in A1 
00001A46  41EE 04A4               1171           LEA.L   BP_TAB(A6),A0       A0 points to BP table 
00001A4A  303C 0007               1172           MOVE.W  #7,D0               Up to eight entries to test 
00001A4E  2218                    1173  NOBR2    MOVE.L  (A0)+,D1            Get entry and 
00001A50  41E8 0002               1174           LEA.L   2(A0),A0            skip past op-code field 
00001A54  B289                    1175           CMP.L   A1,D1               Is this the one? 
00001A56  6706                    1176           BEQ.S   NOBR3               If so go and clear entry 
00001A58  51C8 FFF4               1177           DBRA    D0,NOBR2            Repeat until all tested 
00001A5C  4E75                    1178           RTS 
00001A5E  42A8 FFFA               1179  NOBR3    CLR.L   -6(A0)              Clear address in BP table 
00001A62  4E75                    1180           RTS 
00001A64  41EE 04A4               1181  NOBR4    LEA.L   BP_TAB(A6),A0       Clear all 8 entries in BP table 
00001A68  303C 0007               1182           MOVE.W  #7,D0               Eight entries to clear 
00001A6C  4298                    1183  NOBR5    CLR.L   (A0)+               Clear breakpoint address 
00001A6E  4258                    1184           CLR.W   (A0)+               Clear op-code field 
00001A70  51C8 FFFA               1185           DBRA    D0,NOBR5            Repeat until all done 
00001A74  4E75                    1186           RTS 
00001A76                          1187  * 
00001A76  =00001A76               1188  BR_CLR   EQU     *                   Remove breakpoints from code 
00001A76  41EE 04A4               1189           LEA.L   BP_TAB(A6),A0       A0 points to breakpoint table 
00001A7A  303C 0007               1190           MOVE.W  #7,D0               Up to eight entries to clear 
00001A7E  2218                    1191  BR_CLR1  MOVE.L  (A0)+,D1            Get address of BP in D1 
00001A80  2241                    1192           MOVE.L  D1,A1               and put copy in A1 
00001A82  4A81                    1193           TST.L   D1                  Test this breakpoint 
00001A84  6702                    1194           BEQ.S   BR_CLR2             If zero then skip BP clearing 
00001A86  3290                    1195           MOVE.W  (A0),(A1)           Else restore op-code 
00001A88  41E8 0002               1196  BR_CLR2  LEA.L   2(A0),A0            Skip past op-code field 
00001A8C  51C8 FFF0               1197           DBRA    D0,BR_CLR1          Repeat until all tested 
00001A90  4E75                    1198           RTS 
00001A92                          1199  * 
00001A92                          1200  *  REG_MOD modifies a register in the display frame. The command 
00001A92                          1201  *  format is REG <reg> <value>. E.g. REG D3 1200 
00001A92                          1202  * 
00001A92  4281                    1203  REG_MOD  CLR.L   D1                  D1 to hold name of register 
00001A94  41EE 0444               1204           LEA.L   BUFFPT(A6),A0       A0 contains address of buffer pointer 
00001A98  2050                    1205           MOVE.L  (A0),A0             A0 now points to next char in buffer 
00001A9A  1218                    1206           MOVE.B  (A0)+,D1            Put first char of name in D1 
00001A9C  E159                    1207           ROL.W   #8,D1               Move char one place left 
00001A9E  1218                    1208           MOVE.B  (A0)+,D1            Get second char in D1 
00001AA0  41E8 0001               1209           LEA.L   1(A0),A0            Move pointer past space in buffer 
00001AA4  2D48 0444               1210           MOVE.L  A0,BUFFPT(A6)       Update buffer pointer 
00001AA8  4282                    1211           CLR.L   D2                  D2 is the character pair counter 
00001AAA  41FA 01A9               1212           LEA.L   REGNAME(PC),A0      A0 points to string of character pairs 
00001AAE  43D0                    1213           LEA.L   (A0),A1             A1 also points to string 
00001AB0  B258                    1214  REG_MD1  CMP.W   (A0)+,D1            Compare a char pair with input 
00001AB2  6712                    1215           BEQ.S   REG_MD2             If match then exit loop 
00001AB4  5282                    1216           ADD.L   #1,D2               Else increment match counter 
00001AB6  B4BC 00000013           1217           CMP.L   #19,D2              Test for end of loop 
00001ABC  66F2                    1218           BNE     REG_MD1             Continue until all pairs matched 
00001ABE  49FA 01BE               1219           LEA.L   ERMES1(PC),A4       If here then error 
00001AC2  6000 F5BA               1220           BRA     PSTRING             Display error and return 
00001AC6  43EE 045A               1221  REG_MD2  LEA.L   TSK_T(A6),A1        A1 points to display frame 
00001ACA  E582                    1222           ASL.L   #2,D2               Multiply offset by 4 (4 bytes/entry) 
00001ACC  B4BC 00000048           1223           CMP.L   #72,D2              Test for address of PC 
00001AD2  6602                    1224           BNE.S   REG_MD3             If not PC then all is OK 
00001AD4  5582                    1225           SUB.L   #2,D2               else dec PC pointer as Sr is a word 
00001AD6  45F1 2000               1226  REG_MD3  LEA.L   (A1,D2),A2          Calculate address of entry in disptable 
00001ADA  2012                    1227           MOVE.L  (A2),D0             Get old contents 
00001ADC  6100 F742               1228           BSR     OUT8X               Display them 
00001AE0  6100 F58C               1229           BSR     NEWLINE 
00001AE4  6100 F6CC               1230           BSR     PARAM               Get new data 
00001AE8  4A07                    1231           TST.B   D7                  Test for input error 
00001AEA  6708                    1232           BEQ.S   REG_MD4             If no error then go and store data 
00001AEC  49FA 0190               1233           LEA.L   ERMES1(PC),A4       Else point to error message 
00001AF0  6000 F58C               1234           BRA     PSTRING             print it and return 
00001AF4  B4BC 00000044           1235  REG_MD4  CMP.L   #68,D2              If this address is the SR then 
00001AFA  6704                    1236           BEQ.S   REG_MD5             we have only a word to store 
00001AFC  2480                    1237           MOVE.L  D0,(A2)             Else store new data in display frame 
00001AFE  4E75                    1238           RTS 
00001B00  3480                    1239  REG_MD5  MOVE.W  D0,(A2)             Store SR (one word) 
00001B02  4E75                    1240           RTS 
00001B04                          1241  * 
00001B04                          1242  ************************************************************************* 
00001B04                          1243  * 
00001B04  =00001B04               1244  X_UN    EQU     *                 Uninitialized exception vector routine 
00001B04  49FA 01DE               1245          LEA.L   ERMES6(PC),A4     Point to error message 
00001B08  6100 F574               1246          BSR     PSTRING           Display it 
00001B0C  6100 FB86               1247          BSR     EX_DIS            Display registers 
00001B10  6000 F54C               1248          BRA     WARM              Abort 
00001B14                          1249  * 
00001B14                          1250  ************************************************************************* 
00001B14                          1251  * 
00001B14                          1252  *  All strings and other fixed parameters here 
00001B14                          1253  * 
00001B14= 54 53 42 55 47 20 ...   1254  BANNER   DC.B     'TSBUG 2 Version 23.07.86',0,0
00001B2E= 4D 6F 64 69 66 69 ...   1255  MODIFY    DC.B   'Modified by Eugene A. Rockey Jr. Jan.05.2010',0,0
00001B5C= 66 6F 72 20 75 73 ...   1256  WHY      DC.B     'for use with the M68000 Minimal Computer Configuration',0,0 
00001B94= 55 6E 69 76 65 72 ...   1257  WHERE    DC.B     'University of Louisville',0,0
00001BAE= 0D 0A 54 53 32 4D ...   1258  CRLF     DC.B     CR,LF,'TS2MON >',0 
00001BB9= 0D 0A 53 31 00 00       1259  HEADER   DC.B     CR,LF,'S','1',0,0 
00001BBF= 53 39 20 20 00 00       1260  TAIL     DC.B     'S9  ',0,0 
00001BC5= 20 53 52 20 20 3D ...   1261  MES1     DC.B     ' SR  =  ',0 
00001BCE= 20 50 43 20 20 3D ...   1262  MES2     DC.B     ' PC  =  ',0 
00001BD7= 20 53 53 20 20 3D ...   1263  MES2A    DC.B     ' SS  =  ',0 
00001BE0= 20 20 44 61 74 61 ...   1264  MES3     DC.B     '  Data reg       Address reg',0,0 
00001BFE= 20 20 20 20 20 20 ...   1265  MES4     DC.B     '        ',0,0 
00001C08= 42 75 73 20 65 72 ...   1266  MES8     DC.B     'Bus error   ',0,0 
00001C16= 41 64 64 72 65 73 ...   1267  MES9     DC.B     'Address error   ',0,0 
00001C28= 49 6C 6C 65 67 61 ...   1268  MES10    DC.B     'Illegal instruction ',0,0 
00001C3E= 42 72 65 61 6B 70 ...   1269  MES11    DC.B     'Breakpoint  ',0,0 
00001C4C= 54 72 61 63 65 20 ...   1270  MES12    DC.B     'Trace   ',0 
00001C55= 44 30 44 31 44 32 ...   1271  REGNAME  DC.B     'D0D1D2D3D4D5D6D7' 
00001C65= 41 30 41 31 41 32 ...   1272           DC.B     'A0A1A2A3A4A5A6A7' 
00001C75= 53 53 53 52             1273           DC.B     'SSSR' 
00001C79= 50 43 20 20 00          1274           DC.B     'PC  ',0 
00001C7E= 4E 6F 6E 2D 76 61 ...   1275  ERMES1   DC.B     'Non-valid hexadecimal input  ',0 
00001C9C= 49 6E 76 61 6C 69 ...   1276  ERMES2   DC.B     'Invalid command  ',0 
00001CAE= 4C 6F 61 64 69 6E ...   1277  ERMES3   DC.B     'Loading error',0 
00001CBC= 54 61 62 6C 65 20 ...   1278  ERMES4   DC.B     'Table full  ',0,0 
00001CCA= 42 72 65 61 6B 70 ...   1279  ERMES5   DC.B     'Breakpoint not active   ',0,0 
00001CE4= 55 6E 69 6E 69 74 ...   1280  ERMES6   DC.B     'Uninitialized exception ',0,0 
00001CFE= 4A 55 4D 50 20 3C ...   1281  JUMPHELP DC.B     'JUMP <address> causes execution to begin at <address>',0   
00001D34= 4D 45 4D 4F 52 59 ...   1282  MEMHELP  DC.B     'MEMORY <address> examines contents of address> and allows them to be changed', 0   
00001D81= 4C 4F 41 44 20 3C ...   1283  LOADHELP DC.B     'LOAD <string> loads S1/S2 records from the host. <string> is sent to host', 0
00001DCB= 54 56 20 63 68 65 ...   1284  TVHELP   DC.B     'TV checks all RAM addresses from $4000 to $40FE. Reports corrupt memory addresses', 0
00001E1D= 20 52 61 6E 67 65 ...   1285  ERMES7   DC.B     ' Range error',0
00001E2A= 55 53 45 52 00          1286  UNAME    DC.B     'USER', 0
00001E2F= 50 41 53 53 57 4F ...   1287  PWORD    DC.B     'PASSWORD',0
00001E38= 45 6E 74 65 72 20 ...   1288  LOGINM1  DC.B     'Enter username: ', 0
00001E49= 45 6E 74 65 72 20 ...   1289  LOGINM2  DC.B     'Enter password: ', 0
00001E5A= 49 6E 63 6F 72 72 ...   1290  USRERR   DC.B     'Incorrect username', 0
00001E6D= 43 6F 72 72 65 63 ...   1291  USRSUC   DC.B     'Correct Username', 0
00001E7E= 49 6E 63 6F 72 72 ...   1292  PWERR   DC.B     'Incorrect password', 0
00001E91= 43 6F 72 72 65 63 ...   1293  PWSUC    DC.B     'Correct Password', 0
00001EA2= 4D 45 4D 4F 52 59 ...   1294  MEMFMSG  DC.B     'MEMORY BAD AT: ',0
00001EB2= 41 4C 4C 20 52 41 ...   1295  MEMGMSG  DC.B      'ALL RAM GOOD', 0
00001EBF                          1296   
00001EBF                          1297  * 
00001EBF                          1298  *  COMTAB is the built-in command table. All entries are made up of 
00001EBF                          1299  *         a string length + number of characters to match + the string 
00001EBF                          1300  *         plus the address of the command relative to COMTAB 
00001EBF                          1301  * 
00002000                          1302           ORG      $2000
00002000= 04 04                   1303  COMTAB   DC.B     4,4              JUMP <address> causes execution to 
00002002= 4A 55 4D 50             1304           DC.B     'JUMP'           begin at <address> 
00002006= FFFFF228                1305           DC.L     JUMP-COMTAB                                           
0000200A= 08 03                   1306           DC.B     8,3              MEMORY <address> examines contents of 
0000200C= 4D 45 4D 4F 52 59 ...   1307           DC.B     'MEMORY  '       <address> and allows them to be changed 
00002014= FFFFF23E                1308           DC.L     MEMORY-COMTAB 
00002018= 04 02                   1309           DC.B     4,2              LOAD <string> loads S1/S2 records 
0000201A= 4C 4F 41 44             1310           DC.B     'LOAD'           from the host. <string> is sent to host 
0000201E= FFFFF29E                1311           DC.L     LOAD-COMTAB 
00002022= 04 04                   1312           DC.B    4,4               HELP 
00002024= 48 45 4C 50             1313           DC.B    'HELP'            
00002028= FFFFF712                1314           DC.L    HELP-COMTAB      
0000202C= 02 02                   1315           DC.B    2,2
0000202E= 54 56                   1316           DC.B    'TV'
00002030= FFFFF814                1317           DC.L    TV-COMTAB
00002034= 00 00                   1318           DC.B    0,0 
00002036                          1319  * 
00002036                          1320  ************************************************************************* 
00002036                          1321  * 
00002036                          1322  *  This is a list of the information needed to setup the DCBs 
00002036                          1323  * 
00002036  =00002036               1324  DCB_LST  EQU     * 
00002036= 43 4F 4E 5F 49 4E ...   1325  DCB1     DC.B    'CON_IN  '          Device name (8 bytes) 
0000203E= 000014CC 00008001       1326           DC.L    CON_IN,ACIA_1       Address of driver routine, device 
00002046= 0002                    1327           DC.W    2                   Number of words in parameter field 
00002048= 43 4F 4E 5F 4F 55 ...   1328  DCB2     DC.B    'CON_OUT ' 
00002050= 000014E2 00008001       1329           DC.L    CON_OUT,ACIA_1 
00002058= 0002                    1330           DC.W    2 
0000205A= 41 55 58 5F 49 4E ...   1331  DCB3     DC.B    'AUX_IN  ' 
00002062= 000014F8 00008001       1332           DC.L    AUX_IN,ACIA_2 
0000206A= 0002                    1333           DC.W    2 
0000206C= 41 55 58 5F 4F 55 ...   1334  DCB4     DC.B    'AUX_OUT ' 
00002074= 0000150A 00008001       1335           DC.L    AUX_OUT,ACIA_2 
0000207C= 0002                    1336           DC.W    2 
0000207E= 42 55 46 46 5F 49 ...   1337  DCB5     DC.B    'BUFF_IN ' 
00002086= 00001560 000006D4       1338           DC.L    BUFF_IN,BUFFER 
0000208E= 0002                    1339           DC.W    2 
00002090= 42 55 46 46 5F 4F ...   1340  DCB6     DC.B    'BUFF_OUT' 
00002098= 0000156C 000006D4       1341           DC.L    BUFF_OT,BUFFER 
000020A0= 0002                    1342           DC.W    2 
000020A2                          1343  * 
000020A2                          1344  ************************************************************************* 
000020A2                          1345  * 
000020A2                          1346  *  DCB structure 
000020A2                          1347  * 
000020A2                          1348  *              ----------------------- 
000020A2                          1349  *       0 ->   | DCB  name           | 
000020A2                          1350  *              |---------------------| 
000020A2                          1351  *       8 ->   | Device driver       | 
000020A2                          1352  *              |---------------------| 
000020A2                          1353  *      12 ->   | Device address      | 
000020A2                          1354  *              |---------------------| 
000020A2                          1355  *      16 ->   |Size of param block  | 
000020A2                          1356  *              |---------------------| --- 
000020A2                          1357  *      18 ->   |      Status         |   | 
000020A2                          1358  *              | logical  | physical |   | S 
000020A2                          1359  *              |---------------------|   | 
000020A2                          1360  *              .                     .   . 
000020A2                          1361  *              |---------------------| --- 
000020A2                          1362  *    18+S ->   | Pointer to next DCB | 
000020A2                          1363  * 
000020A2                          1364           END RESET 

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ACIA_1              8001
ACIA_2              8001
ADD_ER              18E2
ADR_DAT             127C
AUX_IN              14F8
AUX_IN1             14FE
AUX_OT1             1510
AUX_OUT             150A
BANNER              1B14
BP_TAB              4A4
BRKPT               18F0
BR_CLR              1A76
BR_CLR1             1A7E
BR_CLR2             1A88
BR_GET              19CC
BR_GET1             19DC
BR_GET2             19E8
BR_GET3             19F8
BR_GET4             1A00
BR_SET              1A0A
BR_SET1             1A18
BR_SET2             1A26
BS                  8
BUFFEND             443
BUFFER              6D4
BUFFPT              444
BUFF_IN             1560
BUFF_OT             156C
BUS_ER              18D4
BYTE                1196
CHECK1              1830
CHECK2              183A
CHECK3              185C
CHECK4              1866
CN_IVEC             452
CN_OVEC             456
COMTAB              2000
CON_IN              14CC
CON_OUT             14E2
CR                  D
CRLF                1BAE
CTRL_A              1
DATA                4800
DCB1                2036
DCB2                2048
DCB3                205A
DCB4                206C
DCB5                207E
DCB6                2090
DCB_LST             2036
DELAY               141A
DELAY1              1424
DUMP                1372
DUMP1               1382
DUMP2               138E
DUMP3               13A4
DUMP4               13B8
DUMP5               13C6
DUMP6               13E0
DUMP7               1404
ECHO                44C
ERMES1              1C7E
ERMES2              1C9C
ERMES3              1CAE
ERMES4              1CBC
ERMES5              1CCA
ERMES6              1CE4
ERMES7              1E1D
ESC                 1B
EXEC1               111E
EXEC2               112E
EXECUTE             110C
EX_D1               16A6
EX_DIS              1694
FIRST               4D4
FOO1                15D2
FOO10               163E
FOO11               164A
FOO12               1656
FOO13               1662
FOO14               166E
FOO15               167A
FOO16               1686
FOO17               1692
FOO2                15DE
FOO3                15EA
FOO4                15F6
FOO5                1602
FOO6                160E
FOO7                161A
FOO8                1626
FOO9                1632
GB                  198E
GETCH2              1540
GETCH3              1548
GETCHAR             151C
GETLINE             1094
GETLN2              109E
GETLN3              10B8
GETLN4              10C2
GETLN5              10C6
GO                  196E
GO1                 197E
GO2                 198C
GROUP1              190E
GROUP1A             192C
GROUP2              1942
GROUP2A             194E
HEADER              1BB9
HEADING             108E
HELP                1712
HEX                 1178
HEX_OK              1194
IL_ER               18BE
IO_OPEN             157A
IO_REQ              14BA
JUMP                1228
JUMP1               1236
JUMPHELP            1CFE
LF                  A
LNBUFF              404
LOAD                129E
LOAD1               12CA
LOAD2               12DA
LOAD3               12F4
LOAD4               130E
LOAD5               131C
LOAD6               131E
LOAD6A              1342
LOAD7               1354
LOAD8               136A
LOADHELP            1D81
LOGIN               1748
LOGIN1              1768
LOGIN2              17AC
LOGINM1             1E38
LOGINM2             1E49
LONGWD              11AC
LOOPRAM             181C
LOOPRAM1            1848
MAXCHR              40
MAX_RAM             7D8
MEM1                1248
MEM2                1266
MEM3                127A
MEMFAIL             187A
MEMFAIL2            1896
MEMFMSG             1EA2
MEMGMSG             1EB2
MEMGOOD             18B2
MEMHELP             1D34
MEMORY              123E
MES1                1BC5
MES10               1C28
MES11               1C3E
MES12               1C4C
MES2                1BCE
MES2A               1BD7
MES3                1BE0
MES4                1BFE
MES8                1C08
MES9                1C16
MIN_RAM             7D4
MODIFY              1B2E
NEWLINE             106E
NOBR                1A30
NOBR1               1A40
NOBR2               1A4E
NOBR3               1A5E
NOBR4               1A64
NOBR5               1A6C
NOT_HEX             1190
NO_EXT              1054
NUL                 0
OPEN1               1582
OPEN2               158A
OPEN3               1598
OPEN4               15AE
OUT1X               11F6
OUT1X1              1208
OUT2X               1210
OUT4X               1218
OUT8X               1220
PARAM               11B2
PARAM1              11BA
PARAM3              11DE
PARAM4              11E2
PARAM5              11EE
PARAM6              11F2
PARAMTR             448
PS1                 1080
PS2                 108A
PSPACE              1290
PSTRING             107E
PUTCHAR             154C
PWERR               1E7E
PWORD               1E2F
PWSUC               1E91
QUIT                1810
RANGE               140A
REGNAME             1C55
REG_MD1             1AB0
REG_MD2             1AC6
REG_MD3             1AD6
REG_MD4             1AF4
REG_MD5             1B00
REG_MOD             1A92
RESET               1000
REST1               19A4
RESTORE             1994
SEARCH              1138
SET_DCB             1470
SPACE               20
SRCH2               1152
SRCH3               1156
SRCH4               115E
SRCH6               1168
SRCH7               1172
STACK               4400
ST_DCB1             1480
ST_DCB2             1484
TAIL                1BBF
TIDY                10CA
TIDY1               10D0
TIDY2               10DC
TIDY3               10E6
TIDY4               10F0
TIDY5               10FA
TIDY6               1106
TM                  142E
TM1                 143A
TRACE               19B8
TRAP_0              15C6
TRAP_16             4E4E
TSK_T               45A
TV                  1814
TVHELP              1DCB
UNAME               1E2A
UPASS               1806
USRERR              1E5A
USRSUC              1E6D
UTAB                44E
U_CASE              44D
WAIT                57
WARM                105E
WHERE               1B94
WHY                 1B5C
WORD                11A6
WRONG               17DE
WRONGPW             17F2
X_BASE              4000
X_SET               15B4
X_SET2              15BC
X_UN                1B04
