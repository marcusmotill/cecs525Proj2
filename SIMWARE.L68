00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.15.04
Created On: 9/21/15 6:52:48 PM

00000000                             1  *        TSBUG2 - 68000 monitor - version of 05 January 2010 
00000000                             2  
00000000                             3           ORG      $0
00000000= 00004400 00001000          4           DC.L     STACK,RESET
00000008                             5  *                                   Symbol equates 
00000008  =00000008                  6  BS       EQU      $08               Back_space 
00000008  =0000000D                  7  CR       EQU      $0D               Carriage_return 
00000008  =0000000A                  8  LF       EQU      $0A               Line_feed 
00000008  =00000020                  9  SPACE    EQU      $20               Space 
00000008  =00000057                 10  WAIT     EQU      'W'               Wait character (to suspend output) 
00000008  =0000001B                 11  ESC      EQU      $1B               ASCII escape character (used by TM) 
00000008  =00000001                 12  CTRL_A   EQU      $01               Control_A forces return to monitor 
00000008                            13  *                                   Device addresses 
00000008  =00004400                 14  STACK    EQU      $4400             Stack_pointer
00000008  =00008001                 15  ACIA_1   EQU      $8001             Console ACIA control 
00000008  =00008001                 16  ACIA_2   EQU      ACIA_1            Auxilary ACIA control 
00000008  =00004000                 17  X_BASE   EQU      $4000             Start of exception vector table 
00000008  =00004E4E                 18  TRAP_14  EQU      $4E4E             Code for TRAP #14 
00000008  =00000040                 19  MAXCHR   EQU      64                Length of input line buffer  
00000008                            20  * 
00000008  =00004800                 21  DATA     EQU      $4800             Data origin 
00000008                            22  LNBUFF   DS.B     MAXCHR            Input line buffer
00000048  =00000047                 23  BUFFEND  EQU      LNBUFF+MAXCHR-1   End of line buffer 
00000048                            24  BUFFPT   DS.L     1                 Pointer to line buffer 
0000004C                            25  PARAMTR  DS.L     1                 Last parameter from line buffer 
00000050                            26  ECHO     DS.B     1                 When clear this enable input echo 
00000051                            27  U_CASE   DS.B     1                 Flag for upper case conversion 
00000052                            28  UTAB     DS.L     1                 Pointer to user command table 
00000056                            29  CN_IVEC  DS.L     1                 Pointer to console input DCB 
0000005A                            30  CN_OVEC  DS.L     1                 Pointer to console output DCB 
0000005E                            31  TSK_T    DS.W     37                Frame for D0-D7, A0-A6, USP, SSP, SW, PC 
000000A8                            32  BP_TAB   DS.W     24                Breakpoint table 
000000D8                            33  FIRST    DS.B     512               DCB area 
000002D8                            34  BUFFER   DS.B     256               256 bytes for I/O buffer 
000003D8                            35  * 
000003D8                            36  ************************************************************************* 
000003D8                            37  * 
000003D8                            38  *  This is the main program which assembles a command in the line 
000003D8                            39  *  buffer, removes leading/embedded spaces and interprets it by matching 
000003D8                            40  *  it with a command in the user table or the built-in table COMTAB 
000003D8                            41  *  All variables are specified with respect to A6 
000003D8                            42  *
00001000                            43           ORG      $1000             Monitor Origin
00001000  =00001000                 44  RESET:   EQU      *
00001000  4DF8 4800                 45           LEA.L    DATA,A6           A6 points to data area 
00001004  2D4E 0096                 46           MOVE.L   A6,TSK_T+56(A6)   initialize A6 in the regster Frame
00001008  42AE 0052                 47           CLR.L    UTAB(A6)          Reset pointer to user extension table 
0000100C  1D7C 0001 0050            48           MOVE.B   #1,ECHO(A6)       Set automatic character echo 
00001012  422E 0051                 49           CLR.B    U_CASE(A6)        Clear case conversion flag (UC<-LC) 
00001016  6100 059A                 50           BSR.L    X_SET             what change did i do here
0000101A  6100 0456                 51           BSR.L    SET_DCB           Setup DCB table in RAM
0000101E  6150                      52           BSR.S    NEWLINE
00001020  49FA 0954                 53           LEA.L    BANNER(PC),A4    
00001024  615A                      54           BSR.S    PSTRING
00001026  6148                      55           BSR.S    NEWLINE           
00001028  49FA 0966                 56           LEA.L    MODIFY(PC),A4
0000102C  6152                      57           BSR.S    PSTRING
0000102E  6140                      58           BSR.S    NEWLINE
00001030  49FA 098C                 59           LEA.L    WHY(PC),A4
00001034  614A                      60           BSR.S    PSTRING
00001036  6138                      61           BSR.S    NEWLINE
00001038  49FA 09BC                 62           LEA.L    WHERE(PC),A4
0000103C  6142                      63           BSR.S    PSTRING
0000103E  6130                      64           BSR.S    NEWLINE
00001040  49FA 09CE                 65           LEA.L    ADDRE(PC),A4
00001044  613A                      66           BSR.S    PSTRING
00001046  6128                      67           BSR.S    NEWLINE
00001048  207C 00003000             68           MOVE.L   #$3000,A0         A0 points to extension ROM 
0000104E  2010                      69           MOVE.L   (A0),D0           Read first longword in extension ROM 
00001050  B0BC 524F4D32             70           CMP.L    #'ROM2',D0        If extension begins with 'ROM2' then 
00001056  6604                      71           BNE.S    NO_EXT            call the subroutine at EXT_ROM+8 
00001058  4EA8 0008                 72           JSR      8(A0)             else continue 
0000105C  4E71                      73  NO_EXT:  NOP                        Two NOPs to allow for a future 
0000105E  4E71                      74           NOP                        call to an initialization routine 
00001060  4287                      75  WARM:    CLR.L    D7                Warm entry point - clear error flag 
00001062  610C                      76           BSR.S    NEWLINE           Print a newline 
00001064  6130                      77           BSR.S    GETLINE           Get a command line 
00001066  6100 0064                 78           BSR      TIDY              Tidy up input buffer contents 
0000106A  6100 00A2                 79           BSR      EXECUTE           Interpret command 
0000106E  60F0                      80           BRA      WARM              Repeat indefinitely 
00001070                            81  * 
00001070                            82  ************************************************************************* 
00001070                            83  * 
00001070                            84  *  Some initialization and basic routines 
00001070                            85  * 
00001070                            86  * 
00001070  =00001070                 87  NEWLINE  EQU      *                 Move cursor to start of newline 
00001070  48E7 0008                 88           MOVEM.L  A4,-(A7)          Save A4 
00001074  49FA 09BD                 89           LEA.L    CRLF(PC),A4       Point to CR/LF string 
00001078  6106                      90           BSR.S    PSTRING           Print it 
0000107A  4CDF 1000                 91           MOVEM.L  (A7)+,A4          Restore A4 
0000107E  4E75                      92           RTS                        Return 
00001080                            93  * 
00001080  =00001080                 94  PSTRING  EQU      *                 Display the string pointed at by A4 
00001080  2F00                      95           MOVE.L   D0,-(A7)          Save D0 
00001082  101C                      96  PS1      MOVE.B   (A4)+,D0          Get character to be printed 
00001084  6706                      97           BEQ.S    PS2               If null then return 
00001086  6100 04C6                 98           BSR      PUTCHAR           Else print it 
0000108A  60F6                      99           BRA      PS1               Continue 
0000108C  201F                     100  PS2      MOVE.L   (A7)+,D0          Restore D0 and exit 
0000108E  4E75                     101           RTS 
00001090                           102  * 
00001090  61DE                     103  HEADING  BSR      NEWLINE           Same as PSTRING but with newline 
00001092  61EC                     104           BSR      PSTRING 
00001094  60DA                     105           BRA      NEWLINE 
00001096                           106  * 
00001096                           107  ************************************************************************* 
00001096                           108  * 
00001096                           109  *  GETLINE  inputs a string of characters into a line buffer 
00001096                           110  *           A3 points to next free entry in line buffer 
00001096                           111  *           A2 points to end of buffer 
00001096                           112  *           A1 points to start of buffer 
00001096                           113  *           D0 holds character to be stored 
00001096                           114  * 
00001096  43EE 0008                115  GETLINE  LEA.L    LNBUFF(A6),A1     A1 points to start of line buffer 
0000109A  47D1                     116           LEA.L    (A1),A3           A3 points to start (initially) 
0000109C  45E9 0040                117           LEA.L    MAXCHR(A1),A2     A2 points to end of buffer 
000010A0  6100 047C                118  GETLN2   BSR      GETCHAR           Get a character 
000010A4  B03C 0001                119           CMP.B    #CTRL_A,D0        If control_A then reject this line 
000010A8  671E                     120           BEQ.S    GETLN5            and get another line 
000010AA  B03C 0008                121           CMP.B    #BS,D0            If back_space then move back pointer 
000010AE  660A                     122           BNE.S    GETLN3            Else skip past wind-back routine 
000010B0  B7C9                     123           CMP.L    A1,A3             First check for empty buffer 
000010B2  67EC                     124           BEQ      GETLN2            If buffer empty then continue 
000010B4  47EB FFFF                125           LEA      -1(A3),A3         Else decrement buffer pointer 
000010B8  60E6                     126           BRA      GETLN2            and continue with next character 
000010BA  16C0                     127  GETLN3   MOVE.B   D0,(A3)+          Store character and update pointer 
000010BC  B03C 000D                128           CMP.B    #CR,D0            Test for command terminator 
000010C0  6602                     129           BNE.S    GETLN4            If not CR then skip past exit 
000010C2  60AC                     130           BRA      NEWLINE           Else new line before next operation 
000010C4  B7CA                     131  GETLN4   CMP.L    A2,A3             Test for buffer overflow 
000010C6  66D8                     132           BNE      GETLN2            If buffer not full then continue 
000010C8  61A6                     133  GETLN5   BSR      NEWLINE           Else move to next line and 
000010CA  60CA                     134           BRA      GETLINE           repeat this routine 
000010CC                           135  * 
000010CC                           136  ************************************************************************* 
000010CC                           137  * 
000010CC                           138  *  TIDY cleans up the line buffer by removing leading spaces and multiple 
000010CC                           139  *       spaces between parameters. At the end of TIDY, BUFFPT points to 
000010CC                           140  *       the first parameter following the command. 
000010CC                           141  *       A0 = pointer to line buffer. A1 = pointer to cleaned up buffer 
000010CC                           142  * 
000010CC  41EE 0008                143  TIDY     LEA.L    LNBUFF(A6),A0     A0 points to line buffer 
000010D0  43D0                     144           LEA.L    (A0),A1           A1 points to start of line buffer 
000010D2  1018                     145  TIDY1    MOVE.B   (A0)+,D0          Read character from line buffer 
000010D4  B03C 0020                146           CMP.B    #SPACE,D0         Repeat until the first non-space 
000010D8  67F8                     147           BEQ      TIDY1             character is found 
000010DA  41E8 FFFF                148           LEA.L    -1(A0),A0         Move pointer back to first char 
000010DE  1018                     149  TIDY2    MOVE.B   (A0)+,D0          Move the string left to remove 
000010E0  12C0                     150           MOVE.B   D0,(A1)+          any leading spaces 
000010E2  B03C 0020                151           CMP.B    #SPACE,D0         Test for embedded space 
000010E6  660A                     152           BNE.S    TIDY4             If not space then test for EOL 
000010E8  0C18 0020                153  TIDY3    CMP.B    #SPACE,(A0)+      If space skip multiple embedded 
000010EC  67FA                     154           BEQ      TIDY3             spaces 
000010EE  41E8 FFFF                155           LEA.L    -1(A0),A0         Move back pointer 
000010F2  B03C 000D                156  TIDY4    CMP.B    #CR,D0            Test for end_of_line (EOL) 
000010F6  66E6                     157           BNE      TIDY2             If not EOL then read next char 
000010F8  41EE 0008                158           LEA.L    LNBUFF(A6),A0     Restore buffer pointer 
000010FC  0C10 000D                159  TIDY5    CMP.B    #CR,(A0)          Test for EOL 
00001100  6706                     160           BEQ.S    TIDY6             If EOL then exit 
00001102  0C18 0020                161           CMP.B    #SPACE,(A0)+      Test for delimiter 
00001106  66F4                     162           BNE      TIDY5             Repeat until delimiter or EOL 
00001108  2D48 0048                163  TIDY6    MOVE.L   A0,BUFFPT(A6)     Update buffer pointer 
0000110C  4E75                     164           RTS 
0000110E                           165  * 
0000110E                           166  ************************************************************************* 
0000110E                           167  * 
0000110E                           168  *  EXECUTE matches the first command in the line buffer with the 
0000110E                           169  *  commands in a command table. An external table pointed at by 
0000110E                           170  *  UTAB is searched first and then the in-built table, COMTAB. 
0000110E                           171  * 
0000110E  4AAE 0052                172  EXECUTE  TST.L    UTAB(A6)          Test pointer to user table 
00001112  670C                     173           BEQ.S    EXEC1             If clear then try built-in table 
00001114  266E 0052                174           MOVE.L   UTAB(A6),A3       Else pick up pointer to user table 
00001118  6120                     175           BSR.S    SEARCH            Look for command in user table 
0000111A  6404                     176           BCC.S    EXEC1             If not found then try internal table 
0000111C  2653                     177           MOVE.L   (A3),A3           Else get absolute address of command 
0000111E  4ED3                     178           JMP      (A3)              from user table and execute it 
00001120                           179  * 
00001120  47FA 0AA4                180  EXEC1    LEA.L    COMTAB(PC),A3     Try built-in command table 
00001124  6114                     181           BSR.S    SEARCH            Look for command in built-in table 
00001126  6508                     182           BCS.S    EXEC2             If found then execute command 
00001128  49FA 09F7                183           LEA.L    ERMES2(PC),A4     Else print "invalid command" 
0000112C  6000 FF52                184           BRA.L    PSTRING           and return 
00001130  2653                     185  EXEC2    MOVE.L   (A3),A3           Get the relative command address 
00001132  49FA 0A92                186           LEA.L    COMTAB(PC),A4     pointed at by A3 and add it to 
00001136  D7CC                     187           ADD.L    A4,A3             the PC to generate the actual 
00001138  4ED3                     188           JMP      (A3)              command address. Then execute it. 
0000113A                           189  * 
0000113A  =0000113A                190  SEARCH   EQU      *                 Match the command in the line buffer 
0000113A  4280                     191           CLR.L    D0                with command table pointed at by A3 
0000113C  1013                     192           MOVE.B   (A3),D0           Get the first character in the 
0000113E  6734                     193           BEQ.S    SRCH7             current entry. If zero then exit 
00001140  49F3 0006                194           LEA.L    6(A3,D0.W),A4     Else calculate address of next entry 
00001144  122B 0001                195           MOVE.B   1(A3),D1          Get number of characters to match 
00001148  4BEE 0008                196           LEA.L    LNBUFF(A6),A5     A5 points to command in line buffer 
0000114C  142B 0002                197           MOVE.B   2(A3),D2          Get first character in this entry 
00001150  B41D                     198           CMP.B    (A5)+,D2          from the table and match with buffer 
00001152  6704                     199           BEQ.S    SRCH3             If match then try rest of string 
00001154  264C                     200  SRCH2    MOVE.L   A4,A3             Else get address of next entry 
00001156  60E2                     201           BRA      SEARCH            and try the next entry in the table 
00001158  5301                     202  SRCH3    SUB.B    #1,D1             One less character to match 
0000115A  670E                     203           BEQ.S    SRCH6             If match counter zero then all done 
0000115C  47EB 0003                204           LEA.L    3(A3),A3          Else point to next character in table 
00001160  141B                     205  SRCH4    MOVE.B   (A3)+,D2          Now match a pair of characters 
00001162  B41D                     206           CMP.B    (A5)+,D2 
00001164  66EE                     207           BNE      SRCH2             If no match then try next entry 
00001166  5301                     208           SUB.B    #1,D1             Else decrement match counter and 
00001168  66F6                     209           BNE      SRCH4             repeat until no chars left to match 
0000116A  47EC FFFC                210  SRCH6    LEA.L    -4(A4),A3         Calculate address of command entry 
0000116E  003C 0001                211           OR.B     #1,CCR            point. Mark carry flag as success 
00001172  4E75                     212           RTS                        and return 
00001174  023C 00FE                213  SRCH7    AND.B    #$FE,CCR          Fail - clear carry to indicate 
00001178  4E75                     214           RTS                        command not found and return 
0000117A                           215  * 
0000117A                           216  ************************************************************************* 
0000117A                           217  * 
0000117A                           218  *  Basic input routines 
0000117A                           219  *  HEX    =  Get one   hexadecimal character  into D0 
0000117A                           220  *  BYTE   =  Get two   hexadecimal characters into D0 
0000117A                           221  *  WORD   =  Get four  hexadecimal characters into D0 
0000117A                           222  *  LONGWD =  Get eight hexadecimal characters into D0 
0000117A                           223  *  PARAM  =  Get a longword from the line buffer into D0 
0000117A                           224  *  Bit 0 of D7 is set to indicate a hexadecimal input error 
0000117A                           225  * 
0000117A  6100 03A2                226  HEX      BSR      GETCHAR           Get a character from input device 
0000117E  0400 0030                227           SUB.B    #$30,D0           Convert to binary 
00001182  6B0E                     228           BMI.S    NOT_HEX           If less than $30 then exit with error 
00001184  B03C 0009                229           CMP.B    #$09,D0           Else test for number (0 to 9) 
00001188  6F0C                     230           BLE.S    HEX_OK            If number then exit - success 
0000118A  5F00                     231           SUB.B    #$07,D0           Else convert letter to hex 
0000118C  B03C 000F                232           CMP.B    #$0F,D0           If character in range "A" to "F" 
00001190  6F04                     233           BLE.S    HEX_OK            then exit successfully 
00001192  8E3C 0001                234  NOT_HEX  OR.B     #1,D7             Else set error flag 
00001196  4E75                     235  HEX_OK   RTS                        and return 
00001198                           236  * 
00001198  2F01                     237  BYTE     MOVE.L   D1,-(A7)          Save D1 
0000119A  61DE                     238           BSR      HEX               Get first hex character 
0000119C  E900                     239           ASL.B    #4,D0             Move it to MS nybble position 
0000119E  1200                     240           MOVE.B   D0,D1             Save MS nybble in D1 
000011A0  61D8                     241           BSR      HEX               Get second hex character 
000011A2  D001                     242           ADD.B    D1,D0             Merge MS and LS nybbles 
000011A4  221F                     243           MOVE.L   (A7)+,D1          Restore D1 
000011A6  4E75                     244           RTS 
000011A8                           245  * 
000011A8  61EE                     246  WORD     BSR      BYTE              Get upper order byte 
000011AA  E140                     247           ASL.W    #8,D0             Move it to MS position 
000011AC  60EA                     248           BRA      BYTE              Get LS byte and return 
000011AE                           249  * 
000011AE  61F8                     250  LONGWD   BSR      WORD              Get upper order word 
000011B0  4840                     251           SWAP     D0                Move it to MS position 
000011B2  60F4                     252           BRA      WORD              Get lower order word and return 
000011B4                           253  * 
000011B4                           254  *  PARAM reads a parameter from the line buffer and puts it in both 
000011B4                           255  *  PARAMTR(A6) and D0. Bit 1 of D7 is set on error. 
000011B4                           256  * 
000011B4  2F01                     257  PARAM    MOVE.L   D1,-(A7)          Save D1 
000011B6  4281                     258           CLR.L    D1                Clear input accumulator 
000011B8  206E 0048                259           MOVE.L   BUFFPT(A6),A0     A0 points to parameter in buffer 
000011BC  1018                     260  PARAM1   MOVE.B   (A0)+,D0          Read character from line buffer 
000011BE  B03C 0020                261           CMP.B    #SPACE,D0         Test for delimiter 
000011C2  6720                     262           BEQ.S    PARAM4            The permitted delimiter is a 
000011C4  B03C 000D                263           CMP.B    #CR,D0            space or a carriage return 
000011C8  671A                     264           BEQ.S    PARAM4            Exit on either space or C/R 
000011CA  E981                     265           ASL.L    #4,D1             Shift accumulated result 4 bits left 
000011CC  0400 0030                266           SUB.B    #$30,D0           Convert new character to hex 
000011D0  6B1E                     267           BMI.S    PARAM5            If less than $30 then not-hex 
000011D2  B03C 0009                268           CMP.B    #$09,D0           If less than 10 
000011D6  6F08                     269           BLE.S    PARAM3            then continue 
000011D8  5F00                     270           SUB.B    #$07,D0           Else assume $A - $F 
000011DA  B03C 000F                271           CMP.B    #$0F,D0           If more than $F 
000011DE  6E10                     272           BGT.S    PARAM5            then exit to error on not-hex 
000011E0  D200                     273  PARAM3   ADD.B    D0,D1             Add latest nybble to total in D1 
000011E2  60D8                     274           BRA      PARAM1            Repeat until delimiter found 
000011E4  2D48 0048                275  PARAM4   MOVE.L   A0,BUFFPT(A6)     Save pointer in memory 
000011E8  2D41 004C                276           MOVE.L   D1,PARAMTR(A6)    Save parameter in memory 
000011EC  2001                     277           MOVE.L   D1,D0             Put parameter in D0 for return 
000011EE  6004                     278           BRA.S    PARAM6            Return without error 
000011F0  8E3C 0002                279  PARAM5   OR.B     #2,D7             Set error flag before return 
000011F4  221F                     280  PARAM6   MOVE.L   (A7)+,D1          Restore working register 
000011F6  4E75                     281           RTS                        Return with error 
000011F8                           282  * 
000011F8                           283  ************************************************************************* 
000011F8                           284  * 
000011F8                           285  *  Output routines 
000011F8                           286  *  OUT1X   = print one   hexadecimal character 
000011F8                           287  *  OUT2X   = print two   hexadecimal characters 
000011F8                           288  *  OUT4X   = print four  hexadecimal characters 
000011F8                           289  *  OUT8X   = print eight hexadecimal characters 
000011F8                           290  *  In each case, the data to be printed is in D0 
000011F8                           291  * 
000011F8  3F00                     292  OUT1X    MOVE.W   D0,-(A7)          Save D0 
000011FA  C03C 000F                293           AND.B    #$0F,D0           Mask off MS nybble 
000011FE  0600 0030                294           ADD.B    #$30,D0           Convert to ASCII 
00001202  B03C 0039                295           CMP.B    #$39,D0           ASCII = HEX + $30 
00001206  6302                     296           BLS.S    OUT1X1            If ASCII <= $39 then print and exit 
00001208  5E00                     297           ADD.B    #$07,D0           Else ASCII := HEX + 7 
0000120A  6100 0342                298  OUT1X1   BSR      PUTCHAR           Print the character 
0000120E  301F                     299           MOVE.W   (A7)+,D0          Restore D0 
00001210  4E75                     300           RTS 
00001212                           301  * 
00001212  E818                     302  OUT2X    ROR.B    #4,D0             Get MS nybble in LS position 
00001214  61E2                     303           BSR      OUT1X             Print MS nybble 
00001216  E918                     304           ROL.B    #4,D0             Restore LS nybble 
00001218  60DE                     305           BRA      OUT1X             Print LS nybble and return 
0000121A                           306  * 
0000121A  E058                     307  OUT4X    ROR.W    #8,D0             Get MS byte in LS position 
0000121C  61F4                     308           BSR      OUT2X             Print MS byte 
0000121E  E158                     309           ROL.W    #8,D0             Restore LS byte 
00001220  60F0                     310           BRA      OUT2X             Print LS byte and return 
00001222                           311  * 
00001222  4840                     312  OUT8X    SWAP     D0                Get MS word in LS position 
00001224  61F4                     313           BSR      OUT4X             Print MS word 
00001226  4840                     314           SWAP     D0                Restore LS word 
00001228  60F0                     315           BRA      OUT4X             Print LS word and return 
0000122A                           316  * 
0000122A                           317  ************************************************************************* 
0000122A                           318  * 
0000122A                           319  * JUMP causes execution to begin at the address in the line buffer 
0000122A                           320  * 
0000122A  6188                     321  JUMP     BSR     PARAM              Get address from buffer 
0000122C  4A07                     322           TST.B   D7                 Test for input error 
0000122E  6608                     323           BNE.S   JUMP1              If error flag not zero then exit 
00001230  4A80                     324           TST.L   D0                 Else test for missing address 
00001232  6704                     325           BEQ.S   JUMP1              field. If no address then exit 
00001234  2040                     326           MOVE.L  D0,A0              Put jump address in A0 and call the 
00001236  4ED0                     327           JMP     (A0)               subroutine. User to supply RTS!! 
00001238  49FA 08C9                328  JUMP1    LEA.L   ERMES1(PC),A4      Here for error - display error 
0000123C  6000 FE42                329           BRA     PSTRING            message and return 
00001240                           330  * 
00001240                           331  ************************************************************************* 
00001240                           332  * 
00001240                           333  *  Display the contents of a memory location and modify it 
00001240                           334  * 
00001240  6100 FF72                335  MEMORY   BSR      PARAM             Get start address from line buffer 
00001244  4A07                     336           TST.B    D7                Test for input error 
00001246  6634                     337           BNE.S    MEM3              If error then exit 
00001248  2640                     338           MOVE.L   D0,A3             A3 points to location to be opened 
0000124A  6100 FE24                339  MEM1     BSR      NEWLINE 
0000124E  612E                     340           BSR.S    ADR_DAT           Print current address and contents 
00001250  6140                     341           BSR.S    PSPACE             update pointer, A3, and O/P space 
00001252  6100 02CA                342           BSR      GETCHAR           Input char to decide next action 
00001256  B03C 000D                343           CMP.B    #CR,D0            If carriage return then exit 
0000125A  6720                     344           BEQ.S    MEM3              Exit 
0000125C  B03C 002D                345           CMP.B    #'-',D0           If "-" then move back 
00001260  6606                     346           BNE.S    MEM2              Else skip wind-back procedure 
00001262  47EB FFFC                347           LEA.L    -4(A3),A3         Move pointer back 2+2 
00001266  60E2                     348           BRA      MEM1              Repeat until carriage return 
00001268  B03C 0020                349  MEM2     CMP.B    #SPACE,D0         Test for space (= new entry) 
0000126C  66DC                     350           BNE.S    MEM1              If not space then repeat 
0000126E  6100 FF38                351           BSR      WORD              Else get new word to store 
00001272  4A07                     352           TST.B    D7                Test for input error 
00001274  6606                     353           BNE.S    MEM3              If error then exit 
00001276  3740 FFFE                354           MOVE.W   D0,-2(A3)         Store new word 
0000127A  60CE                     355           BRA      MEM1              Repeat until carriage return 
0000127C  4E75                     356  MEM3     RTS 
0000127E                           357  * 
0000127E  2F00                     358  ADR_DAT  MOVE.L   D0,-(A7)          Print the contents of A3 and the 
00001280  200B                     359           MOVE.L   A3,D0             word pointed at by A3. 
00001282  619E                     360           BSR      OUT8X              and print current address 
00001284  610C                     361           BSR.S    PSPACE            Insert delimiter 
00001286  3013                     362           MOVE.W   (A3),D0           Get data at this address in D0 
00001288  6190                     363           BSR      OUT4X              and print it 
0000128A  47EB 0002                364           LEA.L    2(A3),A3          Point to next address to display 
0000128E  201F                     365           MOVE.L   (A7)+,D0          Restore D0 
00001290  4E75                     366           RTS 
00001292                           367  * 
00001292  1F00                     368  PSPACE   MOVE.B   D0,-(A7)          Print a single space 
00001294  103C 0020                369           MOVE.B   #SPACE,D0 
00001298  6100 02B4                370           BSR      PUTCHAR 
0000129C  101F                     371           MOVE.B   (A7)+,D0 
0000129E  4E75                     372           RTS 
000012A0                           373  * 
000012A0                           374  ************************************************************************* 
000012A0                           375  * 
000012A0                           376  *  LOAD  Loads data formatted in hexadecimal "S" format from Port 2 
000012A0                           377  *        NOTE - I/O is automatically redirected to the aux port for 
000012A0                           378  *        loader functions. S1 or S2 records accepted 
000012A0                           379  * 
000012A0  2F2E 005A                380  LOAD     MOVE.L   CN_OVEC(A6),-(A7) Save current output device name 
000012A4  2F2E 0056                381           MOVE.L   CN_IVEC(A6),-(A7) Save current input device name 
000012A8  2D7C 00001C8E 005A       382           MOVE.L   #DCB4,CN_OVEC(A6) Set up aux ACIA as output 
000012B0  2D7C 00001C7C 0056       383           MOVE.L   #DCB3,CN_IVEC(A6) Set up aux ACIA as input 
000012B8  522E 0050                384           ADD.B    #1,ECHO(A6)       Turn off character echo 
000012BC  6100 FDB2                385           BSR      NEWLINE           Send newline to host 
000012C0  6100 015A                386           BSR      DELAY             Wait for host to "settle" 
000012C4  6100 0156                387           BSR      DELAY 
000012C8  286E 0048                388           MOVE.L   BUFFPT(A6),A4     Any string in the line buffer is 
000012CC  101C                     389  LOAD1    MOVE.B   (A4)+,D0          transmitted to the host computer 
000012CE  6100 027E                390           BSR      PUTCHAR           before the loading begins 
000012D2  B03C 000D                391           CMP.B    #CR,D0            Read from the buffer until EOL 
000012D6  66F4                     392           BNE      LOAD1 
000012D8  6100 FD96                393           BSR      NEWLINE           Send newline before loading 
000012DC  6100 0240                394  LOAD2    BSR      GETCHAR           Records from the host must begin 
000012E0  B03C 0053                395           CMP.B    #'S',D0           with S1/S2 (data) or S9/S8 (term) 
000012E4  66F6                     396           BNE.S    LOAD2             Repeat GETCHAR until char = "S" 
000012E6  6100 0236                397           BSR      GETCHAR           Get character after "S" 
000012EA  B03C 0039                398           CMP.B    #'9',D0           Test for the two terminators S9/S8 
000012EE  6706                     399           BEQ.S    LOAD3             If S9 record then exit else test 
000012F0  B03C 0038                400           CMP.B    #'8',D0           for S8 terminator. Fall through to 
000012F4  662A                     401           BNE.S    LOAD6             exit on S8 else continue search 
000012F6  =000012F6                402  LOAD3    EQU      *                 Exit point from LOAD 
000012F6  2D5F 0056                403           MOVE.L   (A7)+,CN_IVEC(A6) Clean up by restoring input device 
000012FA  2D5F 005A                404           MOVE.L   (A7)+,CN_OVEC(A6) and output device name 
000012FE  422E 0050                405           CLR.B    ECHO(A6)          Restore input character echo 
00001302  0807 0000                406           BTST     #0,D7             Test for input errors 
00001306  6708                     407           BEQ.S    LOAD4             If no I/P error then look at checksum 
00001308  49FA 07F9                408           LEA.L    ERMES1(PC),A4     Else point to error message 
0000130C  6100 FD72                409           BSR      PSTRING           Print it 
00001310  0807 0003                410  LOAD4    BTST     #3,D7             Test for checksum error 
00001314  6708                     411           BEQ.S    LOAD5             If clear then exit 
00001316  49FA 081B                412           LEA.L    ERMES3(PC),A4     Else point to error message 
0000131A  6100 FD64                413           BSR      PSTRING           Print it and return 
0000131E  4E75                     414  LOAD5    RTS 
00001320                           415  * 
00001320  B03C 0031                416  LOAD6    CMP.B    #'1',D0           Test for S1 record 
00001324  671E                     417           BEQ.S    LOAD6A            If S1 record then read it 
00001326  B03C 0032                418           CMP.B    #'2',D0           Else test for S2 record 
0000132A  66B0                     419           BNE.S    LOAD2             Repeat until valid header found 
0000132C  4203                     420           CLR.B    D3                Read the S2 byte count and address, 
0000132E  613C                     421           BSR.S    LOAD8             clear the checksum 
00001330  5900                     422           SUB.B    #4,D0             Calculate size of data field 
00001332  1400                     423           MOVE.B   D0,D2             D2 contains data bytes to read 
00001334  4280                     424           CLR.L    D0                Clear address accumulator 
00001336  6134                     425           BSR.S    LOAD8             Read most sig byte of address 
00001338  E180                     426           ASL.L    #8,D0             Move it one byte left 
0000133A  6130                     427           BSR.S    LOAD8             Read the middle byte of address 
0000133C  E180                     428           ASL.L    #8,D0             Move it one byte left 
0000133E  612C                     429           BSR.S    LOAD8             Read least sig byte of address 
00001340  2440                     430           MOVE.L   D0,A2             A2 points to destination of record 
00001342  6012                     431           BRA.S    LOAD7             Skip past S1 header loader 
00001344  4203                     432  LOAD6A   CLR.B    D3                S1 record found - clear checksum 
00001346  6124                     433           BSR.S    LOAD8             Get byte and update checksum 
00001348  5700                     434           SUB.B    #3,D0             Subtract 3 from record length 
0000134A  1400                     435           MOVE.B   D0,D2             Save byte count in D2 
0000134C  4280                     436           CLR.L    D0                Clear address accumulator 
0000134E  611C                     437           BSR.S    LOAD8             Get MS byte of load address 
00001350  E180                     438           ASL.L    #8,D0             Move it to MS position 
00001352  6118                     439           BSR.S    LOAD8             Get LS byte in D2 
00001354  2440                     440           MOVE.L   D0,A2             A2 points to destination of data 
00001356  6114                     441  LOAD7    BSR.S    LOAD8             Get byte of data for loading 
00001358  14C0                     442           MOVE.B   D0,(A2)+          Store it 
0000135A  5302                     443           SUB.B    #1,D2             Decrement byte counter 
0000135C  66F8                     444           BNE      LOAD7             Repeat until count = 0 
0000135E  610C                     445           BSR.S    LOAD8             Read checksum 
00001360  5203                     446           ADD.B    #1,D3             Add 1 to total checksum 
00001362  6700 FF78                447           BEQ      LOAD2             If zero then start next record 
00001366  8E3C 0008                448           OR.B     #%00001000,D7     Else set checksum error bit, 
0000136A  608A                     449           BRA      LOAD3             restore I/O devices and return 
0000136C                           450  * 
0000136C  6100 FE2A                451  LOAD8    BSR     BYTE               Get a byte 
00001370  D600                     452           ADD.B   D0,D3              Update checksum 
00001372  4E75                     453           RTS                         and return 
00001374                           454  * 
00001374                           455  ************************************************************************* 
00001374                           456  * 
00001374                           457  *  DUMP   Transmit S1 formatted records to host computer 
00001374                           458  *         A3 = Starting address of data block 
00001374                           459  *         A2 = End address of data block 
00001374                           460  *         D1 = Checksum, D2 = current record length 
00001374                           461  * 
00001374  6100 0096                462  DUMP     BSR      RANGE             Get start and end address 
00001378  4A07                     463           TST.B    D7                Test for input error 
0000137A  6708                     464           BEQ.S    DUMP1             If no error then continue 
0000137C  49FA 0785                465           LEA.L    ERMES1(PC),A4     Else point to error message, 
00001380  6000 FCFE                466           BRA      PSTRING           print it and return 
00001384  B08B                     467  DUMP1    CMP.L    A3,D0             Compare start and end addresses 
00001386  6A08                     468           BPL.S    DUMP2             If positive then start < end 
00001388  49FA 082F                469           LEA.L    ERMES7(PC),A4     Else print error message 
0000138C  6000 FCF2                470           BRA      PSTRING           and return 
00001390  2F2E 005A                471  DUMP2    MOVE.L   CN_OVEC(A6),-(A7) Save name of current output device 
00001394  2D7C 00001C8E 005A       472           MOVE.L   #DCB4,CN_OVEC(A6) Set up Port 2 as output device 
0000139C  6100 FCD2                473           BSR      NEWLINE           Send newline to host and wait 
000013A0  617A                     474           BSR.S    DELAY 
000013A2  286E 0048                475           MOVE.L   BUFFPT(A6),A4     Before dumping, send any string 
000013A6  101C                     476  DUMP3    MOVE.B   (A4)+,D0          in the input buffer to the host 
000013A8  6100 01A4                477           BSR      PUTCHAR           Repeat 
000013AC  B03C 000D                478           CMP.B    #CR,D0            Transmit char from buffer to host 
000013B0  66F4                     479           BNE      DUMP3             Until char = C/R 
000013B2  6100 FCBC                480           BSR      NEWLINE 
000013B6  6164                     481           BSR.S    DELAY             Allow time for host to settle 
000013B8  528A                     482           ADDQ.L   #1,A2             A2 contains length of record + 1 
000013BA  240A                     483  DUMP4    MOVE.L   A2,D2             D2 points to end address 
000013BC  948B                     484           SUB.L    A3,D2             D2 contains bytes left to print 
000013BE  B4BC 00000011            485           CMP.L    #17,D2            If this is not a full record of 16 
000013C4  6502                     486           BCS.S    DUMP5             then load D2 with record size 
000013C6  7410                     487           MOVEQ    #16,D2            Else preset byte count to 16 
000013C8  49FA 0674                488  DUMP5    LEA.L    HEADER(PC),A4     Point to record header 
000013CC  6100 FCB2                489           BSR      PSTRING           Print header 
000013D0  4201                     490           CLR.B    D1                Clear checksum 
000013D2  1002                     491           MOVE.B   D2,D0             Move record length to output register 
000013D4  5600                     492           ADD.B    #3,D0             Length includes address + count 
000013D6  612E                     493           BSR.S    DUMP7             Print number of bytes in record 
000013D8  200B                     494           MOVE.L   A3,D0             Get start address to be printed 
000013DA  E158                     495           ROL.W    #8,D0             Get MS byte in LS position 
000013DC  6128                     496           BSR.S    DUMP7             Print MS byte of address 
000013DE  E058                     497           ROR.W    #8,D0             Restore LS byte 
000013E0  6124                     498           BSR.S    DUMP7             Print LS byte of address 
000013E2  101B                     499  DUMP6    MOVE.B   (A3)+,D0          Get data byte to be printed 
000013E4  6120                     500           BSR.S    DUMP7             Print it 
000013E6  5302                     501           SUB.B    #1,D2             Decrement byte count 
000013E8  66F8                     502           BNE      DUMP6             Repeat until all this record printed 
000013EA  4601                     503           NOT.B    D1                Complement checksum 
000013EC  1001                     504           MOVE.B   D1,D0             Move to output register 
000013EE  6116                     505           BSR.S    DUMP7             Print checksum 
000013F0  6100 FC7E                506           BSR      NEWLINE 
000013F4  B7CA                     507           CMP.L    A2,A3             Have all records been printed? 
000013F6  66C2                     508           BNE      DUMP4             Repeat until all done 
000013F8  49FA 064A                509           LEA.L    TAIL(PC),A4       Point to message tail (S9 record) 
000013FC  6100 FC82                510           BSR      PSTRING           Print it 
00001400  2D5F 005A                511           MOVE.L   (A7)+,CN_OVEC(A6) Restore name of output device 
00001404  4E75                     512           RTS                        and return 
00001406                           513  * 
00001406  D200                     514  DUMP7    ADD.B    D0,D1             Update checksum, transmit byte 
00001408  6000 FE08                515           BRA      OUT2X             to host and return 
0000140C                           516  * 
0000140C  =0000140C                517  RANGE    EQU      *                 Get the range of addresses to be 
0000140C  4207                     518           CLR.B    D7                transmitted from the buffer 
0000140E  6100 FDA4                519           BSR      PARAM             Get starting address 
00001412  2640                     520           MOVE.L   D0,A3             Set up start address in A3 
00001414  6100 FD9E                521           BSR      PARAM             Get end address 
00001418  2440                     522           MOVE.L   D0,A2             Set up end address in A2 
0000141A  4E75                     523           RTS 
0000141C                           524  * 
0000141C  =0000141C                525  DELAY    EQU       *                Provide a time delay for the host 
0000141C  48E7 8008                526           MOVEM.L   D0/A4,-(A7)      to settle. Save working registers 
00001420  203C 00004000            527           MOVE.L    #$4000,D0        Set up delay constant 
00001426  5380                     528  DELAY1   SUB.L     #1,D0            Count down         (8 clk cycles) 
00001428  66FC                     529           BNE       DELAY1           Repeat until zero  (10 clk cycles) 
0000142A  4CDF 1001                530           MOVEM.L   (A7)+,D0/A4      Restore working registers 
0000142E  4E75                     531           RTS 
00001430                           532  * 
00001430                           533  ************************************************************************* 
00001430                           534  * 
00001430                           535  *  TM  Enter transparant mode (All communication to go from terminal to 
00001430                           536  *  the host processor until escape sequence entered). End sequence 
00001430                           537  *  = ESC, E. A newline is sent to the host to "clear it down". 
00001430                           538  * 
00001430  13FC 0055 00008001       539  TM       MOVE.B    #$55,ACIA_1      Force RTS* high to re-route data 
00001438  522E 0050                540           ADD.B     #1,ECHO(A6)      Turn off character echo 
0000143C  6100 00E0                541  TM1      BSR       GETCHAR          Get character 
00001440  B03C 001B                542           CMP.B     #ESC,D0          Test for end of TM mode 
00001444  66F6                     543           BNE       TM1              Repeat until first escape character 
00001446  6100 00D6                544           BSR       GETCHAR          Get second character 
0000144A  B03C 0045                545           CMP.B     #'E',D0          If second char = E then exit TM 
0000144E  66EC                     546           BNE       TM1              Else continue 
00001450  2F2E 005A                547           MOVE.L    CN_OVEC(A6),-(A7) Save output port device name 
00001454  2D7C 00001C8E 005A       548           MOVE.L    #DCB4,CN_OVEC(A6) Get name of host port (aux port) 
0000145C  6100 FC12                549           BSR       NEWLINE          Send newline to host to clear it 
00001460  2D5F 005A                550           MOVE.L    (A7)+,CN_OVEC(A6) Restore output device port name 
00001464  422E 0050                551           CLR.B     ECHO(A6)         Restore echo mode 
00001468  13FC 0015 00008001       552           MOVE.B    #$15,ACIA_1      Restore normal ACIA mode (RTS* low) 
00001470  4E75                     553           RTS 
00001472                           554  * 
00001472                           555  ************************************************************************* 
00001472                           556  * 
00001472                           557  *  This routine sets up the system DCBs in RAM using the information 
00001472                           558  *  stored in ROM at address DCB_LST. This is called at initialization. 
00001472                           559  *  CN_IVEC contains the name "DCB1" and IO_VEC the name "DCB2" 
00001472                           560  * 
00001472  48E7 F0F0                561  SET_DCB  MOVEM.L A0-A3/D0-D3,-(A7) Save all working registers 
00001476  41EE 00D8                562           LEA.L   FIRST(A6),A0    Pointer to first DCB destination in RAM 
0000147A  43FA 07DC                563           LEA.L   DCB_LST(PC),A1  A1 points to DCB info block in ROM 
0000147E  303C 0005                564           MOVE.W  #5,D0           6 DCBs to set up 
00001482  323C 000F                565  ST_DCB1  MOVE.W  #15,D1          16 bytes to move per DCB header 
00001486  10D9                     566  ST_DCB2  MOVE.B  (A1)+,(A0)+     Move the 16 bytes of a DCB header 
00001488  51C9 FFFC                567           DBRA    D1,ST_DCB2      from ROM to RAM 
0000148C  3619                     568           MOVE.W  (A1)+,D3        Get size of parameter block (bytes) 
0000148E  3083                     569           MOVE.W  D3,(A0)         Store size in DCB in RAM 
00001490  41F0 3002                570           LEA.L   2(A0,D3.W),A0   A0 points to tail of DCB in RAM 
00001494  47E8 0004                571           LEA.L   4(A0),A3        A3 contains address of next DCB in RAM 
00001498  208B                     572           MOVE.L  A3,(A0)         Store pointer to next DCB in this DCB 
0000149A  41D3                     573           LEA.L   (A3),A0         A0 now points at next DCB in RAM 
0000149C  51C8 FFE4                574           DBRA    D0,ST_DCB1      Repeat until all DCBs set up 
000014A0  47EB FFFC                575           LEA.L   -4(A3),A3       Adjust A3 to point to last DCB pointer 
000014A4  4293                     576           CLR.L   (A3)            and force last pointer to zero 
000014A6  2D7C 00001C58 0056       577           MOVE.L  #DCB1,CN_IVEC(A6) Set up vector to console input DCB 
000014AE  2D7C 00001C6A 005A       578           MOVE.L  #DCB2,CN_OVEC(A6) Set up vector to console output DCB 
000014B6  4CDF 0F0F                579           MOVEM.L (A7)+,A0-A3/D0-D3 Restore registers 
000014BA  4E75                     580           RTS 
000014BC                           581  * 
000014BC                           582  ************************************************************************* 
000014BC                           583  * 
000014BC                           584  *  IO_REQ handles all input/output transactions. A0 points to DCB on 
000014BC                           585  *  entry. IO_REQ calls the device driver whose address is in the DCB. 
000014BC                           586  * 
000014BC  48E7 00C0                587  IO_REQ   MOVEM.L A0-A1,-(A7)     Save working registers 
000014C0  43E8 0008                588           LEA.L   8(A0),A1        A1 points to device handler field in DCB 
000014C4  2251                     589           MOVE.L  (A1),A1         A1 contains device handler address 
000014C6  4E91                     590           JSR     (A1)            Call device handler 
000014C8  4CDF 0300                591           MOVEM.L (A7)+,A0-A1     Restore working registers 
000014CC  4E75                     592           RTS 
000014CE                           593  * 
000014CE                           594  ************************************************************************* 
000014CE                           595  * 
000014CE                           596  *  CON_IN handles input from the console device 
000014CE                           597  *  Exit with input in D0 
000014CE                           598  * 
000014CE  48E7 4000                599  CON_IN   MOVEM.L D1,-(A7)        Save working registers 
000014D2  4228 0013                600           CLR.B   19(A0)
000014D6  103C 0005                601           MOVE.B  #5,D0           Read input from ACIA
000014DA  4E4F                     602           TRAP    #15
000014DC  1001                     603           MOVE.B  D1,D0
000014DE  4CDF 0002                604           MOVEM.L (A7)+,D1     `  Restore working registers 
000014E2  4E75                     605           RTS 
000014E4                           606  * 
000014E4                           607  ************************************************************************* 
000014E4                           608  * 
000014E4                           609  *   This is the CON_OUT device driver. Output in D0  
000014E4                           610  * 
000014E4  48E7 4000                611  CON_OUT  MOVEM.L D1,-(A7)  Save working registers 
000014E8  4228 0013                612           CLR.B   19(A0)
000014EC  1200                     613           MOVE.B  D0,D1
000014EE  103C 0006                614           MOVE.B  #6,D0
000014F2  4E4F                     615           TRAP    #15
000014F4  4CDF 0002                616           MOVEM.L (A7)+,D1  Restore working registers 
000014F8  4E75                     617           RTS 
000014FA                           618  * 
000014FA                           619  ************************************************************************* 
000014FA                           620  * 
000014FA                           621  *  AUX_IN and AUX_OUT are simplified versions of CON_IN and 
000014FA                           622  *  CON_OUT for use with the port to the host processor 
000014FA                           623  * 
000014FA  43E8 000C                624  AUX_IN   LEA.L   12(A0),A1       Get pointer to aux ACIA from DCB 
000014FE  2251                     625           MOVE.L  (A1),A1         Get address of aux ACIA 
00001500  0811 0000                626  AUX_IN1  BTST.B  #0,(A1)         Test for data ready 
00001504  67FA                     627           BEQ     AUX_IN1         Repeat until ready 
00001506  1029 0002                628           MOVE.B  2(A1),D0        Read input 
0000150A  4E75                     629           RTS 
0000150C                           630  * 
0000150C  43E8 000C                631  AUX_OUT  LEA.L   12(A0),A1       Get pointer to aux ACIA from DCB 
00001510  2251                     632           MOVE.L  (A1),A1         Get address of aux ACIA 
00001512  0811 0001                633  AUX_OT1  BTST.B  #1,(A1)         Test for ready to transmit 
00001516  67FA                     634           BEQ     AUX_OT1         Repeat until transmitter ready 
00001518  1340 0002                635           MOVE.B  D0,2(A1)        Transmit data 
0000151C  4E75                     636           RTS 
0000151E                           637  * 
0000151E                           638  ************************************************************************* 
0000151E                           639  * 
0000151E                           640  *  GETCHAR gets a character from the console device 
0000151E                           641  *  This is the main input routine and uses the device whose name  
0000151E                           642  *  is stored in CN_IVEC. Changing this name redirects input. 
0000151E                           643  * 
0000151E  2F08                     644  GETCHAR  MOVE.L  A0,-(A7)        Save working register 
00001520  206E 0056                645           MOVE.L  CN_IVEC(A6),A0  A0 points to name of console DCB 
00001524  6152                     646           BSR.S   IO_OPEN         Open console (get DCB address in A0) 
00001526  0807 0003                647           BTST    #3,D7           D7(3) set if open error 
0000152A  661E                     648           BNE.S   GETCH3          If error then exit now 
0000152C  618E                     649           BSR     IO_REQ          Else execute I/O transaction 
0000152E  C03C 007F                650           AND.B   #$7F,D0         Strip msb of input 
00001532  4A2E 0051                651           TST.B   U_CASE(A6)      Test for upper -> lower case conversion 
00001536  660A                     652           BNE.S   GETCH2          If flag not zero do not convert case 
00001538  0800 0006                653           BTST    #6,D0             Test input for lower case 
0000153C  6704                     654           BEQ.S   GETCH2          If upper case then skip conversion 
0000153E  C03C 00DF                655           AND.B   #%11011111,D0   Else clear bit 5 for upper case conv 
00001542  4A2E 0050                656  GETCH2   TST.B   ECHO(A6)        Do we need to echo the input? 
00001546  6602                     657           BNE.S   GETCH3          If ECHO not zero then no echo 
00001548  6104                     658           BSR.S   PUTCHAR         Else echo the input 
0000154A  205F                     659  GETCH3   MOVE.L  (A7)+,A0        Restore working register 
0000154C  4E75                     660           RTS                     and return 
0000154E                           661  * 
0000154E                           662  ************************************************************************* 
0000154E                           663  * 
0000154E                           664  *  PUTCHAR sends a character to the console device 
0000154E                           665  *  The name of the output device is in CN_OVEC. 
0000154E                           666  * 
0000154E  2F08                     667  PUTCHAR  MOVE.L  A0,-(A7)        Save working register 
00001550  206E 005A                668           MOVE.L  CN_OVEC(A6),A0  A0 points to name of console output 
00001554  6122                     669           BSR.S   IO_OPEN         Open console (Get address of DCB) 
00001556  6100 FF64                670           BSR     IO_REQ          Perform output with DCB pointed at by A0 
0000155A  205F                     671           MOVE.L  (A7)+,A0        Restore working register 
0000155C  4E75                     672           RTS 
0000155E                           673  * 
0000155E                           674  ************************************************************************* 
0000155E                           675  * 
0000155E                           676  *  BUFF_IN and BUFF_OUT are two rudimentary input and output routines 
0000155E                           677  *  which input data from and output data to a buffer in RAM. These are 
0000155E                           678  *  used by DCB5 and DCB6, respectively. 
0000155E                           679  * 
0000155E  43E8 000C                680  BUFF_IN  LEA.L   12(A0),A1       A1 points to I/P buffer 
00001562  2451                     681           MOVE.L  (A1),A2         A2 gets I/P pointer from buffer 
00001564  1022                     682           MOVE.B  -(A2),D0        Read char from buffer and adjust A2 
00001566  228A                     683           MOVE.L  A2,(A1)         Restore pointer in buffer 
00001568  4E75                     684           RTS 
0000156A                           685  * 
0000156A  43E8 000C                686  BUFF_OT  LEA.L   12(A0),A1       A1 points to O/P buffer 
0000156E  2469 0004                687           MOVE.L  4(A1),A2        A2 gets O/P pointer from buffer 
00001572  14C0                     688           MOVE.B  D0,(A2)+        Store char in buffer and adjust A2 
00001574  228A                     689           MOVE.L  A2,(A1)         Restore pointer in buffer 
00001576  4E75                     690           RTS 
00001578                           691  * 
00001578                           692  ************************************************************************* 
00001578                           693  * 
00001578                           694  *  Open - opens a DCB for input or output. IO_OPEN converts the 
00001578                           695  *  name pointed at by A0 into the address of the DCB pointed at 
00001578                           696  *  by A0. Bit 3 of D7 is set to zero if DCB not found 
00001578                           697  * 
00001578  48E7 F870                698  IO_OPEN  MOVEM.L  A1-A3/D0-D4,-(A7) Save working registers 
0000157C  43EE 00D8                699           LEA.L    FIRST(A6),A1   A1 points to first DCB in chain in RAM 
00001580  45D1                     700  OPEN1    LEA.L    (A1),A2        A2 = temp copy of pointer to DCB 
00001582  47D0                     701           LEA.L    (A0),A3        A3 = temp copy of pointer to DCB name 
00001584  303C 0007                702           MOVE.W   #7,D0          Up to 8 chars of DCB name to match 
00001588  181A                     703  OPEN2    MOVE.B   (A2)+,D4       Compare DCB name with string 
0000158A  B81B                     704           CMP.B    (A3)+,D4 
0000158C  6608                     705           BNE.S    OPEN3          If no match try next DCB 
0000158E  51C8 FFF8                706           DBRA     D0,OPEN2       Else repeat until all chars matched 
00001592  41D1                     707           LEA.L    (A1),A0        Success - move this DCB address to A0 
00001594  6016                     708           BRA.S    OPEN4          and return 
00001596  =00001596                709  OPEN3    EQU      *              Fail - calculate address of next DCB 
00001596  3229 0010                710           MOVE.W   16(A1),D1      Get parameter block size of DCB 
0000159A  43F1 1012                711           LEA.L    18(A1,D1.W),A1 A1 points to pointer to next DCB 
0000159E  2251                     712           MOVE.L   (A1),A1        A1 now points to next DCB 
000015A0  B3FC 00000000            713           CMP.L    #0,A1          Test for end of DCB chain 
000015A6  66D8                     714           BNE      OPEN1          If not end of chain then try next DCB 
000015A8  8E3C 0008                715           OR.B     #8,D7          Else set error flag and return 
000015AC  4CDF 0E1F                716  OPEN4    MOVEM.L  (A7)+,A1-A3/D0-D4 Restore working registers 
000015B0  4E75                     717           RTS 
000015B2                           718  * 
000015B2                           719  ************************************************************************* 
000015B2                           720  * 
000015B2                           721  *  Exception vector table initialization routine 
000015B2                           722  *  All vectors not setup are loaded with uninitialized routine vector 
000015B2                           723  * 
000015B2  303C 0007                724  X_SET   MOVE.W  #7,D0             Now clear the breakpoint table 
000015B6  41EE 00A8                725          LEA.L   BP_TAB(A6),A0     Point to table 
000015BA  4298                     726  X_SET2  CLR.L   (A0)+             Clear an address entry 
000015BC  4258                     727          CLR.W   (A0)+             Clear the corresponding data 
000015BE  51C8 FFFA                728          DBRA    D0,X_SET2         Repeat until all 8 cleared 
000015C2  4E75                     729          RTS 
000015C4                           730  * 
000015C4                           731  ************************************************************************* 
000015C4                           732  * 
000015C4  =000015C4                733  TRAP_0  EQU     *                 User links to  TS2BUG via TRAP #0 
000015C4  B23C 0000                734          CMP.B   #0,D1             D1 = 0 = Get character 
000015C8  6606                     735          BNE.S   FOO1           
000015CA  6100 FF52                736          BSR     GETCHAR 
000015CE  4E73                     737          RTE 
000015D0  B23C 0001                738  FOO1    CMP.B   #1,D1             D1 = 1 = Print character 
000015D4  6606                     739          BNE.S   FOO2 
000015D6  6100 FF76                740          BSR     PUTCHAR 
000015DA  4E73                     741          RTE 
000015DC  B23C 0002                742  FOO2    CMP.B   #2,D1             D1 = 2 = Newline 
000015E0  6606                     743          BNE.S   FOO3 
000015E2  6100 FA8C                744          BSR     NEWLINE 
000015E6  4E73                     745          RTE 
000015E8  B23C 0003                746  FOO3    CMP.B   #3,D1             D1 = 3 = Get parameter from buffer 
000015EC  6606                     747          BNE.S   FOO4 
000015EE  6100 FBC4                748          BSR     PARAM 
000015F2  4E73                     749          RTE 
000015F4  B23C 0004                750  FOO4    CMP.B   #4,D1             D1 = 4 = Print string pointed at by A4 
000015F8  6606                     751          BNE.S   FOO5 
000015FA  6100 FA84                752          BSR     PSTRING 
000015FE  4E73                     753          RTE 
00001600  B23C 0005                754  FOO5    CMP.B   #5,D1             D1 = 5 = Get a hex character 
00001604  6606                     755          BNE.S   FOO6 
00001606  6100 FB72                756          BSR     HEX 
0000160A  4E73                     757          RTE 
0000160C  B23C 0006                758  FOO6    CMP.B   #6,D1             D1 = 6 = Get a hex byte 
00001610  6606                     759          BNE.S   FOO7 
00001612  6100 FB84                760          BSR     BYTE 
00001616  4E73                     761          RTE 
00001618  B23C 0007                762  FOO7    CMP.B   #7,D1             D1 = 7 = Get a word 
0000161C  6606                     763          BNE.S   FOO8 
0000161E  6100 FB88                764          BSR     WORD 
00001622  4E73                     765          RTE 
00001624  B23C 0008                766  FOO8    CMP.B   #8,D1             D1 = 8 = Get a longword 
00001628  6606                     767          BNE.S   FOO9 
0000162A  6100 FB82                768          BSR     LONGWD 
0000162E  4E73                     769          RTE 
00001630  B23C 0009                770  FOO9    CMP.B   #9,D1             D1 = 9 = Output hex byte 
00001634  6606                     771          BNE.S   FOO10  
00001636  6100 FBDA                772          BSR     OUT2X 
0000163A  4E73                     773          RTE 
0000163C  B23C 000A                774  FOO10   CMP.B   #10,D1            D1 = 10 = Output hex word 
00001640  6606                     775          BNE.S   FOO11 
00001642  6100 FBD6                776          BSR     OUT4X 
00001646  4E73                     777          RTE 
00001648  B23C 000B                778  FOO11   CMP.B   #11,D1            D1 = 11 = Output hex longword 
0000164C  6606                     779          BNE.S   FOO12 
0000164E  6100 FBD2                780          BSR     OUT8X 
00001652  4E73                     781          RTE 
00001654  B23C 000C                782  FOO12   CMP.B   #12,D1            D1 = 12 = Print a space 
00001658  6606                     783          BNE.S   FOO13 
0000165A  6100 FC36                784          BSR     PSPACE 
0000165E  4E73                     785          RTE 
00001660  B23C 000D                786  FOO13   CMP.B   #13,D1            D1 = 13 = Get a line of text into 
00001664  6606                     787          BNE.S   FOO14            the line buffer 
00001666  6100 FA2E                788          BSR     GETLINE 
0000166A  4E73                     789          RTE 
0000166C  B23C 000E                790  FOO14   CMP.B   #14,D1            D1 = 14 = Tidy up the line in the 
00001670  6606                     791          BNE.S   FOO15            line buffer by removing leading 
00001672  6100 FA58                792          BSR     TIDY              leading and multiple embeded spaces 
00001676  4E73                     793          RTE 
00001678  B23C 000F                794  FOO15   CMP.B   #15,D1            D1 = 15 = Execute the command in 
0000167C  6606                     795          BNE.S   FOO16            the line buffer 
0000167E  6100 FA8E                796          BSR     EXECUTE 
00001682  4E73                     797          RTE 
00001684  B23C 0010                798  FOO16   CMP.B   #16,D1            D1 = 16 = Call RESTORE to transfer 
00001688  6606                     799          BNE.S   FOO17            the registers in TSK_T to the 68000 
0000168A  6100 016A                800          BSR     RESTORE           and therefore execute a program 
0000168E  4E73                     801          RTE 
00001690  4E73                     802  FOO17   RTE 
00001692                           803  * 
00001692                           804  ************************************************************************* 
00001692                           805  * 
00001692                           806  *  Display exception frame (D0 - D7, A0 - A6, USP, SSP, SR, PC) 
00001692                           807  *  EX_DIS prints registers saved after a breakpoint or exception 
00001692                           808  *  The registers are saved in TSK_T 
00001692                           809  * 
00001692  4BEE 005E                810  EX_DIS  LEA.L   TSK_T(A6),A5      A5 points to display frame 
00001696  49FA 03CD                811          LEA.L   MES3(PC),A4       Point to heading 
0000169A  6100 F9F4                812          BSR     HEADING           and print it 
0000169E  3C3C 0007                813          MOVE.W  #7,D6             8 pairs of registers to display 
000016A2  4205                     814          CLR.B   D5                D5 is the line counter 
000016A4  1005                     815  EX_D1   MOVE.B  D5,D0             Put current register number in D0 
000016A6  6100 FB50                816          BSR     OUT1X             and print it 
000016AA  6100 FBE6                817          BSR     PSPACE            and a space 
000016AE  5205                     818          ADD.B   #1,D5             Update counter for next pair 
000016B0  2015                     819          MOVE.L  (A5),D0           Get data register to be displayed 
000016B2  6100 FB6E                820          BSR     OUT8X             from the frame and print it 
000016B6  49FA 03CB                821          LEA.L   MES4(PC),A4       Print string of spaces 
000016BA  6100 F9C4                822          BSR.L   PSTRING           between data and address registers 
000016BE  202D 0020                823          MOVE.L  32(A5),D0         Get address register to be displayed 
000016C2  6100 FB5E                824          BSR     OUT8X             which is 32 bytes on from data reg 
000016C6  6100 F9A8                825          BSR     NEWLINE 
000016CA  4BED 0004                826          LEA.L   4(A5),A5          Point to next pair (ie Di, Ai) 
000016CE  51CE FFD4                827          DBRA    D6,EX_D1          Repeat until all displayed 
000016D2  4BED 0020                828          LEA.L   32(A5),A5         Adjust pointer by 8 longwords 
000016D6  6100 F998                829          BSR     NEWLINE           to point to SSP 
000016DA  49FA 0380                830          LEA.L   MES2A(PC),A4      Point to "SS =" 
000016DE  6100 F9A0                831          BSR     PSTRING           Print it 
000016E2  201D                     832          MOVE.L  (A5)+,D0          Get SSP from frame 
000016E4  6100 FB3C                833          BSR     OUT8X             and display it 
000016E8  6100 F986                834          BSR     NEWLINE 
000016EC  49FA 035C                835          LEA.L   MES1(PC),A4       Point to 'SR =' 
000016F0  6100 F98E                836          BSR     PSTRING           Print it 
000016F4  301D                     837          MOVE.W  (A5)+,D0          Get status register 
000016F6  6100 FB22                838          BSR     OUT4X             Display status 
000016FA  6100 F974                839          BSR     NEWLINE 
000016FE  49FA 0353                840          LEA.L   MES2(PC),A4       Point to 'PC =' 
00001702  6100 F97C                841          BSR     PSTRING           Print it 
00001706  201D                     842          MOVE.L  (A5)+,D0          Get PC 
00001708  6100 FB18                843          BSR     OUT8X             Display PC 
0000170C  6000 F962                844          BRA     NEWLINE           Newline and return 
00001710                           845  * 
00001710                           846  ************************************************************************* 
00001710                           847  
00001710  49F9 00001B83            848  HELP     LEA.L    JUMPHELP,A4
00001716  6100 F968                849           BSR.W    PSTRING
0000171A  6100 F954                850           BSR.W    NEWLINE
0000171E  4E75                     851           RTS
00001720                           852           
00001720                           853  *************************************************************************         
00001720                           854  * 
00001720                           855  *  Exception handling routines 
00001720                           856  * 
00001720  =00001720                857  IL_ER   EQU      *                Illegal instruction exception 
00001720  2F0C                     858          MOVE.L  A4,-(A7)          Save A4 
00001722  49FA 0389                859          LEA.L   MES10(PC),A4      Point to heading 
00001726  6100 F968                860          BSR     HEADING           Print it 
0000172A  285F                     861          MOVE.L  (A7)+,A4          Restore A4 
0000172C  6176                     862          BSR.S   GROUP2            Save registers in display frame 
0000172E  6100 FF62                863          BSR     EX_DIS            Display registers saved in frame 
00001732  6000 F92C                864          BRA     WARM              Abort from illegal instruction 
00001736                           865  * 
00001736  =00001736                866  BUS_ER  EQU     *                 Bus error (group 1) exception 
00001736  2F0C                     867          MOVE.L  A4,-(A7)          Save A4 
00001738  49FA 0353                868          LEA.L   MES8(PC),A4       Point to heading 
0000173C  6100 F952                869          BSR     HEADING           Print it 
00001740  285F                     870          MOVE.L  (A7)+,A4          Restore A4 
00001742  602C                     871          BRA.S   GROUP1            Deal with group 1 exception 
00001744                           872  * 
00001744  =00001744                873  ADD_ER  EQU     *                 Address error (group 1) exception 
00001744  2F0C                     874          MOVE.L  A4,-(A7)          Save A4 
00001746  49FA 0353                875          LEA.L   MES9(PC),A4       Point to heading 
0000174A  6100 F944                876          BSR     HEADING           Print it 
0000174E  285F                     877          MOVE.L  (A7)+,A4          Restore A4 
00001750  601E                     878          BRA.S   GROUP1            Deal with group 1 exception 
00001752                           879  * 
00001752  =00001752                880  BRKPT   EQU     *                   Deal with breakpoint 
00001752  48E7 FFFE                881          MOVEM.L D0-D7/A0-A6,-(A7)   Save all registers 
00001756  6100 0180                882          BSR     BR_CLR              Clear breakpoints in code 
0000175A  4CDF 7FFF                883          MOVEM.L (A7)+,D0-D7/A0-A6   Restore registers 
0000175E  6144                     884          BSR.S   GROUP2            Treat as group 2 exception 
00001760  49FA 0361                885          LEA.L   MES11(PC),A4      Point to heading 
00001764  6100 F92A                886          BSR     HEADING           Print it 
00001768  6100 FF28                887          BSR     EX_DIS            Display saved registers 
0000176C  6000 F8F2                888          BRA     WARM              Return to monitor 
00001770                           889  * 
00001770                           890  *       GROUP1 is called by address and bus error exceptions 
00001770                           891  *       These are "turned into group 2" exceptions (eg TRAP) 
00001770                           892  *       by modifying the stack frame saved by a group 1 exception 
00001770                           893  * 
00001770  48E7 8080                894  GROUP1  MOVEM.L D0/A0,-(A7)       Save working registers 
00001774  206F 0012                895          MOVE.L  18(A7),A0         Get PC from group 1 stack frame 
00001778  302F 000E                896          MOVE.W  14(A7),D0         Get instruction from stack frame 
0000177C  B060                     897          CMP.W   -(A0),D0          Now backtrack to find the "correct PC" 
0000177E  670E                     898          BEQ.S   GROUP1A           by matching the op-code on the stack 
00001780  B060                     899          CMP.W   -(A0),D0          with the code in the region of the 
00001782  670A                     900          BEQ.S   GROUP1A           PC on the stack 
00001784  B060                     901          CMP.W   -(A0),D0 
00001786  6706                     902          BEQ.S   GROUP1A 
00001788  B060                     903          CMP.W   -(A0),D0 
0000178A  6702                     904          BEQ.S   GROUP1A 
0000178C  5588                     905          SUBQ.L  #2,A0 
0000178E  2F48 0012                906  GROUP1A MOVE.L  A0,18(A7)          Restore modified PC to stack frame 
00001792  4CDF 0101                907          MOVEM.L (A7)+,D0/A0        Restore working registers 
00001796  4FEF 0008                908          LEA.L   8(A7),A7           Adjust stack pointer to group 1 type 
0000179A  6108                     909          BSR.S   GROUP2             Now treat as group 1 exception 
0000179C  6100 FEF4                910          BSR     EX_DIS             Display contents of exception frame 
000017A0  6000 F8BE                911          BRA     WARM               Exit to monitor - no RTE from group 2 
000017A4                           912  * 
000017A4  =000017A4                913  GROUP2  EQU     *                 Deal with group 2 exceptions 
000017A4  48E7 FFFF                914          MOVEM.L A0-A7/D0-D7,-(A7) Save all registers on the stack 
000017A8  303C 000E                915          MOVE.W  #14,D0            Transfer D0 - D7, A0 - A6 from 
000017AC  41EE 005E                916          LEA.L   TSK_T(A6),A0      the stack to the display frame 
000017B0  20DF                     917  GROUP2A MOVE.L  (A7)+,(A0)+       Move a register from stack to frame 
000017B2  51C8 FFFC                918          DBRA    D0,GROUP2A        and repeat until D0-D7/A0-A6 moved 
000017B6  4E6A                     919          MOVE.L  USP,A2            Get the user stack pointer and put it 
000017B8  20CA                     920          MOVE.L  A2,(A0)+          in the A7 position in the frame 
000017BA  201F                     921          MOVE.L  (A7)+,D0          Now transfer the SSP to the frame, 
000017BC  0480 0000000A            922          SUB.L   #10,D0            remembering to account for the 
000017C2  20C0                     923          MOVE.L  D0,(A0)+          data pushed on the stack to this point 
000017C4  225F                     924          MOVE.L  (A7)+,A1          Copy TOS (return address) to A1 
000017C6  30DF                     925          MOVE.W  (A7)+,(A0)+       Move SR to display frame 
000017C8  201F                     926          MOVE.L  (A7)+,D0          Get PC in D0 
000017CA  5580                     927          SUBQ.L  #2,D0             Move back to current instruction 
000017CC  20C0                     928          MOVE.L  D0,(A0)+          Put adjusted PC in display frame 
000017CE  4ED1                     929          JMP     (A1)              Return from subroutine 
000017D0                           930  * 
000017D0                           931  ************************************************************************* 
000017D0                           932  * 
000017D0                           933  *  GO executes a program either from a supplied address or 
000017D0                           934  *  by using the data in the display frame 
000017D0  6100 F9E2                935  GO       BSR     PARAM               Get entry address (if any) 
000017D4  4A07                     936           TST.B   D7                  Test for error in input 
000017D6  6708                     937           BEQ.S   GO1                 If D7 zero then OK 
000017D8  49FA 0329                938           LEA.L   ERMES1(PC),A4       Else point to error message, 
000017DC  6000 F8A2                939           BRA     PSTRING             print it and return 
000017E0  4A80                     940  GO1      TST.L   D0                  If no address entered then get 
000017E2  670A                     941           BEQ.S   GO2                 address from display frame 
000017E4  2D40 00A4                942           MOVE.L  D0,TSK_T+70(A6)     Else save address in display frame 
000017E8  3D7C 0700 00A2           943           MOVE.W  #$0700,TSK_T+68(A6) Store dummy status in frame 
000017EE  6006                     944  GO2      BRA.S   RESTORE             Restore volatile environment and go 
000017F0                           945  * 
000017F0  6100 007A                946  GB       BSR     BR_SET              Same as go but presets breakpoints 
000017F4  60DA                     947           BRA.S   GO                  Execute program 
000017F6                           948  * 
000017F6                           949  *        RESTORE moves the volatile environment from the display 
000017F6                           950  *        frame and transfers it to the 68000's registers. This 
000017F6                           951  *        re-runs a program suspended after an exception 
000017F6                           952  * 
000017F6  47EE 005E                953  RESTORE  LEA.L   TSK_T(A6),A3        A3 points to display frame 
000017FA  47EB 004A                954           LEA.L   74(A3),A3           A3 now points to end of frame + 4 
000017FE  4FEF 0004                955           LEA.L   4(A7),A7            Remove return address from stack 
00001802  303C 0024                956           MOVE.W  #36,D0              Counter for 37 words to be moved 
00001806  3F23                     957  REST1    MOVE.W  -(A3),-(A7)         Move word from display frame to stack 
00001808  51C8 FFFC                958           DBRA    D0,REST1            Repeat until entire frame moved 
0000180C  4CDF 00FF                959           MOVEM.L (A7)+,D0-D7         Restore old data registers from stack 
00001810  4CDF 7F00                960           MOVEM.L (A7)+,A0-A6         Restore old address registers 
00001814  4FEF 0008                961           LEA.L   8(A7),A7            Except SSP/USP - so adjust stack 
00001818  4E73                     962           RTE                         Return from exception to run program 
0000181A                           963  * 
0000181A  =0000181A                964  TRACE    EQU     *                   TRACE exception (rudimentary version) 
0000181A  287A 02B5                965           MOVE.L  MES12(PC),A4        Point to heading 
0000181E  6100 F870                966           BSR     HEADING             Print it 
00001822  6100 FF4C                967           BSR     GROUP1              Save volatile environment 
00001826  6100 FE6A                968           BSR     EX_DIS              Display it 
0000182A  6000 F834                969           BRA     WARM                Return to monitor 
0000182E                           970  * 
0000182E                           971  ************************************************************************* 
0000182E                           972  *  Breakpoint routines: BR_GET gets the address of a breakpoint and 
0000182E                           973  *  puts it in the breakpoint table. It does not plant it in the code. 
0000182E                           974  *  BR_SET plants all breakpoints in the code. NOBR removes one or all 
0000182E                           975  *  breakpoints from the table. KILL removes breakpoints from the code. 
0000182E                           976  * 
0000182E  6100 F984                977  BR_GET   BSR     PARAM               Get breakpoint address in table 
00001832  4A07                     978           TST.B   D7                  Test for input error 
00001834  6708                     979           BEQ.S   BR_GET1             If no error then continue 
00001836  49FA 02CB                980           LEA.L   ERMES1(PC),A4       Else display error 
0000183A  6000 F844                981           BRA     PSTRING             and return 
0000183E  47EE 00A8                982  BR_GET1  LEA.L   BP_TAB(A6),A3       A6 points to breakpoint table 
00001842  2A40                     983           MOVE.L  D0,A5               Save new BP address in A5 
00001844  2C00                     984           MOVE.L  D0,D6               and in D6 because D0 gets corrupted 
00001846  3A3C 0007                985           MOVE.W  #7,D5               Eight entries to test 
0000184A  201B                     986  BR_GET2  MOVE.L  (A3)+,D0            Read entry from breakpoint table 
0000184C  660C                     987           BNE.S   BR_GET3             If not zero display existing BP 
0000184E  4A86                     988           TST.L   D6                  Only store a non-zero breakpoint 
00001850  6710                     989           BEQ.S   BR_GET4 
00001852  274D FFFC                990           MOVE.L  A5,-4(A3)           Store new breakpoint in table 
00001856  3695                     991           MOVE.W  (A5),(A3)           Save code at BP address in table 
00001858  4286                     992           CLR.L   D6                  Clear D6 to avoid repetition 
0000185A  6100 F9C6                993  BR_GET3  BSR     OUT8X               Display this breakpoint 
0000185E  6100 F810                994           BSR     NEWLINE 
00001862  47EB 0002                995  BR_GET4  LEA.L   2(A3),A3            Step past stored op-code 
00001866  51CD FFE2                996           DBRA    D5,BR_GET2          Repeat until all entries tested 
0000186A  4E75                     997           RTS                         Return 
0000186C                           998  * 
0000186C  =0000186C                999  BR_SET   EQU     *                   Plant any breakpoints in user code 
0000186C  41EE 00A8               1000           LEA.L   BP_TAB(A6),A0       A0 points to BP table 
00001870  45EE 00A4               1001           LEA.L   TSK_T+70(A6),A2     A2 points to PC in display frame 
00001874  2452                    1002           MOVE.L  (A2),A2             Now A2 contains value of PC 
00001876  303C 0007               1003           MOVE.W  #7,D0               Up to eight entries to plant 
0000187A  2218                    1004  BR_SET1  MOVE.L  (A0)+,D1            Read breakpoint address from table 
0000187C  670A                    1005           BEQ.S   BR_SET2             If zero then skip planting 
0000187E  B28A                    1006           CMP.L   A2,D1               Don't want to plant BP at current PC 
00001880  6706                    1007           BEQ.S   BR_SET2             location, so skip planting if same 
00001882  2241                    1008           MOVE.L  D1,A1               Transfer BP address to address reg 
00001884  32BC 4E4E               1009           MOVE.W  #TRAP_14,(A1)       Plant op-code for TRAP #14 in code 
00001888  41E8 0002               1010  BR_SET2  LEA.L   2(A0),A0            Skip past op-code field in table 
0000188C  51C8 FFEC               1011           DBRA    D0,BR_SET1          Repeat until all entries tested 
00001890  4E75                    1012           RTS 
00001892                          1013  * 
00001892  =00001892               1014  NOBR     EQU     *                   Clear one or all breakpoints 
00001892  6100 F920               1015           BSR     PARAM               Get BP address (if any) 
00001896  4A07                    1016           TST.B   D7                  Test for input error 
00001898  6708                    1017           BEQ.S   NOBR1               If no error then skip abort 
0000189A  49FA 0267               1018           LEA.L   ERMES1(PC),A4       Point to error message 
0000189E  6000 F7E0               1019           BRA     PSTRING             Display it and return 
000018A2  4A80                    1020  NOBR1    TST.L   D0                  Test for null address (clear all) 
000018A4  6720                    1021           BEQ.S   NOBR4               If no address then clear all entries 
000018A6  2240                    1022           MOVE.L  D0,A1               Else just clear breakpoint in A1 
000018A8  41EE 00A8               1023           LEA.L   BP_TAB(A6),A0       A0 points to BP table 
000018AC  303C 0007               1024           MOVE.W  #7,D0               Up to eight entries to test 
000018B0  2218                    1025  NOBR2    MOVE.L  (A0)+,D1            Get entry and 
000018B2  41E8 0002               1026           LEA.L   2(A0),A0            skip past op-code field 
000018B6  B289                    1027           CMP.L   A1,D1               Is this the one? 
000018B8  6706                    1028           BEQ.S   NOBR3               If so go and clear entry 
000018BA  51C8 FFF4               1029           DBRA    D0,NOBR2            Repeat until all tested 
000018BE  4E75                    1030           RTS 
000018C0  42A8 FFFA               1031  NOBR3    CLR.L   -6(A0)              Clear address in BP table 
000018C4  4E75                    1032           RTS 
000018C6  41EE 00A8               1033  NOBR4    LEA.L   BP_TAB(A6),A0       Clear all 8 entries in BP table 
000018CA  303C 0007               1034           MOVE.W  #7,D0               Eight entries to clear 
000018CE  4298                    1035  NOBR5    CLR.L   (A0)+               Clear breakpoint address 
000018D0  4258                    1036           CLR.W   (A0)+               Clear op-code field 
000018D2  51C8 FFFA               1037           DBRA    D0,NOBR5            Repeat until all done 
000018D6  4E75                    1038           RTS 
000018D8                          1039  * 
000018D8  =000018D8               1040  BR_CLR   EQU     *                   Remove breakpoints from code 
000018D8  41EE 00A8               1041           LEA.L   BP_TAB(A6),A0       A0 points to breakpoint table 
000018DC  303C 0007               1042           MOVE.W  #7,D0               Up to eight entries to clear 
000018E0  2218                    1043  BR_CLR1  MOVE.L  (A0)+,D1            Get address of BP in D1 
000018E2  2241                    1044           MOVE.L  D1,A1               and put copy in A1 
000018E4  4A81                    1045           TST.L   D1                  Test this breakpoint 
000018E6  6702                    1046           BEQ.S   BR_CLR2             If zero then skip BP clearing 
000018E8  3290                    1047           MOVE.W  (A0),(A1)           Else restore op-code 
000018EA  41E8 0002               1048  BR_CLR2  LEA.L   2(A0),A0            Skip past op-code field 
000018EE  51C8 FFF0               1049           DBRA    D0,BR_CLR1          Repeat until all tested 
000018F2  4E75                    1050           RTS 
000018F4                          1051  * 
000018F4                          1052  *  REG_MOD modifies a register in the display frame. The command 
000018F4                          1053  *  format is REG <reg> <value>. E.g. REG D3 1200 
000018F4                          1054  * 
000018F4  4281                    1055  REG_MOD  CLR.L   D1                  D1 to hold name of register 
000018F6  41EE 0048               1056           LEA.L   BUFFPT(A6),A0       A0 contains address of buffer pointer 
000018FA  2050                    1057           MOVE.L  (A0),A0             A0 now points to next char in buffer 
000018FC  1218                    1058           MOVE.B  (A0)+,D1            Put first char of name in D1 
000018FE  E159                    1059           ROL.W   #8,D1               Move char one place left 
00001900  1218                    1060           MOVE.B  (A0)+,D1            Get second char in D1 
00001902  41E8 0001               1061           LEA.L   1(A0),A0            Move pointer past space in buffer 
00001906  2D48 0048               1062           MOVE.L  A0,BUFFPT(A6)       Update buffer pointer 
0000190A  4282                    1063           CLR.L   D2                  D2 is the character pair counter 
0000190C  41FA 01CC               1064           LEA.L   REGNAME(PC),A0      A0 points to string of character pairs 
00001910  43D0                    1065           LEA.L   (A0),A1             A1 also points to string 
00001912  B258                    1066  REG_MD1  CMP.W   (A0)+,D1            Compare a char pair with input 
00001914  6712                    1067           BEQ.S   REG_MD2             If match then exit loop 
00001916  5282                    1068           ADD.L   #1,D2               Else increment match counter 
00001918  B4BC 00000013           1069           CMP.L   #19,D2              Test for end of loop 
0000191E  66F2                    1070           BNE     REG_MD1             Continue until all pairs matched 
00001920  49FA 01E1               1071           LEA.L   ERMES1(PC),A4       If here then error 
00001924  6000 F75A               1072           BRA     PSTRING             Display error and return 
00001928  43EE 005E               1073  REG_MD2  LEA.L   TSK_T(A6),A1        A1 points to display frame 
0000192C  E582                    1074           ASL.L   #2,D2               Multiply offset by 4 (4 bytes/entry) 
0000192E  B4BC 00000048           1075           CMP.L   #72,D2              Test for address of PC 
00001934  6602                    1076           BNE.S   REG_MD3             If not PC then all is OK 
00001936  5582                    1077           SUB.L   #2,D2               else dec PC pointer as Sr is a word 
00001938  45F1 2000               1078  REG_MD3  LEA.L   (A1,D2),A2          Calculate address of entry in disptable 
0000193C  2012                    1079           MOVE.L  (A2),D0             Get old contents 
0000193E  6100 F8E2               1080           BSR     OUT8X               Display them 
00001942  6100 F72C               1081           BSR     NEWLINE 
00001946  6100 F86C               1082           BSR     PARAM               Get new data 
0000194A  4A07                    1083           TST.B   D7                  Test for input error 
0000194C  6708                    1084           BEQ.S   REG_MD4             If no error then go and store data 
0000194E  49FA 01B3               1085           LEA.L   ERMES1(PC),A4       Else point to error message 
00001952  6000 F72C               1086           BRA     PSTRING             print it and return 
00001956  B4BC 00000044           1087  REG_MD4  CMP.L   #68,D2              If this address is the SR then 
0000195C  6704                    1088           BEQ.S   REG_MD5             we have only a word to store 
0000195E  2480                    1089           MOVE.L  D0,(A2)             Else store new data in display frame 
00001960  4E75                    1090           RTS 
00001962  3480                    1091  REG_MD5  MOVE.W  D0,(A2)             Store SR (one word) 
00001964  4E75                    1092           RTS 
00001966                          1093  * 
00001966                          1094  ************************************************************************* 
00001966                          1095  * 
00001966  =00001966               1096  X_UN    EQU     *                 Uninitialized exception vector routine 
00001966  49FA 0201               1097          LEA.L   ERMES6(PC),A4     Point to error message 
0000196A  6100 F714               1098          BSR     PSTRING           Display it 
0000196E  6100 FD22               1099          BSR     EX_DIS            Display registers 
00001972  6000 F6EC               1100          BRA     WARM              Abort 
00001976                          1101  * 
00001976                          1102  ************************************************************************* 
00001976                          1103  * 
00001976                          1104  *  All strings and other fixed parameters here 
00001976                          1105  * 
00001976= 54 53 42 55 47 20 ...   1106  BANNER   DC.B     'TSBUG 2 Version 23.07.86',0,0
00001990= 4D 6F 64 69 66 69 ...   1107  MODIFY   DC.B     'Modified by Eugene A. Rockey Jr. Jan.05.2010',0,0
000019BE= 66 6F 72 20 75 73 ...   1108  WHY      DC.B     'for use with the M68000 Minimal Computer Configuration',0,0 
000019F6= 55 6E 69 76 65 72 ...   1109  WHERE    DC.B     'University of Louisville',0,0
00001A10= 2A 20 49 4D 50 4F ...   1110  ADDRE    DC.B     '* IMPORTANT, TURN ON CAPS LOCK  *',0,0
00001A33= 0D 0A 54 53 32 4D ...   1111  CRLF     DC.B     CR,LF,'TS2MON >',0 
00001A3E= 0D 0A 53 31 00 00       1112  HEADER   DC.B     CR,LF,'S','1',0,0 
00001A44= 53 39 20 20 00 00       1113  TAIL     DC.B     'S9  ',0,0 
00001A4A= 20 53 52 20 20 3D ...   1114  MES1     DC.B     ' SR  =  ',0 
00001A53= 20 50 43 20 20 3D ...   1115  MES2     DC.B     ' PC  =  ',0 
00001A5C= 20 53 53 20 20 3D ...   1116  MES2A    DC.B     ' SS  =  ',0 
00001A65= 20 20 44 61 74 61 ...   1117  MES3     DC.B     '  Data reg       Address reg',0,0 
00001A83= 20 20 20 20 20 20 ...   1118  MES4     DC.B     '        ',0,0 
00001A8D= 42 75 73 20 65 72 ...   1119  MES8     DC.B     'Bus error   ',0,0 
00001A9B= 41 64 64 72 65 73 ...   1120  MES9     DC.B     'Address error   ',0,0 
00001AAD= 49 6C 6C 65 67 61 ...   1121  MES10    DC.B     'Illegal instruction ',0,0 
00001AC3= 42 72 65 61 6B 70 ...   1122  MES11    DC.B     'Breakpoint  ',0,0 
00001AD1= 54 72 61 63 65 20 ...   1123  MES12    DC.B     'Trace   ',0 
00001ADA= 44 30 44 31 44 32 ...   1124  REGNAME  DC.B     'D0D1D2D3D4D5D6D7' 
00001AEA= 41 30 41 31 41 32 ...   1125           DC.B     'A0A1A2A3A4A5A6A7' 
00001AFA= 53 53 53 52             1126           DC.B     'SSSR' 
00001AFE= 50 43 20 20 00          1127           DC.B     'PC  ',0 
00001B03= 4E 6F 6E 2D 76 61 ...   1128  ERMES1   DC.B     'Non-valid hexadecimal input  ',0 
00001B21= 49 6E 76 61 6C 69 ...   1129  ERMES2   DC.B     'Invalid command  ',0 
00001B33= 4C 6F 61 64 69 6E ...   1130  ERMES3   DC.B     'Loading error',0 
00001B41= 54 61 62 6C 65 20 ...   1131  ERMES4   DC.B     'Table full  ',0,0 
00001B4F= 42 72 65 61 6B 70 ...   1132  ERMES5   DC.B     'Breakpoint not active   ',0,0 
00001B69= 55 6E 69 6E 69 74 ...   1133  ERMES6   DC.B     'Uninitialized exception ',0,0 
00001B83= 4A 55 4D 50 20 3C ...   1134  JUMPHELP DC.B     'JUMP <address> causes execution to begin at <address>',0      
00001BB9= 20 52 61 6E 67 65 ...   1135  ERMES7   DC.B     ' Range error',0 
00001BC6                          1136  * 
00001BC6                          1137  *  COMTAB is the built-in command table. All entries are made up of 
00001BC6                          1138  *         a string length + number of characters to match + the string 
00001BC6                          1139  *         plus the address of the command relative to COMTAB 
00001BC6                          1140  * 
00001BC6= 04 04                   1141  COMTAB   DC.B     4,4              JUMP <address> causes execution to 
00001BC8= 4A 55 4D 50             1142           DC.B     'JUMP'           begin at <address> 
00001BCC= FFFFF664                1143           DC.L     JUMP-COMTAB                                           
00001BD0= 08 03                   1144           DC.B     8,3              MEMORY <address> examines contents of 
00001BD2= 4D 45 4D 4F 52 59 ...   1145           DC.B     'MEMORY  '       <address> and allows them to be changed 
00001BDA= FFFFF67A                1146           DC.L     MEMORY-COMTAB 
00001BDE= 04 02                   1147           DC.B     4,2              LOAD <string> loads S1/S2 records 
00001BE0= 4C 4F 41 44             1148           DC.B     'LOAD'           from the host. <string> is sent to host 
00001BE4= FFFFF6DA                1149           DC.L     LOAD-COMTAB 
00001BE8= 04 02                   1150           DC.B     4,2              DUMP <string> sends S1 records to the 
00001BEA= 44 55 4D 50             1151           DC.B     'DUMP'           host and is preceeded by <string>. 
00001BEE= FFFFF7AE                1152           DC.L     DUMP-COMTAB 
00001BF2= 04 03                   1153           DC.B     4,3              TRAN enters the transparant mode 
00001BF4= 54 52 41 4E             1154           DC.B     'TRAN'           and is exited by ESC,E. 
00001BF8= FFFFF86A                1155           DC.L     TM-COMTAB 
00001BFC= 04 02                   1156           DC.B     4,2              NOBR <address> removes the breakpoint 
00001BFE= 4E 4F 42 52             1157           DC.B     'NOBR'           at <address> from the BP table. If 
00001C02= FFFFFCCC                1158           DC.L     NOBR-COMTAB      no address is given all BPs are removed. 
00001C06= 04 02                   1159           DC.B     4,2              DISP displays the contents of the 
00001C08= 44 49 53 50             1160           DC.B     'DISP'           pseudo registers in TSK_T. 
00001C0C= FFFFFACC                1161           DC.L     EX_DIS-COMTAB 
00001C10= 04 02                   1162           DC.B    4,2               GO <address> starts program execution 
00001C12= 47 4F 20 20             1163           DC.B    'GO  '            at <address> and loads regs from TSK_T 
00001C16= FFFFFC0A                1164           DC.L    GO-COMTAB 
00001C1A= 04 02                   1165           DC.B    4,2               BRGT puts a breakpoint in the BP 
00001C1C= 42 52 47 54             1166           DC.B    'BRGT'            table - but not in the code 
00001C20= FFFFFC68                1167           DC.L    BR_GET-COMTAB 
00001C24= 04 02                   1168           DC.B    4,2               PLAN puts the breakpoints in the code 
00001C26= 50 4C 41 4E             1169           DC.B    'PLAN' 
00001C2A= FFFFFCA6                1170           DC.L    BR_SET-COMTAB 
00001C2E= 04 04                   1171           DC.B    4,4               KILL removes breakpoints from the code 
00001C30= 4B 49 4C 4C             1172           DC.B    'KILL' 
00001C34= FFFFFD12                1173           DC.L    BR_CLR-COMTAB 
00001C38= 04 02                   1174           DC.B    4,2               GB <address> sets breakpoints and 
00001C3A= 47 42 20 20             1175           DC.B    'GB  '            then calls GO. 
00001C3E= FFFFFC2A                1176           DC.L    GB-COMTAB 
00001C42= 04 03                   1177           DC.B    4,3               REG <reg> <value> loads <value> 
00001C44= 52 45 47 20             1178           DC.B    'REG '            into <reg> in TASK_T. Used to preset 
00001C48= FFFFFD2E                1179           DC.L    REG_MOD-COMTAB    registers before a GO or GB 
00001C4C= 04 04                   1180           DC.B    4,4               REG <reg> <value> loads <value> 
00001C4E= 48 45 4C 50             1181           DC.B    'HELP'            into <reg> in TASK_T. Used to preset 
00001C52= FFFFFB4A                1182           DC.L    HELP-COMTAB       registers before a GO or GB 
00001C56= 00 00                   1183           DC.B    0,0 
00001C58                          1184  * 
00001C58                          1185  ************************************************************************* 
00001C58                          1186  * 
00001C58                          1187  *  This is a list of the information needed to setup the DCBs 
00001C58                          1188  * 
00001C58  =00001C58               1189  DCB_LST  EQU     * 
00001C58= 43 4F 4E 5F 49 4E ...   1190  DCB1     DC.B    'CON_IN  '          Device name (8 bytes) 
00001C60= 000014CE 00008001       1191           DC.L    CON_IN,ACIA_1       Address of driver routine, device 
00001C68= 0002                    1192           DC.W    2                   Number of words in parameter field 
00001C6A= 43 4F 4E 5F 4F 55 ...   1193  DCB2     DC.B    'CON_OUT ' 
00001C72= 000014E4 00008001       1194           DC.L    CON_OUT,ACIA_1 
00001C7A= 0002                    1195           DC.W    2 
00001C7C= 41 55 58 5F 49 4E ...   1196  DCB3     DC.B    'AUX_IN  ' 
00001C84= 000014FA 00008001       1197           DC.L    AUX_IN,ACIA_2 
00001C8C= 0002                    1198           DC.W    2 
00001C8E= 41 55 58 5F 4F 55 ...   1199  DCB4     DC.B    'AUX_OUT ' 
00001C96= 0000150C 00008001       1200           DC.L    AUX_OUT,ACIA_2 
00001C9E= 0002                    1201           DC.W    2 
00001CA0= 42 55 46 46 5F 49 ...   1202  DCB5     DC.B    'BUFF_IN ' 
00001CA8= 0000155E 000002D8       1203           DC.L    BUFF_IN,BUFFER 
00001CB0= 0002                    1204           DC.W    2 
00001CB2= 42 55 46 46 5F 4F ...   1205  DCB6     DC.B    'BUFF_OUT' 
00001CBA= 0000156A 000002D8       1206           DC.L    BUFF_OT,BUFFER 
00001CC2= 0002                    1207           DC.W    2 
00001CC4                          1208  * 
00001CC4                          1209  ************************************************************************* 
00001CC4                          1210  * 
00001CC4                          1211  *  DCB structure 
00001CC4                          1212  * 
00001CC4                          1213  *              ----------------------- 
00001CC4                          1214  *       0 ->   | DCB  name           | 
00001CC4                          1215  *              |---------------------| 
00001CC4                          1216  *       8 ->   | Device driver       | 
00001CC4                          1217  *              |---------------------| 
00001CC4                          1218  *      12 ->   | Device address      | 
00001CC4                          1219  *              |---------------------| 
00001CC4                          1220  *      16 ->   |Size of param block  | 
00001CC4                          1221  *              |---------------------| --- 
00001CC4                          1222  *      18 ->   |      Status         |   | 
00001CC4                          1223  *              | logical  | physical |   | S 
00001CC4                          1224  *              |---------------------|   | 
00001CC4                          1225  *              .                     .   . 
00001CC4                          1226  *              |---------------------| --- 
00001CC4                          1227  *    18+S ->   | Pointer to next DCB | 
00001CC4                          1228  * 
00001CC4                          1229           END RESET 

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ACIA_1              8001
ACIA_2              8001
ADDRE               1A10
ADD_ER              1744
ADR_DAT             127E
AUX_IN              14FA
AUX_IN1             1500
AUX_OT1             1512
AUX_OUT             150C
BANNER              1976
BP_TAB              A8
BRKPT               1752
BR_CLR              18D8
BR_CLR1             18E0
BR_CLR2             18EA
BR_GET              182E
BR_GET1             183E
BR_GET2             184A
BR_GET3             185A
BR_GET4             1862
BR_SET              186C
BR_SET1             187A
BR_SET2             1888
BS                  8
BUFFEND             47
BUFFER              2D8
BUFFPT              48
BUFF_IN             155E
BUFF_OT             156A
BUS_ER              1736
BYTE                1198
CN_IVEC             56
CN_OVEC             5A
COMTAB              1BC6
CON_IN              14CE
CON_OUT             14E4
CR                  D
CRLF                1A33
CTRL_A              1
DATA                4800
DCB1                1C58
DCB2                1C6A
DCB3                1C7C
DCB4                1C8E
DCB5                1CA0
DCB6                1CB2
DCB_LST             1C58
DELAY               141C
DELAY1              1426
DUMP                1374
DUMP1               1384
DUMP2               1390
DUMP3               13A6
DUMP4               13BA
DUMP5               13C8
DUMP6               13E2
DUMP7               1406
ECHO                50
ERMES1              1B03
ERMES2              1B21
ERMES3              1B33
ERMES4              1B41
ERMES5              1B4F
ERMES6              1B69
ERMES7              1BB9
ESC                 1B
EXEC1               1120
EXEC2               1130
EXECUTE             110E
EX_D1               16A4
EX_DIS              1692
FIRST               D8
FOO1                15D0
FOO10               163C
FOO11               1648
FOO12               1654
FOO13               1660
FOO14               166C
FOO15               1678
FOO16               1684
FOO17               1690
FOO2                15DC
FOO3                15E8
FOO4                15F4
FOO5                1600
FOO6                160C
FOO7                1618
FOO8                1624
FOO9                1630
GB                  17F0
GETCH2              1542
GETCH3              154A
GETCHAR             151E
GETLINE             1096
GETLN2              10A0
GETLN3              10BA
GETLN4              10C4
GETLN5              10C8
GO                  17D0
GO1                 17E0
GO2                 17EE
GROUP1              1770
GROUP1A             178E
GROUP2              17A4
GROUP2A             17B0
HEADER              1A3E
HEADING             1090
HELP                1710
HEX                 117A
HEX_OK              1196
IL_ER               1720
IO_OPEN             1578
IO_REQ              14BC
JUMP                122A
JUMP1               1238
JUMPHELP            1B83
LF                  A
LNBUFF              8
LOAD                12A0
LOAD1               12CC
LOAD2               12DC
LOAD3               12F6
LOAD4               1310
LOAD5               131E
LOAD6               1320
LOAD6A              1344
LOAD7               1356
LOAD8               136C
LONGWD              11AE
MAXCHR              40
MEM1                124A
MEM2                1268
MEM3                127C
MEMORY              1240
MES1                1A4A
MES10               1AAD
MES11               1AC3
MES12               1AD1
MES2                1A53
MES2A               1A5C
MES3                1A65
MES4                1A83
MES8                1A8D
MES9                1A9B
MODIFY              1990
NEWLINE             1070
NOBR                1892
NOBR1               18A2
NOBR2               18B0
NOBR3               18C0
NOBR4               18C6
NOBR5               18CE
NOT_HEX             1192
NO_EXT              105C
OPEN1               1580
OPEN2               1588
OPEN3               1596
OPEN4               15AC
OUT1X               11F8
OUT1X1              120A
OUT2X               1212
OUT4X               121A
OUT8X               1222
PARAM               11B4
PARAM1              11BC
PARAM3              11E0
PARAM4              11E4
PARAM5              11F0
PARAM6              11F4
PARAMTR             4C
PS1                 1082
PS2                 108C
PSPACE              1292
PSTRING             1080
PUTCHAR             154E
RANGE               140C
REGNAME             1ADA
REG_MD1             1912
REG_MD2             1928
REG_MD3             1938
REG_MD4             1956
REG_MD5             1962
REG_MOD             18F4
RESET               1000
REST1               1806
RESTORE             17F6
SEARCH              113A
SET_DCB             1472
SPACE               20
SRCH2               1154
SRCH3               1158
SRCH4               1160
SRCH6               116A
SRCH7               1174
STACK               4400
ST_DCB1             1482
ST_DCB2             1486
TAIL                1A44
TIDY                10CC
TIDY1               10D2
TIDY2               10DE
TIDY3               10E8
TIDY4               10F2
TIDY5               10FC
TIDY6               1108
TM                  1430
TM1                 143C
TRACE               181A
TRAP_0              15C4
TRAP_14             4E4E
TSK_T               5E
UTAB                52
U_CASE              51
WAIT                57
WARM                1060
WHERE               19F6
WHY                 19BE
WORD                11A8
X_BASE              4000
X_SET               15B2
X_SET2              15BA
X_UN                1966
