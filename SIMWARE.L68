00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.15.04
Created On: 9/24/15 11:35:12 PM

00000000                             1  *        TSBUG2 - 68000 monitor - version of 05 January 2010 
00000000                             2  
00000000                             3      ORG      $0
00000000= 00004400 00001000 ...      4           DC.L STACK,RESET,BUS_ER,ADD_ER,IL_ER,DIV0_ER,X_UN,X_UN,PRIV_ER,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN
00000040= 00001BDC 00001BDC ...      5           DC.L X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN
00000080= 00001648 00001BDC ...      6           DC.L TRAP_0,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN
000000C4= 00001BDC 00001BDC ...      7           DC.L X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN
00000104= 00001BDC 00001BDC ...      8           DC.L X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN
00000144= 00001BDC 00001BDC ...      9           DC.L X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN
00000184= 00001BDC 00001BDC ...     10           DC.L X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN
000001C4= 00001BDC 00001BDC ...     11           DC.L X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN
00000204= 00001BDC 00001BDC ...     12           DC.L X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN
00000244= 00001BDC 00001BDC ...     13           DC.L X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN
00000284= 00001BDC 00001BDC ...     14           DC.L X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN
000002C4= 00001BDC 00001BDC ...     15           DC.L X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN
00000304= 00001BDC 00001BDC ...     16           DC.L X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN
00000344= 00001BDC 00001BDC ...     17           DC.L X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN
00000384= 00001BDC 00001BDC ...     18           DC.L X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN
000003C4= 00001BDC 00001BDC ...     19           DC.L X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN
00000404                            20  *                                   Symbol equates 
00000404  =00000008                 21  BS       EQU      $08               Back_space 
00000404  =0000000D                 22  CR       EQU      $0D               Carriage_return 
00000404  =00000000                 23  NUL      EQU      $00               NUL character
00000404  =0000000A                 24  LF       EQU      $0A               Line_feed 
00000404  =00000020                 25  SPACE    EQU      $20               Space 
00000404  =00000057                 26  WAIT     EQU      'W'               Wait character (to suspend output) 
00000404  =0000001B                 27  ESC      EQU      $1B               ASCII escape character (used by TM) 
00000404  =00000001                 28  CTRL_A   EQU      $01               Control_A forces return to monitor 
00000404                            29  *                                   Device addresses 
00000404  =00004400                 30  STACK    EQU      $4400             Stack_pointer
00000404  =00008001                 31  ACIA_1   EQU      $8001             Console ACIA control 
00000404  =00008001                 32  ACIA_2   EQU      ACIA_1            Auxilary ACIA control 
00000404  =00004000                 33  X_BASE   EQU      $4000             Start of exception vector table 
00000404  =00004E4E                 34  TRAP_16  EQU      $4E4E             Code for TRAP #14 
00000404  =00000040                 35  MAXCHR   EQU      64                Length of input line buffer  
00000404                            36  * 
00000404  =00004800                 37  DATA     EQU      $4800             Data origin 
00000404                            38  LNBUFF   DS.B     MAXCHR            Input line buffer
00000444  =00000443                 39  BUFFEND  EQU      LNBUFF+MAXCHR-1   End of line buffer 
00000444                            40  BUFFPT   DS.L     1                 Pointer to line buffer 
00000448                            41  PARAMTR  DS.L     1                 Last parameter from line buffer 
0000044C                            42  ECHO     DS.B     1                 When clear this enable input echo 
0000044D                            43  U_CASE   DS.B     1                 Flag for upper case conversion 
0000044E                            44  UTAB     DS.L     1                 Pointer to user command table 
00000452                            45  CN_IVEC  DS.L     1                 Pointer to console input DCB 
00000456                            46  CN_OVEC  DS.L     1                 Pointer to console output DCB 
0000045A                            47  TSK_T    DS.W     37                Frame for D0-D7, A0-A6, USP, SSP, SW, PC 
000004A4                            48  BP_TAB   DS.W     24                Breakpoint table 
000004D4                            49  FIRST    DS.B     512               DCB area 
000006D4                            50  BUFFER   DS.B     256               256 bytes for I/O buffer 
000007D4= 00004000                  51  MIN_RAM  DC.L     $004000
000007D8= 00004100                  52  MAX_RAM  DC.L     $004100
000007DC                            53  * 
000007DC                            54  ************************************************************************* 
000007DC                            55  * 
000007DC                            56  *  This is the main program which assembles a command in the line 
000007DC                            57  *  buffer, removes leading/embedded spaces and interprets it by matching 
000007DC                            58  *  it with a command in the user table or the built-in table COMTAB 
000007DC                            59  *  All variables are specified with respect to A6 
000007DC                            60  *
00001000                            61           ORG      $1000             Monitor Origin
00001000  =00001000                 62  RESET:   EQU      *
00001000  4DF8 4800                 63           LEA.L    DATA,A6           A6 points to data area 
00001004  2D4E 0492                 64           MOVE.L    A6,TSK_T+56(A6)   initialize A6 in the regster Frame
00001008  42AE 044E                 65           CLR.L    UTAB(A6)          Reset pointer to user extension table 
0000100C  1D7C 0001 044C            66           MOVE.B   #1,ECHO(A6)       Set automatic character echo 
00001012  422E 044D                 67           CLR.B    U_CASE(A6)        Clear case conversion flag (UC<-LC) 
00001016  6100 05B4                 68           BSR.L     X_SET         what change did i do here
0000101A  6100 046C                 69           BSR.L    SET_DCB           Setup DCB table in RAM
0000101E  6166                      70           BSR.S    NEWLINE
00001020  49FA 0BCA                 71           LEA.L    BANNER(PC),A4    
00001024  6170                      72           BSR.S    PSTRING
00001026  615E                      73           BSR.S    NEWLINE           
00001028  49FA 0BDC                 74           LEA.L     MODIFY(PC),A4
0000102C  6168                      75           BSR.S    PSTRING
0000102E  6156                      76           BSR.S    NEWLINE
00001030  49FA 0C02                 77           LEA.L     WHY(PC),A4
00001034  6160                      78           BSR.S    PSTRING
00001036  614E                      79           BSR.S    NEWLINE
00001038  49FA 0C32                 80           LEA.L     WHERE(PC),A4
0000103C  6158                      81           BSR.S    PSTRING
0000103E  6146                      82           BSR.S    NEWLINE
00001040  207C 00003000             83           MOVE.L   #$3000,A0         A0 points to extension ROM 
00001046  2010                      84           MOVE.L   (A0),D0           Read first longword in extension ROM 
00001048  B0BC 524F4D32             85           CMP.L    #'ROM2',D0        If extension begins with 'ROM2' then 
0000104E  6604                      86           BNE.S    NO_EXT            call the subroutine at EXT_ROM+8 
00001050  4EA8 0008                 87           JSR      8(A0)             else continue 
00001054  4E71                      88  NO_EXT:  NOP                        Two NOPs to allow for a future 
00001056  4E71                      89           NOP                        call to an initialization routine
00001058  383C 0008                 90           MOVE.W   #8,D4
0000105C  3A3C 000A                 91           MOVE.W   #10,D5
00001060  123C 0012                 92           MOVE.B   #18,D1
00001064  4EB9 00001648             93           JSR      TRAP_0
0000106A  1003                      94           MOVE.B   D3,D0
0000106C  6100 01CA                 95           BSR.W    OUT8X
00001070  4EB9 000017FA             96           JSR      LOGIN
00001076  4287                      97  WARM:    CLR.L    D7                Warm entry point - clear error flag 
00001078  610C                      98           BSR.S    NEWLINE           Print a newline 
0000107A  6130                      99           BSR.S    GETLINE           Get a command line 
0000107C  6100 0064                100           BSR      TIDY              Tidy up input buffer contents 
00001080  6100 00A2                101           BSR      EXECUTE           Interpret command 
00001084  60F0                     102           BRA      WARM              Repeat indefinitely 
00001086                           103  * 
00001086                           104  ************************************************************************* 
00001086                           105  * 
00001086                           106  *  Some initialization and basic routines 
00001086                           107  * 
00001086                           108  * 
00001086  =00001086                109  NEWLINE  EQU      *                 Move cursor to start of newline 
00001086  48E7 0008                110           MOVEM.L  A4,-(A7)          Save A4 
0000108A  49FA 0BFA                111           LEA.L    CRLF(PC),A4       Point to CR/LF string 
0000108E  6106                     112           BSR.S    PSTRING           Print it 
00001090  4CDF 1000                113           MOVEM.L  (A7)+,A4          Restore A4 
00001094  4E75                     114           RTS                        Return 
00001096                           115  * 
00001096  =00001096                116  PSTRING  EQU      *                 Display the string pointed at by A4 
00001096  2F00                     117           MOVE.L   D0,-(A7)          Save D0 
00001098  101C                     118  PS1      MOVE.B   (A4)+,D0          Get character to be printed 
0000109A  6706                     119           BEQ.S    PS2               If null then return 
0000109C  6100 04C6                120           BSR      PUTCHAR           Else print it 
000010A0  60F6                     121           BRA      PS1               Continue 
000010A2  201F                     122  PS2      MOVE.L   (A7)+,D0          Restore D0 and exit 
000010A4  4E75                     123           RTS 
000010A6                           124  * 
000010A6  61DE                     125  HEADING  BSR      NEWLINE           Same as PSTRING but with newline 
000010A8  61EC                     126           BSR      PSTRING 
000010AA  60DA                     127           BRA      NEWLINE 
000010AC                           128  * 
000010AC                           129  ************************************************************************* 
000010AC                           130  * 
000010AC                           131  *  GETLINE  inputs a string of characters into a line buffer 
000010AC                           132  *           A3 points to next free entry in line buffer 
000010AC                           133  *           A2 points to end of buffer 
000010AC                           134  *           A1 points to start of buffer 
000010AC                           135  *           D0 holds character to be stored 
000010AC                           136  * 
000010AC  43EE 0404                137  GETLINE  LEA.L    LNBUFF(A6),A1     A1 points to start of line buffer 
000010B0  47D1                     138           LEA.L    (A1),A3           A3 points to start (initially) 
000010B2  45E9 0040                139           LEA.L    MAXCHR(A1),A2     A2 points to end of buffer 
000010B6  6100 047C                140  GETLN2   BSR      GETCHAR           Get a character 
000010BA  B03C 0001                141           CMP.B    #CTRL_A,D0        If control_A then reject this line 
000010BE  671E                     142           BEQ.S    GETLN5            and get another line 
000010C0  B03C 0008                143           CMP.B    #BS,D0            If back_space then move back pointer 
000010C4  660A                     144           BNE.S    GETLN3            Else skip past wind-back routine 
000010C6  B7C9                     145           CMP.L    A1,A3             First check for empty buffer 
000010C8  67EC                     146           BEQ      GETLN2            If buffer empty then continue 
000010CA  47EB FFFF                147           LEA      -1(A3),A3         Else decrement buffer pointer 
000010CE  60E6                     148           BRA      GETLN2            and continue with next character 
000010D0  16C0                     149  GETLN3   MOVE.B   D0,(A3)+          Store character and update pointer 
000010D2  B03C 000D                150           CMP.B    #CR,D0            Test for command terminator 
000010D6  6602                     151           BNE.S    GETLN4            If not CR then skip past exit 
000010D8  60AC                     152           BRA      NEWLINE           Else new line before next operation 
000010DA  B7CA                     153  GETLN4   CMP.L    A2,A3             Test for buffer overflow 
000010DC  66D8                     154           BNE      GETLN2            If buffer not full then continue 
000010DE  61A6                     155  GETLN5   BSR      NEWLINE           Else move to next line and 
000010E0  60CA                     156           BRA      GETLINE           repeat this routine 
000010E2                           157  * 
000010E2                           158  ************************************************************************* 
000010E2                           159  * 
000010E2                           160  *  TIDY cleans up the line buffer by removing leading spaces and multiple 
000010E2                           161  *       spaces between parameters. At the end of TIDY, BUFFPT points to 
000010E2                           162  *       the first parameter following the command. 
000010E2                           163  *       A0 = pointer to line buffer. A1 = pointer to cleaned up buffer 
000010E2                           164  * 
000010E2  41EE 0404                165  TIDY     LEA.L    LNBUFF(A6),A0     A0 points to line buffer 
000010E6  43D0                     166           LEA.L    (A0),A1           A1 points to start of line buffer 
000010E8  1018                     167  TIDY1    MOVE.B   (A0)+,D0          Read character from line buffer 
000010EA  B03C 0020                168           CMP.B    #SPACE,D0         Repeat until the first non-space 
000010EE  67F8                     169           BEQ      TIDY1             character is found 
000010F0  41E8 FFFF                170           LEA.L    -1(A0),A0         Move pointer back to first char 
000010F4  1018                     171  TIDY2    MOVE.B   (A0)+,D0          Move the string left to remove 
000010F6  12C0                     172           MOVE.B   D0,(A1)+          any leading spaces 
000010F8  B03C 0020                173           CMP.B    #SPACE,D0         Test for embedded space 
000010FC  660A                     174           BNE.S    TIDY4             If not space then test for EOL 
000010FE  0C18 0020                175  TIDY3    CMP.B    #SPACE,(A0)+      If space skip multiple embedded 
00001102  67FA                     176           BEQ      TIDY3             spaces 
00001104  41E8 FFFF                177           LEA.L    -1(A0),A0         Move back pointer 
00001108  B03C 000D                178  TIDY4    CMP.B    #CR,D0            Test for end_of_line (EOL) 
0000110C  66E6                     179           BNE      TIDY2             If not EOL then read next char 
0000110E  41EE 0404                180           LEA.L    LNBUFF(A6),A0     Restore buffer pointer 
00001112  0C10 000D                181  TIDY5    CMP.B    #CR,(A0)          Test for EOL 
00001116  6706                     182           BEQ.S    TIDY6             If EOL then exit 
00001118  0C18 0020                183           CMP.B    #SPACE,(A0)+      Test for delimiter 
0000111C  66F4                     184           BNE      TIDY5             Repeat until delimiter or EOL 
0000111E  2D48 0444                185  TIDY6    MOVE.L   A0,BUFFPT(A6)     Update buffer pointer 
00001122  4E75                     186           RTS 
00001124                           187  * 
00001124                           188  ************************************************************************* 
00001124                           189  * 
00001124                           190  *  EXECUTE matches the first command in the line buffer with the 
00001124                           191  *  commands in a command table. An external table pointed at by 
00001124                           192  *  UTAB is searched first and then the built-in table, COMTAB. 
00001124                           193  * 
00001124  4AAE 044E                194  EXECUTE  TST.L    UTAB(A6)          Test pointer to user table 
00001128  670C                     195           BEQ.S    EXEC1             If clear then try built-in table 
0000112A  266E 044E                196           MOVE.L   UTAB(A6),A3       Else pick up pointer to user table 
0000112E  6120                     197           BSR.S    SEARCH            Look for command in user table 
00001130  6404                     198           BCC.S    EXEC1             If not found then try internal table 
00001132  2653                     199           MOVE.L   (A3),A3           Else get absolute address of command 
00001134  4ED3                     200           JMP      (A3)              from user table and execute it 
00001136                           201  * 
00001136  47FA 0EC8                202  EXEC1    LEA.L    COMTAB(PC),A3     Try built-in command table 
0000113A  6114                     203           BSR.S    SEARCH            Look for command in built-in table 
0000113C  6508                     204           BCS.S    EXEC2             If found then execute command 
0000113E  49FA 0C59                205           LEA.L    ERMES2(PC),A4     Else print "invalid command" 
00001142  6000 FF52                206           BRA.L    PSTRING           and return 
00001146  2653                     207  EXEC2    MOVE.L   (A3),A3           Get the relative command address 
00001148  49FA 0EB6                208           LEA.L    COMTAB(PC),A4     pointed at by A3 and add it to 
0000114C  D7CC                     209           ADD.L    A4,A3             the PC to generate the actual 
0000114E  4ED3                     210           JMP      (A3)              command address. Then execute it. 
00001150                           211  * 
00001150  =00001150                212  SEARCH   EQU      *                 Match the command in the line buffer 
00001150  4280                     213           CLR.L    D0                with command table pointed at by A3 
00001152  1013                     214           MOVE.B   (A3),D0           Get the first character in the 
00001154  6734                     215           BEQ.S    SRCH7             current entry. If zero then exit 
00001156  49F3 0006                216           LEA.L    6(A3,D0.W),A4     Else calculate address of next entry 
0000115A  122B 0001                217           MOVE.B   1(A3),D1          Get number of characters to match 
0000115E  4BEE 0404                218           LEA.L    LNBUFF(A6),A5     A5 points to command in line buffer 
00001162  142B 0002                219           MOVE.B   2(A3),D2          Get first character in this entry 
00001166  B41D                     220           CMP.B    (A5)+,D2          from the table and match with buffer 
00001168  6704                     221           BEQ.S    SRCH3             If match then try rest of string 
0000116A  264C                     222  SRCH2    MOVE.L   A4,A3             Else get address of next entry 
0000116C  60E2                     223           BRA      SEARCH            and try the next entry in the table 
0000116E  5301                     224  SRCH3    SUB.B    #1,D1             One less character to match 
00001170  670E                     225           BEQ.S    SRCH6             If match counter zero then all done 
00001172  47EB 0003                226           LEA.L    3(A3),A3          Else point to next character in table 
00001176  141B                     227  SRCH4    MOVE.B   (A3)+,D2          Now match a pair of characters 
00001178  B41D                     228           CMP.B    (A5)+,D2 
0000117A  66EE                     229           BNE      SRCH2             If no match then try next entry 
0000117C  5301                     230           SUB.B    #1,D1             Else decrement match counter and 
0000117E  66F6                     231           BNE      SRCH4             repeat until no chars left to match 
00001180  47EC FFFC                232  SRCH6    LEA.L    -4(A4),A3         Calculate address of command entry 
00001184  003C 0001                233           OR.B     #1,CCR            point. Mark carry flag as success 
00001188  4E75                     234           RTS                        and return 
0000118A  023C 00FE                235  SRCH7    AND.B    #$FE,CCR          Fail - clear carry to indicate 
0000118E  4E75                     236           RTS                        command not found and return 
00001190                           237  * 
00001190                           238  ************************************************************************* 
00001190                           239  * 
00001190                           240  *  Basic input routines 
00001190                           241  *  HEX    =  Get one   hexadecimal character  into D0 
00001190                           242  *  BYTE   =  Get two   hexadecimal characters into D0 
00001190                           243  *  WORD   =  Get four  hexadecimal characters into D0 
00001190                           244  *  LONGWD =  Get eight hexadecimal characters into D0 
00001190                           245  *  PARAM  =  Get a longword from the line buffer into D0 
00001190                           246  *  Bit 0 of D7 is set to indicate a hexadecimal input error 
00001190                           247  * 
00001190  6100 03A2                248  HEX      BSR      GETCHAR           Get a character from input device 
00001194  0400 0030                249           SUB.B    #$30,D0           Convert to binary 
00001198  6B0E                     250           BMI.S    NOT_HEX           If less than $30 then exit with error 
0000119A  B03C 0009                251           CMP.B    #$09,D0           Else test for number (0 to 9) 
0000119E  6F0C                     252           BLE.S    HEX_OK            If number then exit - success 
000011A0  5F00                     253           SUB.B    #$07,D0           Else convert letter to hex 
000011A2  B03C 000F                254           CMP.B    #$0F,D0           If character in range "A" to "F" 
000011A6  6F04                     255           BLE.S    HEX_OK            then exit successfully 
000011A8  8E3C 0001                256  NOT_HEX  OR.B     #1,D7             Else set error flag 
000011AC  4E75                     257  HEX_OK   RTS                        and return 
000011AE                           258  * 
000011AE  2F01                     259  BYTE     MOVE.L   D1,-(A7)          Save D1 
000011B0  61DE                     260           BSR      HEX               Get first hex character 
000011B2  E900                     261           ASL.B    #4,D0             Move it to MS nybble position 
000011B4  1200                     262           MOVE.B   D0,D1             Save MS nybble in D1 
000011B6  61D8                     263           BSR      HEX               Get second hex character 
000011B8  D001                     264           ADD.B    D1,D0             Merge MS and LS nybbles 
000011BA  221F                     265           MOVE.L   (A7)+,D1          Restore D1 
000011BC  4E75                     266           RTS 
000011BE                           267  * 
000011BE  61EE                     268  WORD     BSR      BYTE              Get upper order byte 
000011C0  E140                     269           ASL.W    #8,D0             Move it to MS position 
000011C2  60EA                     270           BRA      BYTE              Get LS byte and return 
000011C4                           271  * 
000011C4  61F8                     272  LONGWD   BSR      WORD              Get upper order word 
000011C6  4840                     273           SWAP     D0                Move it to MS position 
000011C8  60F4                     274           BRA      WORD              Get lower order word and return 
000011CA                           275  * 
000011CA                           276  *  PARAM reads a parameter from the line buffer and puts it in both 
000011CA                           277  *  PARAMTR(A6) and D0. Bit 1 of D7 is set on error. 
000011CA                           278  * 
000011CA  2F01                     279  PARAM    MOVE.L   D1,-(A7)          Save D1 
000011CC  4281                     280           CLR.L    D1                Clear input accumulator 
000011CE  206E 0444                281           MOVE.L   BUFFPT(A6),A0     A0 points to parameter in buffer 
000011D2  1018                     282  PARAM1   MOVE.B   (A0)+,D0          Read character from line buffer 
000011D4  B03C 0020                283           CMP.B    #SPACE,D0         Test for delimiter 
000011D8  6720                     284           BEQ.S    PARAM4            The permitted delimiter is a 
000011DA  B03C 000D                285           CMP.B    #CR,D0            space or a carriage return 
000011DE  671A                     286           BEQ.S    PARAM4            Exit on either space or C/R 
000011E0  E981                     287           ASL.L    #4,D1             Shift accumulated result 4 bits left 
000011E2  0400 0030                288           SUB.B    #$30,D0           Convert new character to hex 
000011E6  6B1E                     289           BMI.S    PARAM5            If less than $30 then not-hex 
000011E8  B03C 0009                290           CMP.B    #$09,D0           If less than 10 
000011EC  6F08                     291           BLE.S    PARAM3            then continue 
000011EE  5F00                     292           SUB.B    #$07,D0           Else assume $A - $F 
000011F0  B03C 000F                293           CMP.B    #$0F,D0           If more than $F 
000011F4  6E10                     294           BGT.S    PARAM5            then exit to error on not-hex 
000011F6  D200                     295  PARAM3   ADD.B    D0,D1             Add latest nybble to total in D1 
000011F8  60D8                     296           BRA      PARAM1            Repeat until delimiter found 
000011FA  2D48 0444                297  PARAM4   MOVE.L   A0,BUFFPT(A6)     Save pointer in memory 
000011FE  2D41 0448                298           MOVE.L   D1,PARAMTR(A6)    Save parameter in memory 
00001202  2001                     299           MOVE.L   D1,D0             Put parameter in D0 for return 
00001204  6004                     300           BRA.S    PARAM6            Return without error 
00001206  8E3C 0002                301  PARAM5   OR.B     #2,D7             Set error flag before return 
0000120A  221F                     302  PARAM6   MOVE.L   (A7)+,D1          Restore working register 
0000120C  4E75                     303           RTS                        Return with error 
0000120E                           304  * 
0000120E                           305  ************************************************************************* 
0000120E                           306  * 
0000120E                           307  *  Output routines 
0000120E                           308  *  OUT1X   = print one   hexadecimal character 
0000120E                           309  *  OUT2X   = print two   hexadecimal characters 
0000120E                           310  *  OUT4X   = print four  hexadecimal characters 
0000120E                           311  *  OUT8X   = print eight hexadecimal characters 
0000120E                           312  *  In each case, the data to be printed is in D0 
0000120E                           313  * 
0000120E  3F00                     314  OUT1X    MOVE.W   D0,-(A7)          Save D0 
00001210  C03C 000F                315           AND.B    #$0F,D0           Mask off MS nybble 
00001214  0600 0030                316           ADD.B    #$30,D0           Convert to ASCII 
00001218  B03C 0039                317           CMP.B    #$39,D0           ASCII = HEX + $30 
0000121C  6302                     318           BLS.S    OUT1X1            If ASCII <= $39 then print and exit 
0000121E  5E00                     319           ADD.B    #$07,D0           Else ASCII := HEX + 7 
00001220  6100 0342                320  OUT1X1   BSR      PUTCHAR           Print the character 
00001224  301F                     321           MOVE.W   (A7)+,D0          Restore D0 
00001226  4E75                     322           RTS 
00001228                           323  * 
00001228  E818                     324  OUT2X    ROR.B    #4,D0             Get MS nybble in LS position 
0000122A  61E2                     325           BSR      OUT1X             Print MS nybble 
0000122C  E918                     326           ROL.B    #4,D0             Restore LS nybble 
0000122E  60DE                     327           BRA      OUT1X             Print LS nybble and return 
00001230                           328  * 
00001230  E058                     329  OUT4X    ROR.W    #8,D0             Get MS byte in LS position 
00001232  61F4                     330           BSR      OUT2X             Print MS byte 
00001234  E158                     331           ROL.W    #8,D0             Restore LS byte 
00001236  60F0                     332           BRA      OUT2X             Print LS byte and return 
00001238                           333  * 
00001238  4840                     334  OUT8X    SWAP     D0                Get MS word in LS position 
0000123A  61F4                     335           BSR      OUT4X             Print MS word 
0000123C  4840                     336           SWAP     D0                Restore LS word 
0000123E  60F0                     337           BRA      OUT4X             Print LS word and return 
00001240                           338  * 
00001240                           339  ************************************************************************* 
00001240                           340  * 
00001240                           341  * JUMP causes execution to begin at the address in the line buffer 
00001240                           342  * 
00001240  6188                     343  JUMP     BSR     PARAM              Get address from buffer 
00001242  4A07                     344           TST.B   D7                 Test for input error 
00001244  6608                     345           BNE.S   JUMP1              If error flag not zero then exit 
00001246  4A80                     346           TST.L   D0                 Else test for missing address 
00001248  6704                     347           BEQ.S   JUMP1              field. If no address then exit 
0000124A  2040                     348           MOVE.L  D0,A0              Put jump address in A0 and call the 
0000124C  4ED0                     349           JMP     (A0)               subroutine. User to supply RTS!! 
0000124E  49FA 0B2B                350  JUMP1    LEA.L   ERMES1(PC),A4      Here for error - display error 
00001252  6000 FE42                351           BRA     PSTRING            message and return 
00001256                           352  * 
00001256                           353  ************************************************************************* 
00001256                           354  * 
00001256                           355  *  Display the contents of a memory location and modify it 
00001256                           356  * 
00001256  6100 FF72                357  MEMORY   BSR      PARAM             Get start address from line buffer 
0000125A  4A07                     358           TST.B    D7                Test for input error 
0000125C  6634                     359           BNE.S    MEM3              If error then exit 
0000125E  2640                     360           MOVE.L   D0,A3             A3 points to location to be opened 
00001260  6100 FE24                361  MEM1     BSR      NEWLINE 
00001264  612E                     362           BSR.S    ADR_DAT           Print current address and contents 
00001266  6140                     363           BSR.S    PSPACE             update pointer, A3, and O/P space 
00001268  6100 02CA                364           BSR      GETCHAR           Input char to decide next action 
0000126C  B03C 000D                365           CMP.B    #CR,D0            If carriage return then exit 
00001270  6720                     366           BEQ.S    MEM3              Exit 
00001272  B03C 002D                367           CMP.B    #'-',D0           If "-" then move back 
00001276  6606                     368           BNE.S    MEM2              Else skip wind-back procedure 
00001278  47EB FFFC                369           LEA.L    -4(A3),A3         Move pointer back 2+2 
0000127C  60E2                     370           BRA      MEM1              Repeat until carriage return 
0000127E  B03C 0020                371  MEM2     CMP.B    #SPACE,D0         Test for space (= new entry) 
00001282  66DC                     372           BNE.S    MEM1              If not space then repeat 
00001284  6100 FF38                373           BSR      WORD              Else get new word to store 
00001288  4A07                     374           TST.B    D7                Test for input error 
0000128A  6606                     375           BNE.S    MEM3              If error then exit 
0000128C  3740 FFFE                376           MOVE.W   D0,-2(A3)         Store new word 
00001290  60CE                     377           BRA      MEM1              Repeat until carriage return 
00001292  4E75                     378  MEM3     RTS 
00001294                           379  * 
00001294  2F00                     380  ADR_DAT  MOVE.L   D0,-(A7)          Print the contents of A3 and the 
00001296  200B                     381           MOVE.L   A3,D0             word pointed at by A3. 
00001298  619E                     382           BSR      OUT8X              and print current address 
0000129A  610C                     383           BSR.S    PSPACE            Insert delimiter 
0000129C  3013                     384           MOVE.W   (A3),D0           Get data at this address in D0 
0000129E  6190                     385           BSR      OUT4X              and print it 
000012A0  47EB 0002                386           LEA.L    2(A3),A3          Point to next address to display 
000012A4  201F                     387           MOVE.L   (A7)+,D0          Restore D0 
000012A6  4E75                     388           RTS 
000012A8                           389  * 
000012A8  1F00                     390  PSPACE   MOVE.B   D0,-(A7)          Print a single space 
000012AA  103C 0020                391           MOVE.B   #SPACE,D0 
000012AE  6100 02B4                392           BSR      PUTCHAR 
000012B2  101F                     393           MOVE.B   (A7)+,D0 
000012B4  4E75                     394           RTS 
000012B6                           395  * 
000012B6                           396  ************************************************************************* 
000012B6                           397  * 
000012B6                           398  *  LOAD  Loads data formatted in hexadecimal "S" format from Port 2 
000012B6                           399  *        NOTE - I/O is automatically redirected to the aux port for 
000012B6                           400  *        loader functions. S1 or S2 records accepted 
000012B6                           401  * 
000012B6  2F2E 0456                402  LOAD     MOVE.L   CN_OVEC(A6),-(A7) Save current output device name 
000012BA  2F2E 0452                403           MOVE.L   CN_IVEC(A6),-(A7) Save current input device name 
000012BE  2D7C 0000206C 0456       404           MOVE.L   #DCB4,CN_OVEC(A6) Set up aux ACIA as output 
000012C6  2D7C 0000205A 0452       405           MOVE.L   #DCB3,CN_IVEC(A6) Set up aux ACIA as input 
000012CE  522E 044C                406           ADD.B    #1,ECHO(A6)       Turn off character echo 
000012D2  6100 FDB2                407           BSR      NEWLINE           Send newline to host 
000012D6  6100 015A                408           BSR      DELAY             Wait for host to "settle" 
000012DA  6100 0156                409           BSR      DELAY 
000012DE  286E 0444                410           MOVE.L   BUFFPT(A6),A4     Any string in the line buffer is 
000012E2  101C                     411  LOAD1    MOVE.B   (A4)+,D0          transmitted to the host computer 
000012E4  6100 027E                412           BSR      PUTCHAR           before the loading begins 
000012E8  B03C 000D                413           CMP.B    #CR,D0            Read from the buffer until EOL 
000012EC  66F4                     414           BNE      LOAD1 
000012EE  6100 FD96                415           BSR      NEWLINE           Send newline before loading 
000012F2  6100 0240                416  LOAD2    BSR      GETCHAR           Records from the host must begin 
000012F6  B03C 0053                417           CMP.B    #'S',D0           with S1/S2 (data) or S9/S8 (term) 
000012FA  66F6                     418           BNE.S    LOAD2             Repeat GETCHAR until char = "S" 
000012FC  6100 0236                419           BSR      GETCHAR           Get character after "S" 
00001300  B03C 0039                420           CMP.B    #'9',D0           Test for the two terminators S9/S8 
00001304  6706                     421           BEQ.S    LOAD3             If S9 record then exit else test 
00001306  B03C 0038                422           CMP.B    #'8',D0           for S8 terminator. Fall through to 
0000130A  662A                     423           BNE.S    LOAD6             exit on S8 else continue search 
0000130C  =0000130C                424  LOAD3    EQU      *                 Exit point from LOAD 
0000130C  2D5F 0452                425           MOVE.L   (A7)+,CN_IVEC(A6) Clean up by restoring input device 
00001310  2D5F 0456                426           MOVE.L   (A7)+,CN_OVEC(A6) and output device name 
00001314  422E 044C                427           CLR.B    ECHO(A6)          Restore input character echo 
00001318  0807 0000                428           BTST     #0,D7             Test for input errors 
0000131C  6708                     429           BEQ.S    LOAD4             If no I/P error then look at checksum 
0000131E  49FA 0A5B                430           LEA.L    ERMES1(PC),A4     Else point to error message 
00001322  6100 FD72                431           BSR      PSTRING           Print it 
00001326  0807 0003                432  LOAD4    BTST     #3,D7             Test for checksum error 
0000132A  6708                     433           BEQ.S    LOAD5             If clear then exit 
0000132C  49FA 0A7D                434           LEA.L    ERMES3(PC),A4     Else point to error message 
00001330  6100 FD64                435           BSR      PSTRING           Print it and return 
00001334  4E75                     436  LOAD5    RTS 
00001336                           437  * 
00001336  B03C 0031                438  LOAD6    CMP.B    #'1',D0           Test for S1 record 
0000133A  671E                     439           BEQ.S    LOAD6A            If S1 record then read it 
0000133C  B03C 0032                440           CMP.B    #'2',D0           Else test for S2 record 
00001340  66B0                     441           BNE.S    LOAD2             Repeat until valid header found 
00001342  4203                     442           CLR.B    D3                Read the S2 byte count and address, 
00001344  613C                     443           BSR.S    LOAD8             clear the checksum 
00001346  5900                     444           SUB.B    #4,D0             Calculate size of data field 
00001348  1400                     445           MOVE.B   D0,D2             D2 contains data bytes to read 
0000134A  4280                     446           CLR.L    D0                Clear address accumulator 
0000134C  6134                     447           BSR.S    LOAD8             Read most sig byte of address 
0000134E  E180                     448           ASL.L    #8,D0             Move it one byte left 
00001350  6130                     449           BSR.S    LOAD8             Read the middle byte of address 
00001352  E180                     450           ASL.L    #8,D0             Move it one byte left 
00001354  612C                     451           BSR.S    LOAD8             Read least sig byte of address 
00001356  2440                     452           MOVE.L   D0,A2             A2 points to destination of record 
00001358  6012                     453           BRA.S    LOAD7             Skip past S1 header loader 
0000135A  4203                     454  LOAD6A   CLR.B    D3                S1 record found - clear checksum 
0000135C  6124                     455           BSR.S    LOAD8             Get byte and update checksum 
0000135E  5700                     456           SUB.B    #3,D0             Subtract 3 from record length 
00001360  1400                     457           MOVE.B   D0,D2             Save byte count in D2 
00001362  4280                     458           CLR.L    D0                Clear address accumulator 
00001364  611C                     459           BSR.S    LOAD8             Get MS byte of load address 
00001366  E180                     460           ASL.L    #8,D0             Move it to MS position 
00001368  6118                     461           BSR.S    LOAD8             Get LS byte in D2 
0000136A  2440                     462           MOVE.L   D0,A2             A2 points to destination of data 
0000136C  6114                     463  LOAD7    BSR.S    LOAD8             Get byte of data for loading 
0000136E  14C0                     464           MOVE.B   D0,(A2)+          Store it 
00001370  5302                     465           SUB.B    #1,D2             Decrement byte counter 
00001372  66F8                     466           BNE      LOAD7             Repeat until count = 0 
00001374  610C                     467           BSR.S    LOAD8             Read checksum 
00001376  5203                     468           ADD.B    #1,D3             Add 1 to total checksum 
00001378  6700 FF78                469           BEQ      LOAD2             If zero then start next record 
0000137C  8E3C 0008                470           OR.B     #%00001000,D7     Else set checksum error bit, 
00001380  608A                     471           BRA      LOAD3             restore I/O devices and return 
00001382                           472  * 
00001382  6100 FE2A                473  LOAD8    BSR     BYTE               Get a byte 
00001386  D600                     474           ADD.B   D0,D3              Update checksum 
00001388  4E75                     475           RTS                         and return 
0000138A                           476  * 
0000138A                           477  ************************************************************************* 
0000138A                           478  * 
0000138A                           479  *  DUMP   Transmit S1 formatted records to host computer 
0000138A                           480  *         A3 = Starting address of data block 
0000138A                           481  *         A2 = End address of data block 
0000138A                           482  *         D1 = Checksum, D2 = current record length 
0000138A                           483  * 
0000138A  6100 0096                484  DUMP     BSR      RANGE             Get start and end address 
0000138E  4A07                     485           TST.B    D7                Test for input error 
00001390  6708                     486           BEQ.S    DUMP1             If no error then continue 
00001392  49FA 09E7                487           LEA.L    ERMES1(PC),A4     Else point to error message, 
00001396  6000 FCFE                488           BRA      PSTRING           print it and return 
0000139A  B08B                     489  DUMP1    CMP.L    A3,D0             Compare start and end addresses 
0000139C  6A08                     490           BPL.S    DUMP2             If positive then start < end 
0000139E  49FA 0B7A                491           LEA.L    ERMES7(PC),A4     Else print error message 
000013A2  6000 FCF2                492           BRA      PSTRING           and return 
000013A6  2F2E 0456                493  DUMP2    MOVE.L   CN_OVEC(A6),-(A7) Save name of current output device 
000013AA  2D7C 0000206C 0456       494           MOVE.L   #DCB4,CN_OVEC(A6) Set up Port 2 as output device 
000013B2  6100 FCD2                495           BSR      NEWLINE           Send newline to host and wait 
000013B6  617A                     496           BSR.S    DELAY 
000013B8  286E 0444                497           MOVE.L   BUFFPT(A6),A4     Before dumping, send any string 
000013BC  101C                     498  DUMP3    MOVE.B   (A4)+,D0          in the input buffer to the host 
000013BE  6100 01A4                499           BSR      PUTCHAR           Repeat 
000013C2  B03C 000D                500           CMP.B    #CR,D0            Transmit char from buffer to host 
000013C6  66F4                     501           BNE      DUMP3             Until char = C/R 
000013C8  6100 FCBC                502           BSR      NEWLINE 
000013CC  6164                     503           BSR.S    DELAY             Allow time for host to settle 
000013CE  528A                     504           ADDQ.L   #1,A2             A2 contains length of record + 1 
000013D0  240A                     505  DUMP4    MOVE.L   A2,D2             D2 points to end address 
000013D2  948B                     506           SUB.L    A3,D2             D2 contains bytes left to print 
000013D4  B4BC 00000011            507           CMP.L    #17,D2            If this is not a full record of 16 
000013DA  6502                     508           BCS.S    DUMP5             then load D2 with record size 
000013DC  7410                     509           MOVEQ    #16,D2            Else preset byte count to 16 
000013DE  49FA 08B1                510  DUMP5    LEA.L    HEADER(PC),A4     Point to record header 
000013E2  6100 FCB2                511           BSR      PSTRING           Print header 
000013E6  4201                     512           CLR.B    D1                Clear checksum 
000013E8  1002                     513           MOVE.B   D2,D0             Move record length to output register 
000013EA  5600                     514           ADD.B    #3,D0             Length includes address + count 
000013EC  612E                     515           BSR.S    DUMP7             Print number of bytes in record 
000013EE  200B                     516           MOVE.L   A3,D0             Get start address to be printed 
000013F0  E158                     517           ROL.W    #8,D0             Get MS byte in LS position 
000013F2  6128                     518           BSR.S    DUMP7             Print MS byte of address 
000013F4  E058                     519           ROR.W    #8,D0             Restore LS byte 
000013F6  6124                     520           BSR.S    DUMP7             Print LS byte of address 
000013F8  101B                     521  DUMP6    MOVE.B   (A3)+,D0          Get data byte to be printed 
000013FA  6120                     522           BSR.S    DUMP7             Print it 
000013FC  5302                     523           SUB.B    #1,D2             Decrement byte count 
000013FE  66F8                     524           BNE      DUMP6             Repeat until all this record printed 
00001400  4601                     525           NOT.B    D1                Complement checksum 
00001402  1001                     526           MOVE.B   D1,D0             Move to output register 
00001404  6116                     527           BSR.S    DUMP7             Print checksum 
00001406  6100 FC7E                528           BSR      NEWLINE 
0000140A  B7CA                     529           CMP.L    A2,A3             Have all records been printed? 
0000140C  66C2                     530           BNE      DUMP4             Repeat until all done 
0000140E  49FA 0887                531           LEA.L    TAIL(PC),A4       Point to message tail (S9 record) 
00001412  6100 FC82                532           BSR      PSTRING           Print it 
00001416  2D5F 0456                533           MOVE.L   (A7)+,CN_OVEC(A6) Restore name of output device 
0000141A  4E75                     534           RTS                        and return 
0000141C                           535  * 
0000141C  D200                     536  DUMP7    ADD.B    D0,D1             Update checksum, transmit byte 
0000141E  6000 FE08                537           BRA      OUT2X             to host and return 
00001422                           538  * 
00001422  =00001422                539  RANGE    EQU      *                 Get the range of addresses to be 
00001422  4207                     540           CLR.B    D7                transmitted from the buffer 
00001424  6100 FDA4                541           BSR      PARAM             Get starting address 
00001428  2640                     542           MOVE.L   D0,A3             Set up start address in A3 
0000142A  6100 FD9E                543           BSR      PARAM             Get end address 
0000142E  2440                     544           MOVE.L   D0,A2             Set up end address in A2 
00001430  4E75                     545           RTS 
00001432                           546  * 
00001432  =00001432                547  DELAY    EQU       *                Provide a time delay for the host 
00001432  48E7 8008                548           MOVEM.L   D0/A4,-(A7)      to settle. Save working registers 
00001436  203C 00004000            549           MOVE.L    #$4000,D0        Set up delay constant 
0000143C  5380                     550  DELAY1   SUB.L     #1,D0            Count down         (8 clk cycles) 
0000143E  66FC                     551           BNE       DELAY1           Repeat until zero  (10 clk cycles) 
00001440  4CDF 1001                552           MOVEM.L   (A7)+,D0/A4      Restore working registers 
00001444  4E75                     553           RTS 
00001446                           554  * 
00001446                           555  ************************************************************************* 
00001446                           556  * 
00001446                           557  *  TM  Enter transparant mode (All communication to go from terminal to 
00001446                           558  *  the host processor until escape sequence entered). End sequence 
00001446                           559  *  = ESC, E. A newline is sent to the host to "clear it down". 
00001446                           560  * 
00001446  13FC 0055 00008001       561  TM       MOVE.B    #$55,ACIA_1      Force RTS* high to re-route data 
0000144E  522E 044C                562           ADD.B     #1,ECHO(A6)      Turn off character echo 
00001452  6100 00E0                563  TM1      BSR       GETCHAR          Get character 
00001456  B03C 001B                564           CMP.B     #ESC,D0          Test for end of TM mode 
0000145A  66F6                     565           BNE       TM1              Repeat until first escape character 
0000145C  6100 00D6                566           BSR       GETCHAR          Get second character 
00001460  B03C 0045                567           CMP.B     #'E',D0          If second char = E then exit TM 
00001464  66EC                     568           BNE       TM1              Else continue 
00001466  2F2E 0456                569           MOVE.L    CN_OVEC(A6),-(A7) Save output port device name 
0000146A  2D7C 0000206C 0456       570           MOVE.L    #DCB4,CN_OVEC(A6) Get name of host port (aux port) 
00001472  6100 FC12                571           BSR       NEWLINE          Send newline to host to clear it 
00001476  2D5F 0456                572           MOVE.L    (A7)+,CN_OVEC(A6) Restore output device port name 
0000147A  422E 044C                573           CLR.B     ECHO(A6)         Restore echo mode 
0000147E  13FC 0015 00008001       574           MOVE.B    #$15,ACIA_1      Restore normal ACIA mode (RTS* low) 
00001486  4E75                     575           RTS 
00001488                           576  * 
00001488                           577  ************************************************************************* 
00001488                           578  * 
00001488                           579  *  This routine sets up the system DCBs in RAM using the information 
00001488                           580  *  stored in ROM at address DCB_LST. This is called at initialization. 
00001488                           581  *  CN_IVEC contains the name "DCB1" and IO_VEC the name "DCB2" 
00001488                           582  * 
00001488  48E7 F0F0                583  SET_DCB  MOVEM.L A0-A3/D0-D3,-(A7) Save all working registers 
0000148C  41EE 04D4                584           LEA.L   FIRST(A6),A0    Pointer to first DCB destination in RAM 
00001490  43FA 0BA4                585           LEA.L   DCB_LST(PC),A1  A1 points to DCB info block in ROM 
00001494  303C 0005                586           MOVE.W  #5,D0           6 DCBs to set up 
00001498  323C 000F                587  ST_DCB1  MOVE.W  #15,D1          16 bytes to move per DCB header 
0000149C  10D9                     588  ST_DCB2  MOVE.B  (A1)+,(A0)+     Move the 16 bytes of a DCB header 
0000149E  51C9 FFFC                589           DBRA    D1,ST_DCB2      from ROM to RAM 
000014A2  3619                     590           MOVE.W  (A1)+,D3        Get size of parameter block (bytes) 
000014A4  3083                     591           MOVE.W  D3,(A0)         Store size in DCB in RAM 
000014A6  41F0 3002                592           LEA.L   2(A0,D3.W),A0   A0 points to tail of DCB in RAM 
000014AA  47E8 0004                593           LEA.L   4(A0),A3        A3 contains address of next DCB in RAM 
000014AE  208B                     594           MOVE.L  A3,(A0)         Store pointer to next DCB in this DCB 
000014B0  41D3                     595           LEA.L   (A3),A0         A0 now points at next DCB in RAM 
000014B2  51C8 FFE4                596           DBRA    D0,ST_DCB1      Repeat until all DCBs set up 
000014B6  47EB FFFC                597           LEA.L   -4(A3),A3       Adjust A3 to point to last DCB pointer 
000014BA  4293                     598           CLR.L   (A3)            and force last pointer to zero 
000014BC  2D7C 00002036 0452       599           MOVE.L  #DCB1,CN_IVEC(A6) Set up vector to console input DCB 
000014C4  2D7C 00002048 0456       600           MOVE.L  #DCB2,CN_OVEC(A6) Set up vector to console output DCB 
000014CC  4CDF 0F0F                601           MOVEM.L (A7)+,A0-A3/D0-D3 Restore registers 
000014D0  4E75                     602           RTS 
000014D2                           603  * 
000014D2                           604  ************************************************************************* 
000014D2                           605  * 
000014D2                           606  *  IO_REQ handles all input/output transactions. A0 points to DCB on 
000014D2                           607  *  entry. IO_REQ calls the device driver whose address is in the DCB. 
000014D2                           608  * 
000014D2  48E7 00C0                609  IO_REQ   MOVEM.L A0-A1,-(A7)     Save working registers 
000014D6  43E8 0008                610           LEA.L   8(A0),A1        A1 points to device handler field in DCB 
000014DA  2251                     611           MOVE.L  (A1),A1         A1 contains device handler address 
000014DC  4E91                     612           JSR     (A1)            Call device handler 
000014DE  4CDF 0300                613           MOVEM.L (A7)+,A0-A1     Restore working registers 
000014E2  4E75                     614           RTS 
000014E4                           615  * 
000014E4                           616  ************************************************************************* 
000014E4                           617  * 
000014E4                           618  *  CON_IN handles input from the console device 
000014E4                           619  *  Exit with input in D0 
000014E4                           620  * 
000014E4  48E7 4000                621  CON_IN   MOVEM.L D1,-(A7)         Save working registers 
000014E8  4228 0013                622      CLR.B    19(A0)
000014EC  103C 0005                623           MOVE.B    #5,D0             Read input from ACIA
000014F0  4E4F                     624      TRAP     #15
000014F2  1001                     625      MOVE.B  D1,D0
000014F4  4CDF 0002                626           MOVEM.L (A7)+,D1     `   Restore working registers 
000014F8  4E75                     627           RTS 
000014FA                           628  * 
000014FA                           629  ************************************************************************* 
000014FA                           630  * 
000014FA                           631  *   This is the CON_OUT device driver. Output in D0  
000014FA                           632  * 
000014FA  48E7 4000                633  CON_OUT  MOVEM.L D1,-(A7)  Save working registers 
000014FE  4228 0013                634      CLR.B    19(A0)
00001502  1200                     635           MOVE.B    D0,D1
00001504  103C 0006                636           MOVE.B    #6,D0
00001508  4E4F                     637           TRAP   #15
0000150A  4CDF 0002                638           MOVEM.L (A7)+,D1  Restore working registers 
0000150E  4E75                     639           RTS 
00001510                           640  * 
00001510                           641  ************************************************************************* 
00001510                           642  * 
00001510                           643  *  AUX_IN and AUX_OUT are simplified versions of CON_IN and 
00001510                           644  *  CON_OUT for use with the port to the host processor 
00001510                           645  * 
00001510  43E8 000C                646  AUX_IN   LEA.L   12(A0),A1       Get pointer to aux ACIA from DCB 
00001514  2251                     647           MOVE.L  (A1),A1         Get address of aux ACIA 
00001516  0811 0000                648  AUX_IN1  BTST.B  #0,(A1)         Test for data ready 
0000151A  67FA                     649           BEQ     AUX_IN1         Repeat until ready 
0000151C  1029 0002                650           MOVE.B  2(A1),D0        Read input 
00001520  4E75                     651           RTS 
00001522                           652  * 
00001522  43E8 000C                653  AUX_OUT  LEA.L   12(A0),A1       Get pointer to aux ACIA from DCB 
00001526  2251                     654           MOVE.L  (A1),A1         Get address of aux ACIA 
00001528  0811 0001                655  AUX_OT1  BTST.B  #1,(A1)         Test for ready to transmit 
0000152C  67FA                     656           BEQ     AUX_OT1         Repeat until transmitter ready 
0000152E  1340 0002                657           MOVE.B  D0,2(A1)        Transmit data 
00001532  4E75                     658           RTS 
00001534                           659  * 
00001534                           660  ************************************************************************* 
00001534                           661  * 
00001534                           662  *  GETCHAR gets a character from the console device 
00001534                           663  *  This is the main input routine and uses the device whose name  
00001534                           664  *  is stored in CN_IVEC. Changing this name redirects input. 
00001534                           665  * 
00001534  2F08                     666  GETCHAR  MOVE.L  A0,-(A7)        Save working register 
00001536  206E 0452                667           MOVE.L  CN_IVEC(A6),A0  A0 points to name of console DCB 
0000153A  6156                     668           BSR.S   IO_OPEN         Open console (get DCB address in A0) 
0000153C  0807 0003                669           BTST    #3,D7           D7(3) set if open error 
00001540  661E                     670           BNE.S   GETCH3          If error then exit now 
00001542  618E                     671           BSR     IO_REQ          Else execute I/O transaction 
00001544  C03C 007F                672           AND.B   #$7F,D0         Strip msb of input 
00001548  4A2E 044D                673           TST.B   U_CASE(A6)      Test for upper -> lower case conversion 
0000154C  660A                     674           BNE.S   GETCH2          If flag not zero do not convert case 
0000154E  0800 0006                675           BTST    #6,D0             Test input for lower case 
00001552  6704                     676           BEQ.S   GETCH2          If upper case then skip conversion 
00001554  C03C 00DF                677           AND.B   #%11011111,D0   Else clear bit 5 for upper case conv 
00001558  4A2E 044C                678  GETCH2   TST.B   ECHO(A6)        Do we need to echo the input? 
0000155C  6602                     679           BNE.S   GETCH3          If ECHO not zero then no echo 
0000155E  6104                     680           BSR.S   PUTCHAR         Else echo the input 
00001560  205F                     681  GETCH3   MOVE.L  (A7)+,A0        Restore working register 
00001562  4E75                     682           RTS                     and return 
00001564                           683  * 
00001564                           684  ************************************************************************* 
00001564                           685  * 
00001564                           686  *  PUTCHAR sends a character to the console device 
00001564                           687  *  The name of the output device is in CN_OVEC. 
00001564                           688  * 
00001564  BC3C 0001                689  PUTCHAR  CMP.B   #1,D6
00001568                           690           *BEQ     PUTASK
00001568  2F08                     691           MOVE.L  A0,-(A7)        Save working register
0000156A  206E 0456                692           MOVE.L  CN_OVEC(A6),A0  A0 points to name of console output 
0000156E  6122                     693           BSR.S   IO_OPEN         Open console (Get address of DCB) 
00001570  6100 FF60                694           BSR     IO_REQ          Perform output with DCB pointed at by A0 
00001574  205F                     695           MOVE.L  (A7)+,A0        Restore working register 
00001576  4E75                     696           RTS 
00001578                           697  
00001578                           698  *PUTASK   MOVE    D0,-(A5)
00001578                           699  *         MOVE    #'*',D0
00001578                           700  *         MOVE.L  A0,-(A7)        Save working register
00001578                           701  *         MOVE.L  CN_OVEC(A6),A0  A0 points to name of console output 
00001578                           702  *         BSR.S   IO_OPEN         Open console (Get address of DCB) 
00001578                           703  *         BSR     IO_REQ          Perform output with DCB pointed at by A0 
00001578                           704  *         MOVE.L  (A7)+,A0        Restore working register
00001578                           705  *         MOVE    (A5)+,D0
00001578                           706  *         RTS 
00001578                           707  * 
00001578                           708  ************************************************************************* 
00001578                           709  * 
00001578                           710  *  BUFF_IN and BUFF_OUT are two rudimentary input and output routines 
00001578                           711  *  which input data from and output data to a buffer in RAM. These are 
00001578                           712  *  used by DCB5 and DCB6, respectively. 
00001578                           713  * 
00001578  43E8 000C                714  BUFF_IN  LEA.L   12(A0),A1       A1 points to I/P buffer 
0000157C  2451                     715           MOVE.L  (A1),A2         A2 gets I/P pointer from buffer 
0000157E  1022                     716           MOVE.B  -(A2),D0        Read char from buffer and adjust A2 
00001580  228A                     717           MOVE.L  A2,(A1)         Restore pointer in buffer 
00001582  4E75                     718           RTS 
00001584                           719  * 
00001584  43E8 000C                720  BUFF_OT  LEA.L   12(A0),A1       A1 points to O/P buffer 
00001588  2469 0004                721           MOVE.L  4(A1),A2        A2 gets O/P pointer from buffer 
0000158C  14C0                     722           MOVE.B  D0,(A2)+        Store char in buffer and adjust A2 
0000158E  228A                     723           MOVE.L  A2,(A1)         Restore pointer in buffer 
00001590  4E75                     724           RTS 
00001592                           725  * 
00001592                           726  ************************************************************************* 
00001592                           727  * 
00001592                           728  *  Open - opens a DCB for input or output. IO_OPEN converts the 
00001592                           729  *  name pointed at by A0 into the address of the DCB pointed at 
00001592                           730  *  by A0. Bit 3 of D7 is set to zero if DCB not found 
00001592                           731  * 
00001592  48E7 F870                732  IO_OPEN  MOVEM.L  A1-A3/D0-D4,-(A7) Save working registers 
00001596  43EE 04D4                733           LEA.L    FIRST(A6),A1   A1 points to first DCB in chain in RAM 
0000159A  45D1                     734  OPEN1    LEA.L    (A1),A2        A2 = temp copy of pointer to DCB 
0000159C  47D0                     735           LEA.L    (A0),A3        A3 = temp copy of pointer to DCB name 
0000159E  303C 0007                736           MOVE.W   #7,D0          Up to 8 chars of DCB name to match 
000015A2  181A                     737  OPEN2    MOVE.B   (A2)+,D4       Compare DCB name with string 
000015A4  B81B                     738           CMP.B    (A3)+,D4 
000015A6  6608                     739           BNE.S    OPEN3          If no match try next DCB 
000015A8  51C8 FFF8                740           DBRA     D0,OPEN2       Else repeat until all chars matched 
000015AC  41D1                     741           LEA.L    (A1),A0        Success - move this DCB address to A0 
000015AE  6016                     742           BRA.S    OPEN4          and return 
000015B0  =000015B0                743  OPEN3    EQU      *              Fail - calculate address of next DCB 
000015B0  3229 0010                744           MOVE.W   16(A1),D1      Get parameter block size of DCB 
000015B4  43F1 1012                745           LEA.L    18(A1,D1.W),A1 A1 points to pointer to next DCB 
000015B8  2251                     746           MOVE.L   (A1),A1        A1 now points to next DCB 
000015BA  B3FC 00000000            747           CMP.L    #0,A1          Test for end of DCB chain 
000015C0  66D8                     748           BNE      OPEN1          If not end of chain then try next DCB 
000015C2  8E3C 0008                749           OR.B     #8,D7          Else set error flag and return 
000015C6  4CDF 0E1F                750  OPEN4    MOVEM.L  (A7)+,A1-A3/D0-D4 Restore working registers 
000015CA  4E75                     751           RTS 
000015CC                           752  * 
000015CC                           753  ************************************************************************* 
000015CC                           754  * 
000015CC                           755  *  Exception vector table initialization routine 
000015CC                           756  *  All vectors not setup are loaded with uninitialized routine vector 
000015CC                           757  * 
000015CC  303C 0007                758  X_SET   MOVE.W  #7,D0             Now clear the breakpoint table 
000015D0  41EE 04A4                759          LEA.L   BP_TAB(A6),A0     Point to table 
000015D4  4298                     760  X_SET2  CLR.L   (A0)+             Clear an address entry 
000015D6  4258                     761          CLR.W   (A0)+             Clear the corresponding data 
000015D8  51C8 FFFA                762          DBRA    D0,X_SET2         Repeat until all 8 cleared 
000015DC  4E75                     763          RTS 
000015DE                           764  * 
000015DE                           765  *************************************************************************
000015DE  DA04                     766  ADD_0   ADD.B     D4,D5
000015E0  1605                     767          MOVE.B    D5,D3
000015E2  183C 0000                768          MOVE.B    #0,D4           resetting neg flag
000015E6  6B00 0040                769          BMI       SETNEG
000015EA  4E75                     770          RTS
000015EC                           771  
000015EC  9A04                     772  SUB_0   SUB.B     D4,D5
000015EE  183C 0000                773          MOVE.B    #0,D4           resetting neg flag
000015F2  1605                     774          MOVE.B    D5,D3
000015F4  6B00 0032                775          BMI       SETNEG
000015F8  4E75                     776          RTS
000015FA                           777          
000015FA  CBC4                     778  MUL_0   MULS      D4,D5
000015FC  383C 0000                779          MOVE.W    #0,D4           resetting neg flag
00001600  2605                     780          MOVE.L    D5,D3
00001602  6B00 0034                781          BMI       MULNEG
00001606  4E75                     782          RTS
00001608                           783  
00001608  8BC4                     784  DIV_0   DIVS      D4,D5
0000160A  183C 0000                785          MOVE.B    #0,D4           resetting neg flag
0000160E  1605                     786          MOVE.B    D5,D3
00001610  4603                     787          NOT.B     D3
00001612  C63C 007F                788          AND.B     #%01111111,D3
00001616  5203                     789          ADD.B     #1,D3
00001618  BA7C 007F                790          CMP.W     #127,D5
0000161C  6500 0004                791          BCS       DIVNEG
00001620  4E75                     792          RTS
00001622                           793  
00001622  183C 0001                794  DIVNEG  MOVE.B    #1,D4
00001626  4E75                     795          RTS
00001628                           796  
00001628  183C 00FF                797  SETNEG  MOVE.B    #255,D4
0000162C  9803                     798          SUB.B     D3,D4
0000162E  1604                     799          MOVE.B    D4,D3
00001630  5203                     800          ADD.B     #1,D3
00001632  183C 0001                801          MOVE.B    #1,D4
00001636  4E75                     802          RTS
00001638                           803  
00001638  183C 0001                804  MULNEG  MOVE.B    #1,D4
0000163C  4683                     805          NOT.L     D3
0000163E  C6BC 7FFFFFFF            806          AND.L     #%01111111111111111111111111111111,D3
00001644  5203                     807          ADD.B     #1,D3
00001646  4E75                     808          RTS
00001648                           809  
00001648                           810  * 
00001648                           811  ************************************************************************* 
00001648                           812  * 
00001648  =00001648                813  TRAP_0  EQU     *                 User links to  TS2BUG via TRAP #0 
00001648  B23C 0000                814          CMP.B   #0,D1             D1 = 0 = Get character 
0000164C  6606                     815          BNE.S   FOO1           
0000164E  6100 FEE4                816          BSR     GETCHAR 
00001652  4E73                     817          RTE 
00001654  B23C 0001                818  FOO1    CMP.B   #1,D1             D1 = 1 = Print character 
00001658  6606                     819          BNE.S   FOO2 
0000165A  6100 FF08                820          BSR     PUTCHAR 
0000165E  4E73                     821          RTE 
00001660  B23C 0002                822  FOO2    CMP.B   #2,D1             D1 = 2 = Newline 
00001664  6606                     823          BNE.S   FOO3 
00001666  6100 FA1E                824          BSR     NEWLINE 
0000166A  4E73                     825          RTE 
0000166C  B23C 0003                826  FOO3    CMP.B   #3,D1             D1 = 3 = Get parameter from buffer 
00001670  6606                     827          BNE.S   FOO4 
00001672  6100 FB56                828          BSR     PARAM 
00001676  4E73                     829          RTE 
00001678  B23C 0004                830  FOO4    CMP.B   #4,D1             D1 = 4 = Print string pointed at by A4 
0000167C  6606                     831          BNE.S   FOO5 
0000167E  6100 FA16                832          BSR     PSTRING 
00001682  4E73                     833          RTE 
00001684  B23C 0005                834  FOO5    CMP.B   #5,D1             D1 = 5 = Get a hex character 
00001688  6606                     835          BNE.S   FOO6 
0000168A  6100 FB04                836          BSR     HEX 
0000168E  4E73                     837          RTE 
00001690  B23C 0006                838  FOO6    CMP.B   #6,D1             D1 = 6 = Get a hex byte 
00001694  6606                     839          BNE.S   FOO7 
00001696  6100 FB16                840          BSR     BYTE 
0000169A  4E73                     841          RTE 
0000169C  B23C 0007                842  FOO7    CMP.B   #7,D1             D1 = 7 = Get a word 
000016A0  6606                     843          BNE.S   FOO8 
000016A2  6100 FB1A                844          BSR     WORD 
000016A6  4E73                     845          RTE 
000016A8  B23C 0008                846  FOO8    CMP.B   #8,D1             D1 = 8 = Get a longword 
000016AC  6606                     847          BNE.S   FOO9 
000016AE  6100 FB14                848          BSR     LONGWD 
000016B2  4E73                     849          RTE 
000016B4  B23C 0009                850  FOO9    CMP.B   #9,D1             D1 = 9 = Output hex byte 
000016B8  6606                     851          BNE.S   FOO10  
000016BA  6100 FB6C                852          BSR     OUT2X 
000016BE  4E73                     853          RTE 
000016C0  B23C 000A                854  FOO10   CMP.B   #10,D1            D1 = 10 = Output hex word 
000016C4  6606                     855          BNE.S   FOO11 
000016C6  6100 FB68                856          BSR     OUT4X 
000016CA  4E73                     857          RTE 
000016CC  B23C 000B                858  FOO11   CMP.B   #11,D1            D1 = 11 = Output hex longword 
000016D0  6606                     859          BNE.S   FOO12 
000016D2  6100 FB64                860          BSR     OUT8X 
000016D6  4E73                     861          RTE 
000016D8  B23C 000C                862  FOO12   CMP.B   #12,D1            D1 = 12 = Print a space 
000016DC  6606                     863          BNE.S   FOO13 
000016DE  6100 FBC8                864          BSR     PSPACE 
000016E2  4E73                     865          RTE 
000016E4  B23C 000D                866  FOO13   CMP.B   #13,D1            D1 = 13 = Get a line of text into 
000016E8  6606                     867          BNE.S   FOO14            the line buffer 
000016EA  6100 F9C0                868          BSR     GETLINE 
000016EE  4E73                     869          RTE 
000016F0  B23C 000E                870  FOO14   CMP.B   #14,D1            D1 = 14 = Tidy up the line in the 
000016F4  6606                     871          BNE.S   FOO15            line buffer by removing leading 
000016F6  6100 F9EA                872          BSR     TIDY              leading and multiple embeded spaces 
000016FA  4E73                     873          RTE 
000016FC  B23C 000F                874  FOO15   CMP.B   #15,D1            D1 = 15 = Execute the command in 
00001700  6606                     875          BNE.S   FOO16            the line buffer 
00001702  6100 FA20                876          BSR     EXECUTE 
00001706  4E73                     877          RTE 
00001708  B23C 0010                878  FOO16   CMP.B   #16,D1            D1 = 16 = Call RESTORE to transfer 
0000170C  6606                     879          BNE.S   FOO17            the registers in TSK_T to the 68000 
0000170E  6100 035C                880          BSR     RESTORE           and therefore execute a program 
00001712  4E73                     881          RTE 
00001714  B23C 0011                882  FOO17   CMP.B   #17,D1            D1 = 17 = Call ADD_0
00001718  6606                     883          BNE.S   FOO18            
0000171A  6100 FEC2                884          BSR     ADD_0            
0000171E  4E73                     885          RTE 
00001720  B23C 0012                886  FOO18   CMP.B   #18,D1            D1 = 18 = Call SUB_0
00001724  6606                     887          BNE.S   FOO19            
00001726  6100 FEC4                888          BSR     SUB_0            
0000172A  4E73                     889          RTE 
0000172C  B23C 0013                890  FOO19   CMP.B   #19,D1            D1 = 19 = Call MUL_0
00001730  6606                     891          BNE.S   FOO20            
00001732  6100 FEC6                892          BSR     MUL_0            
00001736  4E73                     893          RTE 
00001738  B23C 0014                894  FOO20   CMP.B   #20,D1            D1 = 20 = Call DIV_0
0000173C  6606                     895          BNE.S   FOO21            
0000173E  6100 FEC8                896          BSR     DIV_0            
00001742  4E73                     897          RTE
00001744  4E73                     898  FOO21   RTE         
00001746                           899  * 
00001746                           900  
00001746                           901  ************************************************************************* 
00001746                           902  * 
00001746                           903  *  Display exception frame (D0 - D7, A0 - A6, USP, SSP, SR, PC) 
00001746                           904  *  EX_DIS prints registers saved after a breakpoint or exception 
00001746                           905  *  The registers are saved in TSK_T 
00001746                           906  * 
00001746  4BEE 045A                907  EX_DIS  LEA.L   TSK_T(A6),A5      A5 points to display frame 
0000174A  49FA 056C                908          LEA.L   MES3(PC),A4       Point to heading 
0000174E  6100 F956                909          BSR     HEADING           and print it 
00001752  3C3C 0007                910          MOVE.W  #7,D6             8 pairs of registers to display 
00001756  4205                     911          CLR.B   D5                D5 is the line counter 
00001758  1005                     912  EX_D1   MOVE.B  D5,D0             Put current register number in D0 
0000175A  6100 FAB2                913          BSR     OUT1X             and print it 
0000175E  6100 FB48                914          BSR     PSPACE            and a space 
00001762  5205                     915          ADD.B   #1,D5             Update counter for next pair 
00001764  2015                     916          MOVE.L  (A5),D0           Get data register to be displayed 
00001766  6100 FAD0                917          BSR     OUT8X             from the frame and print it 
0000176A  49FA 056A                918          LEA.L   MES4(PC),A4       Print string of spaces 
0000176E  6100 F926                919          BSR.L   PSTRING           between data and address registers 
00001772  202D 0020                920          MOVE.L  32(A5),D0         Get address register to be displayed 
00001776  6100 FAC0                921          BSR     OUT8X             which is 32 bytes on from data reg 
0000177A  6100 F90A                922          BSR     NEWLINE 
0000177E  4BED 0004                923          LEA.L   4(A5),A5          Point to next pair (ie Di, Ai) 
00001782  51CE FFD4                924          DBRA    D6,EX_D1          Repeat until all displayed 
00001786  4BED 0020                925          LEA.L   32(A5),A5         Adjust pointer by 8 longwords 
0000178A  6100 F8FA                926          BSR     NEWLINE           to point to SSP 
0000178E  49FA 051F                927          LEA.L   MES2A(PC),A4      Point to "SS =" 
00001792  6100 F902                928          BSR     PSTRING           Print it 
00001796  201D                     929          MOVE.L  (A5)+,D0          Get SSP from frame 
00001798  6100 FA9E                930          BSR     OUT8X             and display it 
0000179C  6100 F8E8                931          BSR     NEWLINE 
000017A0  49FA 04FB                932          LEA.L   MES1(PC),A4       Point to 'SR =' 
000017A4  6100 F8F0                933          BSR     PSTRING           Print it 
000017A8  301D                     934          MOVE.W  (A5)+,D0          Get status register 
000017AA  6100 FA84                935          BSR     OUT4X             Display status 
000017AE  6100 F8D6                936          BSR     NEWLINE 
000017B2  49FA 04F2                937          LEA.L   MES2(PC),A4       Point to 'PC =' 
000017B6  6100 F8DE                938          BSR     PSTRING           Print it 
000017BA  201D                     939          MOVE.L  (A5)+,D0          Get PC 
000017BC  6100 FA7A                940          BSR     OUT8X             Display PC 
000017C0  6000 F8C4                941          BRA     NEWLINE           Newline and return 
000017C4                           942  * 
000017C4                           943  ************************************************************************* 
000017C4  49F9 00001DFB            944  HELP     LEA.L    JUMPHELP,A4
000017CA  6100 F8CA                945           BSR.W    PSTRING
000017CE  6100 F8B6                946           BSR.W    NEWLINE
000017D2  49F9 00001E31            947           LEA.L    MEMHELP,A4
000017D8  6100 F8BC                948           BSR.W    PSTRING
000017DC  6100 F8A8                949           BSR.W    NEWLINE
000017E0  49F9 00001E7E            950           LEA.L    LOADHELP,A4
000017E6  6100 F8AE                951           BSR.W    PSTRING
000017EA  6100 F89A                952           BSR.W    NEWLINE
000017EE  49F9 00001EC8            953           LEA.L    TVHELP,A4
000017F4  6100 F8A0                954           BSR.W    PSTRING
000017F8  4E75                     955           RTS
000017FA                           956  *      
000017FA                           957  *************************************************************************
000017FA  B83C 0003                958  LOGIN    CMP.B    #3,D4
000017FE  6700 00C2                959           BEQ      QUIT
00001802  49F9 00001F35            960           LEA.L    LOGINM1,A4
00001808  6100 F88C                961           BSR.W    PSTRING           
0000180C  6100 F878                962           BSR.W    NEWLINE
00001810  6100 F89A                963           BSR      GETLINE
00001814  49F9 00001F27            964           LEA.L    UNAME,A4
0000181A  1A19                     965  LOGIN1   MOVE.B   (A1)+,D5
0000181C  BA1C                     966           CMP.B    (A4)+,D5
0000181E  67FA                     967           BEQ      LOGIN1            iterate through checking each char
00001820  0C21 000D                968           CMP.B    #CR,-(A1)         check for carriage return
00001824  6600 006A                969           BNE      WRONG             if not then wrong input
00001828  0C24 0000                970           CMP.B    #NUL,-(A4)        check for end of stored string
0000182C  6600 0062                971           BNE      WRONG             if not then wrong input
00001830  49F9 00001F6A            972           LEA.L    USRSUC,A4         print success
00001836  6100 F85E                973           BSR.W    PSTRING
0000183A  6100 F84A                974           BSR.W    NEWLINE
0000183E  49F9 00001F46            975           LEA.L    LOGINM2,A4
00001844  6100 F850                976           BSR.W    PSTRING
00001848  6100 F83C                977           BSR.W    NEWLINE
0000184C  1C3C 0001                978           MOVE.B   #1,D6
00001850  6100 F85A                979           BSR.W    GETLINE
00001854  1C3C 0000                980           MOVE.B   #0,D6
00001858  49F9 00001F2C            981           LEA.L    PWORD,A4
0000185E  1A19                     982  LOGIN2   MOVE.B   (A1)+,D5
00001860  BA1C                     983           CMP.B    (A4)+,D5
00001862  67FA                     984           BEQ      LOGIN2            iterate through checking each char
00001864  0C21 000D                985           CMP.B    #CR,-(A1)          check for carriage return
00001868  6600 0026                986           BNE      WRONG             if not then wrong input
0000186C  0C24 0000                987           CMP.B    #NUL,-(A4)            check for end of stored string
00001870  6600 0032                988           BNE      WRONGPW             if not then wrong input
00001874  49F9 00001F8E            989           LEA.L    PWSUC,A4
0000187A  6000 F81A                990           BRA      PSTRING
0000187E  49F9 00001F35            991           LEA.L    LOGINM1,A4
00001884  6100 F810                992           BSR.W    PSTRING           print success
00001888  6100 F7FC                993           BSR.W    NEWLINE
0000188C  6000 F7E8                994           BRA      WARM
00001890                           995  
00001890  49F9 00001F57            996  WRONG    LEA.L    USRERR,A4   
00001896  6100 F7FE                997           BSR.W    PSTRING
0000189A  6100 F7EA                998           BSR.W    NEWLINE
0000189E  5204                     999           ADD.B    #1,D4
000018A0  6000 FF58               1000           BRA      LOGIN
000018A4                          1001  
000018A4  49F9 00001F7B           1002  WRONGPW  LEA.L    PWERR,A4   
000018AA  6100 F7EA               1003           BSR.W    PSTRING
000018AE  6100 F7D6               1004           BSR.W    NEWLINE
000018B2  5204                    1005           ADD.B    #1,D4
000018B4  6000 FF44               1006           BRA      LOGIN
000018B8                          1007  
000018B8  49F9 00001F6A           1008  UPASS    LEA.L    USRSUC,A4
000018BE  6000 F7D6               1009           BRA      PSTRING  
000018C2                          1010  
000018C2  4EF8 18C2               1011  QUIT     JMP      QUIT
000018C6                          1012  *
000018C6                          1013  ************************************************************************* 
000018C6  2878 07D4               1014  TV       MOVE.L   MIN_RAM,A4
000018CA  1C3C 0000               1015           MOVE.B   #0,D6
000018CE  323C 0000               1016  LOOPRAM  MOVE.W   #0,D1
000018D2  3881                    1017           MOVE.W   D1,(A4)
000018D4  49EC 0002               1018           LEA.L    2(A4),A4          Point to next address to display
000018D8  B9F8 07D8               1019           CMP.L    MAX_RAM,A4
000018DC  66F0                    1020           BNE      LOOPRAM
000018DE  2878 07D4               1021           MOVE.L   MIN_RAM,A4
000018E2  3214                    1022  CHECK1   MOVE.W   (A4),D1
000018E4  B27C 0000               1023           CMP.W    #0,D1
000018E8  6600 0042               1024           BNE      MEMFAIL
000018EC  49EC 0002               1025  CHECK2   LEA.L    2(A4),A4          Point to next address to read
000018F0  B9F8 07D8               1026           CMP.L    MAX_RAM,A4
000018F4  66EC                    1027           BNE      CHECK1
000018F6  2878 07D4               1028           MOVE.L   MIN_RAM,A4
000018FA  323C FFFF               1029  LOOPRAM1 MOVE.W   #65535,D1
000018FE  3881                    1030           MOVE.W   D1,(A4)
00001900  49EC 0002               1031           LEA.L    2(A4),A4          Point to next address to display
00001904  B9F8 07D8               1032           CMP.L    MAX_RAM,A4
00001908  66F0                    1033           BNE      LOOPRAM1
0000190A  2878 07D4               1034           MOVE.L   MIN_RAM,A4
0000190E  3214                    1035  CHECK3   MOVE.W   (A4),D1
00001910  B27C FFFF               1036           CMP.W    #65535,D1
00001914  6600 0032               1037           BNE      MEMFAIL2
00001918  49EC 0002               1038  CHECK4   LEA.L    2(A4),A4          Point to next address to read
0000191C  B9F8 07D8               1039           CMP.L    MAX_RAM,A4
00001920  66EC                    1040           BNE      CHECK3
00001922  BC3C 0000               1041           CMP.B    #0,D6
00001926  6700 003C               1042           BEQ      MEMGOOD
0000192A  4E75                    1043           RTS
0000192C                          1044  
0000192C  2F0C                    1045  MEMFAIL  MOVE.L  A4,-(A7)          Save A4 
0000192E  7C01                    1046           MOVE.L  #1,D6
00001930  6100 F754               1047           BSR.W   NEWLINE
00001934  49F9 00001F9F           1048           LEA.L   MEMFMSG,A4
0000193A  6100 F75A               1049           BSR.W   PSTRING
0000193E  285F                    1050           MOVE.L  (A7)+,A4          Restore A4
00001940  200C                    1051           MOVE.L  A4,D0
00001942  6100 F8F4               1052           BSR.W    OUT8X 
00001946  60A4                    1053           BRA     CHECK2
00001948                          1054  
00001948  2F0C                    1055  MEMFAIL2 MOVE.L  A4,-(A7)          Save A4 
0000194A  7C01                    1056           MOVE.L  #1,D6
0000194C  6100 F738               1057           BSR.W   NEWLINE
00001950  49F9 00001F9F           1058           LEA.L   MEMFMSG,A4
00001956  6100 F73E               1059           BSR.W   PSTRING
0000195A  285F                    1060           MOVE.L  (A7)+,A4          Restore A4
0000195C  200C                    1061           MOVE.L  A4,D0
0000195E  6100 F8D8               1062           BSR.W    OUT8X 
00001962  60B4                    1063           BRA     CHECK4         
00001964                          1064   
00001964  49F9 00001FAF           1065  MEMGOOD  LEA.L  MEMGMSG,A4
0000196A  6100 F72A               1066           BSR.W  PSTRING
0000196E  4E75                    1067           RTS
00001970                          1068  
00001970                          1069  *************************************************************************         
00001970                          1070  * 
00001970                          1071  *  Exception handling routines 
00001970                          1072  * 
00001970  =00001970               1073  IL_ER   EQU      *                Illegal instruction exception 
00001970  2F0C                    1074          MOVE.L  A4,-(A7)          Save A4 
00001972  49FA 038C               1075          LEA.L   MES10(PC),A4      Point to heading 
00001976  6100 F72E               1076          BSR     HEADING           Print it 
0000197A  285F                    1077          MOVE.L  (A7)+,A4          Restore A4 
0000197C  6100 009C               1078          BSR.W   GROUP2            Save registers in display frame 
00001980  6100 FDC4               1079          BSR     EX_DIS            Display registers saved in frame 
00001984  6000 F6F0               1080          BRA     WARM              Abort from illegal instruction 
00001988                          1081  * 
00001988  =00001988               1082  BUS_ER  EQU     *                 Bus error (group 1) exception 
00001988  2F0C                    1083          MOVE.L  A4,-(A7)          Save A4 
0000198A  49FA 0354               1084          LEA.L   MES8(PC),A4       Point to heading 
0000198E  6100 F716               1085          BSR     HEADING           Print it 
00001992  285F                    1086          MOVE.L  (A7)+,A4          Restore A4 
00001994  6050                    1087          BRA.S   GROUP1            Deal with group 1 exception 
00001996                          1088  * 
00001996  =00001996               1089  ADD_ER  EQU     *                 Address error (group 1) exception 
00001996  2F0C                    1090          MOVE.L  A4,-(A7)          Save A4 
00001998  49FA 0354               1091          LEA.L   MES9(PC),A4       Point to heading 
0000199C  6100 F708               1092          BSR     HEADING           Print it 
000019A0  285F                    1093          MOVE.L  (A7)+,A4          Restore A4 
000019A2  6042                    1094          BRA.S   GROUP1            Deal with group 1 exception 
000019A4                          1095  * 
000019A4  =000019A4               1096  DIV0_ER  EQU     *                   Divide By Zero Exception
000019A4  2F0C                    1097          MOVE.L  A4,-(A7)          Save A4 
000019A6  49FA 0385               1098          LEA.L   MES13(PC),A4       Point to heading 
000019AA  6100 F6FA               1099          BSR     HEADING           Print it 
000019AE  285F                    1100          MOVE.L  (A7)+,A4          Restore A4 
000019B0  6034                    1101          BRA.S   GROUP1            Deal with group 1 exception 
000019B2                          1102  *
000019B2  =000019B2               1103  PRIV_ER   EQU     *                 Privilege Violation Exception
000019B2  2F0C                    1104          MOVE.L  A4,-(A7)          Save A4 
000019B4  49FA 038C               1105          LEA.L   MES14(PC),A4      Point to heading 
000019B8  6100 F6EC               1106          BSR     HEADING           Print it 
000019BC  285F                    1107          MOVE.L  (A7)+,A4          Restore A4
000019BE  6100 FD86               1108          BSR     EX_dis
000019C2  6000 F6B2               1109          BRA     WARM
000019C6  601E                    1110          BRA.S   GROUP1            Deal with group 1 exception 
000019C8                          1111  * 
000019C8  =000019C8               1112  BRKPT   EQU     *                   Deal with breakpoint 
000019C8  48E7 FFFE               1113          MOVEM.L D0-D7/A0-A6,-(A7)   Save all registers 
000019CC  6100 0180               1114          BSR     BR_CLR              Clear breakpoints in code 
000019D0  4CDF 7FFF               1115          MOVEM.L (A7)+,D0-D7/A0-A6   Restore registers 
000019D4  6144                    1116          BSR.S   GROUP2            Treat as group 2 exception 
000019D6  49FA 033E               1117          LEA.L   MES11(PC),A4      Point to heading 
000019DA  6100 F6CA               1118          BSR     HEADING           Print it 
000019DE  6100 FD66               1119          BSR     EX_DIS            Display saved registers 
000019E2  6000 F692               1120          BRA     WARM              Return to monitor 
000019E6                          1121  
000019E6                          1122  * 
000019E6                          1123  *       GROUP1 is called by address and bus error exceptions 
000019E6                          1124  *       These are "turned into group 2" exceptions (eg TRAP) 
000019E6                          1125  *       by modifying the stack frame saved by a group 1 exception 
000019E6                          1126  * 
000019E6  48E7 8080               1127  GROUP1  MOVEM.L D0/A0,-(A7)       Save working registers 
000019EA  206F 0012               1128          MOVE.L  18(A7),A0         Get PC from group 1 stack frame 
000019EE  302F 000E               1129          MOVE.W  14(A7),D0         Get instruction from stack frame 
000019F2  B060                    1130          CMP.W   -(A0),D0          Now backtrack to find the "correct PC" 
000019F4  670E                    1131          BEQ.S   GROUP1A           by matching the op-code on the stack 
000019F6  B060                    1132          CMP.W   -(A0),D0          with the code in the region of the 
000019F8  670A                    1133          BEQ.S   GROUP1A           PC on the stack 
000019FA  B060                    1134          CMP.W   -(A0),D0 
000019FC  6706                    1135          BEQ.S   GROUP1A 
000019FE  B060                    1136          CMP.W   -(A0),D0 
00001A00  6702                    1137          BEQ.S   GROUP1A 
00001A02  5588                    1138          SUBQ.L  #2,A0 
00001A04  2F48 0012               1139  GROUP1A MOVE.L  A0,18(A7)          Restore modified PC to stack frame 
00001A08  4CDF 0101               1140          MOVEM.L (A7)+,D0/A0        Restore working registers 
00001A0C  4FEF 0008               1141          LEA.L   8(A7),A7           Adjust stack pointer to group 1 type 
00001A10  6108                    1142          BSR.S   GROUP2             Now treat as group 1 exception 
00001A12  6100 FD32               1143          BSR     EX_DIS             Display contents of exception frame 
00001A16  6000 F65E               1144          BRA     WARM               Exit to monitor - no RTE from group 2 
00001A1A                          1145  * 
00001A1A  =00001A1A               1146  GROUP2  EQU     *                 Deal with group 2 exceptions 
00001A1A  48E7 FFFF               1147          MOVEM.L A0-A7/D0-D7,-(A7) Save all registers on the stack 
00001A1E  303C 000E               1148          MOVE.W  #14,D0            Transfer D0 - D7, A0 - A6 from 
00001A22  41EE 045A               1149          LEA.L   TSK_T(A6),A0      the stack to the display frame 
00001A26  20DF                    1150  GROUP2A MOVE.L  (A7)+,(A0)+       Move a register from stack to frame 
00001A28  51C8 FFFC               1151          DBRA    D0,GROUP2A        and repeat until D0-D7/A0-A6 moved 
00001A2C  4E6A                    1152          MOVE.L  USP,A2            Get the user stack pointer and put it 
00001A2E  20CA                    1153          MOVE.L  A2,(A0)+          in the A7 position in the frame 
00001A30  201F                    1154          MOVE.L  (A7)+,D0          Now transfer the SSP to the frame, 
00001A32  0480 0000000A           1155          SUB.L   #10,D0            remembering to account for the 
00001A38  20C0                    1156          MOVE.L  D0,(A0)+          data pushed on the stack to this point 
00001A3A  225F                    1157          MOVE.L  (A7)+,A1          Copy TOS (return address) to A1 
00001A3C  30DF                    1158          MOVE.W  (A7)+,(A0)+       Move SR to display frame 
00001A3E  201F                    1159          MOVE.L  (A7)+,D0          Get PC in D0 
00001A40  5580                    1160          SUBQ.L  #2,D0             Move back to current instruction 
00001A42  20C0                    1161          MOVE.L  D0,(A0)+          Put adjusted PC in display frame 
00001A44  4ED1                    1162          JMP     (A1)              Return from subroutine 
00001A46                          1163  * 
00001A46                          1164  ************************************************************************* 
00001A46                          1165  * 
00001A46                          1166  *  GO executes a program either from a supplied address or 
00001A46                          1167  *  by using the data in the display frame 
00001A46  6100 F782               1168  GO       BSR     PARAM               Get entry address (if any) 
00001A4A  4A07                    1169           TST.B   D7                  Test for error in input 
00001A4C  6708                    1170           BEQ.S   GO1                 If D7 zero then OK 
00001A4E  49FA 032B               1171           LEA.L   ERMES1(PC),A4       Else point to error message, 
00001A52  6000 F642               1172           BRA     PSTRING             print it and return 
00001A56  4A80                    1173  GO1      TST.L   D0                  If no address entered then get 
00001A58  670A                    1174           BEQ.S   GO2                 address from display frame 
00001A5A  2D40 04A0               1175           MOVE.L  D0,TSK_T+70(A6)     Else save address in display frame 
00001A5E  3D7C 0700 049E          1176           MOVE.W  #$0700,TSK_T+68(A6) Store dummy status in frame 
00001A64  6006                    1177  GO2      BRA.S   RESTORE             Restore volatile environment and go 
00001A66                          1178  * 
00001A66  6100 007A               1179  GB       BSR     BR_SET              Same as go but presets breakpoints 
00001A6A  60DA                    1180           BRA.S   GO                  Execute program 
00001A6C                          1181  * 
00001A6C                          1182  *        RESTORE moves the volatile environment from the display 
00001A6C                          1183  *        frame and transfers it to the 68000's registers. This 
00001A6C                          1184  *        re-runs a program suspended after an exception 
00001A6C                          1185  * 
00001A6C  47EE 045A               1186  RESTORE  LEA.L   TSK_T(A6),A3        A3 points to display frame 
00001A70  47EB 004A               1187           LEA.L   74(A3),A3           A3 now points to end of frame + 4 
00001A74  4FEF 0004               1188           LEA.L   4(A7),A7            Remove return address from stack 
00001A78  303C 0024               1189           MOVE.W  #36,D0              Counter for 37 words to be moved 
00001A7C  3F23                    1190  REST1    MOVE.W  -(A3),-(A7)         Move word from display frame to stack 
00001A7E  51C8 FFFC               1191           DBRA    D0,REST1            Repeat until entire frame moved 
00001A82  4CDF 00FF               1192           MOVEM.L (A7)+,D0-D7         Restore old data registers from stack 
00001A86  4CDF 7F00               1193           MOVEM.L (A7)+,A0-A6         Restore old address registers 
00001A8A  4FEF 0008               1194           LEA.L   8(A7),A7            Except SSP/USP - so adjust stack 
00001A8E  4E73                    1195           RTE                         Return from exception to run program 
00001A90                          1196  * 
00001A90  =00001A90               1197  TRACE    EQU     *                   TRACE exception (rudimentary version) 
00001A90  287A 0292               1198           MOVE.L  MES12(PC),A4        Point to heading 
00001A94  6100 F610               1199           BSR     HEADING             Print it 
00001A98  6100 FF4C               1200           BSR     GROUP1              Save volatile environment 
00001A9C  6100 FCA8               1201           BSR     EX_DIS              Display it 
00001AA0  6000 F5D4               1202           BRA     WARM                Return to monitor 
00001AA4                          1203  * 
00001AA4                          1204  ************************************************************************* 
00001AA4                          1205  *  Breakpoint routines: BR_GET gets the address of a breakpoint and 
00001AA4                          1206  *  puts it in the breakpoint table. It does not plant it in the code. 
00001AA4                          1207  *  BR_SET plants all breakpoints in the code. NOBR removes one or all 
00001AA4                          1208  *  breakpoints from the table. KILL removes breakpoints from the code. 
00001AA4                          1209  * 
00001AA4  6100 F724               1210  BR_GET   BSR     PARAM               Get breakpoint address in table 
00001AA8  4A07                    1211           TST.B   D7                  Test for input error 
00001AAA  6708                    1212           BEQ.S   BR_GET1             If no error then continue 
00001AAC  49FA 02CD               1213           LEA.L   ERMES1(PC),A4       Else display error 
00001AB0  6000 F5E4               1214           BRA     PSTRING             and return 
00001AB4  47EE 04A4               1215  BR_GET1  LEA.L   BP_TAB(A6),A3       A6 points to breakpoint table 
00001AB8  2A40                    1216           MOVE.L  D0,A5               Save new BP address in A5 
00001ABA  2C00                    1217           MOVE.L  D0,D6               and in D6 because D0 gets corrupted 
00001ABC  3A3C 0007               1218           MOVE.W  #7,D5               Eight entries to test 
00001AC0  201B                    1219  BR_GET2  MOVE.L  (A3)+,D0            Read entry from breakpoint table 
00001AC2  660C                    1220           BNE.S   BR_GET3             If not zero display existing BP 
00001AC4  4A86                    1221           TST.L   D6                  Only store a non-zero breakpoint 
00001AC6  6710                    1222           BEQ.S   BR_GET4 
00001AC8  274D FFFC               1223           MOVE.L  A5,-4(A3)           Store new breakpoint in table 
00001ACC  3695                    1224           MOVE.W  (A5),(A3)           Save code at BP address in table 
00001ACE  4286                    1225           CLR.L   D6                  Clear D6 to avoid repetition 
00001AD0  6100 F766               1226  BR_GET3  BSR     OUT8X               Display this breakpoint 
00001AD4  6100 F5B0               1227           BSR     NEWLINE 
00001AD8  47EB 0002               1228  BR_GET4  LEA.L   2(A3),A3            Step past stored op-code 
00001ADC  51CD FFE2               1229           DBRA    D5,BR_GET2          Repeat until all entries tested 
00001AE0  4E75                    1230           RTS                         Return 
00001AE2                          1231  * 
00001AE2  =00001AE2               1232  BR_SET   EQU     *                   Plant any breakpoints in user code 
00001AE2  41EE 04A4               1233           LEA.L   BP_TAB(A6),A0       A0 points to BP table 
00001AE6  45EE 04A0               1234           LEA.L   TSK_T+70(A6),A2     A2 points to PC in display frame 
00001AEA  2452                    1235           MOVE.L  (A2),A2             Now A2 contains value of PC 
00001AEC  303C 0007               1236           MOVE.W  #7,D0               Up to eight entries to plant 
00001AF0  2218                    1237  BR_SET1  MOVE.L  (A0)+,D1            Read breakpoint address from table 
00001AF2  670A                    1238           BEQ.S   BR_SET2             If zero then skip planting 
00001AF4  B28A                    1239           CMP.L   A2,D1               Don't want to plant BP at current PC 
00001AF6  6706                    1240           BEQ.S   BR_SET2             location, so skip planting if same 
00001AF8  2241                    1241           MOVE.L  D1,A1               Transfer BP address to address reg 
00001AFA  32BC 4E4E               1242           MOVE.W  #TRAP_16,(A1)       Plant op-code for TRAP #14 in code 
00001AFE  41E8 0002               1243  BR_SET2  LEA.L   2(A0),A0            Skip past op-code field in table 
00001B02  51C8 FFEC               1244           DBRA    D0,BR_SET1          Repeat until all entries tested 
00001B06  4E75                    1245           RTS 
00001B08                          1246  * 
00001B08  =00001B08               1247  NOBR     EQU     *                   Clear one or all breakpoints 
00001B08  6100 F6C0               1248           BSR     PARAM               Get BP address (if any) 
00001B0C  4A07                    1249           TST.B   D7                  Test for input error 
00001B0E  6708                    1250           BEQ.S   NOBR1               If no error then skip abort 
00001B10  49FA 0269               1251           LEA.L   ERMES1(PC),A4       Point to error message 
00001B14  6000 F580               1252           BRA     PSTRING             Display it and return 
00001B18  4A80                    1253  NOBR1    TST.L   D0                  Test for null address (clear all) 
00001B1A  6720                    1254           BEQ.S   NOBR4               If no address then clear all entries 
00001B1C  2240                    1255           MOVE.L  D0,A1               Else just clear breakpoint in A1 
00001B1E  41EE 04A4               1256           LEA.L   BP_TAB(A6),A0       A0 points to BP table 
00001B22  303C 0007               1257           MOVE.W  #7,D0               Up to eight entries to test 
00001B26  2218                    1258  NOBR2    MOVE.L  (A0)+,D1            Get entry and 
00001B28  41E8 0002               1259           LEA.L   2(A0),A0            skip past op-code field 
00001B2C  B289                    1260           CMP.L   A1,D1               Is this the one? 
00001B2E  6706                    1261           BEQ.S   NOBR3               If so go and clear entry 
00001B30  51C8 FFF4               1262           DBRA    D0,NOBR2            Repeat until all tested 
00001B34  4E75                    1263           RTS 
00001B36  42A8 FFFA               1264  NOBR3    CLR.L   -6(A0)              Clear address in BP table 
00001B3A  4E75                    1265           RTS 
00001B3C  41EE 04A4               1266  NOBR4    LEA.L   BP_TAB(A6),A0       Clear all 8 entries in BP table 
00001B40  303C 0007               1267           MOVE.W  #7,D0               Eight entries to clear 
00001B44  4298                    1268  NOBR5    CLR.L   (A0)+               Clear breakpoint address 
00001B46  4258                    1269           CLR.W   (A0)+               Clear op-code field 
00001B48  51C8 FFFA               1270           DBRA    D0,NOBR5            Repeat until all done 
00001B4C  4E75                    1271           RTS 
00001B4E                          1272  * 
00001B4E  =00001B4E               1273  BR_CLR   EQU     *                   Remove breakpoints from code 
00001B4E  41EE 04A4               1274           LEA.L   BP_TAB(A6),A0       A0 points to breakpoint table 
00001B52  303C 0007               1275           MOVE.W  #7,D0               Up to eight entries to clear 
00001B56  2218                    1276  BR_CLR1  MOVE.L  (A0)+,D1            Get address of BP in D1 
00001B58  2241                    1277           MOVE.L  D1,A1               and put copy in A1 
00001B5A  4A81                    1278           TST.L   D1                  Test this breakpoint 
00001B5C  6702                    1279           BEQ.S   BR_CLR2             If zero then skip BP clearing 
00001B5E  3290                    1280           MOVE.W  (A0),(A1)           Else restore op-code 
00001B60  41E8 0002               1281  BR_CLR2  LEA.L   2(A0),A0            Skip past op-code field 
00001B64  51C8 FFF0               1282           DBRA    D0,BR_CLR1          Repeat until all tested 
00001B68  4E75                    1283           RTS 
00001B6A                          1284  * 
00001B6A                          1285  *  REG_MOD modifies a register in the display frame. The command 
00001B6A                          1286  *  format is REG <reg> <value>. E.g. REG D3 1200 
00001B6A                          1287  * 
00001B6A  4281                    1288  REG_MOD  CLR.L   D1                  D1 to hold name of register 
00001B6C  41EE 0444               1289           LEA.L   BUFFPT(A6),A0       A0 contains address of buffer pointer 
00001B70  2050                    1290           MOVE.L  (A0),A0             A0 now points to next char in buffer 
00001B72  1218                    1291           MOVE.B  (A0)+,D1            Put first char of name in D1 
00001B74  E159                    1292           ROL.W   #8,D1               Move char one place left 
00001B76  1218                    1293           MOVE.B  (A0)+,D1            Get second char in D1 
00001B78  41E8 0001               1294           LEA.L   1(A0),A0            Move pointer past space in buffer 
00001B7C  2D48 0444               1295           MOVE.L  A0,BUFFPT(A6)       Update buffer pointer 
00001B80  4282                    1296           CLR.L   D2                  D2 is the character pair counter 
00001B82  41FA 01CE               1297           LEA.L   REGNAME(PC),A0      A0 points to string of character pairs 
00001B86  43D0                    1298           LEA.L   (A0),A1             A1 also points to string 
00001B88  B258                    1299  REG_MD1  CMP.W   (A0)+,D1            Compare a char pair with input 
00001B8A  6712                    1300           BEQ.S   REG_MD2             If match then exit loop 
00001B8C  5282                    1301           ADD.L   #1,D2               Else increment match counter 
00001B8E  B4BC 00000013           1302           CMP.L   #19,D2              Test for end of loop 
00001B94  66F2                    1303           BNE     REG_MD1             Continue until all pairs matched 
00001B96  49FA 01E3               1304           LEA.L   ERMES1(PC),A4       If here then error 
00001B9A  6000 F4FA               1305           BRA     PSTRING             Display error and return 
00001B9E  43EE 045A               1306  REG_MD2  LEA.L   TSK_T(A6),A1        A1 points to display frame 
00001BA2  E582                    1307           ASL.L   #2,D2               Multiply offset by 4 (4 bytes/entry) 
00001BA4  B4BC 00000048           1308           CMP.L   #72,D2              Test for address of PC 
00001BAA  6602                    1309           BNE.S   REG_MD3             If not PC then all is OK 
00001BAC  5582                    1310           SUB.L   #2,D2               else dec PC pointer as Sr is a word 
00001BAE  45F1 2000               1311  REG_MD3  LEA.L   (A1,D2),A2          Calculate address of entry in disptable 
00001BB2  2012                    1312           MOVE.L  (A2),D0             Get old contents 
00001BB4  6100 F682               1313           BSR     OUT8X               Display them 
00001BB8  6100 F4CC               1314           BSR     NEWLINE 
00001BBC  6100 F60C               1315           BSR     PARAM               Get new data 
00001BC0  4A07                    1316           TST.B   D7                  Test for input error 
00001BC2  6708                    1317           BEQ.S   REG_MD4             If no error then go and store data 
00001BC4  49FA 01B5               1318           LEA.L   ERMES1(PC),A4       Else point to error message 
00001BC8  6000 F4CC               1319           BRA     PSTRING             print it and return 
00001BCC  B4BC 00000044           1320  REG_MD4  CMP.L   #68,D2              If this address is the SR then 
00001BD2  6704                    1321           BEQ.S   REG_MD5             we have only a word to store 
00001BD4  2480                    1322           MOVE.L  D0,(A2)             Else store new data in display frame 
00001BD6  4E75                    1323           RTS 
00001BD8  3480                    1324  REG_MD5  MOVE.W  D0,(A2)             Store SR (one word) 
00001BDA  4E75                    1325           RTS 
00001BDC                          1326  * 
00001BDC                          1327  ************************************************************************* 
00001BDC                          1328  * 
00001BDC  =00001BDC               1329  X_UN    EQU     *                 Uninitialized exception vector routine 
00001BDC  49FA 0203               1330          LEA.L   ERMES6(PC),A4     Point to error message 
00001BE0  6100 F4B4               1331          BSR     PSTRING           Display it 
00001BE4  6100 FB60               1332          BSR     EX_DIS            Display registers 
00001BE8  6000 F48C               1333          BRA     WARM              Abort 
00001BEC                          1334  * 
00001BEC                          1335  ************************************************************************* 
00001BEC                          1336  * 
00001BEC                          1337  *  All strings and other fixed parameters here 
00001BEC                          1338  * 
00001BEC= 54 53 42 55 47 20 ...   1339  BANNER   DC.B     'TSBUG 2 Version 23.07.86',0,0
00001C06= 4D 6F 64 69 66 69 ...   1340  MODIFY    DC.B   'Modified by Eugene A. Rockey Jr. Jan.05.2010',0,0
00001C34= 66 6F 72 20 75 73 ...   1341  WHY      DC.B     'for use with the M68000 Minimal Computer Configuration',0,0 
00001C6C= 55 6E 69 76 65 72 ...   1342  WHERE    DC.B     'University of Louisville',0,0
00001C86= 0D 0A 54 53 32 4D ...   1343  CRLF     DC.B     CR,LF,'TS2MON >',0 
00001C91= 0D 0A 53 31 00 00       1344  HEADER   DC.B     CR,LF,'S','1',0,0 
00001C97= 53 39 20 20 00 00       1345  TAIL     DC.B     'S9  ',0,0 
00001C9D= 20 53 52 20 20 3D ...   1346  MES1     DC.B     ' SR  =  ',0 
00001CA6= 20 50 43 20 20 3D ...   1347  MES2     DC.B     ' PC  =  ',0 
00001CAF= 20 53 53 20 20 3D ...   1348  MES2A    DC.B     ' SS  =  ',0 
00001CB8= 20 20 44 61 74 61 ...   1349  MES3     DC.B     '  Data reg       Address reg',0,0 
00001CD6= 20 20 20 20 20 20 ...   1350  MES4     DC.B     '        ',0,0 
00001CE0= 42 75 73 20 65 72 ...   1351  MES8     DC.B     'Bus error   ',0,0 
00001CEE= 41 64 64 72 65 73 ...   1352  MES9     DC.B     'Address error   ',0,0 
00001D00= 49 6C 6C 65 67 61 ...   1353  MES10    DC.B     'Illegal instruction ',0,0 
00001D16= 42 72 65 61 6B 70 ...   1354  MES11    DC.B     'Breakpoint  ',0,0 
00001D24= 54 72 61 63 65 20 ...   1355  MES12    DC.B     'Trace   ',0 
00001D2D= 44 69 76 69 64 65 ...   1356  MES13    DC.B     'Divide by zero error', 0
00001D42= 50 72 69 76 69 6C ...   1357  MES14    DC.B     'Privilege error', 0
00001D52= 44 30 44 31 44 32 ...   1358  REGNAME  DC.B     'D0D1D2D3D4D5D6D7' 
00001D62= 41 30 41 31 41 32 ...   1359           DC.B     'A0A1A2A3A4A5A6A7' 
00001D72= 53 53 53 52             1360           DC.B     'SSSR' 
00001D76= 50 43 20 20 00          1361           DC.B     'PC  ',0 
00001D7B= 4E 6F 6E 2D 76 61 ...   1362  ERMES1   DC.B     'Non-valid hexadecimal input  ',0 
00001D99= 49 6E 76 61 6C 69 ...   1363  ERMES2   DC.B     'Invalid command  ',0 
00001DAB= 4C 6F 61 64 69 6E ...   1364  ERMES3   DC.B     'Loading error',0 
00001DB9= 54 61 62 6C 65 20 ...   1365  ERMES4   DC.B     'Table full  ',0,0 
00001DC7= 42 72 65 61 6B 70 ...   1366  ERMES5   DC.B     'Breakpoint not active   ',0,0 
00001DE1= 55 6E 69 6E 69 74 ...   1367  ERMES6   DC.B     'Uninitialized exception ',0,0 
00001DFB= 4A 55 4D 50 20 3C ...   1368  JUMPHELP DC.B     'JUMP <address> causes execution to begin at <address>',0   
00001E31= 4D 45 4D 4F 52 59 ...   1369  MEMHELP  DC.B     'MEMORY <address> examines contents of address> and allows them to be changed', 0   
00001E7E= 4C 4F 41 44 20 3C ...   1370  LOADHELP DC.B     'LOAD <string> loads S1/S2 records from the host. <string> is sent to host', 0
00001EC8= 54 56 20 63 68 65 ...   1371  TVHELP   DC.B     'TV checks all RAM addresses from $4000 to $40FE. Reports corrupt memory addresses', 0
00001F1A= 20 52 61 6E 67 65 ...   1372  ERMES7   DC.B     ' Range error',0
00001F27= 55 53 45 52 00          1373  UNAME    DC.B     'USER', 0
00001F2C= 50 41 53 53 57 4F ...   1374  PWORD    DC.B     'PASSWORD',0
00001F35= 45 6E 74 65 72 20 ...   1375  LOGINM1  DC.B     'Enter username: ', 0
00001F46= 45 6E 74 65 72 20 ...   1376  LOGINM2  DC.B     'Enter password: ', 0
00001F57= 49 6E 63 6F 72 72 ...   1377  USRERR   DC.B     'Incorrect username', 0
00001F6A= 43 6F 72 72 65 63 ...   1378  USRSUC   DC.B     'Correct Username', 0
00001F7B= 49 6E 63 6F 72 72 ...   1379  PWERR   DC.B     'Incorrect password', 0
00001F8E= 43 6F 72 72 65 63 ...   1380  PWSUC    DC.B     'Correct Password', 0
00001F9F= 4D 45 4D 4F 52 59 ...   1381  MEMFMSG  DC.B     'MEMORY BAD AT: ',0
00001FAF= 41 4C 4C 20 52 41 ...   1382  MEMGMSG  DC.B      'ALL RAM GOOD', 0
00001FBC= 48 45 4C 4C 4F 00       1383  HELLO    DC.B      'HELLO',0
00001FC2                          1384   
00001FC2                          1385  * 
00001FC2                          1386  *  COMTAB is the built-in command table. All entries are made up of 
00001FC2                          1387  *         a string length + number of characters to match + the string 
00001FC2                          1388  *         plus the address of the command relative to COMTAB 
00001FC2                          1389  * 
00002000                          1390           ORG      $2000
00002000= 04 04                   1391  COMTAB   DC.B     4,4              JUMP <address> causes execution to 
00002002= 4A 55 4D 50             1392           DC.B     'JUMP'           begin at <address> 
00002006= FFFFF240                1393           DC.L     JUMP-COMTAB                                           
0000200A= 08 03                   1394           DC.B     8,3              MEMORY <address> examines contents of 
0000200C= 4D 45 4D 4F 52 59 ...   1395           DC.B     'MEMORY  '       <address> and allows them to be changed 
00002014= FFFFF256                1396           DC.L     MEMORY-COMTAB 
00002018= 04 02                   1397           DC.B     4,2              LOAD <string> loads S1/S2 records 
0000201A= 4C 4F 41 44             1398           DC.B     'LOAD'           from the host. <string> is sent to host 
0000201E= FFFFF2B6                1399           DC.L     LOAD-COMTAB 
00002022= 04 04                   1400           DC.B    4,4               HELP 
00002024= 48 45 4C 50             1401           DC.B    'HELP'            
00002028= FFFFF7C4                1402           DC.L    HELP-COMTAB      
0000202C= 02 02                   1403           DC.B    2,2
0000202E= 54 56                   1404           DC.B    'TV'
00002030= FFFFF8C6                1405           DC.L    TV-COMTAB
00002034= 00 00                   1406           DC.B    0,0 
00002036                          1407  * 
00002036                          1408  ************************************************************************* 
00002036                          1409  * 
00002036                          1410  *  This is a list of the information needed to setup the DCBs 
00002036                          1411  * 
00002036  =00002036               1412  DCB_LST  EQU     * 
00002036= 43 4F 4E 5F 49 4E ...   1413  DCB1     DC.B    'CON_IN  '          Device name (8 bytes) 
0000203E= 000014E4 00008001       1414           DC.L    CON_IN,ACIA_1       Address of driver routine, device 
00002046= 0002                    1415           DC.W    2                   Number of words in parameter field 
00002048= 43 4F 4E 5F 4F 55 ...   1416  DCB2     DC.B    'CON_OUT ' 
00002050= 000014FA 00008001       1417           DC.L    CON_OUT,ACIA_1 
00002058= 0002                    1418           DC.W    2 
0000205A= 41 55 58 5F 49 4E ...   1419  DCB3     DC.B    'AUX_IN  ' 
00002062= 00001510 00008001       1420           DC.L    AUX_IN,ACIA_2 
0000206A= 0002                    1421           DC.W    2 
0000206C= 41 55 58 5F 4F 55 ...   1422  DCB4     DC.B    'AUX_OUT ' 
00002074= 00001522 00008001       1423           DC.L    AUX_OUT,ACIA_2 
0000207C= 0002                    1424           DC.W    2 
0000207E= 42 55 46 46 5F 49 ...   1425  DCB5     DC.B    'BUFF_IN ' 
00002086= 00001578 000006D4       1426           DC.L    BUFF_IN,BUFFER 
0000208E= 0002                    1427           DC.W    2 
00002090= 42 55 46 46 5F 4F ...   1428  DCB6     DC.B    'BUFF_OUT' 
00002098= 00001584 000006D4       1429           DC.L    BUFF_OT,BUFFER 
000020A0= 0002                    1430           DC.W    2 
000020A2                          1431  * 
000020A2                          1432  ************************************************************************* 
000020A2                          1433  * 
000020A2                          1434  *  DCB structure 
000020A2                          1435  * 
000020A2                          1436  *              ----------------------- 
000020A2                          1437  *       0 ->   | DCB  name           | 
000020A2                          1438  *              |---------------------| 
000020A2                          1439  *       8 ->   | Device driver       | 
000020A2                          1440  *              |---------------------| 
000020A2                          1441  *      12 ->   | Device address      | 
000020A2                          1442  *              |---------------------| 
000020A2                          1443  *      16 ->   |Size of param block  | 
000020A2                          1444  *              |---------------------| --- 
000020A2                          1445  *      18 ->   |      Status         |   | 
000020A2                          1446  *              | logical  | physical |   | S 
000020A2                          1447  *              |---------------------|   | 
000020A2                          1448  *              .                     .   . 
000020A2                          1449  *              |---------------------| --- 
000020A2                          1450  *    18+S ->   | Pointer to next DCB | 
000020A2                          1451  * 
000020A2                          1452           END RESET 

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ACIA_1              8001
ACIA_2              8001
ADD_0               15DE
ADD_ER              1996
ADR_DAT             1294
AUX_IN              1510
AUX_IN1             1516
AUX_OT1             1528
AUX_OUT             1522
BANNER              1BEC
BP_TAB              4A4
BRKPT               19C8
BR_CLR              1B4E
BR_CLR1             1B56
BR_CLR2             1B60
BR_GET              1AA4
BR_GET1             1AB4
BR_GET2             1AC0
BR_GET3             1AD0
BR_GET4             1AD8
BR_SET              1AE2
BR_SET1             1AF0
BR_SET2             1AFE
BS                  8
BUFFEND             443
BUFFER              6D4
BUFFPT              444
BUFF_IN             1578
BUFF_OT             1584
BUS_ER              1988
BYTE                11AE
CHECK1              18E2
CHECK2              18EC
CHECK3              190E
CHECK4              1918
CN_IVEC             452
CN_OVEC             456
COMTAB              2000
CON_IN              14E4
CON_OUT             14FA
CR                  D
CRLF                1C86
CTRL_A              1
DATA                4800
DCB1                2036
DCB2                2048
DCB3                205A
DCB4                206C
DCB5                207E
DCB6                2090
DCB_LST             2036
DELAY               1432
DELAY1              143C
DIV0_ER             19A4
DIVNEG              1622
DIV_0               1608
DUMP                138A
DUMP1               139A
DUMP2               13A6
DUMP3               13BC
DUMP4               13D0
DUMP5               13DE
DUMP6               13F8
DUMP7               141C
ECHO                44C
ERMES1              1D7B
ERMES2              1D99
ERMES3              1DAB
ERMES4              1DB9
ERMES5              1DC7
ERMES6              1DE1
ERMES7              1F1A
ESC                 1B
EXEC1               1136
EXEC2               1146
EXECUTE             1124
EX_D1               1758
EX_DIS              1746
FIRST               4D4
FOO1                1654
FOO10               16C0
FOO11               16CC
FOO12               16D8
FOO13               16E4
FOO14               16F0
FOO15               16FC
FOO16               1708
FOO17               1714
FOO18               1720
FOO19               172C
FOO2                1660
FOO20               1738
FOO21               1744
FOO3                166C
FOO4                1678
FOO5                1684
FOO6                1690
FOO7                169C
FOO8                16A8
FOO9                16B4
GB                  1A66
GETCH2              1558
GETCH3              1560
GETCHAR             1534
GETLINE             10AC
GETLN2              10B6
GETLN3              10D0
GETLN4              10DA
GETLN5              10DE
GO                  1A46
GO1                 1A56
GO2                 1A64
GROUP1              19E6
GROUP1A             1A04
GROUP2              1A1A
GROUP2A             1A26
HEADER              1C91
HEADING             10A6
HELLO               1FBC
HELP                17C4
HEX                 1190
HEX_OK              11AC
IL_ER               1970
IO_OPEN             1592
IO_REQ              14D2
JUMP                1240
JUMP1               124E
JUMPHELP            1DFB
LF                  A
LNBUFF              404
LOAD                12B6
LOAD1               12E2
LOAD2               12F2
LOAD3               130C
LOAD4               1326
LOAD5               1334
LOAD6               1336
LOAD6A              135A
LOAD7               136C
LOAD8               1382
LOADHELP            1E7E
LOGIN               17FA
LOGIN1              181A
LOGIN2              185E
LOGINM1             1F35
LOGINM2             1F46
LONGWD              11C4
LOOPRAM             18CE
LOOPRAM1            18FA
MAXCHR              40
MAX_RAM             7D8
MEM1                1260
MEM2                127E
MEM3                1292
MEMFAIL             192C
MEMFAIL2            1948
MEMFMSG             1F9F
MEMGMSG             1FAF
MEMGOOD             1964
MEMHELP             1E31
MEMORY              1256
MES1                1C9D
MES10               1D00
MES11               1D16
MES12               1D24
MES13               1D2D
MES14               1D42
MES2                1CA6
MES2A               1CAF
MES3                1CB8
MES4                1CD6
MES8                1CE0
MES9                1CEE
MIN_RAM             7D4
MODIFY              1C06
MULNEG              1638
MUL_0               15FA
NEWLINE             1086
NOBR                1B08
NOBR1               1B18
NOBR2               1B26
NOBR3               1B36
NOBR4               1B3C
NOBR5               1B44
NOT_HEX             11A8
NO_EXT              1054
NUL                 0
OPEN1               159A
OPEN2               15A2
OPEN3               15B0
OPEN4               15C6
OUT1X               120E
OUT1X1              1220
OUT2X               1228
OUT4X               1230
OUT8X               1238
PARAM               11CA
PARAM1              11D2
PARAM3              11F6
PARAM4              11FA
PARAM5              1206
PARAM6              120A
PARAMTR             448
PRIV_ER             19B2
PS1                 1098
PS2                 10A2
PSPACE              12A8
PSTRING             1096
PUTCHAR             1564
PWERR               1F7B
PWORD               1F2C
PWSUC               1F8E
QUIT                18C2
RANGE               1422
REGNAME             1D52
REG_MD1             1B88
REG_MD2             1B9E
REG_MD3             1BAE
REG_MD4             1BCC
REG_MD5             1BD8
REG_MOD             1B6A
RESET               1000
REST1               1A7C
RESTORE             1A6C
SEARCH              1150
SETNEG              1628
SET_DCB             1488
SPACE               20
SRCH2               116A
SRCH3               116E
SRCH4               1176
SRCH6               1180
SRCH7               118A
STACK               4400
ST_DCB1             1498
ST_DCB2             149C
SUB_0               15EC
TAIL                1C97
TIDY                10E2
TIDY1               10E8
TIDY2               10F4
TIDY3               10FE
TIDY4               1108
TIDY5               1112
TIDY6               111E
TM                  1446
TM1                 1452
TRACE               1A90
TRAP_0              1648
TRAP_16             4E4E
TSK_T               45A
TV                  18C6
TVHELP              1EC8
UNAME               1F27
UPASS               18B8
USRERR              1F57
USRSUC              1F6A
UTAB                44E
U_CASE              44D
WAIT                57
WARM                1076
WHERE               1C6C
WHY                 1C34
WORD                11BE
WRONG               1890
WRONGPW             18A4
X_BASE              4000
X_SET               15CC
X_SET2              15D4
X_UN                1BDC
