00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.15.04
Created On: 9/25/15 3:38:40 PM

00000000                             1  *        TSBUG2 - 68000 monitor - version of 05 January 2010 
00000000                             2  
00000000                             3       ORG      $0
00000000= 00004400 00001000 ...      4           DC.L STACK,RESET,BUS_ER,ADD_ER,IL_ER,DIV0_ER,X_UN,X_UN,PRIV_ER,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN
00000040= 00001C18 00001C18 ...      5           DC.L X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN
00000080= 0000163A 00001C18 ...      6           DC.L  TRAP_0,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,TRAP_14,TRAP_15
000000C4                             7           *DC.L X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN
000000C4                             8           *DC.L X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN
000000C4                             9           *DC.L X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN
000000C4                            10           *DC.L X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN
000000C4                            11           *DC.L X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN
000000C4                            12           *DC.L X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN
000000C4                            13           *DC.L X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN
000000C4                            14           *DC.L X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN
000000C4                            15           *DC.L X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN
000000C4                            16           *DC.L X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN
000000C4                            17           *DC.L X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN
000000C4                            18           *DC.L X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN
000000C4                            19           *DC.L X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN
000000C4                            20  *                                   Symbol equates 
000000C4  =00000008                 21  BS       EQU      $08               Back_space 
000000C4  =0000000D                 22  CR       EQU      $0D               Carriage_return 
000000C4  =00000000                 23  NUL      EQU      $00               NUL character
000000C4  =0000000A                 24  LF       EQU      $0A               Line_feed 
000000C4  =00000020                 25  SPACE    EQU      $20               Space 
000000C4  =00000057                 26  WAIT     EQU      'W'               Wait character (to suspend output) 
000000C4  =0000001B                 27  ESC      EQU      $1B               ASCII escape character (used by TM) 
000000C4  =00000001                 28  CTRL_A   EQU      $01               Control_A forces return to monitor 
000000C4                            29  *                                   Device addresses 
000000C4  =00004400                 30  STACK    EQU      $4400             Stack_pointer
000000C4  =00008001                 31  ACIA_1   EQU      $8001             Console ACIA control 
000000C4  =00008001                 32  ACIA_2   EQU      ACIA_1            Auxilary ACIA control 
000000C4                            33  *X_BASE   EQU      $4000             Start of exception vector table 
000000C4  =00004E4E                 34  TRAP_16  EQU      $4E4E             Code for TRAP #16 
000000C4  =00000040                 35  MAXCHR   EQU      64                Length of input line buffer  
000000C4                            36  * 
000000C4  =00004800                 37  DATA     EQU      $4800             Data origin 
000000C4                            38  LNBUFF   DS.B     MAXCHR            Input line buffer
00000104  =00000103                 39  BUFFEND  EQU      LNBUFF+MAXCHR-1   End of line buffer 
00000104                            40  BUFFPT   DS.L     1                 Pointer to line buffer 
00000108                            41  PARAMTR  DS.L     1                 Last parameter from line buffer 
0000010C                            42  ECHO     DS.B     1                 When clear this enable input echo 
0000010D                            43  U_CASE   DS.B     1                 Flag for upper case conversion 
0000010E                            44  UTAB     DS.L     1                 Pointer to user command table 
00000112                            45  CN_IVEC  DS.L     1                 Pointer to console input DCB 
00000116                            46  CN_OVEC  DS.L     1                 Pointer to console output DCB 
0000011A                            47  TSK_T    DS.W     37                Frame for D0-D7, A0-A6, USP, SSP, SW, PC 
00000164                            48  BP_TAB   DS.W     24                Breakpoint table 
00000194                            49  FIRST    DS.B     512               DCB area 
00000394                            50  BUFFER   DS.B     256               256 bytes for I/O buffer 
00000494= 00004000                  51  MIN_RAM  DC.L     $004000
00000498= 00004100                  52  MAX_RAM  DC.L     $004100
0000049C                            53  * 
0000049C                            54  ************************************************************************* 
0000049C                            55  * 
0000049C                            56  *  This is the main program which assembles a command in the line 
0000049C                            57  *  buffer, removes leading/embedded spaces and interprets it by matching 
0000049C                            58  *  it with a command in the user table or the built-in table COMTAB 
0000049C                            59  *  All variables are specified with respect to A6 
0000049C                            60  *
00001000                            61           ORG      $1000             Monitor Origin
00001000  =00001000                 62  RESET:   EQU      *
00001000  4DF8 4800                 63           LEA.L    DATA,A6           A6 points to data area 
00001004  2D4E 0152                 64       MOVE.L   A6,TSK_T+56(A6)   initialize A6 in the regster Frame
00001008  42AE 010E                 65           CLR.L    UTAB(A6)          Reset pointer to user extension table 
0000100C  422E 010C                 66           CLR.B    ECHO(A6)          Set automatic character echo 
00001010  422E 010D                 67           CLR.B    U_CASE(A6)        Clear case conversion flag (UC<-LC) 
00001014  6146                      68           BSR.S    SETACIA           Setup ACIAs 
00001016  6100 05AE                 69           BSR.L    B_CLR         what change did i do here
0000101A  6100 040E                 70           BSR.L    SET_DCB           Setup DCB table in RAM
0000101E  6152                      71           BSR.S    NEWLINE
00001020  49FA 0C06                 72           LEA.L    BANNER(PC),A4    
00001024  615C                      73           BSR.S    PSTRING
00001026  614A                      74           BSR.S    NEWLINE           
00001028  49FA 0C18                 75       LEA.L    MODIFY(PC),A4
0000102C  6154                      76           BSR.S    PSTRING
0000102E  6142                      77           BSR.S    NEWLINE
00001030  49FA 0C3E                 78       LEA.L    WHY(PC),A4
00001034  614C                      79           BSR.S    PSTRING
00001036  613A                      80           BSR.S    NEWLINE
00001038  49FA 0C6E                 81       LEA.L    WHERE(PC),A4
0000103C  6144                      82           BSR.S    PSTRING
0000103E  6132                      83           BSR.S    NEWLINE
00001040                            84  *         MOVE.L   #$3000,A0         A0 points to extension ROM 
00001040                            85  *         MOVE.L   (A0),D0           Read first longword in extension ROM 
00001040                            86  *         CMP.L    #'ROM2',D0        If extension begins with 'ROM2' then 
00001040                            87  *         BNE.S    NO_EXT            call the subroutine at EXT_ROM+8 
00001040                            88  *         JSR      8(A0)             else continue 
00001040  4E71                      89  NO_EXT:  NOP                        Two NOPs to allow for a future 
00001042  4E71                      90           NOP                        call to an initialization routine 
00001044  4287                      91           CLR.L    D7                Warm entry point - clear error flag 
00001046  4EB9 00001836             92           JSR      LOGIN                       
0000104C  4287                      93  WARM:    CLR.L    D7                Warm entry point - clear error flag 
0000104E  6122                      94           BSR.S    NEWLINE           Print a newline 
00001050  6146                      95           BSR.S    GETLINE           Get a command line 
00001052  6100 007A                 96           BSR      TIDY              Tidy up input buffer contents 
00001056  6100 00B8                 97           BSR      EXECUTE           Interpret command 
0000105A  60F0                      98           BRA      WARM              Repeat indefinitely 
0000105C                            99  * 
0000105C                           100  ************************************************************************* 
0000105C                           101  * 
0000105C                           102  *  Some initialization and basic routines 
0000105C                           103  * 
0000105C  =0000105C                104  SETACIA  EQU      *                 Setup ACIA parameters 
0000105C  41F9 00008001            105           LEA.L    ACIA_1,A0         A0 points to console ACIA 
00001062  10BC 0003                106           MOVE.B   #$03,(A0)         Reset ACIA1 
00001066                           107  *         MOVE.B   #$03,1(A0)        Reset ACIA2 
00001066  10BC 0019                108           MOVE.B   #$19,(A0)         Set up ACIA1 constants (no IRQ, 
0000106A  117C 0019 0001           109           MOVE.B   #$19,1(A0)        RTS* low, 8 bit, no parity, 1 stop) 
00001070  4E75                     110           RTS                        Return 
00001072                           111  * 
00001072  =00001072                112  NEWLINE  EQU      *                 Move cursor to start of newline 
00001072  48E7 0008                113           MOVEM.L  A4,-(A7)          Save A4 
00001076  49FA 0C4A                114           LEA.L    CRLF(PC),A4       Point to CR/LF string 
0000107A  6106                     115           BSR.S    PSTRING           Print it 
0000107C  4CDF 1000                116           MOVEM.L  (A7)+,A4          Restore A4 
00001080  4E75                     117           RTS                        Return 
00001082                           118  * 
00001082  =00001082                119  PSTRING  EQU      *                 Display the string pointed at by A4 
00001082  2F00                     120           MOVE.L   D0,-(A7)          Save D0 
00001084  101C                     121  PS1      MOVE.B   (A4)+,D0          Get character to be printed 
00001086  6706                     122           BEQ.S    PS2               If null then return 
00001088  6100 04DC                123           BSR      PUTCHAR           Else print it 
0000108C  60F6                     124           BRA      PS1               Continue 
0000108E  201F                     125  PS2      MOVE.L   (A7)+,D0          Restore D0 and exit 
00001090  4E75                     126           RTS 
00001092                           127  * 
00001092  61DE                     128  HEADING  BSR      NEWLINE           Same as PSTRING but with newline 
00001094  61EC                     129           BSR      PSTRING 
00001096  60DA                     130           BRA      NEWLINE 
00001098                           131  * 
00001098                           132  ************************************************************************* 
00001098                           133  * 
00001098                           134  *  GETLINE  inputs a string of characters into a line buffer 
00001098                           135  *           A3 points to next free entry in line buffer 
00001098                           136  *           A2 points to end of buffer 
00001098                           137  *           A1 points to start of buffer 
00001098                           138  *           D0 holds character to be stored 
00001098                           139  * 
00001098  43EE 00C4                140  GETLINE  LEA.L    LNBUFF(A6),A1     A1 points to start of line buffer 
0000109C  47D1                     141           LEA.L    (A1),A3           A3 points to start (initially) 
0000109E  45E9 0040                142           LEA.L    MAXCHR(A1),A2     A2 points to end of buffer 
000010A2  6100 0476                143  GETLN2   BSR      GETCHAR           Get a character 
000010A6  B03C 0001                144           CMP.B    #CTRL_A,D0        If control_A then reject this line 
000010AA  671E                     145           BEQ.S    GETLN5            and get another line 
000010AC  B03C 0008                146           CMP.B    #BS,D0            If back_space then move back pointer 
000010B0  660A                     147           BNE.S    GETLN3            Else skip past wind-back routine 
000010B2  B7C9                     148           CMP.L    A1,A3             First check for empty buffer 
000010B4  67EC                     149           BEQ      GETLN2            If buffer empty then continue 
000010B6  47EB FFFF                150           LEA      -1(A3),A3         Else decrement buffer pointer 
000010BA  60E6                     151           BRA      GETLN2            and continue with next character 
000010BC  16C0                     152  GETLN3   MOVE.B   D0,(A3)+          Store character and update pointer 
000010BE  B03C 000D                153           CMP.B    #CR,D0            Test for command terminator 
000010C2  6602                     154           BNE.S    GETLN4            If not CR then skip past exit 
000010C4  60AC                     155           BRA      NEWLINE           Else new line before next operation 
000010C6  B7CA                     156  GETLN4   CMP.L    A2,A3             Test for buffer overflow 
000010C8  66D8                     157           BNE      GETLN2            If buffer not full then continue 
000010CA  61A6                     158  GETLN5   BSR      NEWLINE           Else move to next line and 
000010CC  60CA                     159           BRA      GETLINE           repeat this routine 
000010CE                           160  * 
000010CE                           161  ************************************************************************* 
000010CE                           162  * 
000010CE                           163  *  TIDY cleans up the line buffer by removing leading spaces and multiple 
000010CE                           164  *       spaces between parameters. At the end of TIDY, BUFFPT points to 
000010CE                           165  *       the first parameter following the command. 
000010CE                           166  *       A0 = pointer to line buffer. A1 = pointer to cleaned up buffer 
000010CE                           167  * 
000010CE  41EE 00C4                168  TIDY     LEA.L    LNBUFF(A6),A0     A0 points to line buffer 
000010D2  43D0                     169           LEA.L    (A0),A1           A1 points to start of line buffer 
000010D4  1018                     170  TIDY1    MOVE.B   (A0)+,D0          Read character from line buffer 
000010D6  B03C 0020                171           CMP.B    #SPACE,D0         Repeat until the first non-space 
000010DA  67F8                     172           BEQ      TIDY1             character is found 
000010DC  41E8 FFFF                173           LEA.L    -1(A0),A0         Move pointer back to first char 
000010E0  1018                     174  TIDY2    MOVE.B   (A0)+,D0          Move the string left to remove 
000010E2  12C0                     175           MOVE.B   D0,(A1)+          any leading spaces 
000010E4  B03C 0020                176           CMP.B    #SPACE,D0         Test for embedded space 
000010E8  660A                     177           BNE.S    TIDY4             If not space then test for EOL 
000010EA  0C18 0020                178  TIDY3    CMP.B    #SPACE,(A0)+      If space skip multiple embedded 
000010EE  67FA                     179           BEQ      TIDY3             spaces 
000010F0  41E8 FFFF                180           LEA.L    -1(A0),A0         Move back pointer 
000010F4  B03C 000D                181  TIDY4    CMP.B    #CR,D0            Test for end_of_line (EOL) 
000010F8  66E6                     182           BNE      TIDY2             If not EOL then read next char 
000010FA  41EE 00C4                183           LEA.L    LNBUFF(A6),A0     Restore buffer pointer 
000010FE  0C10 000D                184  TIDY5    CMP.B    #CR,(A0)          Test for EOL 
00001102  6706                     185           BEQ.S    TIDY6             If EOL then exit 
00001104  0C18 0020                186           CMP.B    #SPACE,(A0)+      Test for delimiter 
00001108  66F4                     187           BNE      TIDY5             Repeat until delimiter or EOL 
0000110A  2D48 0104                188  TIDY6    MOVE.L   A0,BUFFPT(A6)     Update buffer pointer 
0000110E  4E75                     189           RTS 
00001110                           190  * 
00001110                           191  ************************************************************************* 
00001110                           192  * 
00001110                           193  *  EXECUTE matches the first command in the line buffer with the 
00001110                           194  *  commands in a command table. An external table pointed at by 
00001110                           195  *  UTAB is searched first and then the in-built table, COMTAB. 
00001110                           196  * 
00001110  4AAE 010E                197  EXECUTE  TST.L    UTAB(A6)          Test pointer to user table 
00001114  670C                     198           BEQ.S    EXEC1             If clear then try built-in table 
00001116  266E 010E                199           MOVE.L   UTAB(A6),A3       Else pick up pointer to user table 
0000111A  6120                     200           BSR.S    SEARCH            Look for command in user table 
0000111C  6404                     201           BCC.S    EXEC1             If not found then try internal table 
0000111E  2653                     202           MOVE.L   (A3),A3           Else get absolute address of command 
00001120  4ED3                     203           JMP      (A3)              from user table and execute it 
00001122                           204  * 
00001122  47FA 0EDC                205  EXEC1    LEA.L    COMTAB(PC),A3     Try built-in command table 
00001126  6114                     206           BSR.S    SEARCH            Look for command in built-in table 
00001128  6508                     207           BCS.S    EXEC2             If found then execute command 
0000112A  49FA 0CA9                208           LEA.L    ERMES2(PC),A4     Else print "invalid command" 
0000112E  6000 FF52                209           BRA.L    PSTRING           and return 
00001132  2653                     210  EXEC2    MOVE.L   (A3),A3           Get the relative command address 
00001134  49FA 0ECA                211           LEA.L    COMTAB(PC),A4     pointed at by A3 and add it to 
00001138  D7CC                     212           ADD.L    A4,A3             the PC to generate the actual 
0000113A  4ED3                     213           JMP      (A3)              command address. Then execute it. 
0000113C                           214  * 
0000113C  =0000113C                215  SEARCH   EQU      *                 Match the command in the line buffer 
0000113C  4280                     216           CLR.L    D0                with command table pointed at by A3 
0000113E  1013                     217           MOVE.B   (A3),D0           Get the first character in the 
00001140  6734                     218           BEQ.S    SRCH7             current entry. If zero then exit 
00001142  49F3 0006                219           LEA.L    6(A3,D0.W),A4     Else calculate address of next entry 
00001146  122B 0001                220           MOVE.B   1(A3),D1          Get number of characters to match 
0000114A  4BEE 00C4                221           LEA.L    LNBUFF(A6),A5     A5 points to command in line buffer 
0000114E  142B 0002                222           MOVE.B   2(A3),D2          Get first character in this entry 
00001152  B41D                     223           CMP.B    (A5)+,D2          from the table and match with buffer 
00001154  6704                     224           BEQ.S    SRCH3             If match then try rest of string 
00001156  264C                     225  SRCH2    MOVE.L   A4,A3             Else get address of next entry 
00001158  60E2                     226           BRA      SEARCH            and try the next entry in the table 
0000115A  5301                     227  SRCH3    SUB.B    #1,D1             One less character to match 
0000115C  670E                     228           BEQ.S    SRCH6             If match counter zero then all done 
0000115E  47EB 0003                229           LEA.L    3(A3),A3          Else point to next character in table 
00001162  141B                     230  SRCH4    MOVE.B   (A3)+,D2          Now match a pair of characters 
00001164  B41D                     231           CMP.B    (A5)+,D2 
00001166  66EE                     232           BNE      SRCH2             If no match then try next entry 
00001168  5301                     233           SUB.B    #1,D1             Else decrement match counter and 
0000116A  66F6                     234           BNE      SRCH4             repeat until no chars left to match 
0000116C  47EC FFFC                235  SRCH6    LEA.L    -4(A4),A3         Calculate address of command entry 
00001170  003C 0001                236           OR.B     #1,CCR            point. Mark carry flag as success 
00001174  4E75                     237           RTS                        and return 
00001176  023C 00FE                238  SRCH7    AND.B    #$FE,CCR          Fail - clear carry to indicate 
0000117A  4E75                     239           RTS                        command not found and return 
0000117C                           240  * 
0000117C                           241  ************************************************************************* 
0000117C                           242  * 
0000117C                           243  *  Basic input routines 
0000117C                           244  *  HEX    =  Get one   hexadecimal character  into D0 
0000117C                           245  *  BYTE   =  Get two   hexadecimal characters into D0 
0000117C                           246  *  WORD   =  Get four  hexadecimal characters into D0 
0000117C                           247  *  LONGWD =  Get eight hexadecimal characters into D0 
0000117C                           248  *  PARAM  =  Get a longword from the line buffer into D0 
0000117C                           249  *  Bit 0 of D7 is set to indicate a hexadecimal input error 
0000117C                           250  * 
0000117C  6100 039C                251  HEX      BSR      GETCHAR           Get a character from input device 
00001180  0400 0030                252           SUB.B    #$30,D0           Convert to binary 
00001184  6B0E                     253           BMI.S    NOT_HEX           If less than $30 then exit with error 
00001186  B03C 0009                254           CMP.B    #$09,D0           Else test for number (0 to 9) 
0000118A  6F0C                     255           BLE.S    HEX_OK            If number then exit - success 
0000118C  5F00                     256           SUB.B    #$07,D0           Else convert letter to hex 
0000118E  B03C 000F                257           CMP.B    #$0F,D0           If character in range "A" to "F" 
00001192  6F04                     258           BLE.S    HEX_OK            then exit successfully 
00001194  8E3C 0001                259  NOT_HEX  OR.B     #1,D7             Else set error flag 
00001198  4E75                     260  HEX_OK   RTS                        and return 
0000119A                           261  * 
0000119A  2F01                     262  BYTE     MOVE.L   D1,-(A7)          Save D1 
0000119C  61DE                     263           BSR      HEX               Get first hex character 
0000119E  E900                     264           ASL.B    #4,D0             Move it to MS nybble position 
000011A0  1200                     265           MOVE.B   D0,D1             Save MS nybble in D1 
000011A2  61D8                     266           BSR      HEX               Get second hex character 
000011A4  D001                     267           ADD.B    D1,D0             Merge MS and LS nybbles 
000011A6  221F                     268           MOVE.L   (A7)+,D1          Restore D1 
000011A8  4E75                     269           RTS 
000011AA                           270  * 
000011AA  61EE                     271  WORD     BSR      BYTE              Get upper order byte 
000011AC  E140                     272           ASL.W    #8,D0             Move it to MS position 
000011AE  60EA                     273           BRA      BYTE              Get LS byte and return 
000011B0                           274  * 
000011B0  61F8                     275  LONGWD   BSR      WORD              Get upper order word 
000011B2  4840                     276           SWAP     D0                Move it to MS position 
000011B4  60F4                     277           BRA      WORD              Get lower order word and return 
000011B6                           278  * 
000011B6                           279  *  PARAM reads a parameter from the line buffer and puts it in both 
000011B6                           280  *  PARAMTR(A6) and D0. Bit 1 of D7 is set on error. 
000011B6                           281  * 
000011B6  2F01                     282  PARAM    MOVE.L   D1,-(A7)          Save D1 
000011B8  4281                     283           CLR.L    D1                Clear input accumulator 
000011BA  206E 0104                284           MOVE.L   BUFFPT(A6),A0     A0 points to parameter in buffer 
000011BE  1018                     285  PARAM1   MOVE.B   (A0)+,D0          Read character from line buffer 
000011C0  B03C 0020                286           CMP.B    #SPACE,D0         Test for delimiter 
000011C4  6720                     287           BEQ.S    PARAM4            The permitted delimiter is a 
000011C6  B03C 000D                288           CMP.B    #CR,D0            space or a carriage return 
000011CA  671A                     289           BEQ.S    PARAM4            Exit on either space or C/R 
000011CC  E981                     290           ASL.L    #4,D1             Shift accumulated result 4 bits left 
000011CE  0400 0030                291           SUB.B    #$30,D0           Convert new character to hex 
000011D2  6B1E                     292           BMI.S    PARAM5            If less than $30 then not-hex 
000011D4  B03C 0009                293           CMP.B    #$09,D0           If less than 10 
000011D8  6F08                     294           BLE.S    PARAM3            then continue 
000011DA  5F00                     295           SUB.B    #$07,D0           Else assume $A - $F 
000011DC  B03C 000F                296           CMP.B    #$0F,D0           If more than $F 
000011E0  6E10                     297           BGT.S    PARAM5            then exit to error on not-hex 
000011E2  D200                     298  PARAM3   ADD.B    D0,D1             Add latest nybble to total in D1 
000011E4  60D8                     299           BRA      PARAM1            Repeat until delimiter found 
000011E6  2D48 0104                300  PARAM4   MOVE.L   A0,BUFFPT(A6)     Save pointer in memory 
000011EA  2D41 0108                301           MOVE.L   D1,PARAMTR(A6)    Save parameter in memory 
000011EE  2001                     302           MOVE.L   D1,D0             Put parameter in D0 for return 
000011F0  6004                     303           BRA.S    PARAM6            Return without error 
000011F2  8E3C 0002                304  PARAM5   OR.B     #2,D7             Set error flag before return 
000011F6  221F                     305  PARAM6   MOVE.L   (A7)+,D1          Restore working register 
000011F8  4E75                     306           RTS                        Return with error 
000011FA                           307  * 
000011FA                           308  ************************************************************************* 
000011FA                           309  * 
000011FA                           310  *  Output routines 
000011FA                           311  *  OUT1X   = print one   hexadecimal character 
000011FA                           312  *  OUT2X   = print two   hexadecimal characters 
000011FA                           313  *  OUT4X   = print four  hexadecimal characters 
000011FA                           314  *  OUT8X   = print eight hexadecimal characters 
000011FA                           315  *  In each case, the data to be printed is in D0 
000011FA                           316  * 
000011FA  3F00                     317  OUT1X    MOVE.W   D0,-(A7)          Save D0 
000011FC  C03C 000F                318           AND.B    #$0F,D0           Mask off MS nybble 
00001200  0600 0030                319           ADD.B    #$30,D0           Convert to ASCII 
00001204  B03C 0039                320           CMP.B    #$39,D0           ASCII = HEX + $30 
00001208  6302                     321           BLS.S    OUT1X1            If ASCII <= $39 then print and exit 
0000120A  5E00                     322           ADD.B    #$07,D0           Else ASCII := HEX + 7 
0000120C  6100 0358                323  OUT1X1   BSR      PUTCHAR           Print the character 
00001210  301F                     324           MOVE.W   (A7)+,D0          Restore D0 
00001212  4E75                     325           RTS 
00001214                           326  * 
00001214  E818                     327  OUT2X    ROR.B    #4,D0             Get MS nybble in LS position 
00001216  61E2                     328           BSR      OUT1X             Print MS nybble 
00001218  E918                     329           ROL.B    #4,D0             Restore LS nybble 
0000121A  60DE                     330           BRA      OUT1X             Print LS nybble and return 
0000121C                           331  * 
0000121C  E058                     332  OUT4X    ROR.W    #8,D0             Get MS byte in LS position 
0000121E  61F4                     333           BSR      OUT2X             Print MS byte 
00001220  E158                     334           ROL.W    #8,D0             Restore LS byte 
00001222  60F0                     335           BRA      OUT2X             Print LS byte and return 
00001224                           336  * 
00001224  4840                     337  OUT8X    SWAP     D0                Get MS word in LS position 
00001226  61F4                     338           BSR      OUT4X             Print MS word 
00001228  4840                     339           SWAP     D0                Restore LS word 
0000122A  60F0                     340           BRA      OUT4X             Print LS word and return 
0000122C                           341  * 
0000122C                           342  ************************************************************************* 
0000122C                           343  * 
0000122C                           344  * JUMP causes execution to begin at the address in the line buffer 
0000122C                           345  * 
0000122C  6188                     346  JUMP     BSR     PARAM              Get address from buffer 
0000122E  4A07                     347           TST.B   D7                 Test for input error 
00001230  6608                     348           BNE.S   JUMP1              If error flag not zero then exit 
00001232  4A80                     349           TST.L   D0                 Else test for missing address 
00001234  6704                     350           BEQ.S   JUMP1              field. If no address then exit 
00001236  2040                     351           MOVE.L  D0,A0              Put jump address in A0 and call the 
00001238  4ED0                     352           JMP     (A0)               subroutine. User to supply RTS!! 
0000123A  49FA 0B7B                353  JUMP1    LEA.L   ERMES1(PC),A4      Here for error - display error 
0000123E  6000 FE42                354           BRA     PSTRING            message and return 
00001242                           355  * 
00001242                           356  ************************************************************************* 
00001242                           357  * 
00001242                           358  *  Display the contents of a memory location and modify it 
00001242                           359  * 
00001242  6100 FF72                360  MEMORY   BSR      PARAM             Get start address from line buffer 
00001246  4A07                     361           TST.B    D7                Test for input error 
00001248  6634                     362           BNE.S    MEM3              If error then exit 
0000124A  2640                     363           MOVE.L   D0,A3             A3 points to location to be opened 
0000124C  6100 FE24                364  MEM1     BSR      NEWLINE 
00001250  612E                     365           BSR.S    ADR_DAT           Print current address and contents 
00001252  6140                     366           BSR.S    PSPACE             update pointer, A3, and O/P space 
00001254  6100 02C4                367           BSR      GETCHAR           Input char to decide next action 
00001258  B03C 000D                368           CMP.B    #CR,D0            If carriage return then exit 
0000125C  6720                     369           BEQ.S    MEM3              Exit 
0000125E  B03C 002D                370           CMP.B    #'-',D0           If "-" then move back 
00001262  6606                     371           BNE.S    MEM2              Else skip wind-back procedure 
00001264  47EB FFFC                372           LEA.L    -4(A3),A3         Move pointer back 2+2 
00001268  60E2                     373           BRA      MEM1              Repeat until carriage return 
0000126A  B03C 0020                374  MEM2     CMP.B    #SPACE,D0         Test for space (= new entry) 
0000126E  66DC                     375           BNE.S    MEM1              If not space then repeat 
00001270  6100 FF38                376           BSR      WORD              Else get new word to store 
00001274  4A07                     377           TST.B    D7                Test for input error 
00001276  6606                     378           BNE.S    MEM3              If error then exit 
00001278  3740 FFFE                379           MOVE.W   D0,-2(A3)         Store new word 
0000127C  60CE                     380           BRA      MEM1              Repeat until carriage return 
0000127E  4E75                     381  MEM3     RTS 
00001280                           382  * 
00001280  2F00                     383  ADR_DAT  MOVE.L   D0,-(A7)          Print the contents of A3 and the 
00001282  200B                     384           MOVE.L   A3,D0             word pointed at by A3. 
00001284  619E                     385           BSR      OUT8X              and print current address 
00001286  610C                     386           BSR.S    PSPACE            Insert delimiter 
00001288  3013                     387           MOVE.W   (A3),D0           Get data at this address in D0 
0000128A  6190                     388           BSR      OUT4X              and print it 
0000128C  47EB 0002                389           LEA.L    2(A3),A3          Point to next address to display 
00001290  201F                     390           MOVE.L   (A7)+,D0          Restore D0 
00001292  4E75                     391           RTS 
00001294                           392  * 
00001294  1F00                     393  PSPACE   MOVE.B   D0,-(A7)          Print a single space 
00001296  103C 0020                394           MOVE.B   #SPACE,D0
0000129A  6100 02CA                395           BSR      PUTCHAR 
0000129E  101F                     396           MOVE.B   (A7)+,D0 
000012A0  4E75                     397           RTS 
000012A2                           398  * 
000012A2                           399  ************************************************************************* 
000012A2                           400  * 
000012A2                           401  *  LOAD  Loads data formatted in hexadecimal "S". format from Port 2 
000012A2                           402  *        NOTE - I/O is automatically redirected to the aux port for 
000012A2                           403  *        loader functions. S1 or S2 records accepted 
000012A2                           404  * 
000012A2  2F2E 0116                405  LOAD     MOVE.L   CN_OVEC(A6),-(A7) Save current output device name 
000012A6  2F2E 0112                406           MOVE.L   CN_IVEC(A6),-(A7) Save current input device name 
000012AA  2D7C 00002076 0116       407           MOVE.L   #DCB4,CN_OVEC(A6) Set up aux ACIA as output 
000012B2  2D7C 00002064 0112       408           MOVE.L   #DCB3,CN_IVEC(A6) Set up aux ACIA as input 
000012BA  522E 010C                409           ADD.B    #1,ECHO(A6)       Turn off character echo 
000012BE  6100 FDB2                410           BSR      NEWLINE           Send newline to host 
000012C2  6100 0152                411           BSR      DELAY             Wait for host to "settle" 
000012C6  6100 014E                412           BSR      DELAY 
000012CA  286E 0104                413           MOVE.L   BUFFPT(A6),A4     Any string in the line buffer is 
000012CE  101C                     414  LOAD1    MOVE.B   (A4)+,D0          transmitted to the host computer 
000012D0  6100 0294                415           BSR      PUTCHAR           before the loading begins 
000012D4  B03C 000D                416           CMP.B    #CR,D0            Read from the buffer until EOL 
000012D8  66F4                     417           BNE      LOAD1 
000012DA  6100 FD96                418           BSR      NEWLINE           Send newline before loading 
000012DE  6100 023A                419  LOAD2    BSR      GETCHAR           Records from the host must begin 
000012E2  B03C 0053                420           CMP.B    #'S',D0           with S1/S2 (data) or S9/S8 (term) 
000012E6  66F6                     421           BNE.S    LOAD2             Repeat GETCHAR until char = "S" 
000012E8  6100 0230                422           BSR      GETCHAR           Get character after "S" 
000012EC  B03C 0039                423           CMP.B    #'9',D0           Test for the two terminators S9/S8 
000012F0  6706                     424           BEQ.S    LOAD3             If S9 record then exit else test 
000012F2  B03C 0038                425           CMP.B    #'8',D0           for S8 terminator. Fall through to 
000012F6  662A                     426           BNE.S    LOAD6             exit on S8 else continue search 
000012F8  =000012F8                427  LOAD3    EQU      *                 Exit point from LOAD 
000012F8  2D5F 0112                428           MOVE.L   (A7)+,CN_IVEC(A6) Clean up by restoring input device 
000012FC  2D5F 0116                429           MOVE.L   (A7)+,CN_OVEC(A6) and output device name 
00001300  422E 010C                430           CLR.B    ECHO(A6)          Restore input character echo 
00001304  0807 0000                431           BTST   #0,D7             Test for input errors 
00001308  6708                     432           BEQ.S    LOAD4             If no I/P error then look at checksum 
0000130A  49FA 0AAB                433           LEA.L    ERMES1(PC),A4     Else point to error message 
0000130E  6100 FD72                434           BSR      PSTRING           Print it 
00001312  0807 0003                435  LOAD4    BTST   #3,D7             Test for checksum error 
00001316  6708                     436           BEQ.S    LOAD5             If clear then exit 
00001318  49FA 0ACF                437           LEA.L    ERMES3(PC),A4     Else point to error message 
0000131C  6100 FD64                438           BSR      PSTRING           Print it and return 
00001320  4E75                     439  LOAD5    RTS 
00001322                           440  * 
00001322  B03C 0031                441  LOAD6    CMP.B    #'1',D0           Test for S1 record 
00001326  671E                     442           BEQ.S    LOAD6A            If S1 record then read it 
00001328  B03C 0032                443           CMP.B    #'2',D0           Else test for S2 record 
0000132C  66B0                     444           BNE.S    LOAD2             Repeat until valid header found 
0000132E  4203                     445           CLR.B    D3                Read the S2 byte count and address, 
00001330  613C                     446           BSR.S    LOAD8             clear the checksum 
00001332  5900                     447           SUB.B    #4,D0             Calculate size of data field 
00001334  1400                     448           MOVE.B   D0,D2             D2 contains data bytes to read 
00001336  4280                     449           CLR.L    D0                Clear address accumulator 
00001338  6134                     450           BSR.S    LOAD8             Read most sig byte of address 
0000133A  E180                     451           ASL.L    #8,D0             Move it one byte left 
0000133C  6130                     452           BSR.S    LOAD8             Read the middle byte of address 
0000133E  E180                     453           ASL.L    #8,D0             Move it one byte left 
00001340  612C                     454           BSR.S    LOAD8             Read least sig byte of address 
00001342  2440                     455           MOVE.L   D0,A2             A2 points to destination of record 
00001344  6012                     456           BRA.S    LOAD7             Skip past S1 header loader 
00001346  4203                     457  LOAD6A   CLR.B    D3                S1 record found - clear checksum 
00001348  6124                     458           BSR.S    LOAD8             Get byte and update checksum 
0000134A  5700                     459           SUB.B    #3,D0             Subtract 3 from record length 
0000134C  1400                     460           MOVE.B   D0,D2             Save byte count in D2 
0000134E  4280                     461           CLR.L    D0                Clear address accumulator 
00001350  611C                     462           BSR.S    LOAD8             Get MS byte of load address 
00001352  E180                     463           ASL.L    #8,D0             Move it to MS position 
00001354  6118                     464           BSR.S    LOAD8             Get LS byte in D2 
00001356  2440                     465           MOVE.L   D0,A2             A2 points to destination of data 
00001358  6114                     466  LOAD7    BSR.S    LOAD8             Get byte of data for loading 
0000135A  14C0                     467           MOVE.B   D0,(A2)+          Store it 
0000135C  5302                     468           SUB.B    #1,D2             Decrement byte counter 
0000135E  66F8                     469           BNE      LOAD7             Repeat until count = 0 
00001360  610C                     470           BSR.S    LOAD8             Read checksum 
00001362  5203                     471           ADD.B    #1,D3             Add 1 to total checksum 
00001364  6700 FF78                472           BEQ      LOAD2             If zero then start next record 
00001368  8E3C 0008                473           OR.B     #%00001000,D7     Else set checksum error bit, 
0000136C  608A                     474           BRA      LOAD3             restore I/O devices and return 
0000136E                           475  * 
0000136E  6100 FE2A                476  LOAD8    BSR     BYTE               Get a byte 
00001372  D600                     477           ADD.B   D0,D3              Update checksum 
00001374  4E75                     478           RTS                         and return 
00001376                           479  *************************************************************************** 
00001376                           480  * 
00001376                           481  *  DUMP   Transmit S1 formatted records to host computer 
00001376                           482  *         A3 = Starting address of data block 
00001376                           483  *         A2 = End address of data block 
00001376                           484  *         D1 = Checksum, D2 = current record length 
00001376                           485  * 
00001376  6100 008E                486  DUMP     BSR      RANGE             Get start and end address 
0000137A  4A07                     487           TST.B    D7                Test for input error 
0000137C  6708                     488           BEQ.S    DUMP1             If no error then continue 
0000137E  49FA 0A37                489           LEA.L    ERMES1(PC),A4     Else point to error message, 
00001382  6000 FCFE                490           BRA      PSTRING           print it and return 
00001386  B08B                     491  DUMP1    CMP.L    A3,D0             Compare start and end addresses 
00001388  6A08                     492           BPL.S    DUMP2             If positive then start < end 
0000138A  49FA 0BCC                493           LEA.L    ERMES7(PC),A4     Else print error message 
0000138E  6000 FCF2                494           BRA      PSTRING           and return 
00001392  2F2E 0116                495  DUMP2    MOVE.L   CN_OVEC(A6),-(A7) Save name of current output device 
00001396                           496  *         MOVE.L   #DCB4,CN_OVEC(A6) Set up Port 2 as output device 
00001396  6100 FCDA                497           BSR      NEWLINE           Send newline to host and wait 
0000139A  617A                     498           BSR.S    DELAY 
0000139C  286E 0104                499           MOVE.L   BUFFPT(A6),A4     Before dumping, send any string 
000013A0  101C                     500  DUMP3    MOVE.B   (A4)+,D0          in the input buffer to the host 
000013A2  6100 01C2                501           BSR      PUTCHAR           Repeat 
000013A6  B03C 000D                502           CMP.B    #CR,D0            Transmit char from buffer to host 
000013AA  66F4                     503           BNE      DUMP3             Until char = C/R 
000013AC  6100 FCC4                504           BSR      NEWLINE 
000013B0  6164                     505           BSR.S    DELAY             Allow time for host to settle 
000013B2  528A                     506           ADDQ.L   #1,A2             A2 contains length of record + 1 
000013B4  240A                     507  DUMP4    MOVE.L   A2,D2             D2 points to end address 
000013B6  948B                     508           SUB.L    A3,D2             D2 contains bytes left to print 
000013B8  B4BC 00000011            509           CMP.L    #17,D2            If this is not a full record of 16 
000013BE  6502                     510           BCS.S    DUMP5             then load D2 with record size 
000013C0  7410                     511           MOVEQ    #16,D2            Else preset byte count to 16 
000013C2  49FA 0909                512  DUMP5    LEA.L    HEADER(PC),A4     Point to record header 
000013C6  6100 FCBA                513           BSR      PSTRING           Print header 
000013CA  4201                     514           CLR.B    D1                Clear checksum 
000013CC  1002                     515           MOVE.B   D2,D0             Move record length to output register 
000013CE  5600                     516           ADD.B    #3,D0             Length includes address + count 
000013D0  612E                     517           BSR.S    DUMP7             Print number of bytes in record 
000013D2  200B                     518           MOVE.L   A3,D0             Get start address to be printed 
000013D4  E158                     519           ROL.W    #8,D0             Get MS byte in LS position 
000013D6  6128                     520           BSR.S    DUMP7             Print MS byte of address 
000013D8  E058                     521           ROR.W    #8,D0             Restore LS byte 
000013DA  6124                     522           BSR.S    DUMP7             Print LS byte of address 
000013DC  101B                     523  DUMP6    MOVE.B   (A3)+,D0          Get data byte to be printed 
000013DE  6120                     524           BSR.S    DUMP7             Print it 
000013E0  5302                     525           SUB.B    #1,D2             Decrement byte count 
000013E2  66F8                     526           BNE      DUMP6             Repeat until all this record printed 
000013E4  4601                     527           NOT.B    D1                Complement checksum 
000013E6  1001                     528           MOVE.B   D1,D0             Move to output register 
000013E8  6116                     529           BSR.S    DUMP7             Print checksum 
000013EA  6100 FC86                530           BSR      NEWLINE 
000013EE  B7CA                     531           CMP.L    A2,A3             Have all records been printed? 
000013F0  66C2                     532           BNE      DUMP4             Repeat until all done 
000013F2  49FA 08DF                533           LEA.L    TAIL(PC),A4       Point to message tail (S9 record) 
000013F6  6100 FC8A                534           BSR      PSTRING           Print it 
000013FA  2D5F 0116                535           MOVE.L   (A7)+,CN_OVEC(A6) Restore name of output device 
000013FE  4E75                     536           RTS                        and return 
00001400                           537  * 
00001400  D200                     538  DUMP7    ADD.B    D0,D1             Update checksum, transmit byte 
00001402  6000 FE10                539           BRA      OUT2X             to host and return 
00001406                           540  * 
00001406  =00001406                541  RANGE    EQU      *                 Get the range of addresses to be 
00001406  4207                     542           CLR.B    D7                transmitted from the buffer 
00001408  6100 FDAC                543           BSR      PARAM             Get starting address 
0000140C  2640                     544           MOVE.L   D0,A3             Set up start address in A3 
0000140E  6100 FDA6                545           BSR      PARAM             Get end address 
00001412  2440                     546           MOVE.L   D0,A2             Set up end address in A2 
00001414  4E75                     547           RTS 
00001416                           548  * 
00001416  =00001416                549  DELAY    EQU       *                Provide a time delay for the host 
00001416  48E7 8008                550           MOVEM.L   D0/A4,-(A7)      to settle. Save working registers 
0000141A  203C 00004000            551           MOVE.L    #$4000,D0        Set up delay constant 
00001420  5380                     552  DELAY1   SUB.L     #1,D0            Count down         (8 clk cycles) 
00001422  66FC                     553           BNE       DELAY1           Repeat until zero  (10 clk cycles) 
00001424  4CDF 1001                554           MOVEM.L   (A7)+,D0/A4      Restore working registers 
00001428  4E75                     555           RTS 
0000142A                           556  * 
0000142A                           557  ************************************************************************* 
0000142A                           558  * 
0000142A                           559  *  TM  Enter transparant mode (All communication to go from terminal to 
0000142A                           560  *  the host processor until escape sequence entered). End sequence 
0000142A                           561  *  = ESC, E. A newline is sent to the host to "clear it down". 
0000142A                           562  * 
0000142A                           563  *TM       MOVE.B    #$55,ACIA_1      Force RTS* high to re-route data 
0000142A                           564  *         ADD.B     #1,ECHO(A6)      Turn off character echo 
0000142A                           565  *TM1      BSR       GETCHAR          Get character 
0000142A                           566  *         CMP.B     #ESC,D0          Test for end of TM mode 
0000142A                           567  *         BNE       TM1              Repeat until first escape character 
0000142A                           568  *         BSR       GETCHAR          Get second character 
0000142A                           569  *         CMP.B     #'E',D0          If second char = E then exit TM 
0000142A                           570  *         BNE       TM1              Else continue 
0000142A                           571  *         MOVE.L    CN_OVEC(A6),-(A7) Save output port device name 
0000142A                           572  *         MOVE.L    #DCB4,CN_OVEC(A6) Get name of host port (aux port) 
0000142A                           573  *         BSR       NEWLINE          Send newline to host to clear it 
0000142A                           574  *         MOVE.L    (A7)+,CN_OVEC(A6) Restore output device port name 
0000142A                           575  *         CLR.B     ECHO(A6)         Restore echo mode 
0000142A                           576  *         MOVE.B    #$15,ACIA_1      Restore normal ACIA mode (RTS* low) 
0000142A                           577  *         RTS 
0000142A                           578  * 
0000142A                           579  ************************************************************************* 
0000142A                           580  * 
0000142A                           581  *  This routine sets up the system DCBs in RAM using the information 
0000142A                           582  *  stored in ROM at address DCB_LST. This is called at initialization. 
0000142A                           583  *  CN_IVEC contains the name "DCB1" and IO_VEC the name "DCB2" 
0000142A                           584  * 
0000142A  48E7 F0F0                585  SET_DCB  MOVEM.L A0-A3/D0-D3,-(A7) Save all working registers 
0000142E  41EE 0194                586           LEA.L   FIRST(A6),A0    Pointer to first DCB destination in RAM 
00001432  43FA 0C0C                587           LEA.L   DCB_LST(PC),A1  A1 points to DCB info block in ROM 
00001436  303C 0003                588           MOVE.W  #3,D0           4 DCBs to set up 
0000143A  323C 000F                589  ST_DCB1  MOVE.W  #15,D1          16 bytes to move per DCB header 
0000143E  10D9                     590  ST_DCB2  MOVE.B  (A1)+,(A0)+     Move the 16 bytes of a DCB header 
00001440  51C9 FFFC                591           DBRA    D1,ST_DCB2      from ROM to RAM 
00001444  3619                     592           MOVE.W  (A1)+,D3        Get size of parameter block (bytes) 
00001446  3083                     593           MOVE.W  D3,(A0)         Store size in DCB in RAM 
00001448  41F0 3002                594           LEA.L   2(A0,D3.W),A0   A0 points to tail of DCB in RAM 
0000144C  47E8 0004                595           LEA.L   4(A0),A3        A3 contains address of next DCB in RAM 
00001450  208B                     596           MOVE.L  A3,(A0)         Store pointer to next DCB in this DCB 
00001452  41D3                     597           LEA.L   (A3),A0         A0 now points at next DCB in RAM 
00001454  51C8 FFE4                598           DBRA    D0,ST_DCB1      Repeat until all DCBs set up 
00001458  47EB FFFC                599           LEA.L   -4(A3),A3       Adjust A3 to point to last DCB pointer 
0000145C  4293                     600           CLR.L   (A3)            and force last pointer to zero 
0000145E  2D7C 00002040 0112       601           MOVE.L  #DCB1,CN_IVEC(A6) Set up vector to console input DCB 
00001466  2D7C 00002052 0116       602           MOVE.L  #DCB2,CN_OVEC(A6) Set up vector to console output DCB 
0000146E  4CDF 0F0F                603           MOVEM.L (A7)+,A0-A3/D0-D3 Restore registers 
00001472  4E75                     604           RTS 
00001474                           605  * 
00001474                           606  ************************************************************************* 
00001474                           607  * 
00001474                           608  *  IO_REQ handles all input/output transactions. A0 points to DCB on 
00001474                           609  *  entry. IO_REQ calls the device driver whose address is in the DCB. 
00001474                           610  * 
00001474  48E7 00C0                611  IO_REQ   MOVEM.L A0-A1,-(A7)     Save working registers 
00001478  43E8 0008                612           LEA.L   8(A0),A1        A1 points to device handler field in DCB 
0000147C  2251                     613           MOVE.L  (A1),A1         A1 contains device handler address 
0000147E  4E91                     614           JSR     (A1)            Call device handler 
00001480  4CDF 0300                615           MOVEM.L (A7)+,A0-A1     Restore working registers 
00001484  4E75                     616           RTS 
00001486                           617  * 
00001486                           618  ************************************************************************* 
00001486                           619  * 
00001486                           620  *  CON_IN handles input from the console device 
00001486                           621  *  This is the device driver used by DCB1. Exit with input in D0 
00001486                           622  * 
00001486  48E7 4040                623  CON_IN   MOVEM.L D1/A1,-(A7)     Save working registers 
0000148A  43E8 000C                624           LEA.L   12(A0),A1       Get pointer to ACIA from DCB 
0000148E  2251                     625           MOVE.L  (A1),A1         Get address of ACIA in A1 
00001490  4228 0013                626           CLR.B   19(A0)          Clear logical error in DCB 
00001494  1211                     627  CON_I1   MOVE.B  (A1),D1         Read ACIA status 
00001496  0801 0000                628           BTST  #0,D1           Test RDRF 
0000149A  67F8                     629           BEQ     CON_I1          Repeat until RDRF true 
0000149C  1141 0012                630           MOVE.B  D1,18(A0)       Store physical status in DCB 
000014A0  C23C 00F4                631           AND.B   #%011110100,D1  Mask to input error bits 
000014A4  6706                     632           BEQ.S   CON_I2          If no error then skip update 
000014A6  117C 0001 0013           633           MOVE.B  #1,19(A0)       Else update logical error 
000014AC  1029 0002                634  CON_I2   MOVE.B  2(A1),D0        Read input from ACIA 
000014B0  4CDF 0202                635           MOVEM.L (A7)+,A1/D1     Restore working registers 
000014B4  4E75                     636           RTS 
000014B6                           637  * 
000014B6                           638  ************************************************************************* 
000014B6                           639  * 
000014B6                           640  *   This is the device driver used by DCB2. Output in D0 
000014B6                           641  *   The output can be halted or suspended 
000014B6                           642  * 
000014B6  48E7 6040                643  CON_OUT  MOVEM.L A1/D1-D2,-(A7)  Save working registers 
000014BA  43E8 000C                644           LEA.L   12(A0),A1       Get pointer to ACIA from DCB 
000014BE  2251                     645           MOVE.L  (A1),A1         Get address of ACIA in A1 
000014C0  4228 0013                646           CLR.B   19(A0)          Clear logical error in DCB 
000014C4  1211                     647  CON_OT1  MOVE.B  (A1),D1         Read ACIA status 
000014C6  0801 0000                648           BTST  #0,D1           Test RDRF bit (any input?) 
000014CA  6716                     649           BEQ.S   CON_OT3         If no input then test output status 
000014CC  1429 0002                650           MOVE.B  2(A1),D2        Else read the input 
000014D0  C43C 005F                651           AND.B   #%01011111,D2   Strip parity and bit 5 
000014D4  B43C 0057                652           CMP.B   #WAIT,D2        and test for a wait condition 
000014D8  6608                     653           BNE.S   CON_OT3         If not wait then ignore and test O/P 
000014DA  1411                     654  CON_OT2  MOVE.B  (A1),D2         Else read ACIA status register 
000014DC  0802 0000                655           BTST  #0,D2           and poll ACIA until next char received 
000014E0  67F8                     656           BEQ     CON_OT2 
000014E2  0801 0001                657  CON_OT3  BTST  #1,D1           Repeat 
000014E6  67DC                     658           BEQ     CON_OT1          until ACIA Tx ready 
000014E8  1141 0012                659           MOVE.B  D1,18(A0)       Store status in DCB physical error 
000014EC  1340 0002                660           MOVE.B  D0,2(A1)        Transmit output 
000014F0  4CDF 0206                661           MOVEM.L (A7)+,A1/D1-D2  Restore working registers 
000014F4  4E75                     662           RTS 
000014F6                           663  * 
000014F6                           664  ************************************************************************* 
000014F6                           665  * 
000014F6                           666  *  AUX_IN and AUX_OUT are simplified versions of CON_IN and 
000014F6                           667  *  CON_OUT for use with the port to the host processor 
000014F6                           668  * 
000014F6  43E8 000C                669  AUX_IN   LEA.L   12(A0),A1       Get pointer to aux ACIA from DCB 
000014FA  2251                     670           MOVE.L  (A1),A1         Get address of aux ACIA 
000014FC  0811 0000                671  AUX_IN1  BTST.B  #0,(A1)         Test for data ready 
00001500  67FA                     672           BEQ     AUX_IN1         Repeat until ready 
00001502  1029 0002                673           MOVE.B  2(A1),D0        Read input 
00001506  4E75                     674           RTS 
00001508                           675  * 
00001508  43E8 000C                676  AUX_OUT  LEA.L   12(A0),A1       Get pointer to aux ACIA from DCB 
0000150C  2251                     677           MOVE.L  (A1),A1         Get address of aux ACIA 
0000150E  0811 0001                678  AUX_OT1  BTST.B  #1,(A1)         Test for ready to transmit 
00001512  67FA                     679           BEQ     AUX_OT1         Repeat until transmitter ready 
00001514  1340 0002                680           MOVE.B  D0,2(A1)        Transmit data 
00001518  4E75                     681           RTS 
0000151A                           682  * 
0000151A                           683  ************************************************************************* 
0000151A                           684  * 
0000151A                           685  *  GETCHAR gets a character from the console device 
0000151A                           686  *  This is the main input routine and uses the device whose name  
0000151A                           687  *  is stored in CN_IVEC. Changing this name redirects input. 
0000151A                           688  * 
0000151A  2F08                     689  GETCHAR  MOVE.L  A0,-(A7)        Save working register 
0000151C  206E 0112                690           MOVE.L  CN_IVEC(A6),A0  A0 points to name of console DCB 
00001520  616A                     691           BSR.S   IO_OPEN         Open console (get DCB address in A0) 
00001522  0807 0003                692           BTST    #3,D7           D7(3) set if open error 
00001526  6628                     693           BNE.S   GETCH3          If error then exit now 
00001528  6100 FF4A                694           BSR     IO_REQ          Else execute I/O transaction 
0000152C  C03C 007F                695           AND.B   #$7F,D0         Strip msb of input 
00001530  4A2E 010D                696           TST.B   U_CASE(A6)      Test for upper -> lower case conversion 
00001534  660A                     697           BNE.S   GETCH2          If flag not zero do not convert case 
00001536  0800 0006                698           BTST    #6,D0           Test input for lower case 
0000153A  6704                     699           BEQ.S   GETCH2          If upper case then skip conversion 
0000153C  C03C 00DF                700           AND.B   #%11011111,D0   Else clear bit 5 for upper case conv 
00001540  4A2E 010C                701  GETCH2   TST.B   ECHO(A6)        Do we need to echo the input? 
00001544  660A                     702           BNE.S   GETCH3          If ECHO not zero then no echo
00001546  BC3C 0001                703           CMP.B   #1,D6
0000154A  6700 0008                704           BEQ     PUTASK
0000154E  6116                     705           BSR.S   PUTCHAR         Else echo the input 
00001550  205F                     706  GETCH3   MOVE.L  (A7)+,A0        Restore working register 
00001552  4E75                     707           RTS                     and return 
00001554                           708  
00001554  1600                     709  PUTASK   MOVE.B  D0,D3           save D0
00001556  B07C 000D                710           CMP     #CR,D0
0000155A  6700 001E                711           BEQ     SPUTCHAR
0000155E  103C 002A                712           MOVE.B  #42,D0
00001562  6000 0016                713           BRA    SPUTCHAR
00001566                           714  
00001566                           715  * 
00001566                           716  ************************************************************************* 
00001566                           717  * 
00001566                           718  *  PUTCHAR sends a character to the console device 
00001566                           719  *  The name of the output device is in CN_OVEC. 
00001566                           720  * 
00001566  BC3C 0001                721  PUTCHAR  CMP.B   #1,D6
0000156A                           722           ;BEQ     PUTASK
0000156A  2F08                     723           MOVE.L  A0,-(A7)        Save working register
0000156C  206E 0116                724           MOVE.L  CN_OVEC(A6),A0  A0 points to name of console output 
00001570  611A                     725           BSR.S   IO_OPEN         Open console (Get address of DCB) 
00001572  6100 FF00                726           BSR     IO_REQ          Perform output with DCB pointed at by A0 
00001576  205F                     727           MOVE.L  (A7)+,A0        Restore working register 
00001578  4E75                     728           RTS 
0000157A                           729  
0000157A  2F08                     730  SPUTCHAR  MOVE.L  A0,-(A7)        Save working register
0000157C  206E 0116                731            MOVE.L  CN_OVEC(A6),A0  A0 points to name of console output 
00001580  610A                     732            BSR.S   IO_OPEN         Open console (Get address of DCB) 
00001582  6100 FEF0                733            BSR     IO_REQ          Perform output with DCB pointed at by A0 
00001586  205F                     734            MOVE.L  (A7)+,A0        Restore working register
00001588  1003                     735            MOVE.B  D3,D0           restore d0
0000158A  60C4                     736            BRA     GETCH3 
0000158C                           737  
0000158C                           738  
0000158C                           739  * 
0000158C                           740  * 
0000158C                           741  ************************************************************************* 
0000158C                           742  * 
0000158C                           743  *  BUFF_IN and BUFF_OUT are two rudimentary input and output routines 
0000158C                           744  *  which input data from and output data to a buffer in RAM. These are 
0000158C                           745  *  used by DCB5 and DCB6, respectively. 
0000158C                           746  * 
0000158C                           747  *BUFF_IN  LEA.L   12(A0),A1       A1 points to I/P buffer 
0000158C                           748  *         MOVE.L  (A1),A2         A2 gets I/P pointer from buffer 
0000158C                           749  *         MOVE.B  -(A2),D0        Read char from buffer and adjust A2 
0000158C                           750  *         MOVE.L  A2,(A1)         Restore pointer in buffer 
0000158C                           751  *         RTS 
0000158C                           752  * 
0000158C                           753  *BUFF_OT  LEA.L   12(A0),A1       A1 points to O/P buffer 
0000158C                           754  *         MOVE.L  4(A1),A2        A2 gets O/P pointer from buffer 
0000158C                           755  *         MOVE.B  D0,(A2)+        Store char in buffer and adjust A2 
0000158C                           756  *         MOVE.L  A2,(A1)         Restore pointer in buffer 
0000158C                           757  *         RTS 
0000158C                           758  * 
0000158C                           759  ************************************************************************* 
0000158C                           760  * 
0000158C                           761  *  Open - opens a DCB for input or output. IO_OPEN converts the 
0000158C                           762  *  name pointed at by A0 into the address of the DCB pointed at 
0000158C                           763  *  by A0. Bit 3 of D7 is set to zero if DCB not found 
0000158C                           764  * 
0000158C  48E7 F870                765  IO_OPEN  MOVEM.L  A1-A3/D0-D4,-(A7) Save working registers 
00001590  43EE 0194                766           LEA.L    FIRST(A6),A1   A1 points to first DCB in chain in RAM 
00001594  45D1                     767  OPEN1    LEA.L    (A1),A2        A2 = temp copy of pointer to DCB 
00001596  47D0                     768           LEA.L    (A0),A3        A3 = temp copy of pointer to DCB name 
00001598  303C 0007                769           MOVE.W   #7,D0          Up to 8 chars of DCB name to match 
0000159C  181A                     770  OPEN2    MOVE.B   (A2)+,D4       Compare DCB name with string 
0000159E  B81B                     771           CMP.B    (A3)+,D4 
000015A0  6608                     772           BNE.S    OPEN3          If no match try next DCB 
000015A2  51C8 FFF8                773           DBRA     D0,OPEN2       Else repeat until all chars matched 
000015A6  41D1                     774           LEA.L    (A1),A0        Success - move this DCB address to A0 
000015A8  6016                     775           BRA.S    OPEN4          and return 
000015AA  =000015AA                776  OPEN3    EQU      *              Fail - calculate address of next DCB 
000015AA  3229 0010                777           MOVE.W   16(A1),D1      Get parameter block size of DCB 
000015AE  43F1 1012                778           LEA.L    18(A1,D1.W),A1 A1 points to pointer to next DCB 
000015B2  2251                     779           MOVE.L   (A1),A1        A1 now points to next DCB 
000015B4  B3FC 00000000            780           CMP.L    #0,A1          Test for end of DCB chain 
000015BA  66D8                     781           BNE      OPEN1          If not end of chain then try next DCB 
000015BC  8E3C 0008                782           OR.B     #8,D7          Else set error flag and return 
000015C0  4CDF 0E1F                783  OPEN4    MOVEM.L  (A7)+,A1-A3/D0-D4 Restore working registers 
000015C4  4E75                     784           RTS 
000015C6                           785  * 
000015C6                           786  ************************************************************************* 
000015C6                           787  * 
000015C6                           788  *  Exception vector table initialization routine 
000015C6                           789  *  All vectors not setup are loaded with uninitialized routine vector 
000015C6                           790  * 
000015C6  303C 0007                791  B_CLR   MOVE.W  #7,D0             Now clear the breakpoint table 
000015CA  41EE 0164                792          LEA.L   BP_TAB(A6),A0     Point to table
000015CE  4E75                     793          RTS 
000015D0                           794  *X_SET2  CLR.L   (A0)+             Clear an address entry 
000015D0                           795  *        CLR.W   (A0)+             Clear the corresponding data 
000015D0                           796  *        DBRA    D0,X_SET2         Repeat until all 8 cleared 
000015D0                           797  *        RTS 
000015D0                           798  * 
000015D0                           799  *************************************************************************
000015D0                           800  ADD_0   
000015D0  DA04                     801          ADD.B     D4,D5
000015D2  1605                     802          MOVE.B    D5,D3
000015D4  183C 0000                803          MOVE.B    #0,D4           resetting neg flag
000015D8  6B00 0040                804          BMI       SETNEG
000015DC                           805  *        LEA.L     BANNER,A4
000015DC                           806  *        BRA       PSTRING
000015DC  4E75                     807          RTS
000015DE                           808  
000015DE  9A04                     809  SUB_0   SUB.B     D4,D5
000015E0  183C 0000                810          MOVE.B    #0,D4           resetting neg flag
000015E4  1605                     811          MOVE.B    D5,D3
000015E6  6B00 0032                812          BMI       SETNEG
000015EA  4E75                     813          RTS
000015EC                           814          
000015EC  CBC4                     815  MUL_0   MULS      D4,D5
000015EE  383C 0000                816          MOVE.W    #0,D4           resetting neg flag
000015F2  2605                     817          MOVE.L    D5,D3
000015F4  6B00 0034                818          BMI       MULNEG
000015F8  4E75                     819          RTS
000015FA                           820  
000015FA  8BC4                     821  DIV_0   DIVS      D4,D5
000015FC  183C 0000                822          MOVE.B    #0,D4           resetting neg flag
00001600  1605                     823          MOVE.B    D5,D3
00001602  4603                     824          NOT.B     D3
00001604  C63C 007F                825          AND.B     #%01111111,D3
00001608  5203                     826          ADD.B     #1,D3
0000160A  BA7C 007F                827          CMP.W     #127,D5
0000160E  6500 0004                828          BCS       DIVNEG
00001612  4E75                     829          RTS
00001614                           830  
00001614  183C 0001                831  DIVNEG  MOVE.B    #1,D4
00001618  4E75                     832          RTS
0000161A                           833  
0000161A  183C 00FF                834  SETNEG  MOVE.B    #255,D4
0000161E  9803                     835          SUB.B     D3,D4
00001620  1604                     836          MOVE.B    D4,D3
00001622  5203                     837          ADD.B     #1,D3
00001624  183C 0001                838          MOVE.B    #1,D4
00001628  4E75                     839          RTS
0000162A                           840  
0000162A  183C 0001                841  MULNEG  MOVE.B    #1,D4
0000162E  4683                     842          NOT.L     D3
00001630  C6BC 7FFFFFFF            843          AND.L     #%01111111111111111111111111111111,D3
00001636  5203                     844          ADD.B     #1,D3
00001638  4E75                     845          RTS
0000163A                           846  
0000163A                           847  ************************************************************************* 
0000163A                           848  * 
0000163A                           849  * 
0000163A  =0000163A                850  TRAP_0  EQU     *                 User links to  TS2BUG via TRAP #0 
0000163A  B23C 0000                851          CMP.B   #0,D1             D1 = 0 = Get character 
0000163E  6606                     852          BNE.S   FOO1           
00001640  6100 FED8                853          BSR     GETCHAR 
00001644  4E73                     854          RTE 
00001646  B23C 0001                855  FOO1    CMP.B   #1,D1             D1 = 1 = Print character 
0000164A  6606                     856          BNE.S   FOO2 
0000164C  6100 FF18                857          BSR     PUTCHAR 
00001650  4E73                     858          RTE 
00001652  B23C 0002                859  FOO2    CMP.B   #2,D1             D1 = 2 = Newline 
00001656  6606                     860          BNE.S   FOO3 
00001658  6100 FA18                861          BSR     NEWLINE 
0000165C  4E73                     862          RTE 
0000165E  B23C 0003                863  FOO3    CMP.B   #3,D1             D1 = 3 = Get parameter from buffer 
00001662  6606                     864          BNE.S   FOO4 
00001664  6100 FB50                865          BSR     PARAM 
00001668  4E73                     866          RTE 
0000166A  B23C 0004                867  FOO4    CMP.B   #4,D1             D1 = 4 = Print string pointed at by A4 
0000166E  6606                     868          BNE.S   FOO5 
00001670  6100 FA10                869          BSR     PSTRING 
00001674  4E73                     870          RTE 
00001676  B23C 0005                871  FOO5    CMP.B   #5,D1             D1 = 5 = Get a hex character 
0000167A  6606                     872          BNE.S   FOO6 
0000167C  6100 FAFE                873          BSR     HEX 
00001680  4E73                     874          RTE 
00001682  B23C 0006                875  FOO6    CMP.B   #6,D1             D1 = 6 = Get a hex byte 
00001686  6606                     876          BNE.S   FOO7 
00001688  6100 FB10                877          BSR     BYTE 
0000168C  4E73                     878          RTE 
0000168E  B23C 0007                879  FOO7    CMP.B   #7,D1             D1 = 7 = Get a word 
00001692  6606                     880          BNE.S   FOO8 
00001694  6100 FB14                881          BSR     WORD 
00001698  4E73                     882          RTE 
0000169A  B23C 0008                883  FOO8    CMP.B   #8,D1             D1 = 8 = Get a longword 
0000169E  6606                     884          BNE.S   FOO9 
000016A0  6100 FB0E                885          BSR     LONGWD 
000016A4  4E73                     886          RTE 
000016A6  B23C 0009                887  FOO9    CMP.B   #9,D1             D1 = 9 = Output hex byte 
000016AA  6606                     888          BNE.S   FOO10  
000016AC  6100 FB66                889          BSR     OUT2X 
000016B0  4E73                     890          RTE 
000016B2  B23C 000A                891  FOO10   CMP.B   #10,D1            D1 = 10 = Output hex word 
000016B6  6606                     892          BNE.S   FOO11 
000016B8  6100 FB62                893          BSR     OUT4X 
000016BC  4E73                     894          RTE 
000016BE  B23C 000B                895  FOO11   CMP.B   #11,D1            D1 = 11 = Output hex longword 
000016C2  6606                     896          BNE.S   FOO12 
000016C4  6100 FB5E                897          BSR     OUT8X 
000016C8  4E73                     898          RTE 
000016CA  B23C 000C                899  FOO12   CMP.B   #12,D1            D1 = 12 = Print a space 
000016CE  6606                     900          BNE.S   FOO13 
000016D0  6100 FBC2                901          BSR     PSPACE 
000016D4  4E73                     902          RTE 
000016D6  B23C 000D                903  FOO13   CMP.B   #13,D1            D1 = 13 = Get a line of text into 
000016DA  6606                     904          BNE.S   FOO14            the line buffer 
000016DC  6100 F9BA                905          BSR     GETLINE 
000016E0  4E73                     906          RTE 
000016E2  B23C 000E                907  FOO14   CMP.B   #14,D1            D1 = 14 = Tidy up the line in the 
000016E6  6606                     908          BNE.S   FOO15            line buffer by removing leading 
000016E8  6100 F9E4                909          BSR     TIDY              leading and multiple embeded spaces 
000016EC  4E73                     910          RTE 
000016EE  B23C 000F                911  FOO15   CMP.B   #15,D1            D1 = 15 = Execute the command in 
000016F2  6606                     912          BNE.S   FOO16            the line buffer 
000016F4  6100 FA1A                913          BSR     EXECUTE 
000016F8  4E73                     914          RTE 
000016FA  B23C 0010                915  FOO16   CMP.B   #16,D1            D1 = 16 = Call RESTORE to transfer 
000016FE  6606                     916          BNE.S   FOO17            the registers in TSK_T to the 68000 
00001700  6100 03A6                917          BSR     RESTORE           and therefore execute a program 
00001704  4E73                     918          RTE 
00001706  B23C 0011                919  FOO17   CMP.B   #17,D1            D1 = 17 = Call ADD_0
0000170A  6606                     920          BNE.S   FOO18            
0000170C  6100 FEC2                921          BSR     ADD_0            
00001710  4E73                     922          RTE 
00001712  B23C 0012                923  FOO18   CMP.B   #18,D1            D1 = 18 = Call SUB_0
00001716  6606                     924          BNE.S   FOO19            
00001718  6100 FEC4                925          BSR     SUB_0            
0000171C  4E73                     926          RTE 
0000171E  B23C 0013                927  FOO19   CMP.B   #19,D1            D1 = 19 = Call MUL_0
00001722  6606                     928          BNE.S   FOO20            
00001724  6100 FEC6                929          BSR     MUL_0            
00001728  4E73                     930          RTE 
0000172A  B23C 0014                931  FOO20   CMP.B   #20,D1            D1 = 20 = Call DIV_0
0000172E  6606                     932          BNE.S   FOO21            
00001730  6100 FEC8                933          BSR     DIV_0            
00001734  4E73                     934          RTE
00001736  B23C 0015                935  FOO21   CMP.B   #21,D1
0000173A  6618                     936          BNE.S   FOO22
0000173C  6100 F95A                937          BSR     GETLINE
00001740  1219                     938          MOVE.B  (A1)+,D1
00001742  1611                     939          MOVE.B  (A1),D3
00001744  0441 0030                940          subi    #48,d1
00001748  0443 0030                941          subi    #48,d3   
0000174C  C2FC 000A                942          MULU    #10,D1
00001750  D601                     943          ADD.B   D1,D3
00001752  4E73                     944          RTE
00001754  B23C 0016                945  FOO22   CMP.B   #22,D1
00001758  660A                     946          BNE.S   FOO23
0000175A  6100 F916                947          BSR     NEWLINE
0000175E  1003                     948          MOVE.B  D3,D0
00001760  6100 FAB2                949          BSR     OUT2X
00001764  B23C 0017                950  FOO23   CMP.B   #23,D1
00001768  660A                     951          BNE.S   FOO24
0000176A  6100 F906                952          BSR     NEWLINE
0000176E  1003                     953          MOVE.B  D3,D0
00001770  6100 FAAA                954          BSR     OUT4X
00001774  4E73                     955  FOO24   RTE         
00001776                           956  * 
00001776                           957  ************************************************************************* 
00001776  =00001776                958  TRAP_14  EQU     *
00001776  6000 028C                959           BRA     BRKPT            User application breakpoint
0000177A  4E73                     960           RTE
0000177C                           961  *
0000177C                           962  ************************************************************************* 
0000177C  6000 F8CE                963  TRAP_15  BRA     WARM              
00001780  4E73                     964           RTE
00001782                           965  *
00001782                           966  ************************************************************************* 
00001782                           967  * 
00001782                           968  *  Display exception frame (D0 - D7, A0 - A6, USP, SSP, SR, PC) 
00001782                           969  *  EX_DIS prints registers saved after a breakpoint or exception 
00001782                           970  *  The registers are saved in TSK_T 
00001782                           971  * 
00001782  4BEE 011A                972  EX_DIS  LEA.L   TSK_T(A6),A5      A5 points to display frame 
00001786  49FA 056C                973          LEA.L   MES3(PC),A4       Point to heading 
0000178A  6100 F906                974          BSR     HEADING           and print it 
0000178E  3C3C 0007                975          MOVE.W  #7,D6             8 pairs of registers to display 
00001792  4205                     976          CLR.B   D5                D5 is the line counter 
00001794  1005                     977  EX_D1   MOVE.B  D5,D0             Put current register number in D0 
00001796  6100 FA62                978          BSR     OUT1X             and print it 
0000179A  6100 FAF8                979          BSR     PSPACE            and a space 
0000179E  5205                     980          ADD.B   #1,D5             Update counter for next pair 
000017A0  2015                     981          MOVE.L  (A5),D0           Get data register to be displayed 
000017A2  6100 FA80                982          BSR     OUT8X             from the frame and print it 
000017A6  49FA 056A                983          LEA.L   MES4(PC),A4       Print string of spaces 
000017AA  6100 F8D6                984          BSR.L   PSTRING           between data and address registers 
000017AE  202D 0020                985          MOVE.L  32(A5),D0         Get address register to be displayed 
000017B2  6100 FA70                986          BSR     OUT8X             which is 32 bytes on from data reg 
000017B6  6100 F8BA                987          BSR     NEWLINE 
000017BA  4BED 0004                988          LEA.L   4(A5),A5          Point to next pair (ie Di, Ai) 
000017BE  51CE FFD4                989          DBRA    D6,EX_D1          Repeat until all displayed 
000017C2  4BED 0020                990          LEA.L   32(A5),A5         Adjust pointer by 8 longwords 
000017C6  6100 F8AA                991          BSR     NEWLINE           to point to SSP 
000017CA  49FA 051F                992          LEA.L   MES2A(PC),A4      Point to "SS =" 
000017CE  6100 F8B2                993          BSR     PSTRING           Print it 
000017D2  201D                     994          MOVE.L  (A5)+,D0          Get SSP from frame 
000017D4  6100 FA4E                995          BSR     OUT8X             and display it 
000017D8  6100 F898                996          BSR     NEWLINE 
000017DC  49FA 04FB                997          LEA.L   MES1(PC),A4       Point to 'SR =' 
000017E0  6100 F8A0                998          BSR     PSTRING           Print it 
000017E4  301D                     999          MOVE.W  (A5)+,D0          Get status register 
000017E6  6100 FA34               1000          BSR     OUT4X             Display status 
000017EA  6100 F886               1001          BSR     NEWLINE 
000017EE  49FA 04F2               1002          LEA.L   MES2(PC),A4       Point to 'PC =' 
000017F2  6100 F88E               1003          BSR     PSTRING           Print it 
000017F6  201D                    1004          MOVE.L  (A5)+,D0          Get PC 
000017F8  6100 FA2A               1005          BSR     OUT8X             Display PC 
000017FC  6000 F874               1006          BRA     NEWLINE           Newline and return 
00001800                          1007  * 
00001800                          1008  ************************************************************************* 
00001800                          1009  
00001800  49F9 00001E39           1010  HELP     LEA.L    JUMPHELP,A4
00001806  6100 F87A               1011           BSR.W    PSTRING
0000180A  6100 F866               1012           BSR.W    NEWLINE
0000180E  49F9 00001E6F           1013           LEA.L    MEMHELP,A4
00001814  6100 F86C               1014           BSR.W    PSTRING
00001818  6100 F858               1015           BSR.W    NEWLINE
0000181C  49F9 00001EBC           1016           LEA.L    LOADHELP,A4
00001822  6100 F85E               1017           BSR.W    PSTRING
00001826  6100 F84A               1018           BSR.W    NEWLINE
0000182A  49F9 00001F06           1019           LEA.L    TVHELP,A4
00001830  6100 F850               1020           BSR.W    PSTRING
00001834  4E75                    1021           RTS
00001836                          1022  
00001836                          1023  *      
00001836                          1024  *************************************************************************
00001836  B83C 0002               1025  LOGIN    CMP.B    #2,D4
0000183A  6700 00C2               1026           BEQ      QUIT
0000183E  49F9 00001F73           1027           LEA.L    LOGINM1,A4
00001844  6100 F83C               1028           BSR.W    PSTRING           
00001848  6100 F828               1029           BSR.W    NEWLINE
0000184C  6100 F84A               1030           BSR      GETLINE
00001850  49F9 00001F65           1031           LEA.L    UNAME,A4
00001856  1A19                    1032  LOGIN1   MOVE.B   (A1)+,D5
00001858  BA1C                    1033           CMP.B    (A4)+,D5
0000185A  67FA                    1034           BEQ      LOGIN1            iterate through checking each char
0000185C  0C21 000D               1035           CMP.B    #CR,-(A1)         check for carriage return
00001860  6600 006A               1036           BNE      WRONG             if not then wrong input
00001864  0C24 0000               1037           CMP.B    #NUL,-(A4)        check for end of stored string
00001868  6600 0062               1038           BNE      WRONG             if not then wrong input
0000186C  49F9 00001FBB           1039           LEA.L    USRSUC,A4         print success
00001872  6100 F80E               1040           BSR.W    PSTRING
00001876  6100 F7FA               1041           BSR.W    NEWLINE
0000187A  49F9 00001F84           1042           LEA.L    LOGINM2,A4
00001880  6100 F800               1043           BSR.W    PSTRING
00001884  6100 F7EC               1044           BSR.W    NEWLINE
00001888  1C3C 0001               1045           MOVE.B   #1,D6
0000188C  6100 F80A               1046           BSR.W    GETLINE
00001890  1C3C 0000               1047           MOVE.B   #0,D6
00001894  49F9 00001F6A           1048           LEA.L    PWORD,A4
0000189A  1A19                    1049  LOGIN2   MOVE.B   (A1)+,D5
0000189C  BA1C                    1050           CMP.B    (A4)+,D5
0000189E  67FA                    1051           BEQ      LOGIN2            iterate through checking each char
000018A0  0C21 000D               1052           CMP.B    #CR,-(A1)          check for carriage return
000018A4  6600 003A               1053           BNE      WRONGPW             if not then wrong input
000018A8  0C24 0000               1054           CMP.B    #NUL,-(A4)            check for end of stored string
000018AC  6600 0032               1055           BNE      WRONGPW             if not then wrong input
000018B0  49F9 00001FDF           1056           LEA.L    PWSUC,A4
000018B6  6000 F7CA               1057           BRA      PSTRING
000018BA  49F9 00001F73           1058           LEA.L    LOGINM1,A4
000018C0  6100 F7C0               1059           BSR.W    PSTRING           print success
000018C4  6100 F7AC               1060           BSR.W    NEWLINE
000018C8  6000 F782               1061           BRA      WARM
000018CC                          1062  
000018CC  49F9 00001F95           1063  WRONG    LEA.L    USRERR,A4   
000018D2  6100 F7AE               1064           BSR.W    PSTRING
000018D6  6100 F79A               1065           BSR.W    NEWLINE
000018DA  5204                    1066           ADD.B    #1,D4
000018DC  6000 FF58               1067           BRA      LOGIN
000018E0                          1068  
000018E0  49F9 00001FCC           1069  WRONGPW  LEA.L    PWERR,A4   
000018E6  6100 F79A               1070           BSR.W    PSTRING
000018EA  6100 F786               1071           BSR.W    NEWLINE
000018EE  5204                    1072           ADD.B    #1,D4
000018F0  6000 FF44               1073           BRA      LOGIN
000018F4                          1074  
000018F4  49F9 00001FBB           1075  UPASS    LEA.L    USRSUC,A4
000018FA  6000 F786               1076           BRA      PSTRING  
000018FE                          1077  
000018FE  4EF8 18FE               1078  QUIT     JMP      QUIT
00001902                          1079  
00001902                          1080  *
00001902                          1081  ************************************************************************* 
00001902  2878 0494               1082  TV       MOVE.L   MIN_RAM,A4
00001906  1C3C 0000               1083           MOVE.B   #0,D6
0000190A  323C 0000               1084  LOOPRAM  MOVE.W   #0,D1
0000190E  3881                    1085           MOVE.W   D1,(A4)
00001910  49EC 0002               1086           LEA.L    2(A4),A4          Point to next address to display
00001914  B9F8 0498               1087           CMP.L    MAX_RAM,A4
00001918  66F0                    1088           BNE      LOOPRAM
0000191A  2878 0494               1089           MOVE.L   MIN_RAM,A4
0000191E  3214                    1090  CHECK1   MOVE.W   (A4),D1
00001920  B27C 0000               1091           CMP.W    #0,D1
00001924  6600 0042               1092           BNE      MEMFAIL           
00001928  49EC 0002               1093  CHECK2   LEA.L    2(A4),A4          Point to next address to read
0000192C  B9F8 0498               1094           CMP.L    MAX_RAM,A4
00001930  66EC                    1095           BNE      CHECK1
00001932  2878 0494               1096           MOVE.L   MIN_RAM,A4
00001936  323C FFFF               1097  LOOPRAM1 MOVE.W   #65535,D1
0000193A  3881                    1098           MOVE.W   D1,(A4)
0000193C  49EC 0002               1099           LEA.L    2(A4),A4          Point to next address to display
00001940  B9F8 0498               1100           CMP.L    MAX_RAM,A4
00001944  66F0                    1101           BNE      LOOPRAM1
00001946  2878 0494               1102           MOVE.L   MIN_RAM,A4
0000194A  3214                    1103  CHECK3   MOVE.W   (A4),D1
0000194C  B27C FFFF               1104           CMP.W    #65535,D1
00001950  6600 0032               1105           BNE      MEMFAIL2
00001954  49EC 0002               1106  CHECK4   LEA.L    2(A4),A4          Point to next address to read
00001958  B9F8 0498               1107           CMP.L    MAX_RAM,A4
0000195C  66EC                    1108           BNE      CHECK3
0000195E  BC3C 0000               1109           CMP.B    #0,D6
00001962  6700 003C               1110           BEQ      MEMGOOD
00001966  4E75                    1111           RTS
00001968                          1112  
00001968  2F0C                    1113  MEMFAIL  MOVE.L  A4,-(A7)          Save A4 
0000196A  7C01                    1114           MOVE.L  #1,D6
0000196C  6100 F704               1115           BSR.W   NEWLINE
00001970  49F9 00001FF0           1116           LEA.L   MEMFMSG,A4
00001976  6100 F70A               1117           BSR.W   PSTRING
0000197A  285F                    1118           MOVE.L  (A7)+,A4          Restore A4
0000197C  200C                    1119           MOVE.L  A4,D0
0000197E  6100 F8A4               1120           BSR.W    OUT8X 
00001982  60A4                    1121           BRA     CHECK2
00001984                          1122  
00001984  2F0C                    1123  MEMFAIL2 MOVE.L  A4,-(A7)          Save A4 
00001986  7C01                    1124           MOVE.L  #1,D6
00001988  6100 F6E8               1125           BSR.W   NEWLINE
0000198C  49F9 00001FF0           1126           LEA.L   MEMFMSG,A4
00001992  6100 F6EE               1127           BSR.W   PSTRING
00001996  285F                    1128           MOVE.L  (A7)+,A4          Restore A4
00001998  200C                    1129           MOVE.L  A4,D0
0000199A  6100 F888               1130           BSR.W    OUT8X 
0000199E  60B4                    1131           BRA     CHECK4         
000019A0                          1132   
000019A0  49F9 00002000           1133  MEMGOOD  LEA.L  MEMGMSG,A4
000019A6  6100 F6DA               1134           BSR.W  PSTRING
000019AA  4E75                    1135           RTS
000019AC                          1136  *************************************************************************
000019AC                          1137  * 
000019AC                          1138  *  Exception handling routines 
000019AC                          1139  * 
000019AC                          1140  *************************************************************************         
000019AC                          1141  * 
000019AC                          1142  *  Exception handling routines 
000019AC                          1143  * 
000019AC  =000019AC               1144  IL_ER   EQU      *                Illegal instruction exception 
000019AC  2F0C                    1145          MOVE.L  A4,-(A7)          Save A4 
000019AE  49FA 038C               1146          LEA.L   MES10(PC),A4      Point to heading 
000019B2  6100 F6DE               1147          BSR     HEADING           Print it 
000019B6  285F                    1148          MOVE.L  (A7)+,A4          Restore A4 
000019B8  6100 009C               1149          BSR.W   GROUP2            Save registers in display frame 
000019BC  6100 FDC4               1150          BSR     EX_DIS            Display registers saved in frame 
000019C0  6000 F68A               1151          BRA     WARM              Abort from illegal instruction 
000019C4                          1152  * 
000019C4  =000019C4               1153  BUS_ER  EQU     *                 Bus error (group 1) exception 
000019C4  2F0C                    1154          MOVE.L  A4,-(A7)          Save A4 
000019C6  49FA 0354               1155          LEA.L   MES8(PC),A4       Point to heading 
000019CA  6100 F6C6               1156          BSR     HEADING           Print it 
000019CE  285F                    1157          MOVE.L  (A7)+,A4          Restore A4  
000019D0  6050                    1158          BRA.S   GROUP1            Deal with group 1 exception 
000019D2                          1159  * 
000019D2  =000019D2               1160  ADD_ER  EQU     *                 Address error (group 1) exception 
000019D2  2F0C                    1161          MOVE.L  A4,-(A7)          Save A4 
000019D4  49FA 0354               1162          LEA.L   MES9(PC),A4       Point to heading 
000019D8  6100 F6B8               1163          BSR     HEADING           Print it 
000019DC  285F                    1164          MOVE.L  (A7)+,A4          Restore A4
000019DE  6042                    1165          BRA.S   GROUP1            Deal with group 1 exception 
000019E0                          1166  * 
000019E0  =000019E0               1167  DIV0_ER  EQU     *                   Divide By Zero Exception
000019E0  2F0C                    1168          MOVE.L  A4,-(A7)          Save A4 
000019E2  49FA 0385               1169          LEA.L   MES13(PC),A4       Point to heading 
000019E6  6100 F6AA               1170          BSR     HEADING           Print it 
000019EA  285F                    1171          MOVE.L  (A7)+,A4          Restore A4
000019EC  6034                    1172          BRA.S   GROUP1            Deal with group 1 exception 
000019EE                          1173  *
000019EE  =000019EE               1174  PRIV_ER   EQU     *                 Privilege Violation Exception
000019EE  2F0C                    1175          MOVE.L  A4,-(A7)          Save A4 
000019F0  49FA 038C               1176          LEA.L   MES14(PC),A4      Point to heading 
000019F4  6100 F69C               1177          BSR     HEADING           Print it 
000019F8  285F                    1178          MOVE.L  (A7)+,A4          Restore A4
000019FA  6100 FD86               1179          BSR     EX_DIS
000019FE  6000 F64C               1180          BRA     WARM
00001A02  601E                    1181          BRA.S   GROUP1            Deal with group 1 exception 
00001A04                          1182  * 
00001A04  =00001A04               1183  BRKPT   EQU     *                   Deal with breakpoint 
00001A04  48E7 FFFE               1184          MOVEM.L D0-D7/A0-A6,-(A7)   Save all registers 
00001A08  6100 0180               1185          BSR     BR_CLR              Clear breakpoints in code 
00001A0C  4CDF 7FFF               1186          MOVEM.L (A7)+,D0-D7/A0-A6   Restore registers 
00001A10  6144                    1187          BSR.S   GROUP2            Treat as group 2 exception 
00001A12  49FA 033E               1188          LEA.L   MES11(PC),A4      Point to heading 
00001A16  6100 F67A               1189          BSR     HEADING           Print it 
00001A1A  6100 FD66               1190          BSR     EX_DIS            Display saved registers 
00001A1E  6000 F62C               1191          BRA     WARM              Return to monitor 
00001A22                          1192  * 
00001A22                          1193  *       GROUP1 is called by address and bus error exceptions 
00001A22                          1194  *       These are "turned into group 2" exceptions (eg TRAP) 
00001A22                          1195  *       by modifying the stack frame saved by a group 1 exception 
00001A22                          1196  * 
00001A22  48E7 8080               1197  GROUP1  MOVEM.L D0/A0,-(A7)       Save working registers 
00001A26  206F 0012               1198          MOVE.L  18(A7),A0         Get PC from group 1 stack frame 
00001A2A  302F 000E               1199          MOVE.W  14(A7),D0         Get instruction from stack frame 
00001A2E  B060                    1200          CMP.W   -(A0),D0          Now backtrack to find the "correct PC" 
00001A30  670E                    1201          BEQ.S   GROUP1A           by matching the op-code on the stack 
00001A32  B060                    1202          CMP.W   -(A0),D0          with the code in the region of the 
00001A34  670A                    1203          BEQ.S   GROUP1A           PC on the stack 
00001A36  B060                    1204          CMP.W   -(A0),D0 
00001A38  6706                    1205          BEQ.S   GROUP1A 
00001A3A  B060                    1206          CMP.W   -(A0),D0 
00001A3C  6702                    1207          BEQ.S   GROUP1A 
00001A3E  5588                    1208          SUBQ.L  #2,A0 
00001A40  2F48 0012               1209  GROUP1A MOVE.L  A0,18(A7)          Restore modified PC to stack frame 
00001A44  4CDF 0101               1210          MOVEM.L (A7)+,D0/A0        Restore working registers 
00001A48  4FEF 0008               1211          LEA.L   8(A7),A7           Adjust stack pointer to group 1 type 
00001A4C  6108                    1212          BSR.S   GROUP2             Now treat as group 1 exception 
00001A4E  6100 FD32               1213          BSR     EX_DIS             Display contents of exception frame 
00001A52  6000 F5F8               1214          BRA     WARM               Exit to monitor - no RTE from group 2 
00001A56                          1215  * 
00001A56  =00001A56               1216  GROUP2  EQU     *                 Deal with group 2 exceptions 
00001A56  48E7 FFFF               1217          MOVEM.L A0-A7/D0-D7,-(A7) Save all registers on the stack 
00001A5A  303C 000E               1218          MOVE.W  #14,D0            Transfer D0 - D7, A0 - A6 from 
00001A5E  41EE 011A               1219          LEA.L   TSK_T(A6),A0      the stack to the display frame 
00001A62  20DF                    1220  GROUP2A MOVE.L  (A7)+,(A0)+       Move a register from stack to frame 
00001A64  51C8 FFFC               1221          DBRA    D0,GROUP2A        and repeat until D0-D7/A0-A6 moved 
00001A68  4E6A                    1222          MOVE.L  USP,A2            Get the user stack pointer and put it 
00001A6A  20CA                    1223          MOVE.L  A2,(A0)+          in the A7 position in the frame 
00001A6C  201F                    1224          MOVE.L  (A7)+,D0          Now transfer the SSP to the frame, 
00001A6E  0480 0000000A           1225          SUB.L   #10,D0            remembering to account for the 
00001A74  20C0                    1226          MOVE.L  D0,(A0)+          data pushed on the stack to this point 
00001A76  225F                    1227          MOVE.L  (A7)+,A1          Copy TOS (return address) to A1 
00001A78  30DF                    1228          MOVE.W  (A7)+,(A0)+       Move SR to display frame 
00001A7A  201F                    1229          MOVE.L  (A7)+,D0          Get PC in D0 
00001A7C  5580                    1230          SUBQ.L  #2,D0             Move back to current instruction 
00001A7E  20C0                    1231          MOVE.L  D0,(A0)+          Put adjusted PC in display frame 
00001A80  4ED1                    1232          JMP     (A1)              Return from subroutine 
00001A82                          1233  * 
00001A82                          1234  ************************************************************************* 
00001A82                          1235  * 
00001A82                          1236  *  GO executes a program either from a supplied address or 
00001A82                          1237  *  by using the data in the display frame 
00001A82  6100 F732               1238  GO       BSR     PARAM               Get entry address (if any) 
00001A86  4A07                    1239           TST.B   D7                  Test for error in input 
00001A88  6708                    1240           BEQ.S   GO1                 If D7 zero then OK 
00001A8A  49FA 032B               1241           LEA.L   ERMES1(PC),A4       Else point to error message, 
00001A8E  6000 F5F2               1242           BRA     PSTRING             print it and return 
00001A92  4A80                    1243  GO1      TST.L   D0                  If no address entered then get 
00001A94  670A                    1244           BEQ.S   GO2                 address from display frame 
00001A96  2D40 0160               1245           MOVE.L  D0,TSK_T+70(A6)     Else save address in display frame 
00001A9A  3D7C 0700 015E          1246           MOVE.W  #$0700,TSK_T+68(A6) Store dummy status in frame 
00001AA0  6006                    1247  GO2      BRA.S   RESTORE             Restore volatile environment and go 
00001AA2                          1248  * 
00001AA2  6100 007A               1249  GB       BSR     BR_SET              Same as go but presets breakpoints 
00001AA6  60DA                    1250           BRA.S   GO                  Execute program 
00001AA8                          1251  * 
00001AA8                          1252  *        RESTORE moves the volatile environment from the display 
00001AA8                          1253  *        frame and transfers it to the 68000's registers. This 
00001AA8                          1254  *        re-runs a program suspended after an exception 
00001AA8                          1255  * 
00001AA8  47EE 011A               1256  RESTORE  LEA.L   TSK_T(A6),A3        A3 points to display frame 
00001AAC  47EB 004A               1257           LEA.L   74(A3),A3           A3 now points to end of frame + 4 
00001AB0  4FEF 0004               1258           LEA.L   4(A7),A7            Remove return address from stack 
00001AB4  303C 0024               1259           MOVE.W  #36,D0              Counter for 37 words to be moved 
00001AB8  3F23                    1260  REST1    MOVE.W  -(A3),-(A7)         Move word from display frame to stack 
00001ABA  51C8 FFFC               1261           DBRA    D0,REST1            Repeat until entire frame moved 
00001ABE  4CDF 00FF               1262           MOVEM.L (A7)+,D0-D7         Restore old data registers from stack 
00001AC2  4CDF 7F00               1263           MOVEM.L (A7)+,A0-A6         Restore old address registers 
00001AC6  4FEF 0008               1264           LEA.L   8(A7),A7            Except SSP/USP - so adjust stack 
00001ACA  4E73                    1265           RTE                         Return from exception to run program 
00001ACC                          1266  * 
00001ACC  =00001ACC               1267  TRACE    EQU     *                   TRACE exception (rudimentary version) 
00001ACC  287A 0292               1268           MOVE.L  MES12(PC),A4        Point to heading 
00001AD0  6100 F5C0               1269           BSR     HEADING             Print it 
00001AD4  6100 FF4C               1270           BSR     GROUP1              Save volatile environment 
00001AD8  6100 FCA8               1271           BSR     EX_DIS              Display it 
00001ADC  6000 F56E               1272           BRA     WARM                Return to monitor 
00001AE0                          1273  * 
00001AE0                          1274  ************************************************************************* 
00001AE0                          1275  *  Breakpoint routines: BR_GET gets the address of a breakpoint and 
00001AE0                          1276  *  puts it in the breakpoint table. It does not plant it in the code. 
00001AE0                          1277  *  BR_SET plants all breakpoints in the code. NOBR removes one or all 
00001AE0                          1278  *  breakpoints from the table. KILL removes breakpoints from the code. 
00001AE0                          1279  * 
00001AE0  6100 F6D4               1280  BR_GET   BSR     PARAM               Get breakpoint address in table 
00001AE4  4A07                    1281           TST.B   D7                  Test for input error 
00001AE6  6708                    1282           BEQ.S   BR_GET1             If no error then continue 
00001AE8  49FA 02CD               1283           LEA.L   ERMES1(PC),A4       Else display error 
00001AEC  6000 F594               1284           BRA     PSTRING             and return 
00001AF0  47EE 0164               1285  BR_GET1  LEA.L   BP_TAB(A6),A3       A6 points to breakpoint table 
00001AF4  2A40                    1286           MOVE.L  D0,A5               Save new BP address in A5 
00001AF6  2C00                    1287           MOVE.L  D0,D6               and in D6 because D0 gets corrupted 
00001AF8  3A3C 0007               1288           MOVE.W  #7,D5               Eight entries to test 
00001AFC  201B                    1289  BR_GET2  MOVE.L  (A3)+,D0            Read entry from breakpoint table 
00001AFE  660C                    1290           BNE.S   BR_GET3             If not zero display existing BP 
00001B00  4A86                    1291           TST.L   D6                  Only store a non-zero breakpoint 
00001B02  6710                    1292           BEQ.S   BR_GET4 
00001B04  274D FFFC               1293           MOVE.L  A5,-4(A3)           Store new breakpoint in table 
00001B08  3695                    1294           MOVE.W  (A5),(A3)           Save code at BP address in table 
00001B0A  4286                    1295           CLR.L   D6                  Clear D6 to avoid repetition 
00001B0C  6100 F716               1296  BR_GET3  BSR     OUT8X               Display this breakpoint 
00001B10  6100 F560               1297           BSR     NEWLINE 
00001B14  47EB 0002               1298  BR_GET4  LEA.L   2(A3),A3            Step past stored op-code 
00001B18  51CD FFE2               1299           DBRA    D5,BR_GET2          Repeat until all entries tested 
00001B1C  4E75                    1300           RTS                         Return 
00001B1E                          1301  * 
00001B1E  =00001B1E               1302  BR_SET   EQU     *                   Plant any breakpoints in user code 
00001B1E  41EE 0164               1303           LEA.L   BP_TAB(A6),A0       A0 points to BP table 
00001B22  45EE 0160               1304           LEA.L   TSK_T+70(A6),A2     A2 points to PC in display frame 
00001B26  2452                    1305           MOVE.L  (A2),A2             Now A2 contains value of PC 
00001B28  303C 0007               1306           MOVE.W  #7,D0               Up to eight entries to plant 
00001B2C  2218                    1307  BR_SET1  MOVE.L  (A0)+,D1            Read breakpoint address from table 
00001B2E  670A                    1308           BEQ.S   BR_SET2             If zero then skip planting 
00001B30  B28A                    1309           CMP.L   A2,D1               Don't want to plant BP at current PC 
00001B32  6706                    1310           BEQ.S   BR_SET2             location, so skip planting if same 
00001B34  2241                    1311           MOVE.L  D1,A1               Transfer BP address to address reg 
00001B36  32BC 4E4E               1312           MOVE.W  #TRAP_16,(A1)       Plant op-code for TRAP #14 in code 
00001B3A  41E8 0002               1313  BR_SET2  LEA.L   2(A0),A0            Skip past op-code field in table 
00001B3E  51C8 FFEC               1314           DBRA    D0,BR_SET1          Repeat until all entries tested 
00001B42  4E75                    1315           RTS 
00001B44                          1316  * 
00001B44  =00001B44               1317  NOBR     EQU     *                   Clear one or all breakpoints 
00001B44  6100 F670               1318           BSR     PARAM               Get BP address (if any) 
00001B48  4A07                    1319           TST.B   D7                  Test for input error 
00001B4A  6708                    1320           BEQ.S   NOBR1               If no error then skip abort 
00001B4C  49FA 0269               1321           LEA.L   ERMES1(PC),A4       Point to error message 
00001B50  6000 F530               1322           BRA     PSTRING             Display it and return 
00001B54  4A80                    1323  NOBR1    TST.L   D0                  Test for null address (clear all) 
00001B56  6720                    1324           BEQ.S   NOBR4               If no address then clear all entries 
00001B58  2240                    1325           MOVE.L  D0,A1               Else just clear breakpoint in A1 
00001B5A  41EE 0164               1326           LEA.L   BP_TAB(A6),A0       A0 points to BP table 
00001B5E  303C 0007               1327           MOVE.W  #7,D0               Up to eight entries to test 
00001B62  2218                    1328  NOBR2    MOVE.L  (A0)+,D1            Get entry and 
00001B64  41E8 0002               1329           LEA.L   2(A0),A0            skip past op-code field 
00001B68  B289                    1330           CMP.L   A1,D1               Is this the one? 
00001B6A  6706                    1331           BEQ.S   NOBR3               If so go and clear entry 
00001B6C  51C8 FFF4               1332           DBRA    D0,NOBR2            Repeat until all tested 
00001B70  4E75                    1333           RTS 
00001B72  42A8 FFFA               1334  NOBR3    CLR.L   -6(A0)              Clear address in BP table 
00001B76  4E75                    1335           RTS 
00001B78  41EE 0164               1336  NOBR4    LEA.L   BP_TAB(A6),A0       Clear all 8 entries in BP table 
00001B7C  303C 0007               1337           MOVE.W  #7,D0               Eight entries to clear 
00001B80  4298                    1338  NOBR5    CLR.L   (A0)+               Clear breakpoint address 
00001B82  4258                    1339           CLR.W   (A0)+               Clear op-code field 
00001B84  51C8 FFFA               1340           DBRA    D0,NOBR5            Repeat until all done 
00001B88  4E75                    1341           RTS 
00001B8A                          1342  * 
00001B8A  =00001B8A               1343  BR_CLR   EQU     *                   Remove breakpoints from code 
00001B8A  41EE 0164               1344           LEA.L   BP_TAB(A6),A0       A0 points to breakpoint table 
00001B8E  303C 0007               1345           MOVE.W  #7,D0               Up to eight entries to clear 
00001B92  2218                    1346  BR_CLR1  MOVE.L  (A0)+,D1            Get address of BP in D1 
00001B94  2241                    1347           MOVE.L  D1,A1               and put copy in A1 
00001B96  4A81                    1348           TST.L   D1                  Test this breakpoint 
00001B98  6702                    1349           BEQ.S   BR_CLR2             If zero then skip BP clearing 
00001B9A  3290                    1350           MOVE.W  (A0),(A1)           Else restore op-code 
00001B9C  41E8 0002               1351  BR_CLR2  LEA.L   2(A0),A0            Skip past op-code field 
00001BA0  51C8 FFF0               1352           DBRA    D0,BR_CLR1          Repeat until all tested 
00001BA4  4E75                    1353           RTS 
00001BA6                          1354  * 
00001BA6                          1355  *  REG_MOD modifies a register in the display frame. The command 
00001BA6                          1356  *  format is REG <reg> <value>. E.g. REG D3 1200 
00001BA6                          1357  * 
00001BA6  4281                    1358  REG_MOD  CLR.L   D1                  D1 to hold name of register 
00001BA8  41EE 0104               1359           LEA.L   BUFFPT(A6),A0       A0 contains address of buffer pointer 
00001BAC  2050                    1360           MOVE.L  (A0),A0             A0 now points to next char in buffer 
00001BAE  1218                    1361           MOVE.B  (A0)+,D1            Put first char of name in D1 
00001BB0  E159                    1362           ROL.W   #8,D1               Move char one place left 
00001BB2  1218                    1363           MOVE.B  (A0)+,D1            Get second char in D1 
00001BB4  41E8 0001               1364           LEA.L   1(A0),A0            Move pointer past space in buffer 
00001BB8  2D48 0104               1365           MOVE.L  A0,BUFFPT(A6)       Update buffer pointer 
00001BBC  4282                    1366           CLR.L   D2                  D2 is the character pair counter 
00001BBE  41FA 01CE               1367           LEA.L   REGNAME(PC),A0      A0 points to string of character pairs 
00001BC2  43D0                    1368           LEA.L   (A0),A1             A1 also points to string 
00001BC4  B258                    1369  REG_MD1  CMP.W   (A0)+,D1            Compare a char pair with input 
00001BC6  6712                    1370           BEQ.S   REG_MD2             If match then exit loop 
00001BC8  5282                    1371           ADD.L   #1,D2               Else increment match counter 
00001BCA  B4BC 00000013           1372           CMP.L   #19,D2              Test for end of loop 
00001BD0  66F2                    1373           BNE     REG_MD1             Continue until all pairs matched 
00001BD2  49FA 01E3               1374           LEA.L   ERMES1(PC),A4       If here then error 
00001BD6  6000 F4AA               1375           BRA     PSTRING             Display error and return 
00001BDA  43EE 011A               1376  REG_MD2  LEA.L   TSK_T(A6),A1        A1 points to display frame 
00001BDE  E582                    1377           ASL.L   #2,D2               Multiply offset by 4 (4 bytes/entry) 
00001BE0  B4BC 00000048           1378           CMP.L   #72,D2              Test for address of PC 
00001BE6  6602                    1379           BNE.S   REG_MD3             If not PC then all is OK 
00001BE8  5582                    1380           SUB.L   #2,D2               else dec PC pointer as Sr is a word 
00001BEA  45F1 2000               1381  REG_MD3  LEA.L   (A1,D2),A2          Calculate address of entry in disptable 
00001BEE  2012                    1382           MOVE.L  (A2),D0             Get old contents 
00001BF0  6100 F632               1383           BSR     OUT8X               Display them 
00001BF4  6100 F47C               1384           BSR     NEWLINE 
00001BF8  6100 F5BC               1385           BSR     PARAM               Get new data 
00001BFC  4A07                    1386           TST.B   D7                  Test for input error 
00001BFE  6708                    1387           BEQ.S   REG_MD4             If no error then go and store data 
00001C00  49FA 01B5               1388           LEA.L   ERMES1(PC),A4       Else point to error message 
00001C04  6000 F47C               1389           BRA     PSTRING             print it and return 
00001C08  B4BC 00000044           1390  REG_MD4  CMP.L   #68,D2              If this address is the SR then 
00001C0E  6704                    1391           BEQ.S   REG_MD5             we have only a word to store 
00001C10  2480                    1392           MOVE.L  D0,(A2)             Else store new data in display frame 
00001C12  4E75                    1393           RTS 
00001C14  3480                    1394  REG_MD5  MOVE.W  D0,(A2)             Store SR (one word) 
00001C16  4E75                    1395           RTS 
00001C18                          1396  * 
00001C18                          1397  ************************************************************************* 
00001C18                          1398  * 
00001C18  =00001C18               1399  X_UN    EQU     *                 Uninitialized exception vector routine 
00001C18  49FA 0205               1400          LEA.L   ERMES6(PC),A4     Point to error message 
00001C1C  6100 F464               1401          BSR     PSTRING           Display it 
00001C20  6100 FB60               1402          BSR     EX_DIS            Display registers 
00001C24  6000 F426               1403          BRA     WARM              Abort 
00001C28                          1404  * 
00001C28                          1405  ************************************************************************* 
00001C28                          1406  * 
00001C28                          1407  *  All strings and other fixed parameters here 
00001C28                          1408  * 
00001C28= 54 53 42 55 47 20 ...   1409  BANNER   DC.B     'TSBUG 2 Version 23.07.86',0,0
00001C42= 4D 6F 64 69 66 69 ...   1410  MODIFY    DC.B   'Modified by Eugene A. Rockey Jr. Jan.05.2010',0,0
00001C70= 66 6F 72 20 75 73 ...   1411  WHY      DC.B     'for use with the M68000 Minimal Computer Configuration',0,0 
00001CA8= 55 6E 69 76 65 72 ...   1412  WHERE    DC.B     'University of Louisville',0,0
00001CC2= 0D 0A 54 53 32 4D ...   1413  CRLF     DC.B     CR,LF,'TS2MON >',0 
00001CCD= 0D 0A 53 31 00 00       1414  HEADER   DC.B     CR,LF,'S','1',0,0 
00001CD3= 53 39 20 20 00 00       1415  TAIL     DC.B     'S9  ',0,0 
00001CD9= 20 53 52 20 20 3D ...   1416  MES1     DC.B     ' SR  =  ',0 
00001CE2= 20 50 43 20 20 3D ...   1417  MES2     DC.B     ' PC  =  ',0 
00001CEB= 20 53 53 20 20 3D ...   1418  MES2A    DC.B     ' SS  =  ',0 
00001CF4= 20 20 44 61 74 61 ...   1419  MES3     DC.B     '  Data reg       Address reg',0,0 
00001D12= 20 20 20 20 20 20 ...   1420  MES4     DC.B     '        ',0,0 
00001D1C= 42 75 73 20 65 72 ...   1421  MES8     DC.B     'Bus error   ',0,0 
00001D2A= 41 64 64 72 65 73 ...   1422  MES9     DC.B     'Address error   ',0,0 
00001D3C= 49 6C 6C 65 67 61 ...   1423  MES10    DC.B     'Illegal instruction ',0,0 
00001D52= 42 72 65 61 6B 70 ...   1424  MES11    DC.B     'Breakpoint  ',0,0 
00001D60= 54 72 61 63 65 20 ...   1425  MES12    DC.B     'Trace   ',0 
00001D69= 44 69 76 69 64 65 ...   1426  MES13    DC.B     'Divide by zero error', 0
00001D7E= 50 72 69 76 69 6C ...   1427  MES14    DC.B     'Privilege error', 0
00001D8E= 44 30 44 31 44 32 ...   1428  REGNAME  DC.B     'D0D1D2D3D4D5D6D7' 
00001D9E= 41 30 41 31 41 32 ...   1429           DC.B     'A0A1A2A3A4A5A6A7' 
00001DAE= 53 53 53 52             1430           DC.B     'SSSR' 
00001DB2= 50 43 20 20 00          1431           DC.B     'PC  ',0 
00001DB7= 4E 6F 6E 2D 76 61 ...   1432  ERMES1   DC.B     'Non-valid hexadecimal input  ',0 
00001DD5= 44 6F 77 6E 6C 6F ...   1433  ERMES2   DC.B     'Download Complete  ',0 
00001DE9= 4C 6F 61 64 69 6E ...   1434  ERMES3   DC.B     'Loading error',0 
00001DF7= 54 61 62 6C 65 20 ...   1435  ERMES4   DC.B     'Table full  ',0,0 
00001E05= 42 72 65 61 6B 70 ...   1436  ERMES5   DC.B     'Breakpoint not active   ',0,0 
00001E1F= 55 6E 69 6E 69 74 ...   1437  ERMES6   DC.B     'Uninitialized exception ',0,0 
00001E39= 4A 55 4D 50 20 3C ...   1438  JUMPHELP DC.B     'JUMP <address> causes execution to begin at <address>',0   
00001E6F= 4D 45 4D 4F 52 59 ...   1439  MEMHELP  DC.B     'MEMORY <address> examines contents of address> and allows them to be changed', 0   
00001EBC= 4C 4F 41 44 20 3C ...   1440  LOADHELP DC.B     'LOAD <string> loads S1/S2 records from the host. <string> is sent to host', 0
00001F06= 54 56 20 63 68 65 ...   1441  TVHELP   DC.B     'TV checks all RAM addresses from $4000 to $40FE. Reports corrupt memory addresses', 0
00001F58= 20 52 61 6E 67 65 ...   1442  ERMES7   DC.B     ' Range error',0
00001F65= 55 53 45 52 00          1443  UNAME    DC.B     'USER', 0
00001F6A= 50 41 53 53 57 4F ...   1444  PWORD    DC.B     'PASSWORD',0
00001F73= 45 6E 74 65 72 20 ...   1445  LOGINM1  DC.B     'Enter username: ', 0
00001F84= 45 6E 74 65 72 20 ...   1446  LOGINM2  DC.B     'Enter password: ', 0
00001F95= 49 6E 63 6F 72 72 ...   1447  USRERR   DC.B     'Incorrect username', 0
00001FA8= 49 6E 63 6F 72 72 ...   1448  PSRERR   DC.B     'Incorrect password', 0
00001FBB= 43 6F 72 72 65 63 ...   1449  USRSUC   DC.B     'Correct Username', 0
00001FCC= 49 6E 63 6F 72 72 ...   1450  PWERR   DC.B     'Incorrect password', 0
00001FDF= 43 6F 72 72 65 63 ...   1451  PWSUC    DC.B     'Correct Password', 0
00001FF0= 4D 45 4D 4F 52 59 ...   1452  MEMFMSG  DC.B     'MEMORY BAD AT: ',0
00002000= 41 4C 4C 20 52 41 ...   1453  MEMGMSG  DC.B      'ALL RAM GOOD', 0
0000200D                          1454  * 
0000200D                          1455  *  COMTAB is the built-in command table. All entries are made up of 
0000200D                          1456  *         a string length + number of characters to match + the string 
0000200D                          1457  *         plus the address of the command relative to COMTAB 
0000200D                          1458  * 
00002000                          1459           ORG      $2000
00002000= 04 04                   1460  COMTAB   DC.B     4,4              JUMP <address> causes execution to 
00002002= 4A 55 4D 50             1461           DC.B     'JUMP'           begin at <address> 
00002006= FFFFF22C                1462           DC.L     JUMP-COMTAB                                           
0000200A= 08 03                   1463           DC.B     8,3              MEMORY <address> examines contents of 
0000200C= 4D 45 4D 4F 52 59 ...   1464           DC.B     'MEMORY  '       <address> and allows them to be changed 
00002014= FFFFF242                1465           DC.L     MEMORY-COMTAB 
00002018= 04 02                   1466           DC.B     4,2              LOAD <string> loads S1/S2 records 
0000201A= 4C 4F 41 44             1467           DC.B     'LOAD'           from the host. <string> is sent to host 
0000201E= FFFFF2A2                1468           DC.L     LOAD-COMTAB 
00002022= 04 02                   1469           DC.B    4,2               GO <address> starts program execution 
00002024= 47 4F 20 20             1470           DC.B    'GO  '            at <address> and loads regs from TSK_T 
00002028= FFFFFA82                1471           DC.L    GO-COMTAB 
0000202C= 04 04                   1472           DC.B    4,4               HELP 
0000202E= 48 45 4C 50             1473           DC.B    'HELP'            
00002032= FFFFF800                1474           DC.L    HELP-COMTAB      
00002036= 02 02                   1475           DC.B    2,2
00002038= 54 56                   1476           DC.B    'TV'
0000203A= FFFFF902                1477           DC.L    TV-COMTAB
0000203E= 00 00                   1478           DC.B    0,0 
00002040                          1479  * 
00002040                          1480  ************************************************************************* 
00002040                          1481  ** 
00002040                          1482  *  This is a list of the information needed to setup the DCBs 
00002040                          1483  * 
00002040  =00002040               1484  DCB_LST  EQU     * 
00002040= 43 4F 4E 5F 49 4E ...   1485  DCB1     DC.B    'CON_IN  '          Device name (8 bytes) 
00002048= 00001486 00008001       1486           DC.L    CON_IN,ACIA_1       Address of driver routine, device 
00002050= 0002                    1487           DC.W    2                   Number of words in parameter field 
00002052= 43 4F 4E 5F 4F 55 ...   1488  DCB2     DC.B    'CON_OUT ' 
0000205A= 000014B6 00008001       1489           DC.L    CON_OUT,ACIA_1 
00002062= 0002                    1490           DC.W    2 
00002064= 41 55 58 5F 49 4E ...   1491  DCB3     DC.B    'AUX_IN  ' 
0000206C= 000014F6 00008001       1492           DC.L    AUX_IN,ACIA_2 
00002074= 0002                    1493           DC.W    2 
00002076= 41 55 58 5F 4F 55 ...   1494  DCB4     DC.B    'AUX_OUT ' 
0000207E= 00001508 00008001       1495           DC.L    AUX_OUT,ACIA_2 
00002086= 0002                    1496           DC.W    2 
00002088                          1497  *DCB5     DC.B    'BUFF_IN ' 
00002088                          1498  *         DC.L    BUFF_IN,BUFFER 
00002088                          1499  *         DC.W    2 
00002088                          1500  *DCB6     DC.B    'BUFF_OUT' 
00002088                          1501  *         DC.L    BUFF_OT,BUFFER 
00002088                          1502  *         DC.W    2 
00002088                          1503  * 
00002088                          1504  ************************************************************************* 
00002088                          1505  * 
00002088                          1506  *  DCB structure 
00002088                          1507  * 
00002088                          1508  *              ----------------------- 
00002088                          1509  *       0 ->   | DCB  name           | 
00002088                          1510  *              |---------------------| 
00002088                          1511  *       8 ->   | Device driver       | 
00002088                          1512  *              |---------------------| 
00002088                          1513  *      12 ->   | Device address      | 
00002088                          1514  *              |---------------------| 
00002088                          1515  *      16 ->   |Size of param block  | 
00002088                          1516  *              |---------------------| --- 
00002088                          1517  *      18 ->   |      Status         |   | 
00002088                          1518  *              | logical  | physical |   | S 
00002088                          1519  *              |---------------------|   | 
00002088                          1520  *              .                     .   . 
00002088                          1521  *              |---------------------| --- 
00002088                          1522  *    18+S ->   | Pointer to next DCB | 
00002088                          1523  * 
00002088                          1524           END RESET 

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ACIA_1              8001
ACIA_2              8001
ADD_0               15D0
ADD_ER              19D2
ADR_DAT             1280
AUX_IN              14F6
AUX_IN1             14FC
AUX_OT1             150E
AUX_OUT             1508
BANNER              1C28
BP_TAB              164
BRKPT               1A04
BR_CLR              1B8A
BR_CLR1             1B92
BR_CLR2             1B9C
BR_GET              1AE0
BR_GET1             1AF0
BR_GET2             1AFC
BR_GET3             1B0C
BR_GET4             1B14
BR_SET              1B1E
BR_SET1             1B2C
BR_SET2             1B3A
BS                  8
BUFFEND             103
BUFFER              394
BUFFPT              104
BUS_ER              19C4
BYTE                119A
B_CLR               15C6
CHECK1              191E
CHECK2              1928
CHECK3              194A
CHECK4              1954
CN_IVEC             112
CN_OVEC             116
COMTAB              2000
CON_I1              1494
CON_I2              14AC
CON_IN              1486
CON_OT1             14C4
CON_OT2             14DA
CON_OT3             14E2
CON_OUT             14B6
CR                  D
CRLF                1CC2
CTRL_A              1
DATA                4800
DCB1                2040
DCB2                2052
DCB3                2064
DCB4                2076
DCB_LST             2040
DELAY               1416
DELAY1              1420
DIV0_ER             19E0
DIVNEG              1614
DIV_0               15FA
DUMP                1376
DUMP1               1386
DUMP2               1392
DUMP3               13A0
DUMP4               13B4
DUMP5               13C2
DUMP6               13DC
DUMP7               1400
ECHO                10C
ERMES1              1DB7
ERMES2              1DD5
ERMES3              1DE9
ERMES4              1DF7
ERMES5              1E05
ERMES6              1E1F
ERMES7              1F58
ESC                 1B
EXEC1               1122
EXEC2               1132
EXECUTE             1110
EX_D1               1794
EX_DIS              1782
FIRST               194
FOO1                1646
FOO10               16B2
FOO11               16BE
FOO12               16CA
FOO13               16D6
FOO14               16E2
FOO15               16EE
FOO16               16FA
FOO17               1706
FOO18               1712
FOO19               171E
FOO2                1652
FOO20               172A
FOO21               1736
FOO22               1754
FOO23               1764
FOO24               1774
FOO3                165E
FOO4                166A
FOO5                1676
FOO6                1682
FOO7                168E
FOO8                169A
FOO9                16A6
GB                  1AA2
GETCH2              1540
GETCH3              1550
GETCHAR             151A
GETLINE             1098
GETLN2              10A2
GETLN3              10BC
GETLN4              10C6
GETLN5              10CA
GO                  1A82
GO1                 1A92
GO2                 1AA0
GROUP1              1A22
GROUP1A             1A40
GROUP2              1A56
GROUP2A             1A62
HEADER              1CCD
HEADING             1092
HELP                1800
HEX                 117C
HEX_OK              1198
IL_ER               19AC
IO_OPEN             158C
IO_REQ              1474
JUMP                122C
JUMP1               123A
JUMPHELP            1E39
LF                  A
LNBUFF              C4
LOAD                12A2
LOAD1               12CE
LOAD2               12DE
LOAD3               12F8
LOAD4               1312
LOAD5               1320
LOAD6               1322
LOAD6A              1346
LOAD7               1358
LOAD8               136E
LOADHELP            1EBC
LOGIN               1836
LOGIN1              1856
LOGIN2              189A
LOGINM1             1F73
LOGINM2             1F84
LONGWD              11B0
LOOPRAM             190A
LOOPRAM1            1936
MAXCHR              40
MAX_RAM             498
MEM1                124C
MEM2                126A
MEM3                127E
MEMFAIL             1968
MEMFAIL2            1984
MEMFMSG             1FF0
MEMGMSG             2000
MEMGOOD             19A0
MEMHELP             1E6F
MEMORY              1242
MES1                1CD9
MES10               1D3C
MES11               1D52
MES12               1D60
MES13               1D69
MES14               1D7E
MES2                1CE2
MES2A               1CEB
MES3                1CF4
MES4                1D12
MES8                1D1C
MES9                1D2A
MIN_RAM             494
MODIFY              1C42
MULNEG              162A
MUL_0               15EC
NEWLINE             1072
NOBR                1B44
NOBR1               1B54
NOBR2               1B62
NOBR3               1B72
NOBR4               1B78
NOBR5               1B80
NOT_HEX             1194
NO_EXT              1040
NUL                 0
OPEN1               1594
OPEN2               159C
OPEN3               15AA
OPEN4               15C0
OUT1X               11FA
OUT1X1              120C
OUT2X               1214
OUT4X               121C
OUT8X               1224
PARAM               11B6
PARAM1              11BE
PARAM3              11E2
PARAM4              11E6
PARAM5              11F2
PARAM6              11F6
PARAMTR             108
PRIV_ER             19EE
PS1                 1084
PS2                 108E
PSPACE              1294
PSRERR              1FA8
PSTRING             1082
PUTASK              1554
PUTCHAR             1566
PWERR               1FCC
PWORD               1F6A
PWSUC               1FDF
QUIT                18FE
RANGE               1406
REGNAME             1D8E
REG_MD1             1BC4
REG_MD2             1BDA
REG_MD3             1BEA
REG_MD4             1C08
REG_MD5             1C14
REG_MOD             1BA6
RESET               1000
REST1               1AB8
RESTORE             1AA8
SEARCH              113C
SETACIA             105C
SETNEG              161A
SET_DCB             142A
SPACE               20
SPUTCHAR            157A
SRCH2               1156
SRCH3               115A
SRCH4               1162
SRCH6               116C
SRCH7               1176
STACK               4400
ST_DCB1             143A
ST_DCB2             143E
SUB_0               15DE
TAIL                1CD3
TIDY                10CE
TIDY1               10D4
TIDY2               10E0
TIDY3               10EA
TIDY4               10F4
TIDY5               10FE
TIDY6               110A
TRACE               1ACC
TRAP_0              163A
TRAP_14             1776
TRAP_15             177C
TRAP_16             4E4E
TSK_T               11A
TV                  1902
TVHELP              1F06
UNAME               1F65
UPASS               18F4
USRERR              1F95
USRSUC              1FBB
UTAB                10E
U_CASE              10D
WAIT                57
WARM                104C
WHERE               1CA8
WHY                 1C70
WORD                11AA
WRONG               18CC
WRONGPW             18E0
X_UN                1C18
