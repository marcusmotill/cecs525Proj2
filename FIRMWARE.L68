00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.15.04
Created On: 9/25/15 12:06:29 AM

00000000                             1  *        TSBUG2 - 68000 monitor - version of 05 January 2010 
00000000                             2  
00000000                             3       ORG      $0
00000000= 00004400 00001000          4           DC.L     STACK,RESET
00000008                             5  *                                   Symbol equates 
00000008  =00000008                  6  BS       EQU      $08               Back_space 
00000008  =0000000D                  7  CR       EQU      $0D               Carriage_return 
00000008  =0000000A                  8  LF       EQU      $0A               Line_feed 
00000008  =00000020                  9  SPACE    EQU      $20               Space 
00000008  =00000057                 10  WAIT     EQU      'W'               Wait character (to suspend output) 
00000008  =0000001B                 11  ESC      EQU      $1B               ASCII escape character (used by TM) 
00000008  =00000001                 12  CTRL_A   EQU      $01               Control_A forces return to monitor 
00000008                            13  *                                   Device addresses 
00000008  =00004400                 14  STACK    EQU      $4400             Stack_pointer
00000008  =00008001                 15  ACIA_1   EQU      $8001             Console ACIA control 
00000008  =00008001                 16  ACIA_2   EQU      ACIA_1            Auxilary ACIA control 
00000008                            17  *X_BASE   EQU      $4000             Start of exception vector table 
00000008  =00004E4E                 18  TRAP_14  EQU      $4E4E             Code for TRAP #14 
00000008  =00000040                 19  MAXCHR   EQU      64                Length of input line buffer  
00000008                            20  * 
00000008  =00004800                 21  DATA     EQU      $4800             Data origin 
00000008                            22  LNBUFF   DS.B     MAXCHR            Input line buffer
00000048  =00000047                 23  BUFFEND  EQU      LNBUFF+MAXCHR-1   End of line buffer 
00000048                            24  BUFFPT   DS.L     1                 Pointer to line buffer 
0000004C                            25  PARAMTR  DS.L     1                 Last parameter from line buffer 
00000050                            26  ECHO     DS.B     1                 When clear this enable input echo 
00000051                            27  U_CASE   DS.B     1                 Flag for upper case conversion 
00000052                            28  UTAB     DS.L     1                 Pointer to user command table 
00000056                            29  CN_IVEC  DS.L     1                 Pointer to console input DCB 
0000005A                            30  CN_OVEC  DS.L     1                 Pointer to console output DCB 
0000005E                            31  TSK_T    DS.W     37                Frame for D0-D7, A0-A6, USP, SSP, SW, PC 
000000A8                            32  BP_TAB   DS.W     24                Breakpoint table 
000000D8                            33  FIRST    DS.B     512               DCB area 
000002D8                            34  BUFFER   DS.B     256               256 bytes for I/O buffer 
000003D8= 00004000                  35  MIN_RAM  DC.L     $004000
000003DC= 00004100                  36  MAX_RAM  DC.L     $004100
000003E0                            37  * 
000003E0                            38  ************************************************************************* 
000003E0                            39  * 
000003E0                            40  *  This is the main program which assembles a command in the line 
000003E0                            41  *  buffer, removes leading/embedded spaces and interprets it by matching 
000003E0                            42  *  it with a command in the user table or the built-in table COMTAB 
000003E0                            43  *  All variables are specified with respect to A6 
000003E0                            44  *
00001000                            45           ORG      $1000             Monitor Origin
00001000  =00001000                 46  RESET:   EQU      *
00001000  4DF8 4800                 47           LEA.L    DATA,A6           A6 points to data area 
00001004  2D4E 0096                 48       MOVE.L   A6,TSK_T+56(A6)   initialize A6 in the regster Frame
00001008  42AE 0052                 49           CLR.L    UTAB(A6)          Reset pointer to user extension table 
0000100C  422E 0050                 50           CLR.B    ECHO(A6)          Set automatic character echo 
00001010  422E 0051                 51           CLR.B    U_CASE(A6)        Clear case conversion flag (UC<-LC) 
00001014  613E                      52           BSR.S    SETACIA           Setup ACIAs 
00001016  6100 0576                 53           BSR.L    B_CLR         what change did i do here
0000101A  6100 0406                 54           BSR.L    SET_DCB           Setup DCB table in RAM
0000101E  614A                      55           BSR.S    NEWLINE
00001020  49FA 092A                 56           LEA.L    BANNER(PC),A4    
00001024  6154                      57           BSR.S    PSTRING
00001026  6142                      58           BSR.S    NEWLINE           
00001028  49FA 093C                 59       LEA.L    MODIFY(PC),A4
0000102C  614C                      60           BSR.S    PSTRING
0000102E  613A                      61           BSR.S    NEWLINE
00001030  49FA 0962                 62       LEA.L    WHY(PC),A4
00001034  6144                      63           BSR.S    PSTRING
00001036  6132                      64           BSR.S    NEWLINE
00001038  49FA 0992                 65       LEA.L    WHERE(PC),A4
0000103C  613C                      66           BSR.S    PSTRING
0000103E  612A                      67           BSR.S    NEWLINE
00001040                            68  *         MOVE.L   #$3000,A0         A0 points to extension ROM 
00001040                            69  *         MOVE.L   (A0),D0           Read first longword in extension ROM 
00001040                            70  *         CMP.L    #'ROM2',D0        If extension begins with 'ROM2' then 
00001040                            71  *         BNE.S    NO_EXT            call the subroutine at EXT_ROM+8 
00001040                            72  *         JSR      8(A0)             else continue 
00001040  4E71                      73  NO_EXT:  NOP                        Two NOPs to allow for a future 
00001042  4E71                      74           NOP                        call to an initialization routine 
00001044  4287                      75  WARM:    CLR.L    D7                Warm entry point - clear error flag 
00001046  6122                      76           BSR.S    NEWLINE           Print a newline 
00001048  6146                      77           BSR.S    GETLINE           Get a command line 
0000104A  6100 007A                 78           BSR      TIDY              Tidy up input buffer contents 
0000104E  6100 00B8                 79           BSR      EXECUTE           Interpret command 
00001052  60F0                      80           BRA      WARM              Repeat indefinitely 
00001054                            81  * 
00001054                            82  ************************************************************************* 
00001054                            83  * 
00001054                            84  *  Some initialization and basic routines 
00001054                            85  * 
00001054  =00001054                 86  SETACIA  EQU      *                 Setup ACIA parameters 
00001054  41F9 00008001             87           LEA.L    ACIA_1,A0         A0 points to console ACIA 
0000105A  10BC 0003                 88           MOVE.B   #$03,(A0)         Reset ACIA1 
0000105E                            89  *         MOVE.B   #$03,1(A0)        Reset ACIA2 
0000105E  10BC 0019                 90           MOVE.B   #$19,(A0)         Set up ACIA1 constants (no IRQ, 
00001062  117C 0019 0001            91           MOVE.B   #$19,1(A0)        RTS* low, 8 bit, no parity, 1 stop) 
00001068  4E75                      92           RTS                        Return 
0000106A                            93  * 
0000106A  =0000106A                 94  NEWLINE  EQU      *                 Move cursor to start of newline 
0000106A  48E7 0008                 95           MOVEM.L  A4,-(A7)          Save A4 
0000106E  49FA 0976                 96           LEA.L    CRLF(PC),A4       Point to CR/LF string 
00001072  6106                      97           BSR.S    PSTRING           Print it 
00001074  4CDF 1000                 98           MOVEM.L  (A7)+,A4          Restore A4 
00001078  4E75                      99           RTS                        Return 
0000107A                           100  * 
0000107A  =0000107A                101  PSTRING  EQU      *                 Display the string pointed at by A4 
0000107A  2F00                     102           MOVE.L   D0,-(A7)          Save D0 
0000107C  101C                     103  PS1      MOVE.B   (A4)+,D0          Get character to be printed 
0000107E  6706                     104           BEQ.S    PS2               If null then return 
00001080  6100 04C2                105           BSR      PUTCHAR           Else print it 
00001084  60F6                     106           BRA      PS1               Continue 
00001086  201F                     107  PS2      MOVE.L   (A7)+,D0          Restore D0 and exit 
00001088  4E75                     108           RTS 
0000108A                           109  * 
0000108A  61DE                     110  HEADING  BSR      NEWLINE           Same as PSTRING but with newline 
0000108C  61EC                     111           BSR      PSTRING 
0000108E  60DA                     112           BRA      NEWLINE 
00001090                           113  * 
00001090                           114  ************************************************************************* 
00001090                           115  * 
00001090                           116  *  GETLINE  inputs a string of characters into a line buffer 
00001090                           117  *           A3 points to next free entry in line buffer 
00001090                           118  *           A2 points to end of buffer 
00001090                           119  *           A1 points to start of buffer 
00001090                           120  *           D0 holds character to be stored 
00001090                           121  * 
00001090  43EE 0008                122  GETLINE  LEA.L    LNBUFF(A6),A1     A1 points to start of line buffer 
00001094  47D1                     123           LEA.L    (A1),A3           A3 points to start (initially) 
00001096  45E9 0040                124           LEA.L    MAXCHR(A1),A2     A2 points to end of buffer 
0000109A  6100 0476                125  GETLN2   BSR      GETCHAR           Get a character 
0000109E  B03C 0001                126           CMP.B    #CTRL_A,D0        If control_A then reject this line 
000010A2  671E                     127           BEQ.S    GETLN5            and get another line 
000010A4  B03C 0008                128           CMP.B    #BS,D0            If back_space then move back pointer 
000010A8  660A                     129           BNE.S    GETLN3            Else skip past wind-back routine 
000010AA  B7C9                     130           CMP.L    A1,A3             First check for empty buffer 
000010AC  67EC                     131           BEQ      GETLN2            If buffer empty then continue 
000010AE  47EB FFFF                132           LEA      -1(A3),A3         Else decrement buffer pointer 
000010B2  60E6                     133           BRA      GETLN2            and continue with next character 
000010B4  16C0                     134  GETLN3   MOVE.B   D0,(A3)+          Store character and update pointer 
000010B6  B03C 000D                135           CMP.B    #CR,D0            Test for command terminator 
000010BA  6602                     136           BNE.S    GETLN4            If not CR then skip past exit 
000010BC  60AC                     137           BRA      NEWLINE           Else new line before next operation 
000010BE  B7CA                     138  GETLN4   CMP.L    A2,A3             Test for buffer overflow 
000010C0  66D8                     139           BNE      GETLN2            If buffer not full then continue 
000010C2  61A6                     140  GETLN5   BSR      NEWLINE           Else move to next line and 
000010C4  60CA                     141           BRA      GETLINE           repeat this routine 
000010C6                           142  * 
000010C6                           143  ************************************************************************* 
000010C6                           144  * 
000010C6                           145  *  TIDY cleans up the line buffer by removing leading spaces and multiple 
000010C6                           146  *       spaces between parameters. At the end of TIDY, BUFFPT points to 
000010C6                           147  *       the first parameter following the command. 
000010C6                           148  *       A0 = pointer to line buffer. A1 = pointer to cleaned up buffer 
000010C6                           149  * 
000010C6  41EE 0008                150  TIDY     LEA.L    LNBUFF(A6),A0     A0 points to line buffer 
000010CA  43D0                     151           LEA.L    (A0),A1           A1 points to start of line buffer 
000010CC  1018                     152  TIDY1    MOVE.B   (A0)+,D0          Read character from line buffer 
000010CE  B03C 0020                153           CMP.B    #SPACE,D0         Repeat until the first non-space 
000010D2  67F8                     154           BEQ      TIDY1             character is found 
000010D4  41E8 FFFF                155           LEA.L    -1(A0),A0         Move pointer back to first char 
000010D8  1018                     156  TIDY2    MOVE.B   (A0)+,D0          Move the string left to remove 
000010DA  12C0                     157           MOVE.B   D0,(A1)+          any leading spaces 
000010DC  B03C 0020                158           CMP.B    #SPACE,D0         Test for embedded space 
000010E0  660A                     159           BNE.S    TIDY4             If not space then test for EOL 
000010E2  0C18 0020                160  TIDY3    CMP.B    #SPACE,(A0)+      If space skip multiple embedded 
000010E6  67FA                     161           BEQ      TIDY3             spaces 
000010E8  41E8 FFFF                162           LEA.L    -1(A0),A0         Move back pointer 
000010EC  B03C 000D                163  TIDY4    CMP.B    #CR,D0            Test for end_of_line (EOL) 
000010F0  66E6                     164           BNE      TIDY2             If not EOL then read next char 
000010F2  41EE 0008                165           LEA.L    LNBUFF(A6),A0     Restore buffer pointer 
000010F6  0C10 000D                166  TIDY5    CMP.B    #CR,(A0)          Test for EOL 
000010FA  6706                     167           BEQ.S    TIDY6             If EOL then exit 
000010FC  0C18 0020                168           CMP.B    #SPACE,(A0)+      Test for delimiter 
00001100  66F4                     169           BNE      TIDY5             Repeat until delimiter or EOL 
00001102  2D48 0048                170  TIDY6    MOVE.L   A0,BUFFPT(A6)     Update buffer pointer 
00001106  4E75                     171           RTS 
00001108                           172  * 
00001108                           173  ************************************************************************* 
00001108                           174  * 
00001108                           175  *  EXECUTE matches the first command in the line buffer with the 
00001108                           176  *  commands in a command table. An external table pointed at by 
00001108                           177  *  UTAB is searched first and then the in-built table, COMTAB. 
00001108                           178  * 
00001108  4AAE 0052                179  EXECUTE  TST.L    UTAB(A6)          Test pointer to user table 
0000110C  670C                     180           BEQ.S    EXEC1             If clear then try built-in table 
0000110E  266E 0052                181           MOVE.L   UTAB(A6),A3       Else pick up pointer to user table 
00001112  6120                     182           BSR.S    SEARCH            Look for command in user table 
00001114  6404                     183           BCC.S    EXEC1             If not found then try internal table 
00001116  2653                     184           MOVE.L   (A3),A3           Else get absolute address of command 
00001118  4ED3                     185           JMP      (A3)              from user table and execute it 
0000111A                           186  * 
0000111A  47FA 0EE4                187  EXEC1    LEA.L    COMTAB(PC),A3     Try built-in command table 
0000111E  6114                     188           BSR.S    SEARCH            Look for command in built-in table 
00001120  6508                     189           BCS.S    EXEC2             If found then execute command 
00001122  49FA 09D5                190           LEA.L    ERMES2(PC),A4     Else print "invalid command" 
00001126  6000 FF52                191           BRA.L    PSTRING           and return 
0000112A  2653                     192  EXEC2    MOVE.L   (A3),A3           Get the relative command address 
0000112C  49FA 0ED2                193           LEA.L    COMTAB(PC),A4     pointed at by A3 and add it to 
00001130  D7CC                     194           ADD.L    A4,A3             the PC to generate the actual 
00001132  4ED3                     195           JMP      (A3)              command address. Then execute it. 
00001134                           196  * 
00001134  =00001134                197  SEARCH   EQU      *                 Match the command in the line buffer 
00001134  4280                     198           CLR.L    D0                with command table pointed at by A3 
00001136  1013                     199           MOVE.B   (A3),D0           Get the first character in the 
00001138  6734                     200           BEQ.S    SRCH7             current entry. If zero then exit 
0000113A  49F3 0006                201           LEA.L    6(A3,D0.W),A4     Else calculate address of next entry 
0000113E  122B 0001                202           MOVE.B   1(A3),D1          Get number of characters to match 
00001142  4BEE 0008                203           LEA.L    LNBUFF(A6),A5     A5 points to command in line buffer 
00001146  142B 0002                204           MOVE.B   2(A3),D2          Get first character in this entry 
0000114A  B41D                     205           CMP.B    (A5)+,D2          from the table and match with buffer 
0000114C  6704                     206           BEQ.S    SRCH3             If match then try rest of string 
0000114E  264C                     207  SRCH2    MOVE.L   A4,A3             Else get address of next entry 
00001150  60E2                     208           BRA      SEARCH            and try the next entry in the table 
00001152  5301                     209  SRCH3    SUB.B    #1,D1             One less character to match 
00001154  670E                     210           BEQ.S    SRCH6             If match counter zero then all done 
00001156  47EB 0003                211           LEA.L    3(A3),A3          Else point to next character in table 
0000115A  141B                     212  SRCH4    MOVE.B   (A3)+,D2          Now match a pair of characters 
0000115C  B41D                     213           CMP.B    (A5)+,D2 
0000115E  66EE                     214           BNE      SRCH2             If no match then try next entry 
00001160  5301                     215           SUB.B    #1,D1             Else decrement match counter and 
00001162  66F6                     216           BNE      SRCH4             repeat until no chars left to match 
00001164  47EC FFFC                217  SRCH6    LEA.L    -4(A4),A3         Calculate address of command entry 
00001168  003C 0001                218           OR.B     #1,CCR            point. Mark carry flag as success 
0000116C  4E75                     219           RTS                        and return 
0000116E  023C 00FE                220  SRCH7    AND.B    #$FE,CCR          Fail - clear carry to indicate 
00001172  4E75                     221           RTS                        command not found and return 
00001174                           222  * 
00001174                           223  ************************************************************************* 
00001174                           224  * 
00001174                           225  *  Basic input routines 
00001174                           226  *  HEX    =  Get one   hexadecimal character  into D0 
00001174                           227  *  BYTE   =  Get two   hexadecimal characters into D0 
00001174                           228  *  WORD   =  Get four  hexadecimal characters into D0 
00001174                           229  *  LONGWD =  Get eight hexadecimal characters into D0 
00001174                           230  *  PARAM  =  Get a longword from the line buffer into D0 
00001174                           231  *  Bit 0 of D7 is set to indicate a hexadecimal input error 
00001174                           232  * 
00001174  6100 039C                233  HEX      BSR      GETCHAR           Get a character from input device 
00001178  0400 0030                234           SUB.B    #$30,D0           Convert to binary 
0000117C  6B0E                     235           BMI.S    NOT_HEX           If less than $30 then exit with error 
0000117E  B03C 0009                236           CMP.B    #$09,D0           Else test for number (0 to 9) 
00001182  6F0C                     237           BLE.S    HEX_OK            If number then exit - success 
00001184  5F00                     238           SUB.B    #$07,D0           Else convert letter to hex 
00001186  B03C 000F                239           CMP.B    #$0F,D0           If character in range "A" to "F" 
0000118A  6F04                     240           BLE.S    HEX_OK            then exit successfully 
0000118C  8E3C 0001                241  NOT_HEX  OR.B     #1,D7             Else set error flag 
00001190  4E75                     242  HEX_OK   RTS                        and return 
00001192                           243  * 
00001192  2F01                     244  BYTE     MOVE.L   D1,-(A7)          Save D1 
00001194  61DE                     245           BSR      HEX               Get first hex character 
00001196  E900                     246           ASL.B    #4,D0             Move it to MS nybble position 
00001198  1200                     247           MOVE.B   D0,D1             Save MS nybble in D1 
0000119A  61D8                     248           BSR      HEX               Get second hex character 
0000119C  D001                     249           ADD.B    D1,D0             Merge MS and LS nybbles 
0000119E  221F                     250           MOVE.L   (A7)+,D1          Restore D1 
000011A0  4E75                     251           RTS 
000011A2                           252  * 
000011A2  61EE                     253  WORD     BSR      BYTE              Get upper order byte 
000011A4  E140                     254           ASL.W    #8,D0             Move it to MS position 
000011A6  60EA                     255           BRA      BYTE              Get LS byte and return 
000011A8                           256  * 
000011A8  61F8                     257  LONGWD   BSR      WORD              Get upper order word 
000011AA  4840                     258           SWAP     D0                Move it to MS position 
000011AC  60F4                     259           BRA      WORD              Get lower order word and return 
000011AE                           260  * 
000011AE                           261  *  PARAM reads a parameter from the line buffer and puts it in both 
000011AE                           262  *  PARAMTR(A6) and D0. Bit 1 of D7 is set on error. 
000011AE                           263  * 
000011AE  2F01                     264  PARAM    MOVE.L   D1,-(A7)          Save D1 
000011B0  4281                     265           CLR.L    D1                Clear input accumulator 
000011B2  206E 0048                266           MOVE.L   BUFFPT(A6),A0     A0 points to parameter in buffer 
000011B6  1018                     267  PARAM1   MOVE.B   (A0)+,D0          Read character from line buffer 
000011B8  B03C 0020                268           CMP.B    #SPACE,D0         Test for delimiter 
000011BC  6720                     269           BEQ.S    PARAM4            The permitted delimiter is a 
000011BE  B03C 000D                270           CMP.B    #CR,D0            space or a carriage return 
000011C2  671A                     271           BEQ.S    PARAM4            Exit on either space or C/R 
000011C4  E981                     272           ASL.L    #4,D1             Shift accumulated result 4 bits left 
000011C6  0400 0030                273           SUB.B    #$30,D0           Convert new character to hex 
000011CA  6B1E                     274           BMI.S    PARAM5            If less than $30 then not-hex 
000011CC  B03C 0009                275           CMP.B    #$09,D0           If less than 10 
000011D0  6F08                     276           BLE.S    PARAM3            then continue 
000011D2  5F00                     277           SUB.B    #$07,D0           Else assume $A - $F 
000011D4  B03C 000F                278           CMP.B    #$0F,D0           If more than $F 
000011D8  6E10                     279           BGT.S    PARAM5            then exit to error on not-hex 
000011DA  D200                     280  PARAM3   ADD.B    D0,D1             Add latest nybble to total in D1 
000011DC  60D8                     281           BRA      PARAM1            Repeat until delimiter found 
000011DE  2D48 0048                282  PARAM4   MOVE.L   A0,BUFFPT(A6)     Save pointer in memory 
000011E2  2D41 004C                283           MOVE.L   D1,PARAMTR(A6)    Save parameter in memory 
000011E6  2001                     284           MOVE.L   D1,D0             Put parameter in D0 for return 
000011E8  6004                     285           BRA.S    PARAM6            Return without error 
000011EA  8E3C 0002                286  PARAM5   OR.B     #2,D7             Set error flag before return 
000011EE  221F                     287  PARAM6   MOVE.L   (A7)+,D1          Restore working register 
000011F0  4E75                     288           RTS                        Return with error 
000011F2                           289  * 
000011F2                           290  ************************************************************************* 
000011F2                           291  * 
000011F2                           292  *  Output routines 
000011F2                           293  *  OUT1X   = print one   hexadecimal character 
000011F2                           294  *  OUT2X   = print two   hexadecimal characters 
000011F2                           295  *  OUT4X   = print four  hexadecimal characters 
000011F2                           296  *  OUT8X   = print eight hexadecimal characters 
000011F2                           297  *  In each case, the data to be printed is in D0 
000011F2                           298  * 
000011F2  3F00                     299  OUT1X    MOVE.W   D0,-(A7)          Save D0 
000011F4  C03C 000F                300           AND.B    #$0F,D0           Mask off MS nybble 
000011F8  0600 0030                301           ADD.B    #$30,D0           Convert to ASCII 
000011FC  B03C 0039                302           CMP.B    #$39,D0           ASCII = HEX + $30 
00001200  6302                     303           BLS.S    OUT1X1            If ASCII <= $39 then print and exit 
00001202  5E00                     304           ADD.B    #$07,D0           Else ASCII := HEX + 7 
00001204  6100 033E                305  OUT1X1   BSR      PUTCHAR           Print the character 
00001208  301F                     306           MOVE.W   (A7)+,D0          Restore D0 
0000120A  4E75                     307           RTS 
0000120C                           308  * 
0000120C  E818                     309  OUT2X    ROR.B    #4,D0             Get MS nybble in LS position 
0000120E  61E2                     310           BSR      OUT1X             Print MS nybble 
00001210  E918                     311           ROL.B    #4,D0             Restore LS nybble 
00001212  60DE                     312           BRA      OUT1X             Print LS nybble and return 
00001214                           313  * 
00001214  E058                     314  OUT4X    ROR.W    #8,D0             Get MS byte in LS position 
00001216  61F4                     315           BSR      OUT2X             Print MS byte 
00001218  E158                     316           ROL.W    #8,D0             Restore LS byte 
0000121A  60F0                     317           BRA      OUT2X             Print LS byte and return 
0000121C                           318  * 
0000121C  4840                     319  OUT8X    SWAP     D0                Get MS word in LS position 
0000121E  61F4                     320           BSR      OUT4X             Print MS word 
00001220  4840                     321           SWAP     D0                Restore LS word 
00001222  60F0                     322           BRA      OUT4X             Print LS word and return 
00001224                           323  * 
00001224                           324  ************************************************************************* 
00001224                           325  * 
00001224                           326  * JUMP causes execution to begin at the address in the line buffer 
00001224                           327  * 
00001224  6188                     328  JUMP     BSR     PARAM              Get address from buffer 
00001226  4A07                     329           TST.B   D7                 Test for input error 
00001228  6608                     330           BNE.S   JUMP1              If error flag not zero then exit 
0000122A  4A80                     331           TST.L   D0                 Else test for missing address 
0000122C  6704                     332           BEQ.S   JUMP1              field. If no address then exit 
0000122E  2040                     333           MOVE.L  D0,A0              Put jump address in A0 and call the 
00001230  4ED0                     334           JMP     (A0)               subroutine. User to supply RTS!! 
00001232  49FA 08A7                335  JUMP1    LEA.L   ERMES1(PC),A4      Here for error - display error 
00001236  6000 FE42                336           BRA     PSTRING            message and return 
0000123A                           337  * 
0000123A                           338  ************************************************************************* 
0000123A                           339  * 
0000123A                           340  *  Display the contents of a memory location and modify it 
0000123A                           341  * 
0000123A  6100 FF72                342  MEMORY   BSR      PARAM             Get start address from line buffer 
0000123E  4A07                     343           TST.B    D7                Test for input error 
00001240  6634                     344           BNE.S    MEM3              If error then exit 
00001242  2640                     345           MOVE.L   D0,A3             A3 points to location to be opened 
00001244  6100 FE24                346  MEM1     BSR      NEWLINE 
00001248  612E                     347           BSR.S    ADR_DAT           Print current address and contents 
0000124A  6140                     348           BSR.S    PSPACE             update pointer, A3, and O/P space 
0000124C  6100 02C4                349           BSR      GETCHAR           Input char to decide next action 
00001250  B03C 000D                350           CMP.B    #CR,D0            If carriage return then exit 
00001254  6720                     351           BEQ.S    MEM3              Exit 
00001256  B03C 002D                352           CMP.B    #'-',D0           If "-" then move back 
0000125A  6606                     353           BNE.S    MEM2              Else skip wind-back procedure 
0000125C  47EB FFFC                354           LEA.L    -4(A3),A3         Move pointer back 2+2 
00001260  60E2                     355           BRA      MEM1              Repeat until carriage return 
00001262  B03C 0020                356  MEM2     CMP.B    #SPACE,D0         Test for space (= new entry) 
00001266  66DC                     357           BNE.S    MEM1              If not space then repeat 
00001268  6100 FF38                358           BSR      WORD              Else get new word to store 
0000126C  4A07                     359           TST.B    D7                Test for input error 
0000126E  6606                     360           BNE.S    MEM3              If error then exit 
00001270  3740 FFFE                361           MOVE.W   D0,-2(A3)         Store new word 
00001274  60CE                     362           BRA      MEM1              Repeat until carriage return 
00001276  4E75                     363  MEM3     RTS 
00001278                           364  * 
00001278  2F00                     365  ADR_DAT  MOVE.L   D0,-(A7)          Print the contents of A3 and the 
0000127A  200B                     366           MOVE.L   A3,D0             word pointed at by A3. 
0000127C  619E                     367           BSR      OUT8X              and print current address 
0000127E  610C                     368           BSR.S    PSPACE            Insert delimiter 
00001280  3013                     369           MOVE.W   (A3),D0           Get data at this address in D0 
00001282  6190                     370           BSR      OUT4X              and print it 
00001284  47EB 0002                371           LEA.L    2(A3),A3          Point to next address to display 
00001288  201F                     372           MOVE.L   (A7)+,D0          Restore D0 
0000128A  4E75                     373           RTS 
0000128C                           374  * 
0000128C  1F00                     375  PSPACE   MOVE.B   D0,-(A7)          Print a single space 
0000128E  103C 0020                376           MOVE.B   #SPACE,D0
00001292  6100 02B0                377           BSR      PUTCHAR 
00001296  101F                     378           MOVE.B   (A7)+,D0 
00001298  4E75                     379           RTS 
0000129A                           380  * 
0000129A                           381  ************************************************************************* 
0000129A                           382  * 
0000129A                           383  *  LOAD  Loads data formatted in hexadecimal "S" format from Port 2 
0000129A                           384  *        NOTE - I/O is automatically redirected to the aux port for 
0000129A                           385  *        loader functions. S1 or S2 records accepted 
0000129A                           386  * 
0000129A  2F2E 005A                387  LOAD     MOVE.L   CN_OVEC(A6),-(A7) Save current output device name 
0000129E  2F2E 0056                388           MOVE.L   CN_IVEC(A6),-(A7) Save current input device name 
000012A2  2D7C 0000206C 005A       389           MOVE.L   #DCB4,CN_OVEC(A6) Set up aux ACIA as output 
000012AA  2D7C 0000205A 0056       390           MOVE.L   #DCB3,CN_IVEC(A6) Set up aux ACIA as input 
000012B2  522E 0050                391           ADD.B    #1,ECHO(A6)       Turn off character echo 
000012B6  6100 FDB2                392           BSR      NEWLINE           Send newline to host 
000012BA  6100 0152                393           BSR      DELAY             Wait for host to "settle" 
000012BE  6100 014E                394           BSR      DELAY 
000012C2  286E 0048                395           MOVE.L   BUFFPT(A6),A4     Any string in the line buffer is 
000012C6  101C                     396  LOAD1    MOVE.B   (A4)+,D0          transmitted to the host computer 
000012C8  6100 027A                397           BSR      PUTCHAR           before the loading begins 
000012CC  B03C 000D                398           CMP.B    #CR,D0            Read from the buffer until EOL 
000012D0  66F4                     399           BNE      LOAD1 
000012D2  6100 FD96                400           BSR      NEWLINE           Send newline before loading 
000012D6  6100 023A                401  LOAD2    BSR      GETCHAR           Records from the host must begin 
000012DA  B03C 0053                402           CMP.B    #'S',D0           with S1/S2 (data) or S9/S8 (term) 
000012DE  66F6                     403           BNE.S    LOAD2             Repeat GETCHAR until char = "S" 
000012E0  6100 0230                404           BSR      GETCHAR           Get character after "S" 
000012E4  B03C 0039                405           CMP.B    #'9',D0           Test for the two terminators S9/S8 
000012E8  6706                     406           BEQ.S    LOAD3             If S9 record then exit else test 
000012EA  B03C 0038                407           CMP.B    #'8',D0           for S8 terminator. Fall through to 
000012EE  662A                     408           BNE.S    LOAD6             exit on S8 else continue search 
000012F0  =000012F0                409  LOAD3    EQU      *                 Exit point from LOAD 
000012F0  2D5F 0056                410           MOVE.L   (A7)+,CN_IVEC(A6) Clean up by restoring input device 
000012F4  2D5F 005A                411           MOVE.L   (A7)+,CN_OVEC(A6) and output device name 
000012F8  422E 0050                412           CLR.B    ECHO(A6)          Restore input character echo 
000012FC  0807 0000                413           BTST   #0,D7             Test for input errors 
00001300  6708                     414           BEQ.S    LOAD4             If no I/P error then look at checksum 
00001302  49FA 07D7                415           LEA.L    ERMES1(PC),A4     Else point to error message 
00001306  6100 FD72                416           BSR      PSTRING           Print it 
0000130A  0807 0003                417  LOAD4    BTST   #3,D7             Test for checksum error 
0000130E  6708                     418           BEQ.S    LOAD5             If clear then exit 
00001310  49FA 07F9                419           LEA.L    ERMES3(PC),A4     Else point to error message 
00001314  6100 FD64                420           BSR      PSTRING           Print it and return 
00001318  4E75                     421  LOAD5    RTS 
0000131A                           422  * 
0000131A  B03C 0031                423  LOAD6    CMP.B    #'1',D0           Test for S1 record 
0000131E  671E                     424           BEQ.S    LOAD6A            If S1 record then read it 
00001320  B03C 0032                425           CMP.B    #'2',D0           Else test for S2 record 
00001324  66B0                     426           BNE.S    LOAD2             Repeat until valid header found 
00001326  4203                     427           CLR.B    D3                Read the S2 byte count and address, 
00001328  613C                     428           BSR.S    LOAD8             clear the checksum 
0000132A  5900                     429           SUB.B    #4,D0             Calculate size of data field 
0000132C  1400                     430           MOVE.B   D0,D2             D2 contains data bytes to read 
0000132E  4280                     431           CLR.L    D0                Clear address accumulator 
00001330  6134                     432           BSR.S    LOAD8             Read most sig byte of address 
00001332  E180                     433           ASL.L    #8,D0             Move it one byte left 
00001334  6130                     434           BSR.S    LOAD8             Read the middle byte of address 
00001336  E180                     435           ASL.L    #8,D0             Move it one byte left 
00001338  612C                     436           BSR.S    LOAD8             Read least sig byte of address 
0000133A  2440                     437           MOVE.L   D0,A2             A2 points to destination of record 
0000133C  6012                     438           BRA.S    LOAD7             Skip past S1 header loader 
0000133E  4203                     439  LOAD6A   CLR.B    D3                S1 record found - clear checksum 
00001340  6124                     440           BSR.S    LOAD8             Get byte and update checksum 
00001342  5700                     441           SUB.B    #3,D0             Subtract 3 from record length 
00001344  1400                     442           MOVE.B   D0,D2             Save byte count in D2 
00001346  4280                     443           CLR.L    D0                Clear address accumulator 
00001348  611C                     444           BSR.S    LOAD8             Get MS byte of load address 
0000134A  E180                     445           ASL.L    #8,D0             Move it to MS position 
0000134C  6118                     446           BSR.S    LOAD8             Get LS byte in D2 
0000134E  2440                     447           MOVE.L   D0,A2             A2 points to destination of data 
00001350  6114                     448  LOAD7    BSR.S    LOAD8             Get byte of data for loading 
00001352  14C0                     449           MOVE.B   D0,(A2)+          Store it 
00001354  5302                     450           SUB.B    #1,D2             Decrement byte counter 
00001356  66F8                     451           BNE      LOAD7             Repeat until count = 0 
00001358  610C                     452           BSR.S    LOAD8             Read checksum 
0000135A  5203                     453           ADD.B    #1,D3             Add 1 to total checksum 
0000135C  6700 FF78                454           BEQ      LOAD2             If zero then start next record 
00001360  8E3C 0008                455           OR.B     #%00001000,D7     Else set checksum error bit, 
00001364  608A                     456           BRA      LOAD3             restore I/O devices and return 
00001366                           457  * 
00001366  6100 FE2A                458  LOAD8    BSR     BYTE               Get a byte 
0000136A  D600                     459           ADD.B   D0,D3              Update checksum 
0000136C  4E75                     460           RTS                         and return 
0000136E                           461  *************************************************************************** 
0000136E                           462  * 
0000136E                           463  *  DUMP   Transmit S1 formatted records to host computer 
0000136E                           464  *         A3 = Starting address of data block 
0000136E                           465  *         A2 = End address of data block 
0000136E                           466  *         D1 = Checksum, D2 = current record length 
0000136E                           467  * 
0000136E  6100 008E                468  DUMP     BSR      RANGE             Get start and end address 
00001372  4A07                     469           TST.B    D7                Test for input error 
00001374  6708                     470           BEQ.S    DUMP1             If no error then continue 
00001376  49FA 0763                471           LEA.L    ERMES1(PC),A4     Else point to error message, 
0000137A  6000 FCFE                472           BRA      PSTRING           print it and return 
0000137E  B08B                     473  DUMP1    CMP.L    A3,D0             Compare start and end addresses 
00001380  6A08                     474           BPL.S    DUMP2             If positive then start < end 
00001382  49FA 08F6                475           LEA.L    ERMES7(PC),A4     Else print error message 
00001386  6000 FCF2                476           BRA      PSTRING           and return 
0000138A  2F2E 005A                477  DUMP2    MOVE.L   CN_OVEC(A6),-(A7) Save name of current output device 
0000138E                           478  *         MOVE.L   #DCB4,CN_OVEC(A6) Set up Port 2 as output device 
0000138E  6100 FCDA                479           BSR      NEWLINE           Send newline to host and wait 
00001392  617A                     480           BSR.S    DELAY 
00001394  286E 0048                481           MOVE.L   BUFFPT(A6),A4     Before dumping, send any string 
00001398  101C                     482  DUMP3    MOVE.B   (A4)+,D0          in the input buffer to the host 
0000139A  6100 01A8                483           BSR      PUTCHAR           Repeat 
0000139E  B03C 000D                484           CMP.B    #CR,D0            Transmit char from buffer to host 
000013A2  66F4                     485           BNE      DUMP3             Until char = C/R 
000013A4  6100 FCC4                486           BSR      NEWLINE 
000013A8  6164                     487           BSR.S    DELAY             Allow time for host to settle 
000013AA  528A                     488           ADDQ.L   #1,A2             A2 contains length of record + 1 
000013AC  240A                     489  DUMP4    MOVE.L   A2,D2             D2 points to end address 
000013AE  948B                     490           SUB.L    A3,D2             D2 contains bytes left to print 
000013B0  B4BC 00000011            491           CMP.L    #17,D2            If this is not a full record of 16 
000013B6  6502                     492           BCS.S    DUMP5             then load D2 with record size 
000013B8  7410                     493           MOVEQ    #16,D2            Else preset byte count to 16 
000013BA  49FA 0635                494  DUMP5    LEA.L    HEADER(PC),A4     Point to record header 
000013BE  6100 FCBA                495           BSR      PSTRING           Print header 
000013C2  4201                     496           CLR.B    D1                Clear checksum 
000013C4  1002                     497           MOVE.B   D2,D0             Move record length to output register 
000013C6  5600                     498           ADD.B    #3,D0             Length includes address + count 
000013C8  612E                     499           BSR.S    DUMP7             Print number of bytes in record 
000013CA  200B                     500           MOVE.L   A3,D0             Get start address to be printed 
000013CC  E158                     501           ROL.W    #8,D0             Get MS byte in LS position 
000013CE  6128                     502           BSR.S    DUMP7             Print MS byte of address 
000013D0  E058                     503           ROR.W    #8,D0             Restore LS byte 
000013D2  6124                     504           BSR.S    DUMP7             Print LS byte of address 
000013D4  101B                     505  DUMP6    MOVE.B   (A3)+,D0          Get data byte to be printed 
000013D6  6120                     506           BSR.S    DUMP7             Print it 
000013D8  5302                     507           SUB.B    #1,D2             Decrement byte count 
000013DA  66F8                     508           BNE      DUMP6             Repeat until all this record printed 
000013DC  4601                     509           NOT.B    D1                Complement checksum 
000013DE  1001                     510           MOVE.B   D1,D0             Move to output register 
000013E0  6116                     511           BSR.S    DUMP7             Print checksum 
000013E2  6100 FC86                512           BSR      NEWLINE 
000013E6  B7CA                     513           CMP.L    A2,A3             Have all records been printed? 
000013E8  66C2                     514           BNE      DUMP4             Repeat until all done 
000013EA  49FA 060B                515           LEA.L    TAIL(PC),A4       Point to message tail (S9 record) 
000013EE  6100 FC8A                516           BSR      PSTRING           Print it 
000013F2  2D5F 005A                517           MOVE.L   (A7)+,CN_OVEC(A6) Restore name of output device 
000013F6  4E75                     518           RTS                        and return 
000013F8                           519  * 
000013F8  D200                     520  DUMP7    ADD.B    D0,D1             Update checksum, transmit byte 
000013FA  6000 FE10                521           BRA      OUT2X             to host and return 
000013FE                           522  * 
000013FE  =000013FE                523  RANGE    EQU      *                 Get the range of addresses to be 
000013FE  4207                     524           CLR.B    D7                transmitted from the buffer 
00001400  6100 FDAC                525           BSR      PARAM             Get starting address 
00001404  2640                     526           MOVE.L   D0,A3             Set up start address in A3 
00001406  6100 FDA6                527           BSR      PARAM             Get end address 
0000140A  2440                     528           MOVE.L   D0,A2             Set up end address in A2 
0000140C  4E75                     529           RTS 
0000140E                           530  * 
0000140E  =0000140E                531  DELAY    EQU       *                Provide a time delay for the host 
0000140E  48E7 8008                532           MOVEM.L   D0/A4,-(A7)      to settle. Save working registers 
00001412  203C 00004000            533           MOVE.L    #$4000,D0        Set up delay constant 
00001418  5380                     534  DELAY1   SUB.L     #1,D0            Count down         (8 clk cycles) 
0000141A  66FC                     535           BNE       DELAY1           Repeat until zero  (10 clk cycles) 
0000141C  4CDF 1001                536           MOVEM.L   (A7)+,D0/A4      Restore working registers 
00001420  4E75                     537           RTS 
00001422                           538  * 
00001422                           539  ************************************************************************* 
00001422                           540  * 
00001422                           541  *  TM  Enter transparant mode (All communication to go from terminal to 
00001422                           542  *  the host processor until escape sequence entered). End sequence 
00001422                           543  *  = ESC, E. A newline is sent to the host to "clear it down". 
00001422                           544  * 
00001422                           545  *TM       MOVE.B    #$55,ACIA_1      Force RTS* high to re-route data 
00001422                           546  *         ADD.B     #1,ECHO(A6)      Turn off character echo 
00001422                           547  *TM1      BSR       GETCHAR          Get character 
00001422                           548  *         CMP.B     #ESC,D0          Test for end of TM mode 
00001422                           549  *         BNE       TM1              Repeat until first escape character 
00001422                           550  *         BSR       GETCHAR          Get second character 
00001422                           551  *         CMP.B     #'E',D0          If second char = E then exit TM 
00001422                           552  *         BNE       TM1              Else continue 
00001422                           553  *         MOVE.L    CN_OVEC(A6),-(A7) Save output port device name 
00001422                           554  *         MOVE.L    #DCB4,CN_OVEC(A6) Get name of host port (aux port) 
00001422                           555  *         BSR       NEWLINE          Send newline to host to clear it 
00001422                           556  *         MOVE.L    (A7)+,CN_OVEC(A6) Restore output device port name 
00001422                           557  *         CLR.B     ECHO(A6)         Restore echo mode 
00001422                           558  *         MOVE.B    #$15,ACIA_1      Restore normal ACIA mode (RTS* low) 
00001422                           559  *         RTS 
00001422                           560  * 
00001422                           561  ************************************************************************* 
00001422                           562  * 
00001422                           563  *  This routine sets up the system DCBs in RAM using the information 
00001422                           564  *  stored in ROM at address DCB_LST. This is called at initialization. 
00001422                           565  *  CN_IVEC contains the name "DCB1" and IO_VEC the name "DCB2" 
00001422                           566  * 
00001422  48E7 F0F0                567  SET_DCB  MOVEM.L A0-A3/D0-D3,-(A7) Save all working registers 
00001426  41EE 00D8                568           LEA.L   FIRST(A6),A0    Pointer to first DCB destination in RAM 
0000142A  43FA 0C0A                569           LEA.L   DCB_LST(PC),A1  A1 points to DCB info block in ROM 
0000142E  303C 0003                570           MOVE.W  #3,D0           4 DCBs to set up 
00001432  323C 000F                571  ST_DCB1  MOVE.W  #15,D1          16 bytes to move per DCB header 
00001436  10D9                     572  ST_DCB2  MOVE.B  (A1)+,(A0)+     Move the 16 bytes of a DCB header 
00001438  51C9 FFFC                573           DBRA    D1,ST_DCB2      from ROM to RAM 
0000143C  3619                     574           MOVE.W  (A1)+,D3        Get size of parameter block (bytes) 
0000143E  3083                     575           MOVE.W  D3,(A0)         Store size in DCB in RAM 
00001440  41F0 3002                576           LEA.L   2(A0,D3.W),A0   A0 points to tail of DCB in RAM 
00001444  47E8 0004                577           LEA.L   4(A0),A3        A3 contains address of next DCB in RAM 
00001448  208B                     578           MOVE.L  A3,(A0)         Store pointer to next DCB in this DCB 
0000144A  41D3                     579           LEA.L   (A3),A0         A0 now points at next DCB in RAM 
0000144C  51C8 FFE4                580           DBRA    D0,ST_DCB1      Repeat until all DCBs set up 
00001450  47EB FFFC                581           LEA.L   -4(A3),A3       Adjust A3 to point to last DCB pointer 
00001454  4293                     582           CLR.L   (A3)            and force last pointer to zero 
00001456  2D7C 00002036 0056       583           MOVE.L  #DCB1,CN_IVEC(A6) Set up vector to console input DCB 
0000145E  2D7C 00002048 005A       584           MOVE.L  #DCB2,CN_OVEC(A6) Set up vector to console output DCB 
00001466  4CDF 0F0F                585           MOVEM.L (A7)+,A0-A3/D0-D3 Restore registers 
0000146A  4E75                     586           RTS 
0000146C                           587  * 
0000146C                           588  ************************************************************************* 
0000146C                           589  * 
0000146C                           590  *  IO_REQ handles all input/output transactions. A0 points to DCB on 
0000146C                           591  *  entry. IO_REQ calls the device driver whose address is in the DCB. 
0000146C                           592  * 
0000146C  48E7 00C0                593  IO_REQ   MOVEM.L A0-A1,-(A7)     Save working registers 
00001470  43E8 0008                594           LEA.L   8(A0),A1        A1 points to device handler field in DCB 
00001474  2251                     595           MOVE.L  (A1),A1         A1 contains device handler address 
00001476  4E91                     596           JSR     (A1)            Call device handler 
00001478  4CDF 0300                597           MOVEM.L (A7)+,A0-A1     Restore working registers 
0000147C  4E75                     598           RTS 
0000147E                           599  * 
0000147E                           600  ************************************************************************* 
0000147E                           601  * 
0000147E                           602  *  CON_IN handles input from the console device 
0000147E                           603  *  This is the device driver used by DCB1. Exit with input in D0 
0000147E                           604  * 
0000147E  48E7 4040                605  CON_IN   MOVEM.L D1/A1,-(A7)     Save working registers 
00001482  43E8 000C                606           LEA.L   12(A0),A1       Get pointer to ACIA from DCB 
00001486  2251                     607           MOVE.L  (A1),A1         Get address of ACIA in A1 
00001488  4228 0013                608           CLR.B   19(A0)          Clear logical error in DCB 
0000148C  1211                     609  CON_I1   MOVE.B  (A1),D1         Read ACIA status 
0000148E  0801 0000                610           BTST  #0,D1           Test RDRF 
00001492  67F8                     611           BEQ     CON_I1          Repeat until RDRF true 
00001494  1141 0012                612           MOVE.B  D1,18(A0)       Store physical status in DCB 
00001498  C23C 00F4                613           AND.B   #%011110100,D1  Mask to input error bits 
0000149C  6706                     614           BEQ.S   CON_I2          If no error then skip update 
0000149E  117C 0001 0013           615           MOVE.B  #1,19(A0)       Else update logical error 
000014A4  1029 0002                616  CON_I2   MOVE.B  2(A1),D0        Read input from ACIA 
000014A8  4CDF 0202                617           MOVEM.L (A7)+,A1/D1     Restore working registers 
000014AC  4E75                     618           RTS 
000014AE                           619  * 
000014AE                           620  ************************************************************************* 
000014AE                           621  * 
000014AE                           622  *   This is the device driver used by DCB2. Output in D0 
000014AE                           623  *   The output can be halted or suspended 
000014AE                           624  * 
000014AE  48E7 6040                625  CON_OUT  MOVEM.L A1/D1-D2,-(A7)  Save working registers 
000014B2  43E8 000C                626           LEA.L   12(A0),A1       Get pointer to ACIA from DCB 
000014B6  2251                     627           MOVE.L  (A1),A1         Get address of ACIA in A1 
000014B8  4228 0013                628           CLR.B   19(A0)          Clear logical error in DCB 
000014BC  1211                     629  CON_OT1  MOVE.B  (A1),D1         Read ACIA status 
000014BE  0801 0000                630           BTST  #0,D1           Test RDRF bit (any input?) 
000014C2  6716                     631           BEQ.S   CON_OT3         If no input then test output status 
000014C4  1429 0002                632           MOVE.B  2(A1),D2        Else read the input 
000014C8  C43C 005F                633           AND.B   #%01011111,D2   Strip parity and bit 5 
000014CC  B43C 0057                634           CMP.B   #WAIT,D2        and test for a wait condition 
000014D0  6608                     635           BNE.S   CON_OT3         If not wait then ignore and test O/P 
000014D2  1411                     636  CON_OT2  MOVE.B  (A1),D2         Else read ACIA status register 
000014D4  0802 0000                637           BTST  #0,D2           and poll ACIA until next char received 
000014D8  67F8                     638           BEQ     CON_OT2 
000014DA  0801 0001                639  CON_OT3  BTST  #1,D1           Repeat 
000014DE  67DC                     640           BEQ     CON_OT1          until ACIA Tx ready 
000014E0  1141 0012                641           MOVE.B  D1,18(A0)       Store status in DCB physical error 
000014E4  1340 0002                642           MOVE.B  D0,2(A1)        Transmit output 
000014E8  4CDF 0206                643           MOVEM.L (A7)+,A1/D1-D2  Restore working registers 
000014EC  4E75                     644           RTS 
000014EE                           645  * 
000014EE                           646  ************************************************************************* 
000014EE                           647  * 
000014EE                           648  *  AUX_IN and AUX_OUT are simplified versions of CON_IN and 
000014EE                           649  *  CON_OUT for use with the port to the host processor 
000014EE                           650  * 
000014EE  43E8 000C                651  AUX_IN   LEA.L   12(A0),A1       Get pointer to aux ACIA from DCB 
000014F2  2251                     652           MOVE.L  (A1),A1         Get address of aux ACIA 
000014F4  0811 0000                653  AUX_IN1  BTST.B  #0,(A1)         Test for data ready 
000014F8  67FA                     654           BEQ     AUX_IN1         Repeat until ready 
000014FA  1029 0002                655           MOVE.B  2(A1),D0        Read input 
000014FE  4E75                     656           RTS 
00001500                           657  * 
00001500  43E8 000C                658  AUX_OUT  LEA.L   12(A0),A1       Get pointer to aux ACIA from DCB 
00001504  2251                     659           MOVE.L  (A1),A1         Get address of aux ACIA 
00001506  0811 0001                660  AUX_OT1  BTST.B  #1,(A1)         Test for ready to transmit 
0000150A  67FA                     661           BEQ     AUX_OT1         Repeat until transmitter ready 
0000150C  1340 0002                662           MOVE.B  D0,2(A1)        Transmit data 
00001510  4E75                     663           RTS 
00001512                           664  * 
00001512                           665  ************************************************************************* 
00001512                           666  * 
00001512                           667  *  GETCHAR gets a character from the console device 
00001512                           668  *  This is the main input routine and uses the device whose name  
00001512                           669  *  is stored in CN_IVEC. Changing this name redirects input. 
00001512                           670  * 
00001512  2F08                     671  GETCHAR  MOVE.L  A0,-(A7)        Save working register 
00001514  206E 0056                672           MOVE.L  CN_IVEC(A6),A0  A0 points to name of console DCB 
00001518  613A                     673           BSR.S   IO_OPEN         Open console (get DCB address in A0) 
0000151A  0807 0003                674           BTST  #3,D7           D7(3) set if open error 
0000151E  6620                     675           BNE.S   GETCH3          If error then exit now 
00001520  6100 FF4A                676           BSR     IO_REQ          Else execute I/O transaction 
00001524  C03C 007F                677           AND.B   #$7F,D0         Strip msb of input 
00001528  4A2E 0051                678           TST.B   U_CASE(A6)      Test for upper -> lower case conversion 
0000152C  660A                     679           BNE.S   GETCH2          If flag not zero do not convert case 
0000152E  0800 0006                680           BTST  #6,D0           Test input for lower case 
00001532  6704                     681           BEQ.S   GETCH2          If upper case then skip conversion 
00001534  C03C 00DF                682           AND.B   #%11011111,D0   Else clear bit 5 for upper case conv 
00001538  4A2E 0050                683  GETCH2   TST.B   ECHO(A6)        Do we need to echo the input? 
0000153C  6602                     684           BNE.S   GETCH3          If ECHO not zero then no echo 
0000153E  6104                     685           BSR.S   PUTCHAR         Else echo the input 
00001540  205F                     686  GETCH3   MOVE.L  (A7)+,A0        Restore working register 
00001542  4E75                     687           RTS                     and return 
00001544                           688  * 
00001544                           689  ************************************************************************* 
00001544                           690  * 
00001544                           691  *  PUTCHAR sends a character to the console device 
00001544                           692  *  The name of the output device is in CN_OVEC. 
00001544                           693  * 
00001544  2F08                     694  PUTCHAR  MOVE.L  A0,-(A7)        Save working register 
00001546  206E 005A                695           MOVE.L  CN_OVEC(A6),A0  A0 points to name of console output 
0000154A  6108                     696           BSR.S   IO_OPEN         Open console (Get address of DCB) 
0000154C  6100 FF1E                697           BSR     IO_REQ          Perform output with DCB pointed at by A0 
00001550  205F                     698           MOVE.L  (A7)+,A0        Restore working register 
00001552  4E75                     699           RTS 
00001554                           700  * 
00001554                           701  ************************************************************************* 
00001554                           702  * 
00001554                           703  *  BUFF_IN and BUFF_OUT are two rudimentary input and output routines 
00001554                           704  *  which input data from and output data to a buffer in RAM. These are 
00001554                           705  *  used by DCB5 and DCB6, respectively. 
00001554                           706  * 
00001554                           707  *BUFF_IN  LEA.L   12(A0),A1       A1 points to I/P buffer 
00001554                           708  *         MOVE.L  (A1),A2         A2 gets I/P pointer from buffer 
00001554                           709  *         MOVE.B  -(A2),D0        Read char from buffer and adjust A2 
00001554                           710  *         MOVE.L  A2,(A1)         Restore pointer in buffer 
00001554                           711  *         RTS 
00001554                           712  * 
00001554                           713  *BUFF_OT  LEA.L   12(A0),A1       A1 points to O/P buffer 
00001554                           714  *         MOVE.L  4(A1),A2        A2 gets O/P pointer from buffer 
00001554                           715  *         MOVE.B  D0,(A2)+        Store char in buffer and adjust A2 
00001554                           716  *         MOVE.L  A2,(A1)         Restore pointer in buffer 
00001554                           717  *         RTS 
00001554                           718  * 
00001554                           719  ************************************************************************* 
00001554                           720  * 
00001554                           721  *  Open - opens a DCB for input or output. IO_OPEN converts the 
00001554                           722  *  name pointed at by A0 into the address of the DCB pointed at 
00001554                           723  *  by A0. Bit 3 of D7 is set to zero if DCB not found 
00001554                           724  * 
00001554  48E7 F870                725  IO_OPEN  MOVEM.L  A1-A3/D0-D4,-(A7) Save working registers 
00001558  43EE 00D8                726           LEA.L    FIRST(A6),A1   A1 points to first DCB in chain in RAM 
0000155C  45D1                     727  OPEN1    LEA.L    (A1),A2        A2 = temp copy of pointer to DCB 
0000155E  47D0                     728           LEA.L    (A0),A3        A3 = temp copy of pointer to DCB name 
00001560  303C 0007                729           MOVE.W   #7,D0          Up to 8 chars of DCB name to match 
00001564  181A                     730  OPEN2    MOVE.B   (A2)+,D4       Compare DCB name with string 
00001566  B81B                     731           CMP.B    (A3)+,D4 
00001568  6608                     732           BNE.S    OPEN3          If no match try next DCB 
0000156A  51C8 FFF8                733           DBRA     D0,OPEN2       Else repeat until all chars matched 
0000156E  41D1                     734           LEA.L    (A1),A0        Success - move this DCB address to A0 
00001570  6016                     735           BRA.S    OPEN4          and return 
00001572  =00001572                736  OPEN3    EQU      *              Fail - calculate address of next DCB 
00001572  3229 0010                737           MOVE.W   16(A1),D1      Get parameter block size of DCB 
00001576  43F1 1012                738           LEA.L    18(A1,D1.W),A1 A1 points to pointer to next DCB 
0000157A  2251                     739           MOVE.L   (A1),A1        A1 now points to next DCB 
0000157C  B3FC 00000000            740           CMP.L    #0,A1          Test for end of DCB chain 
00001582  66D8                     741           BNE      OPEN1          If not end of chain then try next DCB 
00001584  8E3C 0008                742           OR.B     #8,D7          Else set error flag and return 
00001588  4CDF 0E1F                743  OPEN4    MOVEM.L  (A7)+,A1-A3/D0-D4 Restore working registers 
0000158C  4E75                     744           RTS 
0000158E                           745  * 
0000158E                           746  ************************************************************************* 
0000158E                           747  * 
0000158E                           748  *  Exception vector table initialization routine 
0000158E                           749  *  All vectors not setup are loaded with uninitialized routine vector 
0000158E                           750  * 
0000158E  303C 0007                751  B_CLR   MOVE.W  #7,D0             Now clear the breakpoint table 
00001592  41EE 00A8                752          LEA.L   BP_TAB(A6),A0     Point to table
00001596  4E75                     753          RTS 
00001598                           754  *X_SET2  CLR.L   (A0)+             Clear an address entry 
00001598                           755  *        CLR.W   (A0)+             Clear the corresponding data 
00001598                           756  *        DBRA    D0,X_SET2         Repeat until all 8 cleared 
00001598                           757  *        RTS 
00001598                           758  * 
00001598                           759  ************************************************************************* 
00001598                           760  * 
00001598                           761  *TRAP_0  EQU     *                 User links to  TS2BUG via TRAP #0 
00001598                           762  *FUNC0   CMP.B   #0,D1             D1 = 0 = Get character 
00001598                           763  *        BNE.S   FUNC1           
00001598                           764  *        BSR     GETCHAR 
00001598                           765  *        RTE 
00001598                           766  *FUNC1   CMP.B   #1,D1             D1 = 1 = Print character 
00001598                           767  *        BNE.S   FUNC2 
00001598                           768  *        BSR     PUTCHAR 
00001598                           769  *        RTE 
00001598                           770  *FUNC2   CMP.B   #2,D1             D1 = 2 = Newline 
00001598                           771  *        BNE.S   FUNC3 
00001598                           772  *        BSR     NEWLINE 
00001598                           773  *        RTE 
00001598                           774  *FUNC3   CMP.B   #3,D1             D1 = 3 = Get parameter from buffer 
00001598                           775  *        BNE.S   FUNC4 
00001598                           776  *        BSR     PARAM 
00001598                           777  *        RTE 
00001598                           778  *FUNC4   CMP.B   #4,D1             D1 = 4 = Print string pointed at by A4 
00001598                           779  *        BNE.S   FUNC5 
00001598                           780  *        BSR     PSTRING 
00001598                           781  *        RTE 
00001598                           782  *FUNC5   CMP.B   #5,D1             D1 = 5 = Get a hex character 
00001598                           783  *        BNE.S   FUNC6 
00001598                           784  *        BSR     HEX 
00001598                           785  *        RTE 
00001598                           786  *FUNC6   CMP.B   #6,D1             D1 = 6 = Get a hex byte 
00001598                           787  *        BNE.S   FUNC7 
00001598                           788  *        BSR     BYTE 
00001598                           789  *        RTE 
00001598                           790  *FUNC7   CMP.B   #7,D1             D1 = 7 = Get a word 
00001598                           791  *        BNE.S   FUNC8 
00001598                           792  *        BSR     WORD 
00001598                           793  *        RTE 
00001598                           794  *FUNC8   CMP.B   #8,D1             D1 = 8 = Get a longword 
00001598                           795  *        BNE.S   FUNC9 
00001598                           796  *        BSR     LONGWD 
00001598                           797  *        RTE 
00001598                           798  *FUNC9   CMP.B   #9,D1             D1 = 9 = Output hex byte 
00001598                           799  *        BNE.S   FUNC10  
00001598                           800  *        BSR     OUT2X 
00001598                           801  *        RTE 
00001598                           802  *FUNC10  CMP.B   #10,D1            D1 = 10 = Output hex word 
00001598                           803  *        BNE.S   FUNC11 
00001598                           804  *        BSR     OUT4X 
00001598                           805  *        RTE 
00001598                           806  *FUNC11  CMP.B   #11,D1            D1 = 11 = Output hex longword 
00001598                           807  *        BNE.S   FUNC12 
00001598                           808  *        BSR     OUT8X 
00001598                           809  *        RTE 
00001598                           810  *FUNC12  CMP.B   #12,D1            D1 = 12 = Print a space 
00001598                           811  *        BNE.S   FUNC13 
00001598                           812  *        BSR     PSPACE 
00001598                           813  *        RTE 
00001598                           814  *FUNC13  CMP.B   #13,D1            D1 = 13 = Get a line of text into 
00001598                           815  *        BNE.S   FUNC14            the line buffer 
00001598                           816  *        BSR     GETLINE 
00001598                           817  *        RTE 
00001598                           818  *FUNC14  CMP.B   #14,D1            D1 = 14 = Tidy up the line in the 
00001598                           819  *        BNE.S   FUNC15            line buffer by removing leading 
00001598                           820  *        BSR     TIDY              leading and multiple embeded spaces 
00001598                           821  *        RTE 
00001598                           822  *FUNC15  CMP.B   #15,D1            D1 = 15 = Execute the command in 
00001598                           823  *        BNE.S   FUNC16            the line buffer 
00001598                           824  *        BSR     EXECUTE 
00001598                           825  *        RTE 
00001598                           826  *FUNC16  CMP.B   #16,D1            D1 = 16 = Call RESTORE to transfer 
00001598                           827  *        BNE.S   FUNC17            the registers in TSK_T to the 68000 
00001598                           828  *        BSR     RESTORE           and therefore execute a program 
00001598                           829  *        RTE 
00001598                           830  *FUNC17  RTE 
00001598                           831  * 
00001598                           832  ************************************************************************* 
00001598                           833  * 
00001598                           834  *  Display exception frame (D0 - D7, A0 - A6, USP, SSP, SR, PC) 
00001598                           835  *  EX_DIS prints registers saved after a breakpoint or exception 
00001598                           836  *  The registers are saved in TSK_T 
00001598                           837  * 
00001598  4BEE 005E                838  EX_DIS  LEA.L   TSK_T(A6),A5      A5 points to display frame 
0000159C  49FA 047A                839          LEA.L   MES3(PC),A4       Point to heading 
000015A0  6100 FAE8                840          BSR     HEADING           and print it 
000015A4  3C3C 0007                841          MOVE.W  #7,D6             8 pairs of registers to display 
000015A8  4205                     842          CLR.B   D5                D5 is the line counter 
000015AA  1005                     843  EX_D1   MOVE.B  D5,D0             Put current register number in D0 
000015AC  6100 FC44                844          BSR     OUT1X             and print it 
000015B0  6100 FCDA                845          BSR     PSPACE            and a space 
000015B4  5205                     846          ADD.B   #1,D5             Update counter for next pair 
000015B6  2015                     847          MOVE.L  (A5),D0           Get data register to be displayed 
000015B8  6100 FC62                848          BSR     OUT8X             from the frame and print it 
000015BC  49FA 0478                849          LEA.L   MES4(PC),A4       Print string of spaces 
000015C0  6100 FAB8                850          BSR.L   PSTRING           between data and address registers 
000015C4  202D 0020                851          MOVE.L  32(A5),D0         Get address register to be displayed 
000015C8  6100 FC52                852          BSR     OUT8X             which is 32 bytes on from data reg 
000015CC  6100 FA9C                853          BSR     NEWLINE 
000015D0  4BED 0004                854          LEA.L   4(A5),A5          Point to next pair (ie Di, Ai) 
000015D4  51CE FFD4                855          DBRA    D6,EX_D1          Repeat until all displayed 
000015D8  4BED 0020                856          LEA.L   32(A5),A5         Adjust pointer by 8 longwords 
000015DC  6100 FA8C                857          BSR     NEWLINE           to point to SSP 
000015E0  49FA 042D                858          LEA.L   MES2A(PC),A4      Point to "SS =" 
000015E4  6100 FA94                859          BSR     PSTRING           Print it 
000015E8  201D                     860          MOVE.L  (A5)+,D0          Get SSP from frame 
000015EA  6100 FC30                861          BSR     OUT8X             and display it 
000015EE  6100 FA7A                862          BSR     NEWLINE 
000015F2  49FA 0409                863          LEA.L   MES1(PC),A4       Point to 'SR =' 
000015F6  6100 FA82                864          BSR     PSTRING           Print it 
000015FA  301D                     865          MOVE.W  (A5)+,D0          Get status register 
000015FC  6100 FC16                866          BSR     OUT4X             Display status 
00001600  6100 FA68                867          BSR     NEWLINE 
00001604  49FA 0400                868          LEA.L   MES2(PC),A4       Point to 'PC =' 
00001608  6100 FA70                869          BSR     PSTRING           Print it 
0000160C  201D                     870          MOVE.L  (A5)+,D0          Get PC 
0000160E  6100 FC0C                871          BSR     OUT8X             Display PC 
00001612  6000 FA56                872          BRA     NEWLINE           Newline and return 
00001616                           873  * 
00001616                           874  ************************************************************************* 
00001616                           875  
00001616  49F9 00001B5B            876  HELP     LEA.L    JUMPHELP,A4
0000161C  6100 FA5C                877           BSR.W    PSTRING
00001620  6100 FA48                878           BSR.W    NEWLINE
00001624  49F9 00001B91            879           LEA.L    MEMHELP,A4
0000162A  6100 FA4E                880           BSR.W    PSTRING
0000162E  6100 FA3A                881           BSR.W    NEWLINE
00001632  49F9 00001BDE            882           LEA.L    LOADHELP,A4
00001638  6100 FA40                883           BSR.W    PSTRING
0000163C  6100 FA2C                884           BSR.W    NEWLINE
00001640  49F9 00001C28            885           LEA.L    TVHELP,A4
00001646  6100 FA32                886           BSR.W    PSTRING
0000164A  4E75                     887           RTS
0000164C                           888  *
0000164C                           889  ************************************************************************* 
0000164C  2878 03D8                890  TV       MOVE.L   MIN_RAM,A4
00001650  1C3C 0000                891           MOVE.B   #0,D6
00001654  323C 0000                892  LOOPRAM  MOVE.W   #0,D1
00001658  3881                     893           MOVE.W   D1,(A4)
0000165A  49EC 0002                894           LEA.L    2(A4),A4          Point to next address to display
0000165E  B9F8 03DC                895           CMP.L    MAX_RAM,A4
00001662  66F0                     896           BNE      LOOPRAM
00001664  2878 03D8                897           MOVE.L   MIN_RAM,A4
00001668  3214                     898  CHECK1   MOVE.W   (A4),D1
0000166A  B27C 0000                899           CMP.W    #0,D1
0000166E  6700 0042                900           BEQ      MEMFAIL           TODO:// CHANGE BACK TO BNE
00001672  49EC 0002                901  CHECK2   LEA.L    2(A4),A4          Point to next address to read
00001676  B9F8 03DC                902           CMP.L    MAX_RAM,A4
0000167A  66EC                     903           BNE      CHECK1
0000167C  2878 03D8                904           MOVE.L   MIN_RAM,A4
00001680  323C FFFF                905  LOOPRAM1 MOVE.W   #65535,D1
00001684  3881                     906           MOVE.W   D1,(A4)
00001686  49EC 0002                907           LEA.L    2(A4),A4          Point to next address to display
0000168A  B9F8 03DC                908           CMP.L    MAX_RAM,A4
0000168E  66F0                     909           BNE      LOOPRAM1
00001690  2878 03D8                910           MOVE.L   MIN_RAM,A4
00001694  3214                     911  CHECK3   MOVE.W   (A4),D1
00001696  B27C FFFF                912           CMP.W    #65535,D1
0000169A  6600 0032                913           BNE      MEMFAIL2
0000169E  49EC 0002                914  CHECK4   LEA.L    2(A4),A4          Point to next address to read
000016A2  B9F8 03DC                915           CMP.L    MAX_RAM,A4
000016A6  66EC                     916           BNE      CHECK3
000016A8  BC3C 0000                917           CMP.B    #0,D6
000016AC  6700 003C                918           BEQ      MEMGOOD
000016B0  4E75                     919           RTS
000016B2                           920  
000016B2  2F0C                     921  MEMFAIL  MOVE.L  A4,-(A7)          Save A4 
000016B4  7C01                     922           MOVE.L  #1,D6
000016B6  6100 F9B2                923           BSR.W   NEWLINE
000016BA  49F9 00001CFF            924           LEA.L   MEMFMSG,A4
000016C0  6100 F9B8                925           BSR.W   PSTRING
000016C4  285F                     926           MOVE.L  (A7)+,A4          Restore A4
000016C6  200C                     927           MOVE.L  A4,D0
000016C8  6100 FB52                928           BSR.W    OUT8X 
000016CC  60A4                     929           BRA     CHECK2
000016CE                           930  
000016CE  2F0C                     931  MEMFAIL2 MOVE.L  A4,-(A7)          Save A4 
000016D0  7C01                     932           MOVE.L  #1,D6
000016D2  6100 F996                933           BSR.W   NEWLINE
000016D6  49F9 00001CFF            934           LEA.L   MEMFMSG,A4
000016DC  6100 F99C                935           BSR.W   PSTRING
000016E0  285F                     936           MOVE.L  (A7)+,A4          Restore A4
000016E2  200C                     937           MOVE.L  A4,D0
000016E4  6100 FB36                938           BSR.W    OUT8X 
000016E8  60B4                     939           BRA     CHECK4         
000016EA                           940   
000016EA  49F9 00001D0F            941  MEMGOOD  LEA.L  MEMGMSG,A4
000016F0  6100 F988                942           BSR.W  PSTRING
000016F4  4E75                     943           RTS
000016F6                           944  *************************************************************************
000016F6                           945  * 
000016F6                           946  *  Exception handling routines 
000016F6                           947  * 
000016F6  =000016F6                948  IL_ER   EQU      *                Illegal instruction exception 
000016F6  2F0C                     949          MOVE.L  A4,-(A7)          Save A4 
000016F8  49FA 0366                950          LEA.L   MES10(PC),A4      Point to heading 
000016FC  6100 F98C                951          BSR     HEADING           Print it 
00001700  285F                     952          MOVE.L  (A7)+,A4          Restore A4 
00001702  6176                     953          BSR.S   GROUP2            Save registers in display frame 
00001704  6100 FE92                954          BSR     EX_DIS            Display registers saved in frame 
00001708  6000 F93A                955          BRA     WARM              Abort from illegal instruction 
0000170C                           956  * 
0000170C  =0000170C                957  BUS_ER  EQU     *                 Bus error (group 1) exception 
0000170C  2F0C                     958          MOVE.L  A4,-(A7)          Save A4 
0000170E  49FA 0330                959          LEA.L   MES8(PC),A4       Point to heading 
00001712  6100 F976                960          BSR     HEADING           Print it 
00001716  285F                     961          MOVE.L  (A7)+,A4          Restore A4 
00001718  602C                     962          BRA.S   GROUP1            Deal with group 1 exception 
0000171A                           963  * 
0000171A  =0000171A                964  ADD_ER  EQU     *                 Address error (group 1) exception 
0000171A  2F0C                     965          MOVE.L  A4,-(A7)          Save A4 
0000171C  49FA 0330                966          LEA.L   MES9(PC),A4       Point to heading 
00001720  6100 F968                967          BSR     HEADING           Print it 
00001724  285F                     968          MOVE.L  (A7)+,A4          Restore A4 
00001726  601E                     969          BRA.S   GROUP1            Deal with group 1 exception 
00001728                           970  * 
00001728  =00001728                971  BRKPT   EQU     *                   Deal with breakpoint 
00001728  48E7 FFFE                972          MOVEM.L D0-D7/A0-A6,-(A7)   Save all registers 
0000172C  6100 0180                973          BSR     BR_CLR              Clear breakpoints in code 
00001730  4CDF 7FFF                974          MOVEM.L (A7)+,D0-D7/A0-A6   Restore registers 
00001734  6144                     975          BSR.S   GROUP2            Treat as group 2 exception 
00001736  49FA 033E                976          LEA.L   MES11(PC),A4      Point to heading 
0000173A  6100 F94E                977          BSR     HEADING           Print it 
0000173E  6100 FE58                978          BSR     EX_DIS            Display saved registers 
00001742  6000 F900                979          BRA     WARM              Return to monitor 
00001746                           980  * 
00001746                           981  *       GROUP1 is called by address and bus error exceptions 
00001746                           982  *       These are "turned into group 2" exceptions (eg TRAP) 
00001746                           983  *       by modifying the stack frame saved by a group 1 exception 
00001746                           984  * 
00001746  48E7 8080                985  GROUP1  MOVEM.L D0/A0,-(A7)       Save working registers 
0000174A  206F 0012                986          MOVE.L  18(A7),A0         Get PC from group 1 stack frame 
0000174E  302F 000E                987          MOVE.W  14(A7),D0         Get instruction from stack frame 
00001752  B060                     988          CMP.W   -(A0),D0          Now backtrack to find the "correct PC" 
00001754  670E                     989          BEQ.S   GROUP1A           by matching the op-code on the stack 
00001756  B060                     990          CMP.W   -(A0),D0          with the code in the region of the 
00001758  670A                     991          BEQ.S   GROUP1A           PC on the stack 
0000175A  B060                     992          CMP.W   -(A0),D0 
0000175C  6706                     993          BEQ.S   GROUP1A 
0000175E  B060                     994          CMP.W   -(A0),D0 
00001760  6702                     995          BEQ.S   GROUP1A 
00001762  5588                     996          SUBQ.L  #2,A0 
00001764  2F48 0012                997  GROUP1A MOVE.L  A0,18(A7)          Restore modified PC to stack frame 
00001768  4CDF 0101                998          MOVEM.L (A7)+,D0/A0        Restore working registers 
0000176C  4FEF 0008                999          LEA.L   8(A7),A7           Adjust stack pointer to group 1 type 
00001770  6108                    1000          BSR.S   GROUP2             Now treat as group 1 exception 
00001772  6100 FE24               1001          BSR     EX_DIS             Display contents of exception frame 
00001776  6000 F8CC               1002          BRA     WARM               Exit to monitor - no RTE from group 2 
0000177A                          1003  * 
0000177A  =0000177A               1004  GROUP2  EQU     *                 Deal with group 2 exceptions 
0000177A  48E7 FFFF               1005          MOVEM.L A0-A7/D0-D7,-(A7) Save all registers on the stack 
0000177E  303C 000E               1006          MOVE.W  #14,D0            Transfer D0 - D7, A0 - A6 from 
00001782  41EE 005E               1007          LEA.L   TSK_T(A6),A0      the stack to the display frame 
00001786  20DF                    1008  GROUP2A MOVE.L  (A7)+,(A0)+       Move a register from stack to frame 
00001788  51C8 FFFC               1009          DBRA    D0,GROUP2A        and repeat until D0-D7/A0-A6 moved 
0000178C  4E6A                    1010          MOVE.L  USP,A2            Get the user stack pointer and put it 
0000178E  20CA                    1011          MOVE.L  A2,(A0)+          in the A7 position in the frame 
00001790  201F                    1012          MOVE.L  (A7)+,D0          Now transfer the SSP to the frame, 
00001792  0480 0000000A           1013          SUB.L   #10,D0            remembering to account for the 
00001798  20C0                    1014          MOVE.L  D0,(A0)+          data pushed on the stack to this point 
0000179A  225F                    1015          MOVE.L  (A7)+,A1          Copy TOS (return address) to A1 
0000179C  30DF                    1016          MOVE.W  (A7)+,(A0)+       Move SR to display frame 
0000179E  201F                    1017          MOVE.L  (A7)+,D0          Get PC in D0 
000017A0  5580                    1018          SUBQ.L  #2,D0             Move back to current instruction 
000017A2  20C0                    1019          MOVE.L  D0,(A0)+          Put adjusted PC in display frame 
000017A4  4ED1                    1020          JMP     (A1)              Return from subroutine 
000017A6                          1021  * 
000017A6                          1022  ************************************************************************* 
000017A6                          1023  * 
000017A6                          1024  *  GO executes a program either from a supplied address or 
000017A6                          1025  *  by using the data in the display frame 
000017A6  6100 FA06               1026  GO       BSR     PARAM               Get entry address (if any) 
000017AA  4A07                    1027           TST.B   D7                  Test for error in input 
000017AC  6708                    1028           BEQ.S   GO1                 If D7 zero then OK 
000017AE  49FA 032B               1029           LEA.L   ERMES1(PC),A4       Else point to error message, 
000017B2  6000 F8C6               1030           BRA     PSTRING             print it and return 
000017B6  4A80                    1031  GO1      TST.L   D0                  If no address entered then get 
000017B8  670A                    1032           BEQ.S   GO2                 address from display frame 
000017BA  2D40 00A4               1033           MOVE.L  D0,TSK_T+70(A6)     Else save address in display frame 
000017BE  3D7C 0700 00A2          1034           MOVE.W  #$0700,TSK_T+68(A6) Store dummy status in frame 
000017C4  6006                    1035  GO2      BRA.S   RESTORE             Restore volatile environment and go 
000017C6                          1036  * 
000017C6  6100 007A               1037  GB       BSR     BR_SET              Same as go but presets breakpoints 
000017CA  60DA                    1038           BRA.S   GO                  Execute program 
000017CC                          1039  * 
000017CC                          1040  *        RESTORE moves the volatile environment from the display 
000017CC                          1041  *        frame and transfers it to the 68000's registers. This 
000017CC                          1042  *        re-runs a program suspended after an exception 
000017CC                          1043  * 
000017CC  47EE 005E               1044  RESTORE  LEA.L   TSK_T(A6),A3        A3 points to display frame 
000017D0  47EB 004A               1045           LEA.L   74(A3),A3           A3 now points to end of frame + 4 
000017D4  4FEF 0004               1046           LEA.L   4(A7),A7            Remove return address from stack 
000017D8  303C 0024               1047           MOVE.W  #36,D0              Counter for 37 words to be moved 
000017DC  3F23                    1048  REST1    MOVE.W  -(A3),-(A7)         Move word from display frame to stack 
000017DE  51C8 FFFC               1049           DBRA    D0,REST1            Repeat until entire frame moved 
000017E2  4CDF 00FF               1050           MOVEM.L (A7)+,D0-D7         Restore old data registers from stack 
000017E6  4CDF 7F00               1051           MOVEM.L (A7)+,A0-A6         Restore old address registers 
000017EA  4FEF 0008               1052           LEA.L   8(A7),A7            Except SSP/USP - so adjust stack 
000017EE  4E73                    1053           RTE                         Return from exception to run program 
000017F0                          1054  * 
000017F0  =000017F0               1055  TRACE    EQU     *                   TRACE exception (rudimentary version) 
000017F0  287A 0292               1056           MOVE.L  MES12(PC),A4        Point to heading 
000017F4  6100 F894               1057           BSR     HEADING             Print it 
000017F8  6100 FF4C               1058           BSR     GROUP1              Save volatile environment 
000017FC  6100 FD9A               1059           BSR     EX_DIS              Display it 
00001800  6000 F842               1060           BRA     WARM                Return to monitor 
00001804                          1061  * 
00001804                          1062  ************************************************************************* 
00001804                          1063  *  Breakpoint routines: BR_GET gets the address of a breakpoint and 
00001804                          1064  *  puts it in the breakpoint table. It does not plant it in the code. 
00001804                          1065  *  BR_SET plants all breakpoints in the code. NOBR removes one or all 
00001804                          1066  *  breakpoints from the table. KILL removes breakpoints from the code. 
00001804                          1067  * 
00001804  6100 F9A8               1068  BR_GET   BSR     PARAM               Get breakpoint address in table 
00001808  4A07                    1069           TST.B   D7                  Test for input error 
0000180A  6708                    1070           BEQ.S   BR_GET1             If no error then continue 
0000180C  49FA 02CD               1071           LEA.L   ERMES1(PC),A4       Else display error 
00001810  6000 F868               1072           BRA     PSTRING             and return 
00001814  47EE 00A8               1073  BR_GET1  LEA.L   BP_TAB(A6),A3       A6 points to breakpoint table 
00001818  2A40                    1074           MOVE.L  D0,A5               Save new BP address in A5 
0000181A  2C00                    1075           MOVE.L  D0,D6               and in D6 because D0 gets corrupted 
0000181C  3A3C 0007               1076           MOVE.W  #7,D5               Eight entries to test 
00001820  201B                    1077  BR_GET2  MOVE.L  (A3)+,D0            Read entry from breakpoint table 
00001822  660C                    1078           BNE.S   BR_GET3             If not zero display existing BP 
00001824  4A86                    1079           TST.L   D6                  Only store a non-zero breakpoint 
00001826  6710                    1080           BEQ.S   BR_GET4 
00001828  274D FFFC               1081           MOVE.L  A5,-4(A3)           Store new breakpoint in table 
0000182C  3695                    1082           MOVE.W  (A5),(A3)           Save code at BP address in table 
0000182E  4286                    1083           CLR.L   D6                  Clear D6 to avoid repetition 
00001830  6100 F9EA               1084  BR_GET3  BSR     OUT8X               Display this breakpoint 
00001834  6100 F834               1085           BSR     NEWLINE 
00001838  47EB 0002               1086  BR_GET4  LEA.L   2(A3),A3            Step past stored op-code 
0000183C  51CD FFE2               1087           DBRA    D5,BR_GET2          Repeat until all entries tested 
00001840  4E75                    1088           RTS                         Return 
00001842                          1089  * 
00001842  =00001842               1090  BR_SET   EQU     *                   Plant any breakpoints in user code 
00001842  41EE 00A8               1091           LEA.L   BP_TAB(A6),A0       A0 points to BP table 
00001846  45EE 00A4               1092           LEA.L   TSK_T+70(A6),A2     A2 points to PC in display frame 
0000184A  2452                    1093           MOVE.L  (A2),A2             Now A2 contains value of PC 
0000184C  303C 0007               1094           MOVE.W  #7,D0               Up to eight entries to plant 
00001850  2218                    1095  BR_SET1  MOVE.L  (A0)+,D1            Read breakpoint address from table 
00001852  670A                    1096           BEQ.S   BR_SET2             If zero then skip planting 
00001854  B28A                    1097           CMP.L   A2,D1               Don't want to plant BP at current PC 
00001856  6706                    1098           BEQ.S   BR_SET2             location, so skip planting if same 
00001858  2241                    1099           MOVE.L  D1,A1               Transfer BP address to address reg 
0000185A  32BC 4E4E               1100           MOVE.W  #TRAP_14,(A1)       Plant op-code for TRAP #14 in code 
0000185E  41E8 0002               1101  BR_SET2  LEA.L   2(A0),A0            Skip past op-code field in table 
00001862  51C8 FFEC               1102           DBRA    D0,BR_SET1          Repeat until all entries tested 
00001866  4E75                    1103           RTS 
00001868                          1104  * 
00001868  =00001868               1105  NOBR     EQU     *                   Clear one or all breakpoints 
00001868  6100 F944               1106           BSR     PARAM               Get BP address (if any) 
0000186C  4A07                    1107           TST.B   D7                  Test for input error 
0000186E  6708                    1108           BEQ.S   NOBR1               If no error then skip abort 
00001870  49FA 0269               1109           LEA.L   ERMES1(PC),A4       Point to error message 
00001874  6000 F804               1110           BRA     PSTRING             Display it and return 
00001878  4A80                    1111  NOBR1    TST.L   D0                  Test for null address (clear all) 
0000187A  6720                    1112           BEQ.S   NOBR4               If no address then clear all entries 
0000187C  2240                    1113           MOVE.L  D0,A1               Else just clear breakpoint in A1 
0000187E  41EE 00A8               1114           LEA.L   BP_TAB(A6),A0       A0 points to BP table 
00001882  303C 0007               1115           MOVE.W  #7,D0               Up to eight entries to test 
00001886  2218                    1116  NOBR2    MOVE.L  (A0)+,D1            Get entry and 
00001888  41E8 0002               1117           LEA.L   2(A0),A0            skip past op-code field 
0000188C  B289                    1118           CMP.L   A1,D1               Is this the one? 
0000188E  6706                    1119           BEQ.S   NOBR3               If so go and clear entry 
00001890  51C8 FFF4               1120           DBRA    D0,NOBR2            Repeat until all tested 
00001894  4E75                    1121           RTS 
00001896  42A8 FFFA               1122  NOBR3    CLR.L   -6(A0)              Clear address in BP table 
0000189A  4E75                    1123           RTS 
0000189C  41EE 00A8               1124  NOBR4    LEA.L   BP_TAB(A6),A0       Clear all 8 entries in BP table 
000018A0  303C 0007               1125           MOVE.W  #7,D0               Eight entries to clear 
000018A4  4298                    1126  NOBR5    CLR.L   (A0)+               Clear breakpoint address 
000018A6  4258                    1127           CLR.W   (A0)+               Clear op-code field 
000018A8  51C8 FFFA               1128           DBRA    D0,NOBR5            Repeat until all done 
000018AC  4E75                    1129           RTS 
000018AE                          1130  * 
000018AE  =000018AE               1131  BR_CLR   EQU     *                   Remove breakpoints from code 
000018AE  41EE 00A8               1132           LEA.L   BP_TAB(A6),A0       A0 points to breakpoint table 
000018B2  303C 0007               1133           MOVE.W  #7,D0               Up to eight entries to clear 
000018B6  2218                    1134  BR_CLR1  MOVE.L  (A0)+,D1            Get address of BP in D1 
000018B8  2241                    1135           MOVE.L  D1,A1               and put copy in A1 
000018BA  4A81                    1136           TST.L   D1                  Test this breakpoint 
000018BC  6702                    1137           BEQ.S   BR_CLR2             If zero then skip BP clearing 
000018BE  3290                    1138           MOVE.W  (A0),(A1)           Else restore op-code 
000018C0  41E8 0002               1139  BR_CLR2  LEA.L   2(A0),A0            Skip past op-code field 
000018C4  51C8 FFF0               1140           DBRA    D0,BR_CLR1          Repeat until all tested 
000018C8  4E75                    1141           RTS 
000018CA                          1142  * 
000018CA                          1143  *  REG_MOD modifies a register in the display frame. The command 
000018CA                          1144  *  format is REG <reg> <value>. E.g. REG D3 1200 
000018CA                          1145  * 
000018CA  4281                    1146  REG_MOD  CLR.L   D1                  D1 to hold name of register 
000018CC  41EE 0048               1147           LEA.L   BUFFPT(A6),A0       A0 contains address of buffer pointer 
000018D0  2050                    1148           MOVE.L  (A0),A0             A0 now points to next char in buffer 
000018D2  1218                    1149           MOVE.B  (A0)+,D1            Put first char of name in D1 
000018D4  E159                    1150           ROL.W   #8,D1               Move char one place left 
000018D6  1218                    1151           MOVE.B  (A0)+,D1            Get second char in D1 
000018D8  41E8 0001               1152           LEA.L   1(A0),A0            Move pointer past space in buffer 
000018DC  2D48 0048               1153           MOVE.L  A0,BUFFPT(A6)       Update buffer pointer 
000018E0  4282                    1154           CLR.L   D2                  D2 is the character pair counter 
000018E2  41FA 01CE               1155           LEA.L   REGNAME(PC),A0      A0 points to string of character pairs 
000018E6  43D0                    1156           LEA.L   (A0),A1             A1 also points to string 
000018E8  B258                    1157  REG_MD1  CMP.W   (A0)+,D1            Compare a char pair with input 
000018EA  6712                    1158           BEQ.S   REG_MD2             If match then exit loop 
000018EC  5282                    1159           ADD.L   #1,D2               Else increment match counter 
000018EE  B4BC 00000013           1160           CMP.L   #19,D2              Test for end of loop 
000018F4  66F2                    1161           BNE     REG_MD1             Continue until all pairs matched 
000018F6  49FA 01E3               1162           LEA.L   ERMES1(PC),A4       If here then error 
000018FA  6000 F77E               1163           BRA     PSTRING             Display error and return 
000018FE  43EE 005E               1164  REG_MD2  LEA.L   TSK_T(A6),A1        A1 points to display frame 
00001902  E582                    1165           ASL.L   #2,D2               Multiply offset by 4 (4 bytes/entry) 
00001904  B4BC 00000048           1166           CMP.L   #72,D2              Test for address of PC 
0000190A  6602                    1167           BNE.S   REG_MD3             If not PC then all is OK 
0000190C  5582                    1168           SUB.L   #2,D2               else dec PC pointer as Sr is a word 
0000190E  45F1 2000               1169  REG_MD3  LEA.L   (A1,D2),A2          Calculate address of entry in disptable 
00001912  2012                    1170           MOVE.L  (A2),D0             Get old contents 
00001914  6100 F906               1171           BSR     OUT8X               Display them 
00001918  6100 F750               1172           BSR     NEWLINE 
0000191C  6100 F890               1173           BSR     PARAM               Get new data 
00001920  4A07                    1174           TST.B   D7                  Test for input error 
00001922  6708                    1175           BEQ.S   REG_MD4             If no error then go and store data 
00001924  49FA 01B5               1176           LEA.L   ERMES1(PC),A4       Else point to error message 
00001928  6000 F750               1177           BRA     PSTRING             print it and return 
0000192C  B4BC 00000044           1178  REG_MD4  CMP.L   #68,D2              If this address is the SR then 
00001932  6704                    1179           BEQ.S   REG_MD5             we have only a word to store 
00001934  2480                    1180           MOVE.L  D0,(A2)             Else store new data in display frame 
00001936  4E75                    1181           RTS 
00001938  3480                    1182  REG_MD5  MOVE.W  D0,(A2)             Store SR (one word) 
0000193A  4E75                    1183           RTS 
0000193C                          1184  * 
0000193C                          1185  ************************************************************************* 
0000193C                          1186  * 
0000193C  =0000193C               1187  X_UN    EQU     *                 Uninitialized exception vector routine 
0000193C  49FA 0203               1188          LEA.L   ERMES6(PC),A4     Point to error message 
00001940  6100 F738               1189          BSR     PSTRING           Display it 
00001944  6100 FC52               1190          BSR     EX_DIS            Display registers 
00001948  6000 F6FA               1191          BRA     WARM              Abort 
0000194C                          1192  * 
0000194C                          1193  ************************************************************************* 
0000194C                          1194  * 
0000194C                          1195  *  All strings and other fixed parameters here 
0000194C                          1196  * 
0000194C= 54 53 42 55 47 20 ...   1197  BANNER   DC.B     'TSBUG 2 Version 23.07.86',0,0
00001966= 4D 6F 64 69 66 69 ...   1198  MODIFY    DC.B   'Modified by Eugene A. Rockey Jr. Jan.05.2010',0,0
00001994= 66 6F 72 20 75 73 ...   1199  WHY      DC.B     'for use with the M68000 Minimal Computer Configuration',0,0 
000019CC= 55 6E 69 76 65 72 ...   1200  WHERE    DC.B     'University of Louisville',0,0
000019E6= 0D 0A 54 53 32 4D ...   1201  CRLF     DC.B     CR,LF,'TS2MON >',0 
000019F1= 0D 0A 53 31 00 00       1202  HEADER   DC.B     CR,LF,'S','1',0,0 
000019F7= 53 39 20 20 00 00       1203  TAIL     DC.B     'S9  ',0,0 
000019FD= 20 53 52 20 20 3D ...   1204  MES1     DC.B     ' SR  =  ',0 
00001A06= 20 50 43 20 20 3D ...   1205  MES2     DC.B     ' PC  =  ',0 
00001A0F= 20 53 53 20 20 3D ...   1206  MES2A    DC.B     ' SS  =  ',0 
00001A18= 20 20 44 61 74 61 ...   1207  MES3     DC.B     '  Data reg       Address reg',0,0 
00001A36= 20 20 20 20 20 20 ...   1208  MES4     DC.B     '        ',0,0 
00001A40= 42 75 73 20 65 72 ...   1209  MES8     DC.B     'Bus error   ',0,0 
00001A4E= 41 64 64 72 65 73 ...   1210  MES9     DC.B     'Address error   ',0,0 
00001A60= 49 6C 6C 65 67 61 ...   1211  MES10    DC.B     'Illegal instruction ',0,0 
00001A76= 42 72 65 61 6B 70 ...   1212  MES11    DC.B     'Breakpoint  ',0,0 
00001A84= 54 72 61 63 65 20 ...   1213  MES12    DC.B     'Trace   ',0 
00001A8D= 44 69 76 69 64 65 ...   1214  MES13    DC.B     'Divide by zero error', 0
00001AA2= 50 72 69 76 69 6C ...   1215  MES14    DC.B     'Privilege error', 0
00001AB2= 44 30 44 31 44 32 ...   1216  REGNAME  DC.B     'D0D1D2D3D4D5D6D7' 
00001AC2= 41 30 41 31 41 32 ...   1217           DC.B     'A0A1A2A3A4A5A6A7' 
00001AD2= 53 53 53 52             1218           DC.B     'SSSR' 
00001AD6= 50 43 20 20 00          1219           DC.B     'PC  ',0 
00001ADB= 4E 6F 6E 2D 76 61 ...   1220  ERMES1   DC.B     'Non-valid hexadecimal input  ',0 
00001AF9= 49 6E 76 61 6C 69 ...   1221  ERMES2   DC.B     'Invalid command  ',0 
00001B0B= 4C 6F 61 64 69 6E ...   1222  ERMES3   DC.B     'Loading error',0 
00001B19= 54 61 62 6C 65 20 ...   1223  ERMES4   DC.B     'Table full  ',0,0 
00001B27= 42 72 65 61 6B 70 ...   1224  ERMES5   DC.B     'Breakpoint not active   ',0,0 
00001B41= 55 6E 69 6E 69 74 ...   1225  ERMES6   DC.B     'Uninitialized exception ',0,0 
00001B5B= 4A 55 4D 50 20 3C ...   1226  JUMPHELP DC.B     'JUMP <address> causes execution to begin at <address>',0   
00001B91= 4D 45 4D 4F 52 59 ...   1227  MEMHELP  DC.B     'MEMORY <address> examines contents of address> and allows them to be changed', 0   
00001BDE= 4C 4F 41 44 20 3C ...   1228  LOADHELP DC.B     'LOAD <string> loads S1/S2 records from the host. <string> is sent to host', 0
00001C28= 54 56 20 63 68 65 ...   1229  TVHELP   DC.B     'TV checks all RAM addresses from $4000 to $40FE. Reports corrupt memory addresses', 0
00001C7A= 20 52 61 6E 67 65 ...   1230  ERMES7   DC.B     ' Range error',0
00001C87= 55 53 45 52 00          1231  UNAME    DC.B     'USER', 0
00001C8C= 50 41 53 53 57 4F ...   1232  PWORD    DC.B     'PASSWORD',0
00001C95= 45 6E 74 65 72 20 ...   1233  LOGINM1  DC.B     'Enter username: ', 0
00001CA6= 45 6E 74 65 72 20 ...   1234  LOGINM2  DC.B     'Enter password: ', 0
00001CB7= 49 6E 63 6F 72 72 ...   1235  USRERR   DC.B     'Incorrect username', 0
00001CCA= 43 6F 72 72 65 63 ...   1236  USRSUC   DC.B     'Correct Username', 0
00001CDB= 49 6E 63 6F 72 72 ...   1237  PWERR   DC.B     'Incorrect password', 0
00001CEE= 43 6F 72 72 65 63 ...   1238  PWSUC    DC.B     'Correct Password', 0
00001CFF= 4D 45 4D 4F 52 59 ...   1239  MEMFMSG  DC.B     'MEMORY BAD AT: ',0
00001D0F= 41 4C 4C 20 52 41 ...   1240  MEMGMSG  DC.B      'ALL RAM GOOD', 0
00001D1C                          1241  * 
00001D1C                          1242  *  COMTAB is the built-in command table. All entries are made up of 
00001D1C                          1243  *         a string length + number of characters to match + the string 
00001D1C                          1244  *         plus the address of the command relative to COMTAB 
00001D1C                          1245  * 
00002000                          1246           ORG      $2000
00002000= 04 04                   1247  COMTAB   DC.B     4,4              JUMP <address> causes execution to 
00002002= 4A 55 4D 50             1248           DC.B     'JUMP'           begin at <address> 
00002006= FFFFF224                1249           DC.L     JUMP-COMTAB                                           
0000200A= 08 03                   1250           DC.B     8,3              MEMORY <address> examines contents of 
0000200C= 4D 45 4D 4F 52 59 ...   1251           DC.B     'MEMORY  '       <address> and allows them to be changed 
00002014= FFFFF23A                1252           DC.L     MEMORY-COMTAB 
00002018= 04 02                   1253           DC.B     4,2              LOAD <string> loads S1/S2 records 
0000201A= 4C 4F 41 44             1254           DC.B     'LOAD'           from the host. <string> is sent to host 
0000201E= FFFFF29A                1255           DC.L     LOAD-COMTAB 
00002022= 04 04                   1256           DC.B    4,4               HELP 
00002024= 48 45 4C 50             1257           DC.B    'HELP'            
00002028= FFFFF616                1258           DC.L    HELP-COMTAB      
0000202C= 02 02                   1259           DC.B    2,2
0000202E= 54 56                   1260           DC.B    'TV'
00002030= FFFFF64C                1261           DC.L    TV-COMTAB
00002034= 00 00                   1262           DC.B    0,0 
00002036                          1263  * 
00002036                          1264  ************************************************************************* 
00002036                          1265  ** 
00002036                          1266  *  This is a list of the information needed to setup the DCBs 
00002036                          1267  * 
00002036  =00002036               1268  DCB_LST  EQU     * 
00002036= 43 4F 4E 5F 49 4E ...   1269  DCB1     DC.B    'CON_IN  '          Device name (8 bytes) 
0000203E= 0000147E 00008001       1270           DC.L    CON_IN,ACIA_1       Address of driver routine, device 
00002046= 0002                    1271           DC.W    2                   Number of words in parameter field 
00002048= 43 4F 4E 5F 4F 55 ...   1272  DCB2     DC.B    'CON_OUT ' 
00002050= 000014AE 00008001       1273           DC.L    CON_OUT,ACIA_1 
00002058= 0002                    1274           DC.W    2 
0000205A= 41 55 58 5F 49 4E ...   1275  DCB3     DC.B    'AUX_IN  ' 
00002062= 000014EE 00008001       1276           DC.L    AUX_IN,ACIA_2 
0000206A= 0002                    1277           DC.W    2 
0000206C= 41 55 58 5F 4F 55 ...   1278  DCB4     DC.B    'AUX_OUT ' 
00002074= 00001500 00008001       1279           DC.L    AUX_OUT,ACIA_2 
0000207C= 0002                    1280           DC.W    2 
0000207E                          1281  *DCB5     DC.B    'BUFF_IN ' 
0000207E                          1282  *         DC.L    BUFF_IN,BUFFER 
0000207E                          1283  *         DC.W    2 
0000207E                          1284  *DCB6     DC.B    'BUFF_OUT' 
0000207E                          1285  *         DC.L    BUFF_OT,BUFFER 
0000207E                          1286  *         DC.W    2 
0000207E                          1287  * 
0000207E                          1288  ************************************************************************* 
0000207E                          1289  * 
0000207E                          1290  *  DCB structure 
0000207E                          1291  * 
0000207E                          1292  *              ----------------------- 
0000207E                          1293  *       0 ->   | DCB  name           | 
0000207E                          1294  *              |---------------------| 
0000207E                          1295  *       8 ->   | Device driver       | 
0000207E                          1296  *              |---------------------| 
0000207E                          1297  *      12 ->   | Device address      | 
0000207E                          1298  *              |---------------------| 
0000207E                          1299  *      16 ->   |Size of param block  | 
0000207E                          1300  *              |---------------------| --- 
0000207E                          1301  *      18 ->   |      Status         |   | 
0000207E                          1302  *              | logical  | physical |   | S 
0000207E                          1303  *              |---------------------|   | 
0000207E                          1304  *              .                     .   . 
0000207E                          1305  *              |---------------------| --- 
0000207E                          1306  *    18+S ->   | Pointer to next DCB | 
0000207E                          1307  * 
0000207E                          1308           END RESET 

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ACIA_1              8001
ACIA_2              8001
ADD_ER              171A
ADR_DAT             1278
AUX_IN              14EE
AUX_IN1             14F4
AUX_OT1             1506
AUX_OUT             1500
BANNER              194C
BP_TAB              A8
BRKPT               1728
BR_CLR              18AE
BR_CLR1             18B6
BR_CLR2             18C0
BR_GET              1804
BR_GET1             1814
BR_GET2             1820
BR_GET3             1830
BR_GET4             1838
BR_SET              1842
BR_SET1             1850
BR_SET2             185E
BS                  8
BUFFEND             47
BUFFER              2D8
BUFFPT              48
BUS_ER              170C
BYTE                1192
B_CLR               158E
CHECK1              1668
CHECK2              1672
CHECK3              1694
CHECK4              169E
CN_IVEC             56
CN_OVEC             5A
COMTAB              2000
CON_I1              148C
CON_I2              14A4
CON_IN              147E
CON_OT1             14BC
CON_OT2             14D2
CON_OT3             14DA
CON_OUT             14AE
CR                  D
CRLF                19E6
CTRL_A              1
DATA                4800
DCB1                2036
DCB2                2048
DCB3                205A
DCB4                206C
DCB_LST             2036
DELAY               140E
DELAY1              1418
DUMP                136E
DUMP1               137E
DUMP2               138A
DUMP3               1398
DUMP4               13AC
DUMP5               13BA
DUMP6               13D4
DUMP7               13F8
ECHO                50
ERMES1              1ADB
ERMES2              1AF9
ERMES3              1B0B
ERMES4              1B19
ERMES5              1B27
ERMES6              1B41
ERMES7              1C7A
ESC                 1B
EXEC1               111A
EXEC2               112A
EXECUTE             1108
EX_D1               15AA
EX_DIS              1598
FIRST               D8
GB                  17C6
GETCH2              1538
GETCH3              1540
GETCHAR             1512
GETLINE             1090
GETLN2              109A
GETLN3              10B4
GETLN4              10BE
GETLN5              10C2
GO                  17A6
GO1                 17B6
GO2                 17C4
GROUP1              1746
GROUP1A             1764
GROUP2              177A
GROUP2A             1786
HEADER              19F1
HEADING             108A
HELP                1616
HEX                 1174
HEX_OK              1190
IL_ER               16F6
IO_OPEN             1554
IO_REQ              146C
JUMP                1224
JUMP1               1232
JUMPHELP            1B5B
LF                  A
LNBUFF              8
LOAD                129A
LOAD1               12C6
LOAD2               12D6
LOAD3               12F0
LOAD4               130A
LOAD5               1318
LOAD6               131A
LOAD6A              133E
LOAD7               1350
LOAD8               1366
LOADHELP            1BDE
LOGINM1             1C95
LOGINM2             1CA6
LONGWD              11A8
LOOPRAM             1654
LOOPRAM1            1680
MAXCHR              40
MAX_RAM             3DC
MEM1                1244
MEM2                1262
MEM3                1276
MEMFAIL             16B2
MEMFAIL2            16CE
MEMFMSG             1CFF
MEMGMSG             1D0F
MEMGOOD             16EA
MEMHELP             1B91
MEMORY              123A
MES1                19FD
MES10               1A60
MES11               1A76
MES12               1A84
MES13               1A8D
MES14               1AA2
MES2                1A06
MES2A               1A0F
MES3                1A18
MES4                1A36
MES8                1A40
MES9                1A4E
MIN_RAM             3D8
MODIFY              1966
NEWLINE             106A
NOBR                1868
NOBR1               1878
NOBR2               1886
NOBR3               1896
NOBR4               189C
NOBR5               18A4
NOT_HEX             118C
NO_EXT              1040
OPEN1               155C
OPEN2               1564
OPEN3               1572
OPEN4               1588
OUT1X               11F2
OUT1X1              1204
OUT2X               120C
OUT4X               1214
OUT8X               121C
PARAM               11AE
PARAM1              11B6
PARAM3              11DA
PARAM4              11DE
PARAM5              11EA
PARAM6              11EE
PARAMTR             4C
PS1                 107C
PS2                 1086
PSPACE              128C
PSTRING             107A
PUTCHAR             1544
PWERR               1CDB
PWORD               1C8C
PWSUC               1CEE
RANGE               13FE
REGNAME             1AB2
REG_MD1             18E8
REG_MD2             18FE
REG_MD3             190E
REG_MD4             192C
REG_MD5             1938
REG_MOD             18CA
RESET               1000
REST1               17DC
RESTORE             17CC
SEARCH              1134
SETACIA             1054
SET_DCB             1422
SPACE               20
SRCH2               114E
SRCH3               1152
SRCH4               115A
SRCH6               1164
SRCH7               116E
STACK               4400
ST_DCB1             1432
ST_DCB2             1436
TAIL                19F7
TIDY                10C6
TIDY1               10CC
TIDY2               10D8
TIDY3               10E2
TIDY4               10EC
TIDY5               10F6
TIDY6               1102
TRACE               17F0
TRAP_14             4E4E
TSK_T               5E
TV                  164C
TVHELP              1C28
UNAME               1C87
USRERR              1CB7
USRSUC              1CCA
UTAB                52
U_CASE              51
WAIT                57
WARM                1044
WHERE               19CC
WHY                 1994
WORD                11A2
X_UN                193C
