00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.15.04
Created On: 9/29/15 2:53:58 PM

00000000                             1  *        TSBUG2 - 68000 monitor - version of 05 January 2010 
00000000                             2  
00000000                             3       ORG      $0
00000000= 00004400 00001000 ...      4           DC.L STACK,RESET,BUS_ER,ADD_ER,IL_ER,DIV0_ER,X_UN,X_UN,PRIV_ER,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN
00000040= 00001BE4 00001BE4 ...      5           DC.L X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN
00000080= 00001606 00001BE4 ...      6           DC.L TRAP_0,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,BRKPT,TRAP_15
000000C4= 00001BE4 00001BE4 ...      7           DC.L X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN
00000104= 00001BE4 00001BE4 ...      8           DC.L X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN
00000144= 00001BE4 00001BE4 ...      9           DC.L X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN
00000184= 00001BE4 00001BE4 ...     10           DC.L X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN
000001C4= 00001BE4 00001BE4 ...     11           DC.L X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN
00000204= 00001BE4 00001BE4 ...     12           DC.L X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN
00000244= 00001BE4 00001BE4 ...     13           DC.L X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN
00000284= 00001BE4 00001BE4 ...     14           DC.L X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN
000002C4= 00001BE4 00001BE4 ...     15           DC.L X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN
00000304= 00001BE4 00001BE4 ...     16           DC.L X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN
00000344= 00001BE4 00001BE4 ...     17           DC.L X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN
00000384= 00001BE4 00001BE4 ...     18           DC.L X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN
000003C4= 00001BE4 00001BE4 ...     19           DC.L X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN
00000404                            20  *                                   Symbol equates 
00000404  =00000008                 21  BS       EQU      $08               Back_space 
00000404  =0000000D                 22  CR       EQU      $0D               Carriage_return 
00000404  =00000000                 23  NUL      EQU      $00               NUL character
00000404  =0000000A                 24  LF       EQU      $0A               Line_feed 
00000404  =00000020                 25  SPACE    EQU      $20               Space 
00000404  =00000057                 26  WAIT     EQU      'W'               Wait character (to suspend output) 
00000404  =0000001B                 27  ESC      EQU      $1B               ASCII escape character (used by TM) 
00000404  =00000001                 28  CTRL_A   EQU      $01               Control_A forces return to monitor 
00000404                            29  *                                   Device addresses 
00000404  =00004400                 30  STACK    EQU      $4400             Stack_pointer
00000404  =00008001                 31  ACIA_1   EQU      $8001             Console ACIA control 
00000404  =00008001                 32  ACIA_2   EQU      ACIA_1            Auxilary ACIA control 
00000404                            33  *X_BASE   EQU      $4000             Start of exception vector table 
00000404  =00004E4E                 34  TRAP_16  EQU      $4E4E             Code for TRAP #16 
00000404  =00000040                 35  MAXCHR   EQU      64                Length of input line buffer  
00000404                            36  * 
00000404  =00004800                 37  DATA     EQU      $4800             Data origin 
00000404                            38  LNBUFF   DS.B     MAXCHR            Input line buffer
00000444  =00000443                 39  BUFFEND  EQU      LNBUFF+MAXCHR-1   End of line buffer 
00000444                            40  BUFFPT   DS.L     1                 Pointer to line buffer 
00000448                            41  PARAMTR  DS.L     1                 Last parameter from line buffer 
0000044C                            42  ECHO     DS.B     1                 When clear this enable input echo 
0000044D                            43  U_CASE   DS.B     1                 Flag for upper case conversion 
0000044E                            44  UTAB     DS.L     1                 Pointer to user command table 
00000452                            45  CN_IVEC  DS.L     1                 Pointer to console input DCB 
00000456                            46  CN_OVEC  DS.L     1                 Pointer to console output DCB 
0000045A                            47  TSK_T    DS.W     37                Frame for D0-D7, A0-A6, USP, SSP, SW, PC 
000004A4                            48  BP_TAB   DS.W     24                Breakpoint table 
000004D4                            49  FIRST    DS.B     512               DCB area 
000006D4                            50  BUFFER   DS.B     256               256 bytes for I/O buffer 
000007D4= 00004000                  51  MIN_RAM  DC.L     $004000           minimum RAM address to be checked
000007D8= 00004100                  52  MAX_RAM  DC.L     $004100           maximum RAM address to be checked
000007DC                            53  * 
000007DC                            54  ************************************************************************* 
000007DC                            55  * 
000007DC                            56  *  This is the main program which assembles a command in the line 
000007DC                            57  *  buffer, removes leading/embedded spaces and interprets it by matching 
000007DC                            58  *  it with a command in the user table or the built-in table COMTAB 
000007DC                            59  *  All variables are specified with respect to A6 
000007DC                            60  *
00001000                            61           ORG      $1000             Monitor Origin
00001000  =00001000                 62  RESET:   EQU      *
00001000  4DF8 4800                 63           LEA.L    DATA,A6           A6 points to data area 
00001004  2D4E 0492                 64            MOVE.L    A6,TSK_T+56(A6)   initialize A6 in the regster Frame
00001008  42AE 044E                 65           CLR.L    UTAB(A6)          Reset pointer to user extension table 
0000100C  422E 044C                 66           CLR.B    ECHO(A6)          Set automatic character echo 
00001010  422E 044D                 67           CLR.B    U_CASE(A6)        Clear case conversion flag (UC<-LC) 
00001014  6146                      68           BSR.S    SETACIA           Setup ACIAs 
00001016  6100 057A                 69            BSR.L    B_CLR                 what change did i do here
0000101A  6100 03FE                 70           BSR.L    SET_DCB           Setup DCB table in RAM
0000101E  6152                      71           BSR.S    NEWLINE
00001020  49FA 0BD2                 72           LEA.L    BANNER(PC),A4    
00001024  615C                      73           BSR.S    PSTRING
00001026  614A                      74           BSR.S    NEWLINE           
00001028  49FA 0BE4                 75            LEA.L    MODIFY(PC),A4
0000102C  6154                      76           BSR.S    PSTRING
0000102E  6142                      77           BSR.S    NEWLINE
00001030  49FA 0C0A                 78            LEA.L    WHY(PC),A4
00001034  614C                      79           BSR.S    PSTRING
00001036  613A                      80           BSR.S    NEWLINE
00001038  49FA 0C3A                 81            LEA.L    WHERE(PC),A4
0000103C  6144                      82           BSR.S    PSTRING
0000103E  6132                      83           BSR.S    NEWLINE
00001040  4E71                      84  NO_EXT:  NOP                        Two NOPs to allow for a future 
00001042  4E71                      85           NOP                        call to an initialization routine 
00001044  4287                      86           CLR.L    D7                Warm entry point - clear error flag 
00001046  4EB9 00001802             87           JSR      LOGIN             jump tp lgin routine           
0000104C  4287                      88  WARM:    CLR.L    D7                Warm entry point - clear error flag 
0000104E  6122                      89           BSR.S    NEWLINE           Print a newline 
00001050  6146                      90           BSR.S    GETLINE           Get a command line 
00001052  6100 007A                 91           BSR      TIDY              Tidy up input buffer contents 
00001056  6100 00B8                 92           BSR      EXECUTE           Interpret command 
0000105A  60F0                      93           BRA      WARM              Repeat indefinitely 
0000105C                            94  * 
0000105C                            95  ************************************************************************* 
0000105C                            96  * 
0000105C                            97  *  Some initialization and basic routines 
0000105C                            98  * 
0000105C  =0000105C                 99  SETACIA  EQU      *                 Setup ACIA parameters 
0000105C  41F9 00008001            100           LEA.L    ACIA_1,A0         A0 points to console ACIA 
00001062  10BC 0003                101           MOVE.B   #$03,(A0)         Reset ACIA1 
00001066  10BC 0019                102           MOVE.B   #$19,(A0)         Set up ACIA1 constants (no IRQ, 
0000106A  117C 0019 0001           103           MOVE.B   #$19,1(A0)        RTS* low, 8 bit, no parity, 1 stop) 
00001070  4E75                     104           RTS                        Return 
00001072                           105  * 
00001072  =00001072                106  NEWLINE  EQU      *                 Move cursor to start of newline 
00001072  48E7 0008                107           MOVEM.L  A4,-(A7)          Save A4 
00001076  49FA 0C16                108           LEA.L    CRLF(PC),A4       Point to CR/LF string 
0000107A  6106                     109           BSR.S    PSTRING           Print it 
0000107C  4CDF 1000                110           MOVEM.L  (A7)+,A4          Restore A4 
00001080  4E75                     111           RTS                        Return 
00001082                           112  * 
00001082  =00001082                113  PSTRING  EQU      *                 Display the string pointed at by A4 
00001082  2F00                     114           MOVE.L   D0,-(A7)          Save D0 
00001084  101C                     115  PS1      MOVE.B   (A4)+,D0          Get character to be printed 
00001086  6706                     116           BEQ.S    PS2               If null then return 
00001088  6100 04A8                117           BSR      PUTCHAR           Else print it 
0000108C  60F6                     118           BRA      PS1               Continue 
0000108E  201F                     119  PS2      MOVE.L   (A7)+,D0          Restore D0 and exit 
00001090  4E75                     120           RTS 
00001092                           121  * 
00001092  61DE                     122  HEADING  BSR      NEWLINE           Same as PSTRING but with newline 
00001094  61EC                     123           BSR      PSTRING 
00001096  60DA                     124           BRA      NEWLINE 
00001098                           125  * 
00001098                           126  ************************************************************************* 
00001098                           127  * 
00001098                           128  *  GETLINE  inputs a string of characters into a line buffer 
00001098                           129  *           A3 points to next free entry in line buffer 
00001098                           130  *           A2 points to end of buffer 
00001098                           131  *           A1 points to start of buffer 
00001098                           132  *           D0 holds character to be stored 
00001098                           133  * 
00001098  43EE 0404                134  GETLINE  LEA.L    LNBUFF(A6),A1     A1 points to start of line buffer 
0000109C  47D1                     135           LEA.L    (A1),A3           A3 points to start (initially) 
0000109E  45E9 0040                136           LEA.L    MAXCHR(A1),A2     A2 points to end of buffer 
000010A2  6100 0442                137  GETLN2   BSR      GETCHAR           Get a character 
000010A6  B03C 0001                138           CMP.B    #CTRL_A,D0        If control_A then reject this line 
000010AA  671E                     139           BEQ.S    GETLN5            and get another line 
000010AC  B03C 0008                140           CMP.B    #BS,D0            If back_space then move back pointer 
000010B0  660A                     141           BNE.S    GETLN3            Else skip past wind-back routine 
000010B2  B7C9                     142           CMP.L    A1,A3             First check for empty buffer 
000010B4  67EC                     143           BEQ      GETLN2            If buffer empty then continue 
000010B6  47EB FFFF                144           LEA      -1(A3),A3         Else decrement buffer pointer 
000010BA  60E6                     145           BRA      GETLN2            and continue with next character 
000010BC  16C0                     146  GETLN3   MOVE.B   D0,(A3)+          Store character and update pointer 
000010BE  B03C 000D                147           CMP.B    #CR,D0            Test for command terminator 
000010C2  6602                     148           BNE.S    GETLN4            If not CR then skip past exit 
000010C4  60AC                     149           BRA      NEWLINE           Else new line before next operation 
000010C6  B7CA                     150  GETLN4   CMP.L    A2,A3             Test for buffer overflow 
000010C8  66D8                     151           BNE      GETLN2            If buffer not full then continue 
000010CA  61A6                     152  GETLN5   BSR      NEWLINE           Else move to next line and 
000010CC  60CA                     153           BRA      GETLINE           repeat this routine 
000010CE                           154  * 
000010CE                           155  ************************************************************************* 
000010CE                           156  * 
000010CE                           157  *  TIDY cleans up the line buffer by removing leading spaces and multiple 
000010CE                           158  *       spaces between parameters. At the end of TIDY, BUFFPT points to 
000010CE                           159  *       the first parameter following the command. 
000010CE                           160  *       A0 = pointer to line buffer. A1 = pointer to cleaned up buffer 
000010CE                           161  * 
000010CE  41EE 0404                162  TIDY     LEA.L    LNBUFF(A6),A0     A0 points to line buffer 
000010D2  43D0                     163           LEA.L    (A0),A1           A1 points to start of line buffer 
000010D4  1018                     164  TIDY1    MOVE.B   (A0)+,D0          Read character from line buffer 
000010D6  B03C 0020                165           CMP.B    #SPACE,D0         Repeat until the first non-space 
000010DA  67F8                     166           BEQ      TIDY1             character is found 
000010DC  41E8 FFFF                167           LEA.L    -1(A0),A0         Move pointer back to first char 
000010E0  1018                     168  TIDY2    MOVE.B   (A0)+,D0          Move the string left to remove 
000010E2  12C0                     169           MOVE.B   D0,(A1)+          any leading spaces 
000010E4  B03C 0020                170           CMP.B    #SPACE,D0         Test for embedded space 
000010E8  660A                     171           BNE.S    TIDY4             If not space then test for EOL 
000010EA  0C18 0020                172  TIDY3    CMP.B    #SPACE,(A0)+      If space skip multiple embedded 
000010EE  67FA                     173           BEQ      TIDY3             spaces 
000010F0  41E8 FFFF                174           LEA.L    -1(A0),A0         Move back pointer 
000010F4  B03C 000D                175  TIDY4    CMP.B    #CR,D0            Test for end_of_line (EOL) 
000010F8  66E6                     176           BNE      TIDY2             If not EOL then read next char 
000010FA  41EE 0404                177           LEA.L    LNBUFF(A6),A0     Restore buffer pointer 
000010FE  0C10 000D                178  TIDY5    CMP.B    #CR,(A0)          Test for EOL 
00001102  6706                     179           BEQ.S    TIDY6             If EOL then exit 
00001104  0C18 0020                180           CMP.B    #SPACE,(A0)+      Test for delimiter 
00001108  66F4                     181           BNE      TIDY5             Repeat until delimiter or EOL 
0000110A  2D48 0444                182  TIDY6    MOVE.L   A0,BUFFPT(A6)     Update buffer pointer 
0000110E  4E75                     183           RTS 
00001110                           184  * 
00001110                           185  ************************************************************************* 
00001110                           186  * 
00001110                           187  *  EXECUTE matches the first command in the line buffer with the 
00001110                           188  *  commands in a command table. An external table pointed at by 
00001110                           189  *  UTAB is searched first and then the in-built table, COMTAB. 
00001110                           190  * 
00001110  4AAE 044E                191  EXECUTE  TST.L    UTAB(A6)          Test pointer to user table 
00001114  670C                     192           BEQ.S    EXEC1             If clear then try built-in table 
00001116  266E 044E                193           MOVE.L   UTAB(A6),A3       Else pick up pointer to user table 
0000111A  6120                     194           BSR.S    SEARCH            Look for command in user table 
0000111C  6404                     195           BCC.S    EXEC1             If not found then try internal table 
0000111E  2653                     196           MOVE.L   (A3),A3           Else get absolute address of command 
00001120  4ED3                     197           JMP      (A3)              from user table and execute it 
00001122                           198  * 
00001122  47FA 0EDC                199  EXEC1    LEA.L    COMTAB(PC),A3     Try built-in command table 
00001126  6114                     200           BSR.S    SEARCH            Look for command in built-in table 
00001128  6508                     201           BCS.S    EXEC2             If found then execute command 
0000112A  49FA 0C75                202           LEA.L    ERMES2(PC),A4     Else print "invalid command" 
0000112E  6000 FF52                203           BRA.L    PSTRING           and return 
00001132  2653                     204  EXEC2    MOVE.L   (A3),A3           Get the relative command address 
00001134  49FA 0ECA                205           LEA.L    COMTAB(PC),A4     pointed at by A3 and add it to 
00001138  D7CC                     206           ADD.L    A4,A3             the PC to generate the actual 
0000113A  4ED3                     207           JMP      (A3)              command address. Then execute it. 
0000113C                           208  * 
0000113C  =0000113C                209  SEARCH   EQU      *                 Match the command in the line buffer 
0000113C  4280                     210           CLR.L    D0                with command table pointed at by A3 
0000113E  1013                     211           MOVE.B   (A3),D0           Get the first character in the 
00001140  6734                     212           BEQ.S    SRCH7             current entry. If zero then exit 
00001142  49F3 0006                213           LEA.L    6(A3,D0.W),A4     Else calculate address of next entry 
00001146  122B 0001                214           MOVE.B   1(A3),D1          Get number of characters to match 
0000114A  4BEE 0404                215           LEA.L    LNBUFF(A6),A5     A5 points to command in line buffer 
0000114E  142B 0002                216           MOVE.B   2(A3),D2          Get first character in this entry 
00001152  B41D                     217           CMP.B    (A5)+,D2          from the table and match with buffer 
00001154  6704                     218           BEQ.S    SRCH3             If match then try rest of string 
00001156  264C                     219  SRCH2    MOVE.L   A4,A3             Else get address of next entry 
00001158  60E2                     220           BRA      SEARCH            and try the next entry in the table 
0000115A  5301                     221  SRCH3    SUB.B    #1,D1             One less character to match 
0000115C  670E                     222           BEQ.S    SRCH6             If match counter zero then all done 
0000115E  47EB 0003                223           LEA.L    3(A3),A3          Else point to next character in table 
00001162  141B                     224  SRCH4    MOVE.B   (A3)+,D2          Now match a pair of characters 
00001164  B41D                     225           CMP.B    (A5)+,D2 
00001166  66EE                     226           BNE      SRCH2             If no match then try next entry 
00001168  5301                     227           SUB.B    #1,D1             Else decrement match counter and 
0000116A  66F6                     228           BNE      SRCH4             repeat until no chars left to match 
0000116C  47EC FFFC                229  SRCH6    LEA.L    -4(A4),A3         Calculate address of command entry 
00001170  003C 0001                230           OR.B     #1,CCR            point. Mark carry flag as success 
00001174  4E75                     231           RTS                        and return 
00001176  023C 00FE                232  SRCH7    AND.B    #$FE,CCR          Fail - clear carry to indicate 
0000117A  4E75                     233           RTS                        command not found and return 
0000117C                           234  * 
0000117C                           235  ************************************************************************* 
0000117C                           236  * 
0000117C                           237  *  Basic input routines 
0000117C                           238  *  HEX    =  Get one   hexadecimal character  into D0 
0000117C                           239  *  BYTE   =  Get two   hexadecimal characters into D0 
0000117C                           240  *  WORD   =  Get four  hexadecimal characters into D0 
0000117C                           241  *  LONGWD =  Get eight hexadecimal characters into D0 
0000117C                           242  *  PARAM  =  Get a longword from the line buffer into D0 
0000117C                           243  *  Bit 0 of D7 is set to indicate a hexadecimal input error 
0000117C                           244  * 
0000117C  6100 0368                245  HEX      BSR      GETCHAR           Get a character from input device 
00001180  0400 0030                246           SUB.B    #$30,D0           Convert to binary 
00001184  6B0E                     247           BMI.S    NOT_HEX           If less than $30 then exit with error 
00001186  B03C 0009                248           CMP.B    #$09,D0           Else test for number (0 to 9) 
0000118A  6F0C                     249           BLE.S    HEX_OK            If number then exit - success 
0000118C  5F00                     250           SUB.B    #$07,D0           Else convert letter to hex 
0000118E  B03C 000F                251           CMP.B    #$0F,D0           If character in range "A" to "F" 
00001192  6F04                     252           BLE.S    HEX_OK            then exit successfully 
00001194  8E3C 0001                253  NOT_HEX  OR.B     #1,D7             Else set error flag 
00001198  4E75                     254  HEX_OK   RTS                        and return 
0000119A                           255  * 
0000119A  2F01                     256  BYTE     MOVE.L   D1,-(A7)          Save D1 
0000119C  61DE                     257           BSR      HEX               Get first hex character 
0000119E  E900                     258           ASL.B    #4,D0             Move it to MS nybble position 
000011A0  1200                     259           MOVE.B   D0,D1             Save MS nybble in D1 
000011A2  61D8                     260           BSR      HEX               Get second hex character 
000011A4  D001                     261           ADD.B    D1,D0             Merge MS and LS nybbles 
000011A6  221F                     262           MOVE.L   (A7)+,D1          Restore D1 
000011A8  4E75                     263           RTS 
000011AA                           264  * 
000011AA  61EE                     265  WORD     BSR      BYTE              Get upper order byte 
000011AC  E140                     266           ASL.W    #8,D0             Move it to MS position 
000011AE  60EA                     267           BRA      BYTE              Get LS byte and return 
000011B0                           268  * 
000011B0  61F8                     269  LONGWD   BSR      WORD              Get upper order word 
000011B2  4840                     270           SWAP     D0                Move it to MS position 
000011B4  60F4                     271           BRA      WORD              Get lower order word and return 
000011B6                           272  * 
000011B6                           273  *  PARAM reads a parameter from the line buffer and puts it in both 
000011B6                           274  *  PARAMTR(A6) and D0. Bit 1 of D7 is set on error. 
000011B6                           275  * 
000011B6  2F01                     276  PARAM    MOVE.L   D1,-(A7)          Save D1 
000011B8  4281                     277           CLR.L    D1                Clear input accumulator 
000011BA  206E 0444                278           MOVE.L   BUFFPT(A6),A0     A0 points to parameter in buffer 
000011BE  1018                     279  PARAM1   MOVE.B   (A0)+,D0          Read character from line buffer 
000011C0  B03C 0020                280           CMP.B    #SPACE,D0         Test for delimiter 
000011C4  6720                     281           BEQ.S    PARAM4            The permitted delimiter is a 
000011C6  B03C 000D                282           CMP.B    #CR,D0            space or a carriage return 
000011CA  671A                     283           BEQ.S    PARAM4            Exit on either space or C/R 
000011CC  E981                     284           ASL.L    #4,D1             Shift accumulated result 4 bits left 
000011CE  0400 0030                285           SUB.B    #$30,D0           Convert new character to hex 
000011D2  6B1E                     286           BMI.S    PARAM5            If less than $30 then not-hex 
000011D4  B03C 0009                287           CMP.B    #$09,D0           If less than 10 
000011D8  6F08                     288           BLE.S    PARAM3            then continue 
000011DA  5F00                     289           SUB.B    #$07,D0           Else assume $A - $F 
000011DC  B03C 000F                290           CMP.B    #$0F,D0           If more than $F 
000011E0  6E10                     291           BGT.S    PARAM5            then exit to error on not-hex 
000011E2  D200                     292  PARAM3   ADD.B    D0,D1             Add latest nybble to total in D1 
000011E4  60D8                     293           BRA      PARAM1            Repeat until delimiter found 
000011E6  2D48 0444                294  PARAM4   MOVE.L   A0,BUFFPT(A6)     Save pointer in memory 
000011EA  2D41 0448                295           MOVE.L   D1,PARAMTR(A6)    Save parameter in memory 
000011EE  2001                     296           MOVE.L   D1,D0             Put parameter in D0 for return 
000011F0  6004                     297           BRA.S    PARAM6            Return without error 
000011F2  8E3C 0002                298  PARAM5   OR.B     #2,D7             Set error flag before return 
000011F6  221F                     299  PARAM6   MOVE.L   (A7)+,D1          Restore working register 
000011F8  4E75                     300           RTS                        Return with error 
000011FA                           301  * 
000011FA                           302  ************************************************************************* 
000011FA                           303  * 
000011FA                           304  *  Output routines 
000011FA                           305  *  OUT1X   = print one   hexadecimal character 
000011FA                           306  *  OUT2X   = print two   hexadecimal characters 
000011FA                           307  *  OUT4X   = print four  hexadecimal characters 
000011FA                           308  *  OUT8X   = print eight hexadecimal characters 
000011FA                           309  *  In each case, the data to be printed is in D0 
000011FA                           310  * 
000011FA  3F00                     311  OUT1X    MOVE.W   D0,-(A7)          Save D0 
000011FC  C03C 000F                312           AND.B    #$0F,D0           Mask off MS nybble 
00001200  0600 0030                313           ADD.B    #$30,D0           Convert to ASCII 
00001204  B03C 0039                314           CMP.B    #$39,D0           ASCII = HEX + $30 
00001208  6302                     315           BLS.S    OUT1X1            If ASCII <= $39 then print and exit 
0000120A  5E00                     316           ADD.B    #$07,D0           Else ASCII := HEX + 7 
0000120C  6100 0324                317  OUT1X1   BSR      PUTCHAR           Print the character 
00001210  301F                     318           MOVE.W   (A7)+,D0          Restore D0 
00001212  4E75                     319           RTS 
00001214                           320  * 
00001214  E818                     321  OUT2X    ROR.B    #4,D0             Get MS nybble in LS position 
00001216  61E2                     322           BSR      OUT1X             Print MS nybble 
00001218  E918                     323           ROL.B    #4,D0             Restore LS nybble 
0000121A  60DE                     324           BRA      OUT1X             Print LS nybble and return 
0000121C                           325  * 
0000121C  E058                     326  OUT4X    ROR.W    #8,D0             Get MS byte in LS position 
0000121E  61F4                     327           BSR      OUT2X             Print MS byte 
00001220  E158                     328           ROL.W    #8,D0             Restore LS byte 
00001222  60F0                     329           BRA      OUT2X             Print LS byte and return 
00001224                           330  * 
00001224  4840                     331  OUT8X    SWAP     D0                Get MS word in LS position 
00001226  61F4                     332           BSR      OUT4X             Print MS word 
00001228  4840                     333           SWAP     D0                Restore LS word 
0000122A  60F0                     334           BRA      OUT4X             Print LS word and return 
0000122C                           335  * 
0000122C                           336  ************************************************************************* 
0000122C                           337  * 
0000122C                           338  * JUMP causes execution to begin at the address in the line buffer 
0000122C                           339  * 
0000122C  6188                     340  JUMP     BSR     PARAM              Get address from buffer 
0000122E  4A07                     341           TST.B   D7                 Test for input error 
00001230  6608                     342           BNE.S   JUMP1              If error flag not zero then exit 
00001232  4A80                     343           TST.L   D0                 Else test for missing address 
00001234  6704                     344           BEQ.S   JUMP1              field. If no address then exit 
00001236  2040                     345           MOVE.L  D0,A0              Put jump address in A0 and call the 
00001238  4ED0                     346           JMP     (A0)               subroutine. User to supply RTS!! 
0000123A  49FA 0B47                347  JUMP1    LEA.L   ERMES1(PC),A4      Here for error - display error 
0000123E  6000 FE42                348           BRA     PSTRING            message and return 
00001242                           349  * 
00001242                           350  ************************************************************************* 
00001242                           351  * 
00001242                           352  *  Display the contents of a memory location and modify it 
00001242                           353  * 
00001242  6100 FF72                354  MEMORY   BSR      PARAM             Get start address from line buffer 
00001246  4A07                     355           TST.B    D7                Test for input error 
00001248  6634                     356           BNE.S    MEM3              If error then exit 
0000124A  2640                     357           MOVE.L   D0,A3             A3 points to location to be opened 
0000124C  6100 FE24                358  MEM1     BSR      NEWLINE 
00001250  612E                     359           BSR.S    ADR_DAT           Print current address and contents 
00001252  6140                     360           BSR.S    PSPACE             update pointer, A3, and O/P space 
00001254  6100 0290                361           BSR      GETCHAR           Input char to decide next action 
00001258  B03C 000D                362           CMP.B    #CR,D0            If carriage return then exit 
0000125C  6720                     363           BEQ.S    MEM3              Exit 
0000125E  B03C 002D                364           CMP.B    #'-',D0           If "-" then move back 
00001262  6606                     365           BNE.S    MEM2              Else skip wind-back procedure 
00001264  47EB FFFC                366           LEA.L    -4(A3),A3         Move pointer back 2+2 
00001268  60E2                     367           BRA      MEM1              Repeat until carriage return 
0000126A  B03C 0020                368  MEM2     CMP.B    #SPACE,D0         Test for space (= new entry) 
0000126E  66DC                     369           BNE.S    MEM1              If not space then repeat 
00001270  6100 FF38                370           BSR      WORD              Else get new word to store 
00001274  4A07                     371           TST.B    D7                Test for input error 
00001276  6606                     372           BNE.S    MEM3              If error then exit 
00001278  3740 FFFE                373           MOVE.W   D0,-2(A3)         Store new word 
0000127C  60CE                     374           BRA      MEM1              Repeat until carriage return 
0000127E  4E75                     375  MEM3     RTS 
00001280                           376  * 
00001280  2F00                     377  ADR_DAT  MOVE.L   D0,-(A7)          Print the contents of A3 and the 
00001282  200B                     378           MOVE.L   A3,D0             word pointed at by A3. 
00001284  619E                     379           BSR      OUT8X              and print current address 
00001286  610C                     380           BSR.S    PSPACE            Insert delimiter 
00001288  3013                     381           MOVE.W   (A3),D0           Get data at this address in D0 
0000128A  6190                     382           BSR      OUT4X              and print it 
0000128C  47EB 0002                383           LEA.L    2(A3),A3          Point to next address to display 
00001290  201F                     384           MOVE.L   (A7)+,D0          Restore D0 
00001292  4E75                     385           RTS 
00001294                           386  * 
00001294  1F00                     387  PSPACE   MOVE.B   D0,-(A7)          Print a single space 
00001296  103C 0020                388           MOVE.B   #SPACE,D0
0000129A  6100 0296                389           BSR      PUTCHAR 
0000129E  101F                     390           MOVE.B   (A7)+,D0 
000012A0  4E75                     391           RTS 
000012A2                           392  * 
000012A2                           393  ************************************************************************* 
000012A2                           394  * 
000012A2                           395  *  LOAD  Loads data formatted in hexadecimal "S". format from Port 2 
000012A2                           396  *        NOTE - I/O is automatically redirected to the aux port for 
000012A2                           397  *        loader functions. S1 or S2 records accepted 
000012A2                           398  * 
000012A2  2F2E 0456                399  LOAD     MOVE.L   CN_OVEC(A6),-(A7) Save current output device name 
000012A6  2F2E 0452                400           MOVE.L   CN_IVEC(A6),-(A7) Save current input device name 
000012AA                           401           *MOVE.L   #DCB4,CN_OVEC(A6) Set up aux ACIA as output 
000012AA                           402           *MOVE.L   #DCB3,CN_IVEC(A6) Set up aux ACIA as input 
000012AA  522E 044C                403           ADD.B    #1,ECHO(A6)       Turn off character echo 
000012AE  6100 FDC2                404           BSR      NEWLINE           Send newline to host 
000012B2  6100 0152                405           BSR      DELAY             Wait for host to "settle" 
000012B6  6100 014E                406           BSR      DELAY 
000012BA  286E 0444                407           MOVE.L   BUFFPT(A6),A4     Any string in the line buffer is 
000012BE  101C                     408  LOAD1    MOVE.B   (A4)+,D0          transmitted to the host computer 
000012C0  6100 0270                409           BSR      PUTCHAR           before the loading begins 
000012C4  B03C 000D                410           CMP.B    #CR,D0            Read from the buffer until EOL 
000012C8  66F4                     411           BNE      LOAD1 
000012CA  6100 FDA6                412           BSR      NEWLINE           Send newline before loading 
000012CE  6100 0216                413  LOAD2    BSR      GETCHAR           Records from the host must begin 
000012D2  B03C 0053                414           CMP.B    #'S',D0           with S1/S2 (data) or S9/S8 (term) 
000012D6  66F6                     415           BNE.S    LOAD2             Repeat GETCHAR until char = "S" 
000012D8  6100 020C                416           BSR      GETCHAR           Get character after "S" 
000012DC  B03C 0039                417           CMP.B    #'9',D0           Test for the two terminators S9/S8 
000012E0  6706                     418           BEQ.S    LOAD3             If S9 record then exit else test 
000012E2  B03C 0038                419           CMP.B    #'8',D0           for S8 terminator. Fall through to 
000012E6  662A                     420           BNE.S    LOAD6             exit on S8 else continue search 
000012E8  =000012E8                421  LOAD3    EQU      *                 Exit point from LOAD 
000012E8  2D5F 0452                422           MOVE.L   (A7)+,CN_IVEC(A6) Clean up by restoring input device 
000012EC  2D5F 0456                423           MOVE.L   (A7)+,CN_OVEC(A6) and output device name 
000012F0  422E 044C                424           CLR.B    ECHO(A6)          Restore input character echo 
000012F4  0807 0000                425           BTST   #0,D7             Test for input errors 
000012F8  6708                     426           BEQ.S    LOAD4             If no I/P error then look at checksum 
000012FA  49FA 0A87                427           LEA.L    ERMES1(PC),A4     Else point to error message 
000012FE  6100 FD82                428           BSR      PSTRING           Print it 
00001302  0807 0003                429  LOAD4    BTST   #3,D7             Test for checksum error 
00001306  6708                     430           BEQ.S    LOAD5             If clear then exit 
00001308  49FA 0AAB                431           LEA.L    ERMES3(PC),A4     Else point to error message 
0000130C  6100 FD74                432           BSR      PSTRING           Print it and return 
00001310  4E75                     433  LOAD5    RTS 
00001312                           434  * 
00001312  B03C 0031                435  LOAD6    CMP.B    #'1',D0           Test for S1 record 
00001316  671E                     436           BEQ.S    LOAD6A            If S1 record then read it 
00001318  B03C 0032                437           CMP.B    #'2',D0           Else test for S2 record 
0000131C  66B0                     438           BNE.S    LOAD2             Repeat until valid header found 
0000131E  4203                     439           CLR.B    D3                Read the S2 byte count and address, 
00001320  613C                     440           BSR.S    LOAD8             clear the checksum 
00001322  5900                     441           SUB.B    #4,D0             Calculate size of data field 
00001324  1400                     442           MOVE.B   D0,D2             D2 contains data bytes to read 
00001326  4280                     443           CLR.L    D0                Clear address accumulator 
00001328  6134                     444           BSR.S    LOAD8             Read most sig byte of address 
0000132A  E180                     445           ASL.L    #8,D0             Move it one byte left 
0000132C  6130                     446           BSR.S    LOAD8             Read the middle byte of address 
0000132E  E180                     447           ASL.L    #8,D0             Move it one byte left 
00001330  612C                     448           BSR.S    LOAD8             Read least sig byte of address 
00001332  2440                     449           MOVE.L   D0,A2             A2 points to destination of record 
00001334  6012                     450           BRA.S    LOAD7             Skip past S1 header loader 
00001336  4203                     451  LOAD6A   CLR.B    D3                S1 record found - clear checksum 
00001338  6124                     452           BSR.S    LOAD8             Get byte and update checksum 
0000133A  5700                     453           SUB.B    #3,D0             Subtract 3 from record length 
0000133C  1400                     454           MOVE.B   D0,D2             Save byte count in D2 
0000133E  4280                     455           CLR.L    D0                Clear address accumulator 
00001340  611C                     456           BSR.S    LOAD8             Get MS byte of load address 
00001342  E180                     457           ASL.L    #8,D0             Move it to MS position 
00001344  6118                     458           BSR.S    LOAD8             Get LS byte in D2 
00001346  2440                     459           MOVE.L   D0,A2             A2 points to destination of data 
00001348  6114                     460  LOAD7    BSR.S    LOAD8             Get byte of data for loading 
0000134A  14C0                     461           MOVE.B   D0,(A2)+          Store it 
0000134C  5302                     462           SUB.B    #1,D2             Decrement byte counter 
0000134E  66F8                     463           BNE      LOAD7             Repeat until count = 0 
00001350  610C                     464           BSR.S    LOAD8             Read checksum 
00001352  5203                     465           ADD.B    #1,D3             Add 1 to total checksum 
00001354  6700 FF78                466           BEQ      LOAD2             If zero then start next record 
00001358  8E3C 0008                467           OR.B     #%00001000,D7     Else set checksum error bit, 
0000135C  608A                     468           BRA      LOAD3             restore I/O devices and return 
0000135E                           469  * 
0000135E  6100 FE3A                470  LOAD8    BSR     BYTE               Get a byte 
00001362  D600                     471           ADD.B   D0,D3              Update checksum 
00001364  4E75                     472           RTS                         and return 
00001366                           473  *************************************************************************** 
00001366                           474  * 
00001366                           475  *  DUMP   Transmit S1 formatted records to host computer 
00001366                           476  *         A3 = Starting address of data block 
00001366                           477  *         A2 = End address of data block 
00001366                           478  *         D1 = Checksum, D2 = current record length 
00001366                           479  * 
00001366  6100 008E                480  DUMP     BSR      RANGE             Get start and end address 
0000136A  4A07                     481           TST.B    D7                Test for input error 
0000136C  6708                     482           BEQ.S    DUMP1             If no error then continue 
0000136E  49FA 0A13                483           LEA.L    ERMES1(PC),A4     Else point to error message, 
00001372  6000 FD0E                484           BRA      PSTRING           print it and return 
00001376  B08B                     485  DUMP1    CMP.L    A3,D0             Compare start and end addresses 
00001378  6A08                     486           BPL.S    DUMP2             If positive then start < end 
0000137A  49FA 0BA8                487           LEA.L    ERMES7(PC),A4     Else print error message 
0000137E  6000 FD02                488           BRA      PSTRING           and return 
00001382  2F2E 0456                489  DUMP2    MOVE.L   CN_OVEC(A6),-(A7) Save name of current output device 
00001386                           490  *         MOVE.L   #DCB4,CN_OVEC(A6) Set up Port 2 as output device 
00001386  6100 FCEA                491           BSR      NEWLINE           Send newline to host and wait 
0000138A  617A                     492           BSR.S    DELAY 
0000138C  286E 0444                493           MOVE.L   BUFFPT(A6),A4     Before dumping, send any string 
00001390  101C                     494  DUMP3    MOVE.B   (A4)+,D0          in the input buffer to the host 
00001392  6100 019E                495           BSR      PUTCHAR           Repeat 
00001396  B03C 000D                496           CMP.B    #CR,D0            Transmit char from buffer to host 
0000139A  66F4                     497           BNE      DUMP3             Until char = C/R 
0000139C  6100 FCD4                498           BSR      NEWLINE 
000013A0  6164                     499           BSR.S    DELAY             Allow time for host to settle 
000013A2  528A                     500           ADDQ.L   #1,A2             A2 contains length of record + 1 
000013A4  240A                     501  DUMP4    MOVE.L   A2,D2             D2 points to end address 
000013A6  948B                     502           SUB.L    A3,D2             D2 contains bytes left to print 
000013A8  B4BC 00000011            503           CMP.L    #17,D2            If this is not a full record of 16 
000013AE  6502                     504           BCS.S    DUMP5             then load D2 with record size 
000013B0  7410                     505           MOVEQ    #16,D2            Else preset byte count to 16 
000013B2  49FA 08E5                506  DUMP5    LEA.L    HEADER(PC),A4     Point to record header 
000013B6  6100 FCCA                507           BSR      PSTRING           Print header 
000013BA  4201                     508           CLR.B    D1                Clear checksum 
000013BC  1002                     509           MOVE.B   D2,D0             Move record length to output register 
000013BE  5600                     510           ADD.B    #3,D0             Length includes address + count 
000013C0  612E                     511           BSR.S    DUMP7             Print number of bytes in record 
000013C2  200B                     512           MOVE.L   A3,D0             Get start address to be printed 
000013C4  E158                     513           ROL.W    #8,D0             Get MS byte in LS position 
000013C6  6128                     514           BSR.S    DUMP7             Print MS byte of address 
000013C8  E058                     515           ROR.W    #8,D0             Restore LS byte 
000013CA  6124                     516           BSR.S    DUMP7             Print LS byte of address 
000013CC  101B                     517  DUMP6    MOVE.B   (A3)+,D0          Get data byte to be printed 
000013CE  6120                     518           BSR.S    DUMP7             Print it 
000013D0  5302                     519           SUB.B    #1,D2             Decrement byte count 
000013D2  66F8                     520           BNE      DUMP6             Repeat until all this record printed 
000013D4  4601                     521           NOT.B    D1                Complement checksum 
000013D6  1001                     522           MOVE.B   D1,D0             Move to output register 
000013D8  6116                     523           BSR.S    DUMP7             Print checksum 
000013DA  6100 FC96                524           BSR      NEWLINE 
000013DE  B7CA                     525           CMP.L    A2,A3             Have all records been printed? 
000013E0  66C2                     526           BNE      DUMP4             Repeat until all done 
000013E2  49FA 08BB                527           LEA.L    TAIL(PC),A4       Point to message tail (S9 record) 
000013E6  6100 FC9A                528           BSR      PSTRING           Print it 
000013EA  2D5F 0456                529           MOVE.L   (A7)+,CN_OVEC(A6) Restore name of output device 
000013EE  4E75                     530           RTS                        and return 
000013F0                           531  * 
000013F0  D200                     532  DUMP7    ADD.B    D0,D1             Update checksum, transmit byte 
000013F2  6000 FE20                533           BRA      OUT2X             to host and return 
000013F6                           534  * 
000013F6  =000013F6                535  RANGE    EQU      *                 Get the range of addresses to be 
000013F6  4207                     536           CLR.B    D7                transmitted from the buffer 
000013F8  6100 FDBC                537           BSR      PARAM             Get starting address 
000013FC  2640                     538           MOVE.L   D0,A3             Set up start address in A3 
000013FE  6100 FDB6                539           BSR      PARAM             Get end address 
00001402  2440                     540           MOVE.L   D0,A2             Set up end address in A2 
00001404  4E75                     541           RTS 
00001406                           542  * 
00001406  =00001406                543  DELAY    EQU       *                Provide a time delay for the host 
00001406  48E7 8008                544           MOVEM.L   D0/A4,-(A7)      to settle. Save working registers 
0000140A  203C 00004000            545           MOVE.L    #$4000,D0        Set up delay constant 
00001410  5380                     546  DELAY1   SUB.L     #1,D0            Count down         (8 clk cycles) 
00001412  66FC                     547           BNE       DELAY1           Repeat until zero  (10 clk cycles) 
00001414  4CDF 1001                548           MOVEM.L   (A7)+,D0/A4      Restore working registers 
00001418  4E75                     549           RTS 
0000141A                           550  * 
0000141A                           551  ************************************************************************* 
0000141A                           552  * 
0000141A                           553  *  This routine sets up the system DCBs in RAM using the information 
0000141A                           554  *  stored in ROM at address DCB_LST. This is called at initialization. 
0000141A                           555  *  CN_IVEC contains the name "DCB1" and IO_VEC the name "DCB2" 
0000141A                           556  * 
0000141A  48E7 F0F0                557  SET_DCB  MOVEM.L A0-A3/D0-D3,-(A7) Save all working registers 
0000141E  41EE 04D4                558           LEA.L   FIRST(A6),A0    Pointer to first DCB destination in RAM 
00001422  43FA 0C1C                559           LEA.L   DCB_LST(PC),A1  A1 points to DCB info block in ROM 
00001426  303C 0003                560           MOVE.W  #3,D0           4 DCBs to set up 
0000142A  323C 000F                561  ST_DCB1  MOVE.W  #15,D1          16 bytes to move per DCB header 
0000142E  10D9                     562  ST_DCB2  MOVE.B  (A1)+,(A0)+     Move the 16 bytes of a DCB header 
00001430  51C9 FFFC                563           DBRA    D1,ST_DCB2      from ROM to RAM 
00001434  3619                     564           MOVE.W  (A1)+,D3        Get size of parameter block (bytes) 
00001436  3083                     565           MOVE.W  D3,(A0)         Store size in DCB in RAM 
00001438  41F0 3002                566           LEA.L   2(A0,D3.W),A0   A0 points to tail of DCB in RAM 
0000143C  47E8 0004                567           LEA.L   4(A0),A3        A3 contains address of next DCB in RAM 
00001440  208B                     568           MOVE.L  A3,(A0)         Store pointer to next DCB in this DCB 
00001442  41D3                     569           LEA.L   (A3),A0         A0 now points at next DCB in RAM 
00001444  51C8 FFE4                570           DBRA    D0,ST_DCB1      Repeat until all DCBs set up 
00001448  47EB FFFC                571           LEA.L   -4(A3),A3       Adjust A3 to point to last DCB pointer 
0000144C  4293                     572           CLR.L   (A3)            and force last pointer to zero 
0000144E  2D7C 00002040 0452       573           MOVE.L  #DCB1,CN_IVEC(A6) Set up vector to console input DCB 
00001456  2D7C 00002052 0456       574           MOVE.L  #DCB2,CN_OVEC(A6) Set up vector to console output DCB 
0000145E  4CDF 0F0F                575           MOVEM.L (A7)+,A0-A3/D0-D3 Restore registers 
00001462  4E75                     576           RTS 
00001464                           577  * 
00001464                           578  ************************************************************************* 
00001464                           579  * 
00001464                           580  *  IO_REQ handles all input/output transactions. A0 points to DCB on 
00001464                           581  *  entry. IO_REQ calls the device driver whose address is in the DCB. 
00001464                           582  * 
00001464  48E7 00C0                583  IO_REQ   MOVEM.L A0-A1,-(A7)     Save working registers 
00001468  43E8 0008                584           LEA.L   8(A0),A1        A1 points to device handler field in DCB 
0000146C  2251                     585           MOVE.L  (A1),A1         A1 contains device handler address 
0000146E  4E91                     586           JSR     (A1)            Call device handler 
00001470  4CDF 0300                587           MOVEM.L (A7)+,A0-A1     Restore working registers 
00001474  4E75                     588           RTS 
00001476                           589  * 
00001476                           590  ************************************************************************* 
00001476                           591  * 
00001476                           592  *  CON_IN handles input from the console device 
00001476                           593  *  This is the device driver used by DCB1. Exit with input in D0 
00001476                           594  * 
00001476  48E7 4040                595  CON_IN   MOVEM.L D1/A1,-(A7)     Save working registers 
0000147A  43E8 000C                596           LEA.L   12(A0),A1       Get pointer to ACIA from DCB 
0000147E  2251                     597           MOVE.L  (A1),A1         Get address of ACIA in A1 
00001480  4228 0013                598           CLR.B   19(A0)          Clear logical error in DCB 
00001484  1211                     599  CON_I1   MOVE.B  (A1),D1         Read ACIA status 
00001486  0801 0000                600           BTST  #0,D1           Test RDRF 
0000148A  67F8                     601           BEQ     CON_I1          Repeat until RDRF true 
0000148C  1141 0012                602           MOVE.B  D1,18(A0)       Store physical status in DCB 
00001490  C23C 00F4                603           AND.B   #%011110100,D1  Mask to input error bits 
00001494  6706                     604           BEQ.S   CON_I2          If no error then skip update 
00001496  117C 0001 0013           605           MOVE.B  #1,19(A0)       Else update logical error 
0000149C  1029 0002                606  CON_I2   MOVE.B  2(A1),D0        Read input from ACIA 
000014A0  4CDF 0202                607           MOVEM.L (A7)+,A1/D1     Restore working registers 
000014A4  4E75                     608           RTS 
000014A6                           609  * 
000014A6                           610  ************************************************************************* 
000014A6                           611  * 
000014A6                           612  *   This is the device driver used by DCB2. Output in D0 
000014A6                           613  *   The output can be halted or suspended 
000014A6                           614  * 
000014A6  48E7 6040                615  CON_OUT  MOVEM.L A1/D1-D2,-(A7)  Save working registers 
000014AA  43E8 000C                616           LEA.L   12(A0),A1       Get pointer to ACIA from DCB 
000014AE  2251                     617           MOVE.L  (A1),A1         Get address of ACIA in A1 
000014B0  4228 0013                618           CLR.B   19(A0)          Clear logical error in DCB 
000014B4  1211                     619  CON_OT1  MOVE.B  (A1),D1         Read ACIA status 
000014B6  0801 0000                620           BTST  #0,D1           Test RDRF bit (any input?) 
000014BA  6716                     621           BEQ.S   CON_OT3         If no input then test output status 
000014BC  1429 0002                622           MOVE.B  2(A1),D2        Else read the input 
000014C0  C43C 005F                623           AND.B   #%01011111,D2   Strip parity and bit 5 
000014C4  B43C 0057                624           CMP.B   #WAIT,D2        and test for a wait condition 
000014C8  6608                     625           BNE.S   CON_OT3         If not wait then ignore and test O/P 
000014CA  1411                     626  CON_OT2  MOVE.B  (A1),D2         Else read ACIA status register 
000014CC  0802 0000                627           BTST  #0,D2           and poll ACIA until next char received 
000014D0  67F8                     628           BEQ     CON_OT2 
000014D2  0801 0001                629  CON_OT3  BTST  #1,D1           Repeat 
000014D6  67DC                     630           BEQ     CON_OT1          until ACIA Tx ready 
000014D8  1141 0012                631           MOVE.B  D1,18(A0)       Store status in DCB physical error 
000014DC  1340 0002                632           MOVE.B  D0,2(A1)        Transmit output 
000014E0  4CDF 0206                633           MOVEM.L (A7)+,A1/D1-D2  Restore working registers 
000014E4  4E75                     634           RTS 
000014E6                           635  * 
000014E6                           636  ************************************************************************* 
000014E6                           637  * 
000014E6                           638  *  GETCHAR gets a character from the console device 
000014E6                           639  *  This is the main input routine and uses the device whose name  
000014E6                           640  *  is stored in CN_IVEC. Changing this name redirects input. 
000014E6                           641  * 
000014E6  2F08                     642  GETCHAR  MOVE.L  A0,-(A7)        Save working register 
000014E8  206E 0452                643           MOVE.L  CN_IVEC(A6),A0  A0 points to name of console DCB 
000014EC  616A                     644           BSR.S   IO_OPEN         Open console (get DCB address in A0) 
000014EE  0807 0003                645           BTST    #3,D7           D7(3) set if open error 
000014F2  6628                     646           BNE.S   GETCH3          If error then exit now 
000014F4  6100 FF6E                647           BSR     IO_REQ          Else execute I/O transaction 
000014F8  C03C 007F                648           AND.B   #$7F,D0         Strip msb of input 
000014FC  4A2E 044D                649           TST.B   U_CASE(A6)      Test for upper -> lower case conversion 
00001500  660A                     650           BNE.S   GETCH2          If flag not zero do not convert case 
00001502  0800 0006                651           BTST    #6,D0           Test input for lower case 
00001506  6704                     652           BEQ.S   GETCH2          If upper case then skip conversion 
00001508  C03C 00DF                653           AND.B   #%11011111,D0   Else clear bit 5 for upper case conv 
0000150C  4A2E 044C                654  GETCH2   TST.B   ECHO(A6)        Do we need to echo the input? 
00001510  660A                     655           BNE.S   GETCH3          If ECHO not zero then no echo
00001512  BC3C 0001                656           CMP.B   #1,D6
00001516  6700 0008                657           BEQ     PUTASK
0000151A  6116                     658           BSR.S   PUTCHAR         Else echo the input 
0000151C  205F                     659  GETCH3   MOVE.L  (A7)+,A0        Restore working register 
0000151E  4E75                     660           RTS                     and return 
00001520                           661  
00001520  1600                     662  PUTASK   MOVE.B  D0,D3           save D0
00001522  B07C 000D                663           CMP     #CR,D0          if Carriage_return 
00001526  6700 001E                664           BEQ     SPUTCHAR        then PUTCHAR
0000152A  103C 002A                665           MOVE.B  #42,D0          else PUTASK to hide password
0000152E  6000 0016                666           BRA     SPUTCHAR
00001532                           667  
00001532                           668  * 
00001532                           669  ************************************************************************* 
00001532                           670  * 
00001532                           671  *  PUTCHAR sends a character to the console device 
00001532                           672  *  The name of the output device is in CN_OVEC. 
00001532                           673  * 
00001532  BC3C 0001                674  PUTCHAR  CMP.B   #1,D6
00001536  2F08                     675           MOVE.L  A0,-(A7)        Save working register
00001538  206E 0456                676           MOVE.L  CN_OVEC(A6),A0  A0 points to name of console output 
0000153C  611A                     677           BSR.S   IO_OPEN         Open console (Get address of DCB) 
0000153E  6100 FF24                678           BSR     IO_REQ          Perform output with DCB pointed at by A0 
00001542  205F                     679           MOVE.L  (A7)+,A0        Restore working register 
00001544  4E75                     680           RTS 
00001546                           681  
00001546  2F08                     682  SPUTCHAR  MOVE.L  A0,-(A7)        Save working register
00001548  206E 0456                683            MOVE.L  CN_OVEC(A6),A0  A0 points to name of console output 
0000154C  610A                     684            BSR.S   IO_OPEN         Open console (Get address of DCB) 
0000154E  6100 FF14                685            BSR     IO_REQ          Perform output with DCB pointed at by A0 
00001552  205F                     686            MOVE.L  (A7)+,A0        Restore working register
00001554  1003                     687            MOVE.B  D3,D0           restore d0
00001556  60C4                     688            BRA     GETCH3 
00001558                           689  * 
00001558                           690  ************************************************************************* 
00001558                           691  * 
00001558                           692  *  Open - opens a DCB for input or output. IO_OPEN converts the 
00001558                           693  *  name pointed at by A0 into the address of the DCB pointed at 
00001558                           694  *  by A0. Bit 3 of D7 is set to zero if DCB not found 
00001558                           695  * 
00001558  48E7 F870                696  IO_OPEN  MOVEM.L  A1-A3/D0-D4,-(A7) Save working registers 
0000155C  43EE 04D4                697           LEA.L    FIRST(A6),A1   A1 points to first DCB in chain in RAM 
00001560  45D1                     698  OPEN1    LEA.L    (A1),A2        A2 = temp copy of pointer to DCB 
00001562  47D0                     699           LEA.L    (A0),A3        A3 = temp copy of pointer to DCB name 
00001564  303C 0007                700           MOVE.W   #7,D0          Up to 8 chars of DCB name to match 
00001568  181A                     701  OPEN2    MOVE.B   (A2)+,D4       Compare DCB name with string 
0000156A  B81B                     702           CMP.B    (A3)+,D4 
0000156C  6608                     703           BNE.S    OPEN3          If no match try next DCB 
0000156E  51C8 FFF8                704           DBRA     D0,OPEN2       Else repeat until all chars matched 
00001572  41D1                     705           LEA.L    (A1),A0        Success - move this DCB address to A0 
00001574  6016                     706           BRA.S    OPEN4          and return 
00001576  =00001576                707  OPEN3    EQU      *              Fail - calculate address of next DCB 
00001576  3229 0010                708           MOVE.W   16(A1),D1      Get parameter block size of DCB 
0000157A  43F1 1012                709           LEA.L    18(A1,D1.W),A1 A1 points to pointer to next DCB 
0000157E  2251                     710           MOVE.L   (A1),A1        A1 now points to next DCB 
00001580  B3FC 00000000            711           CMP.L    #0,A1          Test for end of DCB chain 
00001586  66D8                     712           BNE      OPEN1          If not end of chain then try next DCB 
00001588  8E3C 0008                713           OR.B     #8,D7          Else set error flag and return 
0000158C  4CDF 0E1F                714  OPEN4    MOVEM.L  (A7)+,A1-A3/D0-D4 Restore working registers 
00001590  4E75                     715           RTS 
00001592                           716  * 
00001592                           717  ************************************************************************* 
00001592                           718  * 
00001592                           719  *  Exception vector table initialization routine 
00001592                           720  *  All vectors not setup are loaded with uninitialized routine vector 
00001592                           721  * 
00001592  303C 0007                722  B_CLR   MOVE.W  #7,D0             Now clear the breakpoint table 
00001596  41EE 04A4                723          LEA.L   BP_TAB(A6),A0     Point to table
0000159A  4E75                     724          RTS 
0000159C                           725  * 
0000159C                           726  *************************************************************************
0000159C  DA04                     727  ADD_0   ADD.B     D4,D5           adding Bytes inputted to D4 and D5
0000159E  1605                     728          MOVE.B    D5,D3           moving D5 to D3
000015A0  183C 0000                729          MOVE.B    #0,D4           resetting neg flag
000015A4  6B00 0040                730          BMI       SETNEG          if negative set neg flag
000015A8  4E75                     731          RTS
000015AA                           732  
000015AA  9A04                     733  SUB_0   SUB.B     D4,D5           subtracting Bytes inputted to D4 and D5
000015AC  183C 0000                734          MOVE.B    #0,D4           resetting neg flag
000015B0  1605                     735          MOVE.B    D5,D3           moving D5 to D3
000015B2  6B00 0032                736          BMI       SETNEG          if negative set neg flag
000015B6  4E75                     737          RTS
000015B8                           738          
000015B8  CBC4                     739  MUL_0   MULS      D4,D5           multiplying Bytes inputted to D4 and D5
000015BA  383C 0000                740          MOVE.W    #0,D4           resetting neg flag
000015BE  2605                     741          MOVE.L    D5,D3           moving D5 to D3
000015C0  6B00 0034                742          BMI       MULNEG          if negative set neg flag
000015C4  4E75                     743          RTS
000015C6                           744  
000015C6  8BC4                     745  DIV_0   DIVS      D4,D5           dividing Bytes inputted to D4 and D5
000015C8  183C 0000                746          MOVE.B    #0,D4           resetting neg flag
000015CC  1605                     747          MOVE.B    D5,D3           moving D5 to D3
000015CE  4603                     748          NOT.B     D3              converting result from twos Complement
000015D0  C63C 007F                749          AND.B     #%01111111,D3   to regular hex values
000015D4  5203                     750          ADD.B     #1,D3           finishing process
000015D6  BA7C 007F                751          CMP.W     #127,D5         if greater than, it is negative
000015DA  6500 0004                752          BCS       DIVNEG          if negative set neg flag
000015DE  4E75                     753          RTS
000015E0                           754  
000015E0  183C 0001                755  DIVNEG  MOVE.B    #1,D4           set neg flag
000015E4  4E75                     756          RTS
000015E6                           757  
000015E6  183C 00FF                758  SETNEG  MOVE.B    #255,D4         convert twos comliment conversion
000015EA  9803                     759          SUB.B     D3,D4           result to regular hex
000015EC  1604                     760          MOVE.B    D4,D3           moving D4 to D3
000015EE  5203                     761          ADD.B     #1,D3           set neg flag
000015F0  183C 0001                762          MOVE.B    #1,D4           set neg flag
000015F4  4E75                     763          RTS
000015F6                           764  
000015F6  183C 0001                765  MULNEG  MOVE.B    #1,D4           setting neg flag
000015FA  4683                     766          NOT.L     D3              since a neg product is twos comliment this must 
000015FC  C6BC 7FFFFFFF            767          AND.L     #%01111111111111111111111111111111,D3       be converted to hex
00001602  5203                     768          ADD.B     #1,D3
00001604  4E75                     769          RTS
00001606                           770  
00001606                           771  ************************************************************************* 
00001606                           772  * 
00001606                           773  * 
00001606  =00001606                774  TRAP_0  EQU     *                 User links to  TS2BUG via TRAP #0 
00001606  B23C 0000                775          CMP.B   #0,D1             D1 = 0 = Get character 
0000160A  6606                     776          BNE.S   FOO1           
0000160C  6100 FED8                777          BSR     GETCHAR 
00001610  4E73                     778          RTE 
00001612  B23C 0001                779  FOO1    CMP.B   #1,D1             D1 = 1 = Print character 
00001616  6606                     780          BNE.S   FOO2 
00001618  6100 FF18                781          BSR     PUTCHAR 
0000161C  4E73                     782          RTE 
0000161E  B23C 0002                783  FOO2    CMP.B   #2,D1             D1 = 2 = Newline 
00001622  6606                     784          BNE.S   FOO3 
00001624  6100 FA4C                785          BSR     NEWLINE 
00001628  4E73                     786          RTE 
0000162A  B23C 0003                787  FOO3    CMP.B   #3,D1             D1 = 3 = Get parameter from buffer 
0000162E  6606                     788          BNE.S   FOO4 
00001630  6100 FB84                789          BSR     PARAM 
00001634  4E73                     790          RTE 
00001636  B23C 0004                791  FOO4    CMP.B   #4,D1             D1 = 4 = Print string pointed at by A4 
0000163A  6606                     792          BNE.S   FOO5 
0000163C  6100 FA44                793          BSR     PSTRING 
00001640  4E73                     794          RTE 
00001642  B23C 0005                795  FOO5    CMP.B   #5,D1             D1 = 5 = Get a hex character 
00001646  6606                     796          BNE.S   FOO6 
00001648  6100 FB32                797          BSR     HEX 
0000164C  4E73                     798          RTE 
0000164E  B23C 0006                799  FOO6    CMP.B   #6,D1             D1 = 6 = Get a hex byte 
00001652  6606                     800          BNE.S   FOO7 
00001654  6100 FB44                801          BSR     BYTE 
00001658  4E73                     802          RTE 
0000165A  B23C 0007                803  FOO7    CMP.B   #7,D1             D1 = 7 = Get a word 
0000165E  6606                     804          BNE.S   FOO8 
00001660  6100 FB48                805          BSR     WORD 
00001664  4E73                     806          RTE 
00001666  B23C 0008                807  FOO8    CMP.B   #8,D1             D1 = 8 = Get a longword 
0000166A  6606                     808          BNE.S   FOO9 
0000166C  6100 FB42                809          BSR     LONGWD 
00001670  4E73                     810          RTE 
00001672  B23C 0009                811  FOO9    CMP.B   #9,D1             D1 = 9 = Output hex byte 
00001676  6606                     812          BNE.S   FOO10  
00001678  6100 FB9A                813          BSR     OUT2X 
0000167C  4E73                     814          RTE 
0000167E  B23C 000A                815  FOO10   CMP.B   #10,D1            D1 = 10 = Output hex word 
00001682  6606                     816          BNE.S   FOO11 
00001684  6100 FB96                817          BSR     OUT4X 
00001688  4E73                     818          RTE 
0000168A  B23C 000B                819  FOO11   CMP.B   #11,D1            D1 = 11 = Output hex longword 
0000168E  6606                     820          BNE.S   FOO12 
00001690  6100 FB92                821          BSR     OUT8X 
00001694  4E73                     822          RTE 
00001696  B23C 000C                823  FOO12   CMP.B   #12,D1            D1 = 12 = Print a space 
0000169A  6606                     824          BNE.S   FOO13 
0000169C  6100 FBF6                825          BSR     PSPACE 
000016A0  4E73                     826          RTE 
000016A2  B23C 000D                827  FOO13   CMP.B   #13,D1            D1 = 13 = Get a line of text into 
000016A6  6606                     828          BNE.S   FOO14            the line buffer 
000016A8  6100 F9EE                829          BSR     GETLINE 
000016AC  4E73                     830          RTE 
000016AE  B23C 000E                831  FOO14   CMP.B   #14,D1            D1 = 14 = Tidy up the line in the 
000016B2  6606                     832          BNE.S   FOO15            line buffer by removing leading 
000016B4  6100 FA18                833          BSR     TIDY              leading and multiple embeded spaces 
000016B8  4E73                     834          RTE 
000016BA  B23C 000F                835  FOO15   CMP.B   #15,D1            D1 = 15 = Execute the command in 
000016BE  6606                     836          BNE.S   FOO16            the line buffer 
000016C0  6100 FA4E                837          BSR     EXECUTE 
000016C4  4E73                     838          RTE 
000016C6  B23C 0010                839  FOO16   CMP.B   #16,D1            D1 = 16 = Call RESTORE to transfer 
000016CA  6606                     840          BNE.S   FOO17            the registers in TSK_T to the 68000 
000016CC  6100 03A6                841          BSR     RESTORE           and therefore execute a program 
000016D0  4E73                     842          RTE 
000016D2  B23C 0011                843  FOO17   CMP.B   #17,D1            D1 = 17 = Call ADD_0
000016D6  6606                     844          BNE.S   FOO18            
000016D8  6100 FEC2                845          BSR     ADD_0            
000016DC  4E73                     846          RTE 
000016DE  B23C 0012                847  FOO18   CMP.B   #18,D1            D1 = 18 = Call SUB_0
000016E2  6606                     848          BNE.S   FOO19            
000016E4  6100 FEC4                849          BSR     SUB_0            
000016E8  4E73                     850          RTE 
000016EA  B23C 0013                851  FOO19   CMP.B   #19,D1            D1 = 19 = Call MUL_0
000016EE  6606                     852          BNE.S   FOO20            
000016F0  6100 FEC6                853          BSR     MUL_0            
000016F4  4E73                     854          RTE 
000016F6  B23C 0014                855  FOO20   CMP.B   #20,D1            D1 = 20 = Call DIV_0
000016FA  6606                     856          BNE.S   FOO21            
000016FC  6100 FEC8                857          BSR     DIV_0            
00001700  4E73                     858          RTE
00001702  B23C 0015                859  FOO21   CMP.B   #21,D1            D1 = 20 = Call GETLINE to get two digit input
00001706  6618                     860          BNE.S   FOO22
00001708  6100 F98E                861          BSR     GETLINE
0000170C  1219                     862          MOVE.B  (A1)+,D1          get first digit
0000170E  1611                     863          MOVE.B  (A1),D3           get second digit
00001710  0441 0030                864          subi    #48,d1            convert to number
00001714  0443 0030                865          subi    #48,d3            convert to number
00001718  C2FC 000A                866          MULU    #10,D1            Multiply first digit by 10
0000171C  D601                     867          ADD.B   D1,D3             add digits
0000171E  4E73                     868          RTE
00001720  B23C 0016                869  FOO22   CMP.B   #22,D1            D1 = 20 = Call DIV_0
00001724  660A                     870          BNE.S   FOO23            
00001726  6100 F94A                871          BSR     NEWLINE
0000172A  1003                     872          MOVE.B  D3,D0             loading answer to D0
0000172C  6100 FAE6                873          BSR     OUT2X             print D0
00001730  B23C 0017                874  FOO23   CMP.B   #23,D1            D1 = 20 = Call DIV_0
00001734  660A                     875          BNE.S   FOO24
00001736  6100 F93A                876          BSR     NEWLINE
0000173A  1003                     877          MOVE.B  D3,D0
0000173C  6100 FADE                878          BSR     OUT4X             print D0
00001740  4E73                     879  FOO24   RTE         
00001742                           880  * 
00001742                           881  ************************************************************************* 
00001742  =00001742                882  TRAP_14  EQU     *
00001742  6000 028C                883           BRA     BRKPT            User application breakpoint
00001746  4E73                     884           RTE
00001748                           885  *
00001748                           886  ************************************************************************* 
00001748  6000 F902                887  TRAP_15  BRA     WARM              
0000174C  4E73                     888           RTE
0000174E                           889  *
0000174E                           890  ************************************************************************* 
0000174E                           891  * 
0000174E                           892  *  Display exception frame (D0 - D7, A0 - A6, USP, SSP, SR, PC) 
0000174E                           893  *  EX_DIS prints registers saved after a breakpoint or exception 
0000174E                           894  *  The registers are saved in TSK_T 
0000174E                           895  * 
0000174E  4BEE 045A                896  EX_DIS  LEA.L   TSK_T(A6),A5      A5 points to display frame 
00001752  49FA 056C                897          LEA.L   MES3(PC),A4       Point to heading 
00001756  6100 F93A                898          BSR     HEADING           and print it 
0000175A  3C3C 0007                899          MOVE.W  #7,D6             8 pairs of registers to display 
0000175E  4205                     900          CLR.B   D5                D5 is the line counter 
00001760  1005                     901  EX_D1   MOVE.B  D5,D0             Put current register number in D0 
00001762  6100 FA96                902          BSR     OUT1X             and print it 
00001766  6100 FB2C                903          BSR     PSPACE            and a space 
0000176A  5205                     904          ADD.B   #1,D5             Update counter for next pair 
0000176C  2015                     905          MOVE.L  (A5),D0           Get data register to be displayed 
0000176E  6100 FAB4                906          BSR     OUT8X             from the frame and print it 
00001772  49FA 056A                907          LEA.L   MES4(PC),A4       Print string of spaces 
00001776  6100 F90A                908          BSR.L   PSTRING           between data and address registers 
0000177A  202D 0020                909          MOVE.L  32(A5),D0         Get address register to be displayed 
0000177E  6100 FAA4                910          BSR     OUT8X             which is 32 bytes on from data reg 
00001782  6100 F8EE                911          BSR     NEWLINE 
00001786  4BED 0004                912          LEA.L   4(A5),A5          Point to next pair (ie Di, Ai) 
0000178A  51CE FFD4                913          DBRA    D6,EX_D1          Repeat until all displayed 
0000178E  4BED 0020                914          LEA.L   32(A5),A5         Adjust pointer by 8 longwords 
00001792  6100 F8DE                915          BSR     NEWLINE           to point to SSP 
00001796  49FA 051F                916          LEA.L   MES2A(PC),A4      Point to "SS =" 
0000179A  6100 F8E6                917          BSR     PSTRING           Print it 
0000179E  201D                     918          MOVE.L  (A5)+,D0          Get SSP from frame 
000017A0  6100 FA82                919          BSR     OUT8X             and display it 
000017A4  6100 F8CC                920          BSR     NEWLINE 
000017A8  49FA 04FB                921          LEA.L   MES1(PC),A4       Point to 'SR =' 
000017AC  6100 F8D4                922          BSR     PSTRING           Print it 
000017B0  301D                     923          MOVE.W  (A5)+,D0          Get status register 
000017B2  6100 FA68                924          BSR     OUT4X             Display status 
000017B6  6100 F8BA                925          BSR     NEWLINE 
000017BA  49FA 04F2                926          LEA.L   MES2(PC),A4       Point to 'PC =' 
000017BE  6100 F8C2                927          BSR     PSTRING           Print it 
000017C2  201D                     928          MOVE.L  (A5)+,D0          Get PC 
000017C4  6100 FA5E                929          BSR     OUT8X             Display PC 
000017C8  6000 F8A8                930          BRA     NEWLINE           Newline and return 
000017CC                           931  * 
000017CC                           932  ************************************************************************* 
000017CC                           933  
000017CC  49F9 00001E05            934  HELP     LEA.L    JUMPHELP,A4     printing strings for command help
000017D2  6100 F8AE                935           BSR.W    PSTRING
000017D6  6100 F89A                936           BSR.W    NEWLINE
000017DA  49F9 00001E3B            937           LEA.L    MEMHELP,A4
000017E0  6100 F8A0                938           BSR.W    PSTRING
000017E4  6100 F88C                939           BSR.W    NEWLINE
000017E8  49F9 00001E88            940           LEA.L    LOADHELP,A4
000017EE  6100 F892                941           BSR.W    PSTRING
000017F2  6100 F87E                942           BSR.W    NEWLINE
000017F6  49F9 00001ED2            943           LEA.L    TVHELP,A4
000017FC  6100 F884                944           BSR.W    PSTRING
00001800  4E75                     945           RTS
00001802                           946  
00001802                           947  *      
00001802                           948  *************************************************************************
00001802  B83C 0002                949  LOGIN    CMP.B    #2,D4             check if the user has attempts left
00001806  6700 00C2                950           BEQ      QUIT              if three incorrect attempts lock out
0000180A  49F9 00001F3F            951           LEA.L    LOGINM1,A4        print message
00001810  6100 F870                952           BSR.W    PSTRING           
00001814  6100 F85C                953           BSR.W    NEWLINE
00001818  6100 F87E                954           BSR      GETLINE           get input
0000181C  49F9 00001F31            955           LEA.L    UNAME,A4          load correct username
00001822  1A19                     956  LOGIN1   MOVE.B   (A1)+,D5          move character to D5 and inc A5
00001824  BA1C                     957           CMP.B    (A4)+,D5          if character matches then continue
00001826  67FA                     958           BEQ      LOGIN1            iterate through checking each char
00001828  0C21 000D                959           CMP.B    #CR,-(A1)         check for carriage return
0000182C  6600 006A                960           BNE      WRONG             if not then wrong input
00001830  0C24 0000                961           CMP.B    #NUL,-(A4)        check for end of stored string
00001834  6600 0062                962           BNE      WRONG             if not then wrong input
00001838  49F9 00001F87            963           LEA.L    USRSUC,A4         print success
0000183E  6100 F842                964           BSR.W    PSTRING
00001842  6100 F82E                965           BSR.W    NEWLINE
00001846  49F9 00001F50            966           LEA.L    LOGINM2,A4
0000184C  6100 F834                967           BSR.W    PSTRING
00001850  6100 F820                968           BSR.W    NEWLINE
00001854  1C3C 0001                969           MOVE.B   #1,D6             flag to let output know to hide password
00001858  6100 F83E                970           BSR.W    GETLINE
0000185C  1C3C 0000                971           MOVE.B   #0,D6             stop hiding output
00001860  49F9 00001F36            972           LEA.L    PWORD,A4
00001866  1A19                     973  LOGIN2   MOVE.B   (A1)+,D5          compare password with correct password
00001868  BA1C                     974           CMP.B    (A4)+,D5
0000186A  67FA                     975           BEQ      LOGIN2            iterate through checking each char
0000186C  0C21 000D                976           CMP.B    #CR,-(A1)         check for carriage return
00001870  6600 0026                977           BNE      WRONG             if not then wrong input
00001874  0C24 0000                978           CMP.B    #NUL,-(A4)        check for end of stored string
00001878  6600 0032                979           BNE      WRONGPW           if not then wrong input
0000187C  49F9 00001FAB            980           LEA.L    PWSUC,A4
00001882  6000 F7FE                981           BRA      PSTRING
00001886  49F9 00001F3F            982           LEA.L    LOGINM1,A4
0000188C  6100 F7F4                983           BSR.W    PSTRING           print success
00001890  6100 F7E0                984           BSR.W    NEWLINE
00001894  6000 F7B6                985           BRA      WARM              jump to warm if correct
00001898                           986  
00001898  49F9 00001F61            987  WRONG    LEA.L    USRERR,A4         print message
0000189E  6100 F7E2                988           BSR.W    PSTRING
000018A2  6100 F7CE                989           BSR.W    NEWLINE
000018A6  5204                     990           ADD.B    #1,D4             inc attempts counter
000018A8  6000 FF58                991           BRA      LOGIN
000018AC                           992  
000018AC  49F9 00001F98            993  WRONGPW  LEA.L    PWERR,A4          print message
000018B2  6100 F7CE                994           BSR.W    PSTRING
000018B6  6100 F7BA                995           BSR.W    NEWLINE
000018BA  5204                     996           ADD.B    #1,D4             inc attempts counter
000018BC  6000 FF44                997           BRA      LOGIN
000018C0                           998  
000018C0  49F9 00001F87            999  UPASS    LEA.L    USRSUC,A4
000018C6  6000 F7BA               1000           BRA      PSTRING  
000018CA                          1001  
000018CA  4EF8 18CA               1002  QUIT     JMP      QUIT
000018CE                          1003  
000018CE                          1004  *
000018CE                          1005  ************************************************************************* 
000018CE  2878 07D4               1006  TV       MOVE.L   MIN_RAM,A4        starting at MIN_RAM
000018D2  1C3C 0000               1007           MOVE.B   #0,D6             error flag 
000018D6  323C 0000               1008  LOOPRAM  MOVE.W   #0,D1             
000018DA  3881                    1009           MOVE.W   D1,(A4)
000018DC  49EC 0002               1010           LEA.L    2(A4),A4          Point to next address to display
000018E0  B9F8 07D8               1011           CMP.L    MAX_RAM,A4        if not the end of ram, continue
000018E4  66F0                    1012           BNE      LOOPRAM
000018E6  2878 07D4               1013           MOVE.L   MIN_RAM,A4        resetting
000018EA  3214                    1014  CHECK1   MOVE.W   (A4),D1
000018EC  B27C 0000               1015           CMP.W    #0,D1             if mem is not zero there is an issue
000018F0  6600 0042               1016           BNE      MEMFAIL           
000018F4  49EC 0002               1017  CHECK2   LEA.L    2(A4),A4          Point to next address to read
000018F8  B9F8 07D8               1018           CMP.L    MAX_RAM,A4        if not the end of ram, continue
000018FC  66EC                    1019           BNE      CHECK1
000018FE  2878 07D4               1020           MOVE.L   MIN_RAM,A4
00001902  323C FFFF               1021  LOOPRAM1 MOVE.W   #65535,D1         loading all ram with 1's
00001906  3881                    1022           MOVE.W   D1,(A4)
00001908  49EC 0002               1023           LEA.L    2(A4),A4          Point to next address to display
0000190C  B9F8 07D8               1024           CMP.L    MAX_RAM,A4
00001910  66F0                    1025           BNE      LOOPRAM1
00001912  2878 07D4               1026           MOVE.L   MIN_RAM,A4
00001916  3214                    1027  CHECK3   MOVE.W   (A4),D1           move address to data reg
00001918  B27C FFFF               1028           CMP.W    #65535,D1         comparing all ram with 1's
0000191C  6600 0032               1029           BNE      MEMFAIL2          mem fail if not all 1's
00001920  49EC 0002               1030  CHECK4   LEA.L    2(A4),A4          Point to next address to read
00001924  B9F8 07D8               1031           CMP.L    MAX_RAM,A4        if not the end of ram, continue
00001928  66EC                    1032           BNE      CHECK3
0000192A  BC3C 0000               1033           CMP.B    #0,D6             not issue flag
0000192E  6700 003C               1034           BEQ      MEMGOOD           print if 0
00001932  4E75                    1035           RTS
00001934                          1036  
00001934  2F0C                    1037  MEMFAIL  MOVE.L  A4,-(A7)          Save A4 
00001936  7C01                    1038           MOVE.L  #1,D6             setting error flag
00001938  6100 F738               1039           BSR.W   NEWLINE
0000193C  49F9 00001FBC           1040           LEA.L   MEMFMSG,A4
00001942  6100 F73E               1041           BSR.W   PSTRING
00001946  285F                    1042           MOVE.L  (A7)+,A4          Restore A4
00001948  200C                    1043           MOVE.L  A4,D0             loading addres to D0
0000194A  6100 F8D8               1044           BSR.W    OUT8X            print contents of D0
0000194E  60A4                    1045           BRA     CHECK2
00001950                          1046  
00001950  2F0C                    1047  MEMFAIL2 MOVE.L  A4,-(A7)          Save A4 
00001952  7C01                    1048           MOVE.L  #1,D6             setting error flag
00001954  6100 F71C               1049           BSR.W   NEWLINE
00001958  49F9 00001FBC           1050           LEA.L   MEMFMSG,A4
0000195E  6100 F722               1051           BSR.W   PSTRING
00001962  285F                    1052           MOVE.L  (A7)+,A4          Restore A4
00001964  200C                    1053           MOVE.L  A4,D0             loading address to D0
00001966  6100 F8BC               1054           BSR.W    OUT8X            print D0
0000196A  60B4                    1055           BRA     CHECK4         
0000196C                          1056   
0000196C  49F9 00001FCC           1057  MEMGOOD  LEA.L  MEMGMSG,A4         memory has no errors
00001972  6100 F70E               1058           BSR.W  PSTRING
00001976  4E75                    1059           RTS
00001978                          1060  *************************************************************************
00001978                          1061  * 
00001978                          1062  *  Exception handling routines 
00001978                          1063  * 
00001978                          1064  *************************************************************************         
00001978                          1065  * 
00001978                          1066  *  Exception handling routines 
00001978                          1067  * 
00001978  =00001978               1068  IL_ER   EQU      *                Illegal instruction exception 
00001978  2F0C                    1069          MOVE.L  A4,-(A7)          Save A4 
0000197A  49FA 038C               1070          LEA.L   MES10(PC),A4      Point to heading 
0000197E  6100 F712               1071          BSR     HEADING           Print it 
00001982  285F                    1072          MOVE.L  (A7)+,A4          Restore A4 
00001984  6100 009C               1073          BSR.W   GROUP2            Save registers in display frame 
00001988  6100 FDC4               1074          BSR     EX_DIS            Display registers saved in frame 
0000198C  6000 F6BE               1075          BRA     WARM              Abort from illegal instruction 
00001990                          1076  * 
00001990  =00001990               1077  BUS_ER  EQU     *                 Bus error (group 1) exception 
00001990  2F0C                    1078          MOVE.L  A4,-(A7)          Save A4 
00001992  49FA 0354               1079          LEA.L   MES8(PC),A4       Point to heading 
00001996  6100 F6FA               1080          BSR     HEADING           Print it 
0000199A  285F                    1081          MOVE.L  (A7)+,A4          Restore A4  
0000199C  6050                    1082          BRA.S   GROUP1            Deal with group 1 exception 
0000199E                          1083  * 
0000199E  =0000199E               1084  ADD_ER  EQU     *                 Address error (group 1) exception 
0000199E  2F0C                    1085          MOVE.L  A4,-(A7)          Save A4 
000019A0  49FA 0354               1086          LEA.L   MES9(PC),A4       Point to heading 
000019A4  6100 F6EC               1087          BSR     HEADING           Print it 
000019A8  285F                    1088          MOVE.L  (A7)+,A4          Restore A4
000019AA  6042                    1089          BRA.S   GROUP1            Deal with group 1 exception 
000019AC                          1090  * 
000019AC  =000019AC               1091  DIV0_ER  EQU     *                   Divide By Zero Exception
000019AC  2F0C                    1092          MOVE.L  A4,-(A7)          Save A4 
000019AE  49FA 0385               1093          LEA.L   MES13(PC),A4       Point to heading 
000019B2  6100 F6DE               1094          BSR     HEADING           Print it 
000019B6  285F                    1095          MOVE.L  (A7)+,A4          Restore A4
000019B8  6034                    1096          BRA.S   GROUP1            Deal with group 1 exception 
000019BA                          1097  *
000019BA  =000019BA               1098  PRIV_ER   EQU     *                 Privilege Violation Exception
000019BA  2F0C                    1099          MOVE.L  A4,-(A7)          Save A4 
000019BC  49FA 038C               1100          LEA.L   MES14(PC),A4      Point to heading 
000019C0  6100 F6D0               1101          BSR     HEADING           Print it 
000019C4  285F                    1102          MOVE.L  (A7)+,A4          Restore A4
000019C6  6100 FD86               1103          BSR     EX_DIS
000019CA  6000 F680               1104          BRA     WARM
000019CE  601E                    1105          BRA.S   GROUP1            Deal with group 1 exception 
000019D0                          1106  * 
000019D0  =000019D0               1107  BRKPT   EQU     *                   Deal with breakpoint 
000019D0  48E7 FFFE               1108          MOVEM.L D0-D7/A0-A6,-(A7)   Save all registers 
000019D4  6100 0180               1109          BSR     BR_CLR              Clear breakpoints in code 
000019D8  4CDF 7FFF               1110          MOVEM.L (A7)+,D0-D7/A0-A6   Restore registers 
000019DC  6144                    1111          BSR.S   GROUP2            Treat as group 2 exception 
000019DE  49FA 033E               1112          LEA.L   MES11(PC),A4      Point to heading 
000019E2  6100 F6AE               1113          BSR     HEADING           Print it 
000019E6  6100 FD66               1114          BSR     EX_DIS            Display saved registers 
000019EA  6000 F660               1115          BRA     WARM              Return to monitor 
000019EE                          1116  * 
000019EE                          1117  *       GROUP1 is called by address and bus error exceptions 
000019EE                          1118  *       These are "turned into group 2" exceptions (eg TRAP) 
000019EE                          1119  *       by modifying the stack frame saved by a group 1 exception 
000019EE                          1120  * 
000019EE  48E7 8080               1121  GROUP1  MOVEM.L D0/A0,-(A7)       Save working registers 
000019F2  206F 0012               1122          MOVE.L  18(A7),A0         Get PC from group 1 stack frame 
000019F6  302F 000E               1123          MOVE.W  14(A7),D0         Get instruction from stack frame 
000019FA  B060                    1124          CMP.W   -(A0),D0          Now backtrack to find the "correct PC" 
000019FC  670E                    1125          BEQ.S   GROUP1A           by matching the op-code on the stack 
000019FE  B060                    1126          CMP.W   -(A0),D0          with the code in the region of the 
00001A00  670A                    1127          BEQ.S   GROUP1A           PC on the stack 
00001A02  B060                    1128          CMP.W   -(A0),D0 
00001A04  6706                    1129          BEQ.S   GROUP1A 
00001A06  B060                    1130          CMP.W   -(A0),D0 
00001A08  6702                    1131          BEQ.S   GROUP1A 
00001A0A  5588                    1132          SUBQ.L  #2,A0 
00001A0C  2F48 0012               1133  GROUP1A MOVE.L  A0,18(A7)          Restore modified PC to stack frame 
00001A10  4CDF 0101               1134          MOVEM.L (A7)+,D0/A0        Restore working registers 
00001A14  4FEF 0008               1135          LEA.L   8(A7),A7           Adjust stack pointer to group 1 type 
00001A18  6108                    1136          BSR.S   GROUP2             Now treat as group 1 exception 
00001A1A  6100 FD32               1137          BSR     EX_DIS             Display contents of exception frame 
00001A1E  6000 F62C               1138          BRA     WARM               Exit to monitor - no RTE from group 2 
00001A22                          1139  * 
00001A22  =00001A22               1140  GROUP2  EQU     *                 Deal with group 2 exceptions 
00001A22  48E7 FFFF               1141          MOVEM.L A0-A7/D0-D7,-(A7) Save all registers on the stack 
00001A26  303C 000E               1142          MOVE.W  #14,D0            Transfer D0 - D7, A0 - A6 from 
00001A2A  41EE 045A               1143          LEA.L   TSK_T(A6),A0      the stack to the display frame 
00001A2E  20DF                    1144  GROUP2A MOVE.L  (A7)+,(A0)+       Move a register from stack to frame 
00001A30  51C8 FFFC               1145          DBRA    D0,GROUP2A        and repeat until D0-D7/A0-A6 moved 
00001A34  4E6A                    1146          MOVE.L  USP,A2            Get the user stack pointer and put it 
00001A36  20CA                    1147          MOVE.L  A2,(A0)+          in the A7 position in the frame 
00001A38  201F                    1148          MOVE.L  (A7)+,D0          Now transfer the SSP to the frame, 
00001A3A  0480 0000000A           1149          SUB.L   #10,D0            remembering to account for the 
00001A40  20C0                    1150          MOVE.L  D0,(A0)+          data pushed on the stack to this point 
00001A42  225F                    1151          MOVE.L  (A7)+,A1          Copy TOS (return address) to A1 
00001A44  30DF                    1152          MOVE.W  (A7)+,(A0)+       Move SR to display frame 
00001A46  201F                    1153          MOVE.L  (A7)+,D0          Get PC in D0 
00001A48  5580                    1154          SUBQ.L  #2,D0             Move back to current instruction 
00001A4A  20C0                    1155          MOVE.L  D0,(A0)+          Put adjusted PC in display frame 
00001A4C  4ED1                    1156          JMP     (A1)              Return from subroutine 
00001A4E                          1157  * 
00001A4E                          1158  ************************************************************************* 
00001A4E                          1159  * 
00001A4E                          1160  *  GO executes a program either from a supplied address or 
00001A4E                          1161  *  by using the data in the display frame 
00001A4E  6100 F766               1162  GO       BSR     PARAM               Get entry address (if any) 
00001A52  4A07                    1163           TST.B   D7                  Test for error in input 
00001A54  6708                    1164           BEQ.S   GO1                 If D7 zero then OK 
00001A56  49FA 032B               1165           LEA.L   ERMES1(PC),A4       Else point to error message, 
00001A5A  6000 F626               1166           BRA     PSTRING             print it and return 
00001A5E  4A80                    1167  GO1      TST.L   D0                  If no address entered then get 
00001A60  670A                    1168           BEQ.S   GO2                 address from display frame 
00001A62  2D40 04A0               1169           MOVE.L  D0,TSK_T+70(A6)     Else save address in display frame 
00001A66  3D7C 0700 049E          1170           MOVE.W  #$0700,TSK_T+68(A6) Store dummy status in frame 
00001A6C  6006                    1171  GO2      BRA.S   RESTORE             Restore volatile environment and go 
00001A6E                          1172  * 
00001A6E  6100 007A               1173  GB       BSR     BR_SET              Same as go but presets breakpoints 
00001A72  60DA                    1174           BRA.S   GO                  Execute program 
00001A74                          1175  * 
00001A74                          1176  *        RESTORE moves the volatile environment from the display 
00001A74                          1177  *        frame and transfers it to the 68000's registers. This 
00001A74                          1178  *        re-runs a program suspended after an exception 
00001A74                          1179  * 
00001A74  47EE 045A               1180  RESTORE  LEA.L   TSK_T(A6),A3        A3 points to display frame 
00001A78  47EB 004A               1181           LEA.L   74(A3),A3           A3 now points to end of frame + 4 
00001A7C  4FEF 0004               1182           LEA.L   4(A7),A7            Remove return address from stack 
00001A80  303C 0024               1183           MOVE.W  #36,D0              Counter for 37 words to be moved 
00001A84  3F23                    1184  REST1    MOVE.W  -(A3),-(A7)         Move word from display frame to stack 
00001A86  51C8 FFFC               1185           DBRA    D0,REST1            Repeat until entire frame moved 
00001A8A  4CDF 00FF               1186           MOVEM.L (A7)+,D0-D7         Restore old data registers from stack 
00001A8E  4CDF 7F00               1187           MOVEM.L (A7)+,A0-A6         Restore old address registers 
00001A92  4FEF 0008               1188           LEA.L   8(A7),A7            Except SSP/USP - so adjust stack 
00001A96  4E73                    1189           RTE                         Return from exception to run program 
00001A98                          1190  * 
00001A98  =00001A98               1191  TRACE    EQU     *                   TRACE exception (rudimentary version) 
00001A98  287A 0292               1192           MOVE.L  MES12(PC),A4        Point to heading 
00001A9C  6100 F5F4               1193           BSR     HEADING             Print it 
00001AA0  6100 FF4C               1194           BSR     GROUP1              Save volatile environment 
00001AA4  6100 FCA8               1195           BSR     EX_DIS              Display it 
00001AA8  6000 F5A2               1196           BRA     WARM                Return to monitor 
00001AAC                          1197  * 
00001AAC                          1198  ************************************************************************* 
00001AAC                          1199  *  Breakpoint routines: BR_GET gets the address of a breakpoint and 
00001AAC                          1200  *  puts it in the breakpoint table. It does not plant it in the code. 
00001AAC                          1201  *  BR_SET plants all breakpoints in the code. NOBR removes one or all 
00001AAC                          1202  *  breakpoints from the table. KILL removes breakpoints from the code. 
00001AAC                          1203  * 
00001AAC  6100 F708               1204  BR_GET   BSR     PARAM               Get breakpoint address in table 
00001AB0  4A07                    1205           TST.B   D7                  Test for input error 
00001AB2  6708                    1206           BEQ.S   BR_GET1             If no error then continue 
00001AB4  49FA 02CD               1207           LEA.L   ERMES1(PC),A4       Else display error 
00001AB8  6000 F5C8               1208           BRA     PSTRING             and return 
00001ABC  47EE 04A4               1209  BR_GET1  LEA.L   BP_TAB(A6),A3       A6 points to breakpoint table 
00001AC0  2A40                    1210           MOVE.L  D0,A5               Save new BP address in A5 
00001AC2  2C00                    1211           MOVE.L  D0,D6               and in D6 because D0 gets corrupted 
00001AC4  3A3C 0007               1212           MOVE.W  #7,D5               Eight entries to test 
00001AC8  201B                    1213  BR_GET2  MOVE.L  (A3)+,D0            Read entry from breakpoint table 
00001ACA  660C                    1214           BNE.S   BR_GET3             If not zero display existing BP 
00001ACC  4A86                    1215           TST.L   D6                  Only store a non-zero breakpoint 
00001ACE  6710                    1216           BEQ.S   BR_GET4 
00001AD0  274D FFFC               1217           MOVE.L  A5,-4(A3)           Store new breakpoint in table 
00001AD4  3695                    1218           MOVE.W  (A5),(A3)           Save code at BP address in table 
00001AD6  4286                    1219           CLR.L   D6                  Clear D6 to avoid repetition 
00001AD8  6100 F74A               1220  BR_GET3  BSR     OUT8X               Display this breakpoint 
00001ADC  6100 F594               1221           BSR     NEWLINE 
00001AE0  47EB 0002               1222  BR_GET4  LEA.L   2(A3),A3            Step past stored op-code 
00001AE4  51CD FFE2               1223           DBRA    D5,BR_GET2          Repeat until all entries tested 
00001AE8  4E75                    1224           RTS                         Return 
00001AEA                          1225  * 
00001AEA  =00001AEA               1226  BR_SET   EQU     *                   Plant any breakpoints in user code 
00001AEA  41EE 04A4               1227           LEA.L   BP_TAB(A6),A0       A0 points to BP table 
00001AEE  45EE 04A0               1228           LEA.L   TSK_T+70(A6),A2     A2 points to PC in display frame 
00001AF2  2452                    1229           MOVE.L  (A2),A2             Now A2 contains value of PC 
00001AF4  303C 0007               1230           MOVE.W  #7,D0               Up to eight entries to plant 
00001AF8  2218                    1231  BR_SET1  MOVE.L  (A0)+,D1            Read breakpoint address from table 
00001AFA  670A                    1232           BEQ.S   BR_SET2             If zero then skip planting 
00001AFC  B28A                    1233           CMP.L   A2,D1               Don't want to plant BP at current PC 
00001AFE  6706                    1234           BEQ.S   BR_SET2             location, so skip planting if same 
00001B00  2241                    1235           MOVE.L  D1,A1               Transfer BP address to address reg 
00001B02  32BC 4E4E               1236           MOVE.W  #TRAP_16,(A1)       Plant op-code for TRAP #14 in code 
00001B06  41E8 0002               1237  BR_SET2  LEA.L   2(A0),A0            Skip past op-code field in table 
00001B0A  51C8 FFEC               1238           DBRA    D0,BR_SET1          Repeat until all entries tested 
00001B0E  4E75                    1239           RTS 
00001B10                          1240  * 
00001B10  =00001B10               1241  NOBR     EQU     *                   Clear one or all breakpoints 
00001B10  6100 F6A4               1242           BSR     PARAM               Get BP address (if any) 
00001B14  4A07                    1243           TST.B   D7                  Test for input error 
00001B16  6708                    1244           BEQ.S   NOBR1               If no error then skip abort 
00001B18  49FA 0269               1245           LEA.L   ERMES1(PC),A4       Point to error message 
00001B1C  6000 F564               1246           BRA     PSTRING             Display it and return 
00001B20  4A80                    1247  NOBR1    TST.L   D0                  Test for null address (clear all) 
00001B22  6720                    1248           BEQ.S   NOBR4               If no address then clear all entries 
00001B24  2240                    1249           MOVE.L  D0,A1               Else just clear breakpoint in A1 
00001B26  41EE 04A4               1250           LEA.L   BP_TAB(A6),A0       A0 points to BP table 
00001B2A  303C 0007               1251           MOVE.W  #7,D0               Up to eight entries to test 
00001B2E  2218                    1252  NOBR2    MOVE.L  (A0)+,D1            Get entry and 
00001B30  41E8 0002               1253           LEA.L   2(A0),A0            skip past op-code field 
00001B34  B289                    1254           CMP.L   A1,D1               Is this the one? 
00001B36  6706                    1255           BEQ.S   NOBR3               If so go and clear entry 
00001B38  51C8 FFF4               1256           DBRA    D0,NOBR2            Repeat until all tested 
00001B3C  4E75                    1257           RTS 
00001B3E  42A8 FFFA               1258  NOBR3    CLR.L   -6(A0)              Clear address in BP table 
00001B42  4E75                    1259           RTS 
00001B44  41EE 04A4               1260  NOBR4    LEA.L   BP_TAB(A6),A0       Clear all 8 entries in BP table 
00001B48  303C 0007               1261           MOVE.W  #7,D0               Eight entries to clear 
00001B4C  4298                    1262  NOBR5    CLR.L   (A0)+               Clear breakpoint address 
00001B4E  4258                    1263           CLR.W   (A0)+               Clear op-code field 
00001B50  51C8 FFFA               1264           DBRA    D0,NOBR5            Repeat until all done 
00001B54  4E75                    1265           RTS 
00001B56                          1266  * 
00001B56  =00001B56               1267  BR_CLR   EQU     *                   Remove breakpoints from code 
00001B56  41EE 04A4               1268           LEA.L   BP_TAB(A6),A0       A0 points to breakpoint table 
00001B5A  303C 0007               1269           MOVE.W  #7,D0               Up to eight entries to clear 
00001B5E  2218                    1270  BR_CLR1  MOVE.L  (A0)+,D1            Get address of BP in D1 
00001B60  2241                    1271           MOVE.L  D1,A1               and put copy in A1 
00001B62  4A81                    1272           TST.L   D1                  Test this breakpoint 
00001B64  6702                    1273           BEQ.S   BR_CLR2             If zero then skip BP clearing 
00001B66  3290                    1274           MOVE.W  (A0),(A1)           Else restore op-code 
00001B68  41E8 0002               1275  BR_CLR2  LEA.L   2(A0),A0            Skip past op-code field 
00001B6C  51C8 FFF0               1276           DBRA    D0,BR_CLR1          Repeat until all tested 
00001B70  4E75                    1277           RTS 
00001B72                          1278  * 
00001B72                          1279  *  REG_MOD modifies a register in the display frame. The command 
00001B72                          1280  *  format is REG <reg> <value>. E.g. REG D3 1200 
00001B72                          1281  * 
00001B72  4281                    1282  REG_MOD  CLR.L   D1                  D1 to hold name of register 
00001B74  41EE 0444               1283           LEA.L   BUFFPT(A6),A0       A0 contains address of buffer pointer 
00001B78  2050                    1284           MOVE.L  (A0),A0             A0 now points to next char in buffer 
00001B7A  1218                    1285           MOVE.B  (A0)+,D1            Put first char of name in D1 
00001B7C  E159                    1286           ROL.W   #8,D1               Move char one place left 
00001B7E  1218                    1287           MOVE.B  (A0)+,D1            Get second char in D1 
00001B80  41E8 0001               1288           LEA.L   1(A0),A0            Move pointer past space in buffer 
00001B84  2D48 0444               1289           MOVE.L  A0,BUFFPT(A6)       Update buffer pointer 
00001B88  4282                    1290           CLR.L   D2                  D2 is the character pair counter 
00001B8A  41FA 01CE               1291           LEA.L   REGNAME(PC),A0      A0 points to string of character pairs 
00001B8E  43D0                    1292           LEA.L   (A0),A1             A1 also points to string 
00001B90  B258                    1293  REG_MD1  CMP.W   (A0)+,D1            Compare a char pair with input 
00001B92  6712                    1294           BEQ.S   REG_MD2             If match then exit loop 
00001B94  5282                    1295           ADD.L   #1,D2               Else increment match counter 
00001B96  B4BC 00000013           1296           CMP.L   #19,D2              Test for end of loop 
00001B9C  66F2                    1297           BNE     REG_MD1             Continue until all pairs matched 
00001B9E  49FA 01E3               1298           LEA.L   ERMES1(PC),A4       If here then error 
00001BA2  6000 F4DE               1299           BRA     PSTRING             Display error and return 
00001BA6  43EE 045A               1300  REG_MD2  LEA.L   TSK_T(A6),A1        A1 points to display frame 
00001BAA  E582                    1301           ASL.L   #2,D2               Multiply offset by 4 (4 bytes/entry) 
00001BAC  B4BC 00000048           1302           CMP.L   #72,D2              Test for address of PC 
00001BB2  6602                    1303           BNE.S   REG_MD3             If not PC then all is OK 
00001BB4  5582                    1304           SUB.L   #2,D2               else dec PC pointer as Sr is a word 
00001BB6  45F1 2000               1305  REG_MD3  LEA.L   (A1,D2),A2          Calculate address of entry in disptable 
00001BBA  2012                    1306           MOVE.L  (A2),D0             Get old contents 
00001BBC  6100 F666               1307           BSR     OUT8X               Display them 
00001BC0  6100 F4B0               1308           BSR     NEWLINE 
00001BC4  6100 F5F0               1309           BSR     PARAM               Get new data 
00001BC8  4A07                    1310           TST.B   D7                  Test for input error 
00001BCA  6708                    1311           BEQ.S   REG_MD4             If no error then go and store data 
00001BCC  49FA 01B5               1312           LEA.L   ERMES1(PC),A4       Else point to error message 
00001BD0  6000 F4B0               1313           BRA     PSTRING             print it and return 
00001BD4  B4BC 00000044           1314  REG_MD4  CMP.L   #68,D2              If this address is the SR then 
00001BDA  6704                    1315           BEQ.S   REG_MD5             we have only a word to store 
00001BDC  2480                    1316           MOVE.L  D0,(A2)             Else store new data in display frame 
00001BDE  4E75                    1317           RTS 
00001BE0  3480                    1318  REG_MD5  MOVE.W  D0,(A2)             Store SR (one word) 
00001BE2  4E75                    1319           RTS 
00001BE4                          1320  * 
00001BE4                          1321  ************************************************************************* 
00001BE4                          1322  * 
00001BE4  =00001BE4               1323  X_UN    EQU     *                 Uninitialized exception vector routine 
00001BE4  49FA 0205               1324          LEA.L   ERMES6(PC),A4     Point to error message 
00001BE8  6100 F498               1325          BSR     PSTRING           Display it 
00001BEC  6100 FB60               1326          BSR     EX_DIS            Display registers 
00001BF0  6000 F45A               1327          BRA     WARM              Abort 
00001BF4                          1328  * 
00001BF4                          1329  ************************************************************************* 
00001BF4                          1330  * 
00001BF4                          1331  *  All strings and other fixed parameters here 
00001BF4                          1332  * 
00001BF4= 54 53 42 55 47 20 ...   1333  BANNER   DC.B     'TSBUG 2 Version 23.07.86',0,0
00001C0E= 4D 6F 64 69 66 69 ...   1334  MODIFY    DC.B   'Modified by Eugene A. Rockey Jr. Jan.05.2010',0,0
00001C3C= 66 6F 72 20 75 73 ...   1335  WHY      DC.B     'for use with the M68000 Minimal Computer Configuration',0,0 
00001C74= 55 6E 69 76 65 72 ...   1336  WHERE    DC.B     'University of Louisville',0,0
00001C8E= 0D 0A 54 53 32 4D ...   1337  CRLF     DC.B     CR,LF,'TS2MON >',0 
00001C99= 0D 0A 53 31 00 00       1338  HEADER   DC.B     CR,LF,'S','1',0,0 
00001C9F= 53 39 20 20 00 00       1339  TAIL     DC.B     'S9  ',0,0 
00001CA5= 20 53 52 20 20 3D ...   1340  MES1     DC.B     ' SR  =  ',0 
00001CAE= 20 50 43 20 20 3D ...   1341  MES2     DC.B     ' PC  =  ',0 
00001CB7= 20 53 53 20 20 3D ...   1342  MES2A    DC.B     ' SS  =  ',0 
00001CC0= 20 20 44 61 74 61 ...   1343  MES3     DC.B     '  Data reg       Address reg',0,0 
00001CDE= 20 20 20 20 20 20 ...   1344  MES4     DC.B     '        ',0,0 
00001CE8= 42 75 73 20 65 72 ...   1345  MES8     DC.B     'Bus error   ',0,0 
00001CF6= 41 64 64 72 65 73 ...   1346  MES9     DC.B     'Address error   ',0,0 
00001D08= 49 6C 6C 65 67 61 ...   1347  MES10    DC.B     'Illegal instruction ',0,0 
00001D1E= 42 72 65 61 6B 70 ...   1348  MES11    DC.B     'Breakpoint  ',0,0 
00001D2C= 54 72 61 63 65 20 ...   1349  MES12    DC.B     'Trace   ',0 
00001D35= 44 69 76 69 64 65 ...   1350  MES13    DC.B     'Divide by zero error', 0
00001D4A= 50 72 69 76 69 6C ...   1351  MES14    DC.B     'Privilege error', 0
00001D5A= 44 30 44 31 44 32 ...   1352  REGNAME  DC.B     'D0D1D2D3D4D5D6D7' 
00001D6A= 41 30 41 31 41 32 ...   1353           DC.B     'A0A1A2A3A4A5A6A7' 
00001D7A= 53 53 53 52             1354           DC.B     'SSSR' 
00001D7E= 50 43 20 20 00          1355           DC.B     'PC  ',0 
00001D83= 4E 6F 6E 2D 76 61 ...   1356  ERMES1   DC.B     'Non-valid hexadecimal input  ',0 
00001DA1= 44 6F 77 6E 6C 6F ...   1357  ERMES2   DC.B     'Download Complete  ',0 
00001DB5= 4C 6F 61 64 69 6E ...   1358  ERMES3   DC.B     'Loading error',0 
00001DC3= 54 61 62 6C 65 20 ...   1359  ERMES4   DC.B     'Table full  ',0,0 
00001DD1= 42 72 65 61 6B 70 ...   1360  ERMES5   DC.B     'Breakpoint not active   ',0,0 
00001DEB= 55 6E 69 6E 69 74 ...   1361  ERMES6   DC.B     'Uninitialized exception ',0,0 
00001E05= 4A 55 4D 50 20 3C ...   1362  JUMPHELP DC.B     'JUMP <address> causes execution to begin at <address>',0   
00001E3B= 4D 45 4D 4F 52 59 ...   1363  MEMHELP  DC.B     'MEMORY <address> examines contents of address> and allows them to be changed', 0   
00001E88= 4C 4F 41 44 20 3C ...   1364  LOADHELP DC.B     'LOAD <string> loads S1/S2 records from the host. <string> is sent to host', 0
00001ED2= 54 56 20 63 68 65 ...   1365  TVHELP   DC.B     'TV checks all RAM addresses from $4000 to $40FE. Reports corrupt memory addresses', 0
00001F24= 20 52 61 6E 67 65 ...   1366  ERMES7   DC.B     ' Range error',0
00001F31= 55 53 45 52 00          1367  UNAME    DC.B     'USER', 0
00001F36= 50 41 53 53 57 4F ...   1368  PWORD    DC.B     'PASSWORD',0
00001F3F= 45 6E 74 65 72 20 ...   1369  LOGINM1  DC.B     'Enter username: ', 0
00001F50= 45 6E 74 65 72 20 ...   1370  LOGINM2  DC.B     'Enter password: ', 0
00001F61= 49 6E 63 6F 72 72 ...   1371  USRERR   DC.B     'Incorrect username', 0
00001F74= 49 6E 63 6F 72 72 ...   1372  PSRERR   DC.B     'Incorrect password', 0
00001F87= 43 6F 72 72 65 63 ...   1373  USRSUC   DC.B     'Correct Username', 0
00001F98= 49 6E 63 6F 72 72 ...   1374  PWERR   DC.B     'Incorrect password', 0
00001FAB= 43 6F 72 72 65 63 ...   1375  PWSUC    DC.B     'Correct Password', 0
00001FBC= 4D 45 4D 4F 52 59 ...   1376  MEMFMSG  DC.B     'MEMORY BAD AT: ',0
00001FCC= 41 4C 4C 20 52 41 ...   1377  MEMGMSG  DC.B      'ALL RAM GOOD', 0
00001FD9                          1378  * 
00001FD9                          1379  *  COMTAB is the built-in command table. All entries are made up of 
00001FD9                          1380  *         a string length + number of characters to match + the string 
00001FD9                          1381  *         plus the address of the command relative to COMTAB 
00001FD9                          1382  * 
00002000                          1383           ORG      $2000
00002000= 04 04                   1384  COMTAB   DC.B     4,4              JUMP <address> causes execution to 
00002002= 4A 55 4D 50             1385           DC.B     'JUMP'           begin at <address> 
00002006= FFFFF22C                1386           DC.L     JUMP-COMTAB                                           
0000200A= 08 03                   1387           DC.B     8,3              MEMORY <address> examines contents of 
0000200C= 4D 45 4D 4F 52 59 ...   1388           DC.B     'MEMORY  '       <address> and allows them to be changed 
00002014= FFFFF242                1389           DC.L     MEMORY-COMTAB 
00002018= 04 02                   1390           DC.B     4,2              LOAD <string> loads S1/S2 records 
0000201A= 4C 4F 41 44             1391           DC.B     'LOAD'           from the host. <string> is sent to host 
0000201E= FFFFF2A2                1392           DC.L     LOAD-COMTAB 
00002022= 04 02                   1393           DC.B    4,2               GO <address> starts program execution 
00002024= 47 4F 20 20             1394           DC.B    'GO  '            at <address> and loads regs from TSK_T 
00002028= FFFFFA4E                1395           DC.L    GO-COMTAB 
0000202C= 04 04                   1396           DC.B    4,4               HELP 
0000202E= 48 45 4C 50             1397           DC.B    'HELP'            
00002032= FFFFF7CC                1398           DC.L    HELP-COMTAB      
00002036= 02 02                   1399           DC.B    2,2
00002038= 54 56                   1400           DC.B    'TV'
0000203A= FFFFF8CE                1401           DC.L    TV-COMTAB
0000203E= 00 00                   1402           DC.B    0,0 
00002040                          1403  * 
00002040                          1404  ************************************************************************* 
00002040                          1405  ** 
00002040                          1406  *  This is a list of the information needed to setup the DCBs 
00002040                          1407  * 
00002040  =00002040               1408  DCB_LST  EQU     * 
00002040= 43 4F 4E 5F 49 4E ...   1409  DCB1     DC.B    'CON_IN  '          Device name (8 bytes) 
00002048= 00001476 00008001       1410           DC.L    CON_IN,ACIA_1       Address of driver routine, device 
00002050= 0002                    1411           DC.W    2                   Number of words in parameter field 
00002052= 43 4F 4E 5F 4F 55 ...   1412  DCB2     DC.B    'CON_OUT ' 
0000205A= 000014A6 00008001       1413           DC.L    CON_OUT,ACIA_1 
00002062= 0002                    1414           DC.W    2 
00002064                          1415  
00002064                          1416  ************************************************************************* 
00002064                          1417  * 
00002064                          1418  *  DCB structure 
00002064                          1419  * 
00002064                          1420  *              ----------------------- 
00002064                          1421  *       0 ->   | DCB  name           | 
00002064                          1422  *              |---------------------| 
00002064                          1423  *       8 ->   | Device driver       | 
00002064                          1424  *              |---------------------| 
00002064                          1425  *      12 ->   | Device address      | 
00002064                          1426  *              |---------------------| 
00002064                          1427  *      16 ->   |Size of param block  | 
00002064                          1428  *              |---------------------| --- 
00002064                          1429  *      18 ->   |      Status         |   | 
00002064                          1430  *              | logical  | physical |   | S 
00002064                          1431  *              |---------------------|   | 
00002064                          1432  *              .                     .   . 
00002064                          1433  *              |---------------------| --- 
00002064                          1434  *    18+S ->   | Pointer to next DCB | 
00002064                          1435  * 
00002064                          1436           END RESET 

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ACIA_1              8001
ACIA_2              8001
ADD_0               159C
ADD_ER              199E
ADR_DAT             1280
BANNER              1BF4
BP_TAB              4A4
BRKPT               19D0
BR_CLR              1B56
BR_CLR1             1B5E
BR_CLR2             1B68
BR_GET              1AAC
BR_GET1             1ABC
BR_GET2             1AC8
BR_GET3             1AD8
BR_GET4             1AE0
BR_SET              1AEA
BR_SET1             1AF8
BR_SET2             1B06
BS                  8
BUFFEND             443
BUFFER              6D4
BUFFPT              444
BUS_ER              1990
BYTE                119A
B_CLR               1592
CHECK1              18EA
CHECK2              18F4
CHECK3              1916
CHECK4              1920
CN_IVEC             452
CN_OVEC             456
COMTAB              2000
CON_I1              1484
CON_I2              149C
CON_IN              1476
CON_OT1             14B4
CON_OT2             14CA
CON_OT3             14D2
CON_OUT             14A6
CR                  D
CRLF                1C8E
CTRL_A              1
DATA                4800
DCB1                2040
DCB2                2052
DCB_LST             2040
DELAY               1406
DELAY1              1410
DIV0_ER             19AC
DIVNEG              15E0
DIV_0               15C6
DUMP                1366
DUMP1               1376
DUMP2               1382
DUMP3               1390
DUMP4               13A4
DUMP5               13B2
DUMP6               13CC
DUMP7               13F0
ECHO                44C
ERMES1              1D83
ERMES2              1DA1
ERMES3              1DB5
ERMES4              1DC3
ERMES5              1DD1
ERMES6              1DEB
ERMES7              1F24
ESC                 1B
EXEC1               1122
EXEC2               1132
EXECUTE             1110
EX_D1               1760
EX_DIS              174E
FIRST               4D4
FOO1                1612
FOO10               167E
FOO11               168A
FOO12               1696
FOO13               16A2
FOO14               16AE
FOO15               16BA
FOO16               16C6
FOO17               16D2
FOO18               16DE
FOO19               16EA
FOO2                161E
FOO20               16F6
FOO21               1702
FOO22               1720
FOO23               1730
FOO24               1740
FOO3                162A
FOO4                1636
FOO5                1642
FOO6                164E
FOO7                165A
FOO8                1666
FOO9                1672
GB                  1A6E
GETCH2              150C
GETCH3              151C
GETCHAR             14E6
GETLINE             1098
GETLN2              10A2
GETLN3              10BC
GETLN4              10C6
GETLN5              10CA
GO                  1A4E
GO1                 1A5E
GO2                 1A6C
GROUP1              19EE
GROUP1A             1A0C
GROUP2              1A22
GROUP2A             1A2E
HEADER              1C99
HEADING             1092
HELP                17CC
HEX                 117C
HEX_OK              1198
IL_ER               1978
IO_OPEN             1558
IO_REQ              1464
JUMP                122C
JUMP1               123A
JUMPHELP            1E05
LF                  A
LNBUFF              404
LOAD                12A2
LOAD1               12BE
LOAD2               12CE
LOAD3               12E8
LOAD4               1302
LOAD5               1310
LOAD6               1312
LOAD6A              1336
LOAD7               1348
LOAD8               135E
LOADHELP            1E88
LOGIN               1802
LOGIN1              1822
LOGIN2              1866
LOGINM1             1F3F
LOGINM2             1F50
LONGWD              11B0
LOOPRAM             18D6
LOOPRAM1            1902
MAXCHR              40
MAX_RAM             7D8
MEM1                124C
MEM2                126A
MEM3                127E
MEMFAIL             1934
MEMFAIL2            1950
MEMFMSG             1FBC
MEMGMSG             1FCC
MEMGOOD             196C
MEMHELP             1E3B
MEMORY              1242
MES1                1CA5
MES10               1D08
MES11               1D1E
MES12               1D2C
MES13               1D35
MES14               1D4A
MES2                1CAE
MES2A               1CB7
MES3                1CC0
MES4                1CDE
MES8                1CE8
MES9                1CF6
MIN_RAM             7D4
MODIFY              1C0E
MULNEG              15F6
MUL_0               15B8
NEWLINE             1072
NOBR                1B10
NOBR1               1B20
NOBR2               1B2E
NOBR3               1B3E
NOBR4               1B44
NOBR5               1B4C
NOT_HEX             1194
NO_EXT              1040
NUL                 0
OPEN1               1560
OPEN2               1568
OPEN3               1576
OPEN4               158C
OUT1X               11FA
OUT1X1              120C
OUT2X               1214
OUT4X               121C
OUT8X               1224
PARAM               11B6
PARAM1              11BE
PARAM3              11E2
PARAM4              11E6
PARAM5              11F2
PARAM6              11F6
PARAMTR             448
PRIV_ER             19BA
PS1                 1084
PS2                 108E
PSPACE              1294
PSRERR              1F74
PSTRING             1082
PUTASK              1520
PUTCHAR             1532
PWERR               1F98
PWORD               1F36
PWSUC               1FAB
QUIT                18CA
RANGE               13F6
REGNAME             1D5A
REG_MD1             1B90
REG_MD2             1BA6
REG_MD3             1BB6
REG_MD4             1BD4
REG_MD5             1BE0
REG_MOD             1B72
RESET               1000
REST1               1A84
RESTORE             1A74
SEARCH              113C
SETACIA             105C
SETNEG              15E6
SET_DCB             141A
SPACE               20
SPUTCHAR            1546
SRCH2               1156
SRCH3               115A
SRCH4               1162
SRCH6               116C
SRCH7               1176
STACK               4400
ST_DCB1             142A
ST_DCB2             142E
SUB_0               15AA
TAIL                1C9F
TIDY                10CE
TIDY1               10D4
TIDY2               10E0
TIDY3               10EA
TIDY4               10F4
TIDY5               10FE
TIDY6               110A
TRACE               1A98
TRAP_0              1606
TRAP_14             1742
TRAP_15             1748
TRAP_16             4E4E
TSK_T               45A
TV                  18CE
TVHELP              1ED2
UNAME               1F31
UPASS               18C0
USRERR              1F61
USRSUC              1F87
UTAB                44E
U_CASE              44D
WAIT                57
WARM                104C
WHERE               1C74
WHY                 1C3C
WORD                11AA
WRONG               1898
WRONGPW             18AC
X_UN                1BE4
