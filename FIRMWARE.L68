00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.15.04
Created On: 9/25/15 1:20:31 AM

00000000                             1  *        TSBUG2 - 68000 monitor - version of 05 January 2010 
00000000                             2  
00000000                             3       ORG      $0
00000000= 00004400 00001000          4           DC.L     STACK,RESET
00000008                             5  *                                   Symbol equates 
00000008  =00000008                  6  BS       EQU      $08               Back_space 
00000008  =0000000D                  7  CR       EQU      $0D               Carriage_return 
00000008  =00000000                  8  NUL      EQU      $00               NUL character
00000008  =0000000A                  9  LF       EQU      $0A               Line_feed 
00000008  =00000020                 10  SPACE    EQU      $20               Space 
00000008  =00000057                 11  WAIT     EQU      'W'               Wait character (to suspend output) 
00000008  =0000001B                 12  ESC      EQU      $1B               ASCII escape character (used by TM) 
00000008  =00000001                 13  CTRL_A   EQU      $01               Control_A forces return to monitor 
00000008                            14  *                                   Device addresses 
00000008  =00004400                 15  STACK    EQU      $4400             Stack_pointer
00000008  =00008001                 16  ACIA_1   EQU      $8001             Console ACIA control 
00000008  =00008001                 17  ACIA_2   EQU      ACIA_1            Auxilary ACIA control 
00000008                            18  *X_BASE   EQU      $4000             Start of exception vector table 
00000008  =00004E4E                 19  TRAP_14  EQU      $4E4E             Code for TRAP #14 
00000008  =00000040                 20  MAXCHR   EQU      64                Length of input line buffer  
00000008                            21  * 
00000008  =00004800                 22  DATA     EQU      $4800             Data origin 
00000008                            23  LNBUFF   DS.B     MAXCHR            Input line buffer
00000048  =00000047                 24  BUFFEND  EQU      LNBUFF+MAXCHR-1   End of line buffer 
00000048                            25  BUFFPT   DS.L     1                 Pointer to line buffer 
0000004C                            26  PARAMTR  DS.L     1                 Last parameter from line buffer 
00000050                            27  ECHO     DS.B     1                 When clear this enable input echo 
00000051                            28  U_CASE   DS.B     1                 Flag for upper case conversion 
00000052                            29  UTAB     DS.L     1                 Pointer to user command table 
00000056                            30  CN_IVEC  DS.L     1                 Pointer to console input DCB 
0000005A                            31  CN_OVEC  DS.L     1                 Pointer to console output DCB 
0000005E                            32  TSK_T    DS.W     37                Frame for D0-D7, A0-A6, USP, SSP, SW, PC 
000000A8                            33  BP_TAB   DS.W     24                Breakpoint table 
000000D8                            34  FIRST    DS.B     512               DCB area 
000002D8                            35  BUFFER   DS.B     256               256 bytes for I/O buffer 
000003D8= 00004000                  36  MIN_RAM  DC.L     $004000
000003DC= 00004100                  37  MAX_RAM  DC.L     $004100
000003E0                            38  * 
000003E0                            39  ************************************************************************* 
000003E0                            40  * 
000003E0                            41  *  This is the main program which assembles a command in the line 
000003E0                            42  *  buffer, removes leading/embedded spaces and interprets it by matching 
000003E0                            43  *  it with a command in the user table or the built-in table COMTAB 
000003E0                            44  *  All variables are specified with respect to A6 
000003E0                            45  *
00001000                            46           ORG      $1000             Monitor Origin
00001000  =00001000                 47  RESET:   EQU      *
00001000  4DF8 4800                 48           LEA.L    DATA,A6           A6 points to data area 
00001004  2D4E 0096                 49       MOVE.L   A6,TSK_T+56(A6)   initialize A6 in the regster Frame
00001008  42AE 0052                 50           CLR.L    UTAB(A6)          Reset pointer to user extension table 
0000100C  422E 0050                 51           CLR.B    ECHO(A6)          Set automatic character echo 
00001010  422E 0051                 52           CLR.B    U_CASE(A6)        Clear case conversion flag (UC<-LC) 
00001014  6146                      53           BSR.S    SETACIA           Setup ACIAs 
00001016  6100 05B0                 54           BSR.L    B_CLR         what change did i do here
0000101A  6100 040E                 55           BSR.L    SET_DCB           Setup DCB table in RAM
0000101E  6152                      56           BSR.S    NEWLINE
00001020  49FA 0A30                 57           LEA.L    BANNER(PC),A4    
00001024  615C                      58           BSR.S    PSTRING
00001026  614A                      59           BSR.S    NEWLINE           
00001028  49FA 0A42                 60       LEA.L    MODIFY(PC),A4
0000102C  6154                      61           BSR.S    PSTRING
0000102E  6142                      62           BSR.S    NEWLINE
00001030  49FA 0A68                 63       LEA.L    WHY(PC),A4
00001034  614C                      64           BSR.S    PSTRING
00001036  613A                      65           BSR.S    NEWLINE
00001038  49FA 0A98                 66       LEA.L    WHERE(PC),A4
0000103C  6144                      67           BSR.S    PSTRING
0000103E  6132                      68           BSR.S    NEWLINE
00001040                            69  *         MOVE.L   #$3000,A0         A0 points to extension ROM 
00001040                            70  *         MOVE.L   (A0),D0           Read first longword in extension ROM 
00001040                            71  *         CMP.L    #'ROM2',D0        If extension begins with 'ROM2' then 
00001040                            72  *         BNE.S    NO_EXT            call the subroutine at EXT_ROM+8 
00001040                            73  *         JSR      8(A0)             else continue 
00001040  4E71                      74  NO_EXT:  NOP                        Two NOPs to allow for a future 
00001042  4E71                      75           NOP                        call to an initialization routine 
00001044  4287                      76           CLR.L    D7                Warm entry point - clear error flag 
00001046  4EB9 00001686             77           JSR      LOGIN                       
0000104C  4287                      78  WARM:    CLR.L    D7                Warm entry point - clear error flag 
0000104E  6122                      79           BSR.S    NEWLINE           Print a newline 
00001050  6146                      80           BSR.S    GETLINE           Get a command line 
00001052  6100 007A                 81           BSR      TIDY              Tidy up input buffer contents 
00001056  6100 00B8                 82           BSR      EXECUTE           Interpret command 
0000105A  60F0                      83           BRA      WARM              Repeat indefinitely 
0000105C                            84  * 
0000105C                            85  ************************************************************************* 
0000105C                            86  * 
0000105C                            87  *  Some initialization and basic routines 
0000105C                            88  * 
0000105C  =0000105C                 89  SETACIA  EQU      *                 Setup ACIA parameters 
0000105C  41F9 00008001             90           LEA.L    ACIA_1,A0         A0 points to console ACIA 
00001062  10BC 0003                 91           MOVE.B   #$03,(A0)         Reset ACIA1 
00001066                            92  *         MOVE.B   #$03,1(A0)        Reset ACIA2 
00001066  10BC 0019                 93           MOVE.B   #$19,(A0)         Set up ACIA1 constants (no IRQ, 
0000106A  117C 0019 0001            94           MOVE.B   #$19,1(A0)        RTS* low, 8 bit, no parity, 1 stop) 
00001070  4E75                      95           RTS                        Return 
00001072                            96  * 
00001072  =00001072                 97  NEWLINE  EQU      *                 Move cursor to start of newline 
00001072  48E7 0008                 98           MOVEM.L  A4,-(A7)          Save A4 
00001076  49FA 0A74                 99           LEA.L    CRLF(PC),A4       Point to CR/LF string 
0000107A  6106                     100           BSR.S    PSTRING           Print it 
0000107C  4CDF 1000                101           MOVEM.L  (A7)+,A4          Restore A4 
00001080  4E75                     102           RTS                        Return 
00001082                           103  * 
00001082  =00001082                104  PSTRING  EQU      *                 Display the string pointed at by A4 
00001082  2F00                     105           MOVE.L   D0,-(A7)          Save D0 
00001084  101C                     106  PS1      MOVE.B   (A4)+,D0          Get character to be printed 
00001086  6706                     107           BEQ.S    PS2               If null then return 
00001088  6100 04DE                108           BSR      PUTCHAR           Else print it 
0000108C  60F6                     109           BRA      PS1               Continue 
0000108E  201F                     110  PS2      MOVE.L   (A7)+,D0          Restore D0 and exit 
00001090  4E75                     111           RTS 
00001092                           112  * 
00001092  61DE                     113  HEADING  BSR      NEWLINE           Same as PSTRING but with newline 
00001094  61EC                     114           BSR      PSTRING 
00001096  60DA                     115           BRA      NEWLINE 
00001098                           116  * 
00001098                           117  ************************************************************************* 
00001098                           118  * 
00001098                           119  *  GETLINE  inputs a string of characters into a line buffer 
00001098                           120  *           A3 points to next free entry in line buffer 
00001098                           121  *           A2 points to end of buffer 
00001098                           122  *           A1 points to start of buffer 
00001098                           123  *           D0 holds character to be stored 
00001098                           124  * 
00001098  43EE 0008                125  GETLINE  LEA.L    LNBUFF(A6),A1     A1 points to start of line buffer 
0000109C  47D1                     126           LEA.L    (A1),A3           A3 points to start (initially) 
0000109E  45E9 0040                127           LEA.L    MAXCHR(A1),A2     A2 points to end of buffer 
000010A2  6100 0476                128  GETLN2   BSR      GETCHAR           Get a character 
000010A6  B03C 0001                129  GETLNR   CMP.B    #CTRL_A,D0        If control_A then reject this line 
000010AA  671E                     130           BEQ.S    GETLN5            and get another line 
000010AC  B03C 0008                131           CMP.B    #BS,D0            If back_space then move back pointer 
000010B0  660A                     132           BNE.S    GETLN3            Else skip past wind-back routine 
000010B2  B7C9                     133           CMP.L    A1,A3             First check for empty buffer 
000010B4  67EC                     134           BEQ      GETLN2            If buffer empty then continue 
000010B6  47EB FFFF                135           LEA      -1(A3),A3         Else decrement buffer pointer 
000010BA  60E6                     136           BRA      GETLN2            and continue with next character 
000010BC  16C0                     137  GETLN3   MOVE.B   D0,(A3)+          Store character and update pointer 
000010BE  B03C 000D                138           CMP.B    #CR,D0            Test for command terminator 
000010C2  6602                     139           BNE.S    GETLN4            If not CR then skip past exit 
000010C4  60AC                     140           BRA      NEWLINE           Else new line before next operation 
000010C6  B7CA                     141  GETLN4   CMP.L    A2,A3             Test for buffer overflow 
000010C8  66D8                     142           BNE      GETLN2            If buffer not full then continue 
000010CA  61A6                     143  GETLN5   BSR      NEWLINE           Else move to next line and 
000010CC  60CA                     144           BRA      GETLINE           repeat this routine 
000010CE                           145  * 
000010CE                           146  ************************************************************************* 
000010CE                           147  * 
000010CE                           148  *  TIDY cleans up the line buffer by removing leading spaces and multiple 
000010CE                           149  *       spaces between parameters. At the end of TIDY, BUFFPT points to 
000010CE                           150  *       the first parameter following the command. 
000010CE                           151  *       A0 = pointer to line buffer. A1 = pointer to cleaned up buffer 
000010CE                           152  * 
000010CE  41EE 0008                153  TIDY     LEA.L    LNBUFF(A6),A0     A0 points to line buffer 
000010D2  43D0                     154           LEA.L    (A0),A1           A1 points to start of line buffer 
000010D4  1018                     155  TIDY1    MOVE.B   (A0)+,D0          Read character from line buffer 
000010D6  B03C 0020                156           CMP.B    #SPACE,D0         Repeat until the first non-space 
000010DA  67F8                     157           BEQ      TIDY1             character is found 
000010DC  41E8 FFFF                158           LEA.L    -1(A0),A0         Move pointer back to first char 
000010E0  1018                     159  TIDY2    MOVE.B   (A0)+,D0          Move the string left to remove 
000010E2  12C0                     160           MOVE.B   D0,(A1)+          any leading spaces 
000010E4  B03C 0020                161           CMP.B    #SPACE,D0         Test for embedded space 
000010E8  660A                     162           BNE.S    TIDY4             If not space then test for EOL 
000010EA  0C18 0020                163  TIDY3    CMP.B    #SPACE,(A0)+      If space skip multiple embedded 
000010EE  67FA                     164           BEQ      TIDY3             spaces 
000010F0  41E8 FFFF                165           LEA.L    -1(A0),A0         Move back pointer 
000010F4  B03C 000D                166  TIDY4    CMP.B    #CR,D0            Test for end_of_line (EOL) 
000010F8  66E6                     167           BNE      TIDY2             If not EOL then read next char 
000010FA  41EE 0008                168           LEA.L    LNBUFF(A6),A0     Restore buffer pointer 
000010FE  0C10 000D                169  TIDY5    CMP.B    #CR,(A0)          Test for EOL 
00001102  6706                     170           BEQ.S    TIDY6             If EOL then exit 
00001104  0C18 0020                171           CMP.B    #SPACE,(A0)+      Test for delimiter 
00001108  66F4                     172           BNE      TIDY5             Repeat until delimiter or EOL 
0000110A  2D48 0048                173  TIDY6    MOVE.L   A0,BUFFPT(A6)     Update buffer pointer 
0000110E  4E75                     174           RTS 
00001110                           175  * 
00001110                           176  ************************************************************************* 
00001110                           177  * 
00001110                           178  *  EXECUTE matches the first command in the line buffer with the 
00001110                           179  *  commands in a command table. An external table pointed at by 
00001110                           180  *  UTAB is searched first and then the in-built table, COMTAB. 
00001110                           181  * 
00001110  4AAE 0052                182  EXECUTE  TST.L    UTAB(A6)          Test pointer to user table 
00001114  670C                     183           BEQ.S    EXEC1             If clear then try built-in table 
00001116  266E 0052                184           MOVE.L   UTAB(A6),A3       Else pick up pointer to user table 
0000111A  6120                     185           BSR.S    SEARCH            Look for command in user table 
0000111C  6404                     186           BCC.S    EXEC1             If not found then try internal table 
0000111E  2653                     187           MOVE.L   (A3),A3           Else get absolute address of command 
00001120  4ED3                     188           JMP      (A3)              from user table and execute it 
00001122                           189  * 
00001122  47FA 0EDC                190  EXEC1    LEA.L    COMTAB(PC),A3     Try built-in command table 
00001126  6114                     191           BSR.S    SEARCH            Look for command in built-in table 
00001128  6508                     192           BCS.S    EXEC2             If found then execute command 
0000112A  49FA 0AD3                193           LEA.L    ERMES2(PC),A4     Else print "invalid command" 
0000112E  6000 FF52                194           BRA.L    PSTRING           and return 
00001132  2653                     195  EXEC2    MOVE.L   (A3),A3           Get the relative command address 
00001134  49FA 0ECA                196           LEA.L    COMTAB(PC),A4     pointed at by A3 and add it to 
00001138  D7CC                     197           ADD.L    A4,A3             the PC to generate the actual 
0000113A  4ED3                     198           JMP      (A3)              command address. Then execute it. 
0000113C                           199  * 
0000113C  =0000113C                200  SEARCH   EQU      *                 Match the command in the line buffer 
0000113C  4280                     201           CLR.L    D0                with command table pointed at by A3 
0000113E  1013                     202           MOVE.B   (A3),D0           Get the first character in the 
00001140  6734                     203           BEQ.S    SRCH7             current entry. If zero then exit 
00001142  49F3 0006                204           LEA.L    6(A3,D0.W),A4     Else calculate address of next entry 
00001146  122B 0001                205           MOVE.B   1(A3),D1          Get number of characters to match 
0000114A  4BEE 0008                206           LEA.L    LNBUFF(A6),A5     A5 points to command in line buffer 
0000114E  142B 0002                207           MOVE.B   2(A3),D2          Get first character in this entry 
00001152  B41D                     208           CMP.B    (A5)+,D2          from the table and match with buffer 
00001154  6704                     209           BEQ.S    SRCH3             If match then try rest of string 
00001156  264C                     210  SRCH2    MOVE.L   A4,A3             Else get address of next entry 
00001158  60E2                     211           BRA      SEARCH            and try the next entry in the table 
0000115A  5301                     212  SRCH3    SUB.B    #1,D1             One less character to match 
0000115C  670E                     213           BEQ.S    SRCH6             If match counter zero then all done 
0000115E  47EB 0003                214           LEA.L    3(A3),A3          Else point to next character in table 
00001162  141B                     215  SRCH4    MOVE.B   (A3)+,D2          Now match a pair of characters 
00001164  B41D                     216           CMP.B    (A5)+,D2 
00001166  66EE                     217           BNE      SRCH2             If no match then try next entry 
00001168  5301                     218           SUB.B    #1,D1             Else decrement match counter and 
0000116A  66F6                     219           BNE      SRCH4             repeat until no chars left to match 
0000116C  47EC FFFC                220  SRCH6    LEA.L    -4(A4),A3         Calculate address of command entry 
00001170  003C 0001                221           OR.B     #1,CCR            point. Mark carry flag as success 
00001174  4E75                     222           RTS                        and return 
00001176  023C 00FE                223  SRCH7    AND.B    #$FE,CCR          Fail - clear carry to indicate 
0000117A  4E75                     224           RTS                        command not found and return 
0000117C                           225  * 
0000117C                           226  ************************************************************************* 
0000117C                           227  * 
0000117C                           228  *  Basic input routines 
0000117C                           229  *  HEX    =  Get one   hexadecimal character  into D0 
0000117C                           230  *  BYTE   =  Get two   hexadecimal characters into D0 
0000117C                           231  *  WORD   =  Get four  hexadecimal characters into D0 
0000117C                           232  *  LONGWD =  Get eight hexadecimal characters into D0 
0000117C                           233  *  PARAM  =  Get a longword from the line buffer into D0 
0000117C                           234  *  Bit 0 of D7 is set to indicate a hexadecimal input error 
0000117C                           235  * 
0000117C  6100 039C                236  HEX      BSR      GETCHAR           Get a character from input device 
00001180  0400 0030                237           SUB.B    #$30,D0           Convert to binary 
00001184  6B0E                     238           BMI.S    NOT_HEX           If less than $30 then exit with error 
00001186  B03C 0009                239           CMP.B    #$09,D0           Else test for number (0 to 9) 
0000118A  6F0C                     240           BLE.S    HEX_OK            If number then exit - success 
0000118C  5F00                     241           SUB.B    #$07,D0           Else convert letter to hex 
0000118E  B03C 000F                242           CMP.B    #$0F,D0           If character in range "A" to "F" 
00001192  6F04                     243           BLE.S    HEX_OK            then exit successfully 
00001194  8E3C 0001                244  NOT_HEX  OR.B     #1,D7             Else set error flag 
00001198  4E75                     245  HEX_OK   RTS                        and return 
0000119A                           246  * 
0000119A  2F01                     247  BYTE     MOVE.L   D1,-(A7)          Save D1 
0000119C  61DE                     248           BSR      HEX               Get first hex character 
0000119E  E900                     249           ASL.B    #4,D0             Move it to MS nybble position 
000011A0  1200                     250           MOVE.B   D0,D1             Save MS nybble in D1 
000011A2  61D8                     251           BSR      HEX               Get second hex character 
000011A4  D001                     252           ADD.B    D1,D0             Merge MS and LS nybbles 
000011A6  221F                     253           MOVE.L   (A7)+,D1          Restore D1 
000011A8  4E75                     254           RTS 
000011AA                           255  * 
000011AA  61EE                     256  WORD     BSR      BYTE              Get upper order byte 
000011AC  E140                     257           ASL.W    #8,D0             Move it to MS position 
000011AE  60EA                     258           BRA      BYTE              Get LS byte and return 
000011B0                           259  * 
000011B0  61F8                     260  LONGWD   BSR      WORD              Get upper order word 
000011B2  4840                     261           SWAP     D0                Move it to MS position 
000011B4  60F4                     262           BRA      WORD              Get lower order word and return 
000011B6                           263  * 
000011B6                           264  *  PARAM reads a parameter from the line buffer and puts it in both 
000011B6                           265  *  PARAMTR(A6) and D0. Bit 1 of D7 is set on error. 
000011B6                           266  * 
000011B6  2F01                     267  PARAM    MOVE.L   D1,-(A7)          Save D1 
000011B8  4281                     268           CLR.L    D1                Clear input accumulator 
000011BA  206E 0048                269           MOVE.L   BUFFPT(A6),A0     A0 points to parameter in buffer 
000011BE  1018                     270  PARAM1   MOVE.B   (A0)+,D0          Read character from line buffer 
000011C0  B03C 0020                271           CMP.B    #SPACE,D0         Test for delimiter 
000011C4  6720                     272           BEQ.S    PARAM4            The permitted delimiter is a 
000011C6  B03C 000D                273           CMP.B    #CR,D0            space or a carriage return 
000011CA  671A                     274           BEQ.S    PARAM4            Exit on either space or C/R 
000011CC  E981                     275           ASL.L    #4,D1             Shift accumulated result 4 bits left 
000011CE  0400 0030                276           SUB.B    #$30,D0           Convert new character to hex 
000011D2  6B1E                     277           BMI.S    PARAM5            If less than $30 then not-hex 
000011D4  B03C 0009                278           CMP.B    #$09,D0           If less than 10 
000011D8  6F08                     279           BLE.S    PARAM3            then continue 
000011DA  5F00                     280           SUB.B    #$07,D0           Else assume $A - $F 
000011DC  B03C 000F                281           CMP.B    #$0F,D0           If more than $F 
000011E0  6E10                     282           BGT.S    PARAM5            then exit to error on not-hex 
000011E2  D200                     283  PARAM3   ADD.B    D0,D1             Add latest nybble to total in D1 
000011E4  60D8                     284           BRA      PARAM1            Repeat until delimiter found 
000011E6  2D48 0048                285  PARAM4   MOVE.L   A0,BUFFPT(A6)     Save pointer in memory 
000011EA  2D41 004C                286           MOVE.L   D1,PARAMTR(A6)    Save parameter in memory 
000011EE  2001                     287           MOVE.L   D1,D0             Put parameter in D0 for return 
000011F0  6004                     288           BRA.S    PARAM6            Return without error 
000011F2  8E3C 0002                289  PARAM5   OR.B     #2,D7             Set error flag before return 
000011F6  221F                     290  PARAM6   MOVE.L   (A7)+,D1          Restore working register 
000011F8  4E75                     291           RTS                        Return with error 
000011FA                           292  * 
000011FA                           293  ************************************************************************* 
000011FA                           294  * 
000011FA                           295  *  Output routines 
000011FA                           296  *  OUT1X   = print one   hexadecimal character 
000011FA                           297  *  OUT2X   = print two   hexadecimal characters 
000011FA                           298  *  OUT4X   = print four  hexadecimal characters 
000011FA                           299  *  OUT8X   = print eight hexadecimal characters 
000011FA                           300  *  In each case, the data to be printed is in D0 
000011FA                           301  * 
000011FA  3F00                     302  OUT1X    MOVE.W   D0,-(A7)          Save D0 
000011FC  C03C 000F                303           AND.B    #$0F,D0           Mask off MS nybble 
00001200  0600 0030                304           ADD.B    #$30,D0           Convert to ASCII 
00001204  B03C 0039                305           CMP.B    #$39,D0           ASCII = HEX + $30 
00001208  6302                     306           BLS.S    OUT1X1            If ASCII <= $39 then print and exit 
0000120A  5E00                     307           ADD.B    #$07,D0           Else ASCII := HEX + 7 
0000120C  6100 035A                308  OUT1X1   BSR      PUTCHAR           Print the character 
00001210  301F                     309           MOVE.W   (A7)+,D0          Restore D0 
00001212  4E75                     310           RTS 
00001214                           311  * 
00001214  E818                     312  OUT2X    ROR.B    #4,D0             Get MS nybble in LS position 
00001216  61E2                     313           BSR      OUT1X             Print MS nybble 
00001218  E918                     314           ROL.B    #4,D0             Restore LS nybble 
0000121A  60DE                     315           BRA      OUT1X             Print LS nybble and return 
0000121C                           316  * 
0000121C  E058                     317  OUT4X    ROR.W    #8,D0             Get MS byte in LS position 
0000121E  61F4                     318           BSR      OUT2X             Print MS byte 
00001220  E158                     319           ROL.W    #8,D0             Restore LS byte 
00001222  60F0                     320           BRA      OUT2X             Print LS byte and return 
00001224                           321  * 
00001224  4840                     322  OUT8X    SWAP     D0                Get MS word in LS position 
00001226  61F4                     323           BSR      OUT4X             Print MS word 
00001228  4840                     324           SWAP     D0                Restore LS word 
0000122A  60F0                     325           BRA      OUT4X             Print LS word and return 
0000122C                           326  * 
0000122C                           327  ************************************************************************* 
0000122C                           328  * 
0000122C                           329  * JUMP causes execution to begin at the address in the line buffer 
0000122C                           330  * 
0000122C  6188                     331  JUMP     BSR     PARAM              Get address from buffer 
0000122E  4A07                     332           TST.B   D7                 Test for input error 
00001230  6608                     333           BNE.S   JUMP1              If error flag not zero then exit 
00001232  4A80                     334           TST.L   D0                 Else test for missing address 
00001234  6704                     335           BEQ.S   JUMP1              field. If no address then exit 
00001236  2040                     336           MOVE.L  D0,A0              Put jump address in A0 and call the 
00001238  4ED0                     337           JMP     (A0)               subroutine. User to supply RTS!! 
0000123A  49FA 09A5                338  JUMP1    LEA.L   ERMES1(PC),A4      Here for error - display error 
0000123E  6000 FE42                339           BRA     PSTRING            message and return 
00001242                           340  * 
00001242                           341  ************************************************************************* 
00001242                           342  * 
00001242                           343  *  Display the contents of a memory location and modify it 
00001242                           344  * 
00001242  6100 FF72                345  MEMORY   BSR      PARAM             Get start address from line buffer 
00001246  4A07                     346           TST.B    D7                Test for input error 
00001248  6634                     347           BNE.S    MEM3              If error then exit 
0000124A  2640                     348           MOVE.L   D0,A3             A3 points to location to be opened 
0000124C  6100 FE24                349  MEM1     BSR      NEWLINE 
00001250  612E                     350           BSR.S    ADR_DAT           Print current address and contents 
00001252  6140                     351           BSR.S    PSPACE             update pointer, A3, and O/P space 
00001254  6100 02C4                352           BSR      GETCHAR           Input char to decide next action 
00001258  B03C 000D                353           CMP.B    #CR,D0            If carriage return then exit 
0000125C  6720                     354           BEQ.S    MEM3              Exit 
0000125E  B03C 002D                355           CMP.B    #'-',D0           If "-" then move back 
00001262  6606                     356           BNE.S    MEM2              Else skip wind-back procedure 
00001264  47EB FFFC                357           LEA.L    -4(A3),A3         Move pointer back 2+2 
00001268  60E2                     358           BRA      MEM1              Repeat until carriage return 
0000126A  B03C 0020                359  MEM2     CMP.B    #SPACE,D0         Test for space (= new entry) 
0000126E  66DC                     360           BNE.S    MEM1              If not space then repeat 
00001270  6100 FF38                361           BSR      WORD              Else get new word to store 
00001274  4A07                     362           TST.B    D7                Test for input error 
00001276  6606                     363           BNE.S    MEM3              If error then exit 
00001278  3740 FFFE                364           MOVE.W   D0,-2(A3)         Store new word 
0000127C  60CE                     365           BRA      MEM1              Repeat until carriage return 
0000127E  4E75                     366  MEM3     RTS 
00001280                           367  * 
00001280  2F00                     368  ADR_DAT  MOVE.L   D0,-(A7)          Print the contents of A3 and the 
00001282  200B                     369           MOVE.L   A3,D0             word pointed at by A3. 
00001284  619E                     370           BSR      OUT8X              and print current address 
00001286  610C                     371           BSR.S    PSPACE            Insert delimiter 
00001288  3013                     372           MOVE.W   (A3),D0           Get data at this address in D0 
0000128A  6190                     373           BSR      OUT4X              and print it 
0000128C  47EB 0002                374           LEA.L    2(A3),A3          Point to next address to display 
00001290  201F                     375           MOVE.L   (A7)+,D0          Restore D0 
00001292  4E75                     376           RTS 
00001294                           377  * 
00001294  1F00                     378  PSPACE   MOVE.B   D0,-(A7)          Print a single space 
00001296  103C 0020                379           MOVE.B   #SPACE,D0
0000129A  6100 02CC                380           BSR      PUTCHAR 
0000129E  101F                     381           MOVE.B   (A7)+,D0 
000012A0  4E75                     382           RTS 
000012A2                           383  * 
000012A2                           384  ************************************************************************* 
000012A2                           385  * 
000012A2                           386  *  LOAD  Loads data formatted in hexadecimal "S" format from Port 2 
000012A2                           387  *        NOTE - I/O is automatically redirected to the aux port for 
000012A2                           388  *        loader functions. S1 or S2 records accepted 
000012A2                           389  * 
000012A2  2F2E 005A                390  LOAD     MOVE.L   CN_OVEC(A6),-(A7) Save current output device name 
000012A6  2F2E 0056                391           MOVE.L   CN_IVEC(A6),-(A7) Save current input device name 
000012AA  2D7C 0000206C 005A       392           MOVE.L   #DCB4,CN_OVEC(A6) Set up aux ACIA as output 
000012B2  2D7C 0000205A 0056       393           MOVE.L   #DCB3,CN_IVEC(A6) Set up aux ACIA as input 
000012BA  522E 0050                394           ADD.B    #1,ECHO(A6)       Turn off character echo 
000012BE  6100 FDB2                395           BSR      NEWLINE           Send newline to host 
000012C2  6100 0152                396           BSR      DELAY             Wait for host to "settle" 
000012C6  6100 014E                397           BSR      DELAY 
000012CA  286E 0048                398           MOVE.L   BUFFPT(A6),A4     Any string in the line buffer is 
000012CE  101C                     399  LOAD1    MOVE.B   (A4)+,D0          transmitted to the host computer 
000012D0  6100 0296                400           BSR      PUTCHAR           before the loading begins 
000012D4  B03C 000D                401           CMP.B    #CR,D0            Read from the buffer until EOL 
000012D8  66F4                     402           BNE      LOAD1 
000012DA  6100 FD96                403           BSR      NEWLINE           Send newline before loading 
000012DE  6100 023A                404  LOAD2    BSR      GETCHAR           Records from the host must begin 
000012E2  B03C 0053                405           CMP.B    #'S',D0           with S1/S2 (data) or S9/S8 (term) 
000012E6  66F6                     406           BNE.S    LOAD2             Repeat GETCHAR until char = "S" 
000012E8  6100 0230                407           BSR      GETCHAR           Get character after "S" 
000012EC  B03C 0039                408           CMP.B    #'9',D0           Test for the two terminators S9/S8 
000012F0  6706                     409           BEQ.S    LOAD3             If S9 record then exit else test 
000012F2  B03C 0038                410           CMP.B    #'8',D0           for S8 terminator. Fall through to 
000012F6  662A                     411           BNE.S    LOAD6             exit on S8 else continue search 
000012F8  =000012F8                412  LOAD3    EQU      *                 Exit point from LOAD 
000012F8  2D5F 0056                413           MOVE.L   (A7)+,CN_IVEC(A6) Clean up by restoring input device 
000012FC  2D5F 005A                414           MOVE.L   (A7)+,CN_OVEC(A6) and output device name 
00001300  422E 0050                415           CLR.B    ECHO(A6)          Restore input character echo 
00001304  0807 0000                416           BTST   #0,D7             Test for input errors 
00001308  6708                     417           BEQ.S    LOAD4             If no I/P error then look at checksum 
0000130A  49FA 08D5                418           LEA.L    ERMES1(PC),A4     Else point to error message 
0000130E  6100 FD72                419           BSR      PSTRING           Print it 
00001312  0807 0003                420  LOAD4    BTST   #3,D7             Test for checksum error 
00001316  6708                     421           BEQ.S    LOAD5             If clear then exit 
00001318  49FA 08F7                422           LEA.L    ERMES3(PC),A4     Else point to error message 
0000131C  6100 FD64                423           BSR      PSTRING           Print it and return 
00001320  4E75                     424  LOAD5    RTS 
00001322                           425  * 
00001322  B03C 0031                426  LOAD6    CMP.B    #'1',D0           Test for S1 record 
00001326  671E                     427           BEQ.S    LOAD6A            If S1 record then read it 
00001328  B03C 0032                428           CMP.B    #'2',D0           Else test for S2 record 
0000132C  66B0                     429           BNE.S    LOAD2             Repeat until valid header found 
0000132E  4203                     430           CLR.B    D3                Read the S2 byte count and address, 
00001330  613C                     431           BSR.S    LOAD8             clear the checksum 
00001332  5900                     432           SUB.B    #4,D0             Calculate size of data field 
00001334  1400                     433           MOVE.B   D0,D2             D2 contains data bytes to read 
00001336  4280                     434           CLR.L    D0                Clear address accumulator 
00001338  6134                     435           BSR.S    LOAD8             Read most sig byte of address 
0000133A  E180                     436           ASL.L    #8,D0             Move it one byte left 
0000133C  6130                     437           BSR.S    LOAD8             Read the middle byte of address 
0000133E  E180                     438           ASL.L    #8,D0             Move it one byte left 
00001340  612C                     439           BSR.S    LOAD8             Read least sig byte of address 
00001342  2440                     440           MOVE.L   D0,A2             A2 points to destination of record 
00001344  6012                     441           BRA.S    LOAD7             Skip past S1 header loader 
00001346  4203                     442  LOAD6A   CLR.B    D3                S1 record found - clear checksum 
00001348  6124                     443           BSR.S    LOAD8             Get byte and update checksum 
0000134A  5700                     444           SUB.B    #3,D0             Subtract 3 from record length 
0000134C  1400                     445           MOVE.B   D0,D2             Save byte count in D2 
0000134E  4280                     446           CLR.L    D0                Clear address accumulator 
00001350  611C                     447           BSR.S    LOAD8             Get MS byte of load address 
00001352  E180                     448           ASL.L    #8,D0             Move it to MS position 
00001354  6118                     449           BSR.S    LOAD8             Get LS byte in D2 
00001356  2440                     450           MOVE.L   D0,A2             A2 points to destination of data 
00001358  6114                     451  LOAD7    BSR.S    LOAD8             Get byte of data for loading 
0000135A  14C0                     452           MOVE.B   D0,(A2)+          Store it 
0000135C  5302                     453           SUB.B    #1,D2             Decrement byte counter 
0000135E  66F8                     454           BNE      LOAD7             Repeat until count = 0 
00001360  610C                     455           BSR.S    LOAD8             Read checksum 
00001362  5203                     456           ADD.B    #1,D3             Add 1 to total checksum 
00001364  6700 FF78                457           BEQ      LOAD2             If zero then start next record 
00001368  8E3C 0008                458           OR.B     #%00001000,D7     Else set checksum error bit, 
0000136C  608A                     459           BRA      LOAD3             restore I/O devices and return 
0000136E                           460  * 
0000136E  6100 FE2A                461  LOAD8    BSR     BYTE               Get a byte 
00001372  D600                     462           ADD.B   D0,D3              Update checksum 
00001374  4E75                     463           RTS                         and return 
00001376                           464  *************************************************************************** 
00001376                           465  * 
00001376                           466  *  DUMP   Transmit S1 formatted records to host computer 
00001376                           467  *         A3 = Starting address of data block 
00001376                           468  *         A2 = End address of data block 
00001376                           469  *         D1 = Checksum, D2 = current record length 
00001376                           470  * 
00001376  6100 008E                471  DUMP     BSR      RANGE             Get start and end address 
0000137A  4A07                     472           TST.B    D7                Test for input error 
0000137C  6708                     473           BEQ.S    DUMP1             If no error then continue 
0000137E  49FA 0861                474           LEA.L    ERMES1(PC),A4     Else point to error message, 
00001382  6000 FCFE                475           BRA      PSTRING           print it and return 
00001386  B08B                     476  DUMP1    CMP.L    A3,D0             Compare start and end addresses 
00001388  6A08                     477           BPL.S    DUMP2             If positive then start < end 
0000138A  49FA 09F4                478           LEA.L    ERMES7(PC),A4     Else print error message 
0000138E  6000 FCF2                479           BRA      PSTRING           and return 
00001392  2F2E 005A                480  DUMP2    MOVE.L   CN_OVEC(A6),-(A7) Save name of current output device 
00001396                           481  *         MOVE.L   #DCB4,CN_OVEC(A6) Set up Port 2 as output device 
00001396  6100 FCDA                482           BSR      NEWLINE           Send newline to host and wait 
0000139A  617A                     483           BSR.S    DELAY 
0000139C  286E 0048                484           MOVE.L   BUFFPT(A6),A4     Before dumping, send any string 
000013A0  101C                     485  DUMP3    MOVE.B   (A4)+,D0          in the input buffer to the host 
000013A2  6100 01C4                486           BSR      PUTCHAR           Repeat 
000013A6  B03C 000D                487           CMP.B    #CR,D0            Transmit char from buffer to host 
000013AA  66F4                     488           BNE      DUMP3             Until char = C/R 
000013AC  6100 FCC4                489           BSR      NEWLINE 
000013B0  6164                     490           BSR.S    DELAY             Allow time for host to settle 
000013B2  528A                     491           ADDQ.L   #1,A2             A2 contains length of record + 1 
000013B4  240A                     492  DUMP4    MOVE.L   A2,D2             D2 points to end address 
000013B6  948B                     493           SUB.L    A3,D2             D2 contains bytes left to print 
000013B8  B4BC 00000011            494           CMP.L    #17,D2            If this is not a full record of 16 
000013BE  6502                     495           BCS.S    DUMP5             then load D2 with record size 
000013C0  7410                     496           MOVEQ    #16,D2            Else preset byte count to 16 
000013C2  49FA 0733                497  DUMP5    LEA.L    HEADER(PC),A4     Point to record header 
000013C6  6100 FCBA                498           BSR      PSTRING           Print header 
000013CA  4201                     499           CLR.B    D1                Clear checksum 
000013CC  1002                     500           MOVE.B   D2,D0             Move record length to output register 
000013CE  5600                     501           ADD.B    #3,D0             Length includes address + count 
000013D0  612E                     502           BSR.S    DUMP7             Print number of bytes in record 
000013D2  200B                     503           MOVE.L   A3,D0             Get start address to be printed 
000013D4  E158                     504           ROL.W    #8,D0             Get MS byte in LS position 
000013D6  6128                     505           BSR.S    DUMP7             Print MS byte of address 
000013D8  E058                     506           ROR.W    #8,D0             Restore LS byte 
000013DA  6124                     507           BSR.S    DUMP7             Print LS byte of address 
000013DC  101B                     508  DUMP6    MOVE.B   (A3)+,D0          Get data byte to be printed 
000013DE  6120                     509           BSR.S    DUMP7             Print it 
000013E0  5302                     510           SUB.B    #1,D2             Decrement byte count 
000013E2  66F8                     511           BNE      DUMP6             Repeat until all this record printed 
000013E4  4601                     512           NOT.B    D1                Complement checksum 
000013E6  1001                     513           MOVE.B   D1,D0             Move to output register 
000013E8  6116                     514           BSR.S    DUMP7             Print checksum 
000013EA  6100 FC86                515           BSR      NEWLINE 
000013EE  B7CA                     516           CMP.L    A2,A3             Have all records been printed? 
000013F0  66C2                     517           BNE      DUMP4             Repeat until all done 
000013F2  49FA 0709                518           LEA.L    TAIL(PC),A4       Point to message tail (S9 record) 
000013F6  6100 FC8A                519           BSR      PSTRING           Print it 
000013FA  2D5F 005A                520           MOVE.L   (A7)+,CN_OVEC(A6) Restore name of output device 
000013FE  4E75                     521           RTS                        and return 
00001400                           522  * 
00001400  D200                     523  DUMP7    ADD.B    D0,D1             Update checksum, transmit byte 
00001402  6000 FE10                524           BRA      OUT2X             to host and return 
00001406                           525  * 
00001406  =00001406                526  RANGE    EQU      *                 Get the range of addresses to be 
00001406  4207                     527           CLR.B    D7                transmitted from the buffer 
00001408  6100 FDAC                528           BSR      PARAM             Get starting address 
0000140C  2640                     529           MOVE.L   D0,A3             Set up start address in A3 
0000140E  6100 FDA6                530           BSR      PARAM             Get end address 
00001412  2440                     531           MOVE.L   D0,A2             Set up end address in A2 
00001414  4E75                     532           RTS 
00001416                           533  * 
00001416  =00001416                534  DELAY    EQU       *                Provide a time delay for the host 
00001416  48E7 8008                535           MOVEM.L   D0/A4,-(A7)      to settle. Save working registers 
0000141A  203C 00004000            536           MOVE.L    #$4000,D0        Set up delay constant 
00001420  5380                     537  DELAY1   SUB.L     #1,D0            Count down         (8 clk cycles) 
00001422  66FC                     538           BNE       DELAY1           Repeat until zero  (10 clk cycles) 
00001424  4CDF 1001                539           MOVEM.L   (A7)+,D0/A4      Restore working registers 
00001428  4E75                     540           RTS 
0000142A                           541  * 
0000142A                           542  ************************************************************************* 
0000142A                           543  * 
0000142A                           544  *  TM  Enter transparant mode (All communication to go from terminal to 
0000142A                           545  *  the host processor until escape sequence entered). End sequence 
0000142A                           546  *  = ESC, E. A newline is sent to the host to "clear it down". 
0000142A                           547  * 
0000142A                           548  *TM       MOVE.B    #$55,ACIA_1      Force RTS* high to re-route data 
0000142A                           549  *         ADD.B     #1,ECHO(A6)      Turn off character echo 
0000142A                           550  *TM1      BSR       GETCHAR          Get character 
0000142A                           551  *         CMP.B     #ESC,D0          Test for end of TM mode 
0000142A                           552  *         BNE       TM1              Repeat until first escape character 
0000142A                           553  *         BSR       GETCHAR          Get second character 
0000142A                           554  *         CMP.B     #'E',D0          If second char = E then exit TM 
0000142A                           555  *         BNE       TM1              Else continue 
0000142A                           556  *         MOVE.L    CN_OVEC(A6),-(A7) Save output port device name 
0000142A                           557  *         MOVE.L    #DCB4,CN_OVEC(A6) Get name of host port (aux port) 
0000142A                           558  *         BSR       NEWLINE          Send newline to host to clear it 
0000142A                           559  *         MOVE.L    (A7)+,CN_OVEC(A6) Restore output device port name 
0000142A                           560  *         CLR.B     ECHO(A6)         Restore echo mode 
0000142A                           561  *         MOVE.B    #$15,ACIA_1      Restore normal ACIA mode (RTS* low) 
0000142A                           562  *         RTS 
0000142A                           563  * 
0000142A                           564  ************************************************************************* 
0000142A                           565  * 
0000142A                           566  *  This routine sets up the system DCBs in RAM using the information 
0000142A                           567  *  stored in ROM at address DCB_LST. This is called at initialization. 
0000142A                           568  *  CN_IVEC contains the name "DCB1" and IO_VEC the name "DCB2" 
0000142A                           569  * 
0000142A  48E7 F0F0                570  SET_DCB  MOVEM.L A0-A3/D0-D3,-(A7) Save all working registers 
0000142E  41EE 00D8                571           LEA.L   FIRST(A6),A0    Pointer to first DCB destination in RAM 
00001432  43FA 0C02                572           LEA.L   DCB_LST(PC),A1  A1 points to DCB info block in ROM 
00001436  303C 0003                573           MOVE.W  #3,D0           4 DCBs to set up 
0000143A  323C 000F                574  ST_DCB1  MOVE.W  #15,D1          16 bytes to move per DCB header 
0000143E  10D9                     575  ST_DCB2  MOVE.B  (A1)+,(A0)+     Move the 16 bytes of a DCB header 
00001440  51C9 FFFC                576           DBRA    D1,ST_DCB2      from ROM to RAM 
00001444  3619                     577           MOVE.W  (A1)+,D3        Get size of parameter block (bytes) 
00001446  3083                     578           MOVE.W  D3,(A0)         Store size in DCB in RAM 
00001448  41F0 3002                579           LEA.L   2(A0,D3.W),A0   A0 points to tail of DCB in RAM 
0000144C  47E8 0004                580           LEA.L   4(A0),A3        A3 contains address of next DCB in RAM 
00001450  208B                     581           MOVE.L  A3,(A0)         Store pointer to next DCB in this DCB 
00001452  41D3                     582           LEA.L   (A3),A0         A0 now points at next DCB in RAM 
00001454  51C8 FFE4                583           DBRA    D0,ST_DCB1      Repeat until all DCBs set up 
00001458  47EB FFFC                584           LEA.L   -4(A3),A3       Adjust A3 to point to last DCB pointer 
0000145C  4293                     585           CLR.L   (A3)            and force last pointer to zero 
0000145E  2D7C 00002036 0056       586           MOVE.L  #DCB1,CN_IVEC(A6) Set up vector to console input DCB 
00001466  2D7C 00002048 005A       587           MOVE.L  #DCB2,CN_OVEC(A6) Set up vector to console output DCB 
0000146E  4CDF 0F0F                588           MOVEM.L (A7)+,A0-A3/D0-D3 Restore registers 
00001472  4E75                     589           RTS 
00001474                           590  * 
00001474                           591  ************************************************************************* 
00001474                           592  * 
00001474                           593  *  IO_REQ handles all input/output transactions. A0 points to DCB on 
00001474                           594  *  entry. IO_REQ calls the device driver whose address is in the DCB. 
00001474                           595  * 
00001474  48E7 00C0                596  IO_REQ   MOVEM.L A0-A1,-(A7)     Save working registers 
00001478  43E8 0008                597           LEA.L   8(A0),A1        A1 points to device handler field in DCB 
0000147C  2251                     598           MOVE.L  (A1),A1         A1 contains device handler address 
0000147E  4E91                     599           JSR     (A1)            Call device handler 
00001480  4CDF 0300                600           MOVEM.L (A7)+,A0-A1     Restore working registers 
00001484  4E75                     601           RTS 
00001486                           602  * 
00001486                           603  ************************************************************************* 
00001486                           604  * 
00001486                           605  *  CON_IN handles input from the console device 
00001486                           606  *  This is the device driver used by DCB1. Exit with input in D0 
00001486                           607  * 
00001486  48E7 4040                608  CON_IN   MOVEM.L D1/A1,-(A7)     Save working registers 
0000148A  43E8 000C                609           LEA.L   12(A0),A1       Get pointer to ACIA from DCB 
0000148E  2251                     610           MOVE.L  (A1),A1         Get address of ACIA in A1 
00001490  4228 0013                611           CLR.B   19(A0)          Clear logical error in DCB 
00001494  1211                     612  CON_I1   MOVE.B  (A1),D1         Read ACIA status 
00001496  0801 0000                613           BTST  #0,D1           Test RDRF 
0000149A  67F8                     614           BEQ     CON_I1          Repeat until RDRF true 
0000149C  1141 0012                615           MOVE.B  D1,18(A0)       Store physical status in DCB 
000014A0  C23C 00F4                616           AND.B   #%011110100,D1  Mask to input error bits 
000014A4  6706                     617           BEQ.S   CON_I2          If no error then skip update 
000014A6  117C 0001 0013           618           MOVE.B  #1,19(A0)       Else update logical error 
000014AC  1029 0002                619  CON_I2   MOVE.B  2(A1),D0        Read input from ACIA 
000014B0  4CDF 0202                620           MOVEM.L (A7)+,A1/D1     Restore working registers 
000014B4  4E75                     621           RTS 
000014B6                           622  * 
000014B6                           623  ************************************************************************* 
000014B6                           624  * 
000014B6                           625  *   This is the device driver used by DCB2. Output in D0 
000014B6                           626  *   The output can be halted or suspended 
000014B6                           627  * 
000014B6  48E7 6040                628  CON_OUT  MOVEM.L A1/D1-D2,-(A7)  Save working registers 
000014BA  43E8 000C                629           LEA.L   12(A0),A1       Get pointer to ACIA from DCB 
000014BE  2251                     630           MOVE.L  (A1),A1         Get address of ACIA in A1 
000014C0  4228 0013                631           CLR.B   19(A0)          Clear logical error in DCB 
000014C4  1211                     632  CON_OT1  MOVE.B  (A1),D1         Read ACIA status 
000014C6  0801 0000                633           BTST  #0,D1           Test RDRF bit (any input?) 
000014CA  6716                     634           BEQ.S   CON_OT3         If no input then test output status 
000014CC  1429 0002                635           MOVE.B  2(A1),D2        Else read the input 
000014D0  C43C 005F                636           AND.B   #%01011111,D2   Strip parity and bit 5 
000014D4  B43C 0057                637           CMP.B   #WAIT,D2        and test for a wait condition 
000014D8  6608                     638           BNE.S   CON_OT3         If not wait then ignore and test O/P 
000014DA  1411                     639  CON_OT2  MOVE.B  (A1),D2         Else read ACIA status register 
000014DC  0802 0000                640           BTST  #0,D2           and poll ACIA until next char received 
000014E0  67F8                     641           BEQ     CON_OT2 
000014E2  0801 0001                642  CON_OT3  BTST  #1,D1           Repeat 
000014E6  67DC                     643           BEQ     CON_OT1          until ACIA Tx ready 
000014E8  1141 0012                644           MOVE.B  D1,18(A0)       Store status in DCB physical error 
000014EC  1340 0002                645           MOVE.B  D0,2(A1)        Transmit output 
000014F0  4CDF 0206                646           MOVEM.L (A7)+,A1/D1-D2  Restore working registers 
000014F4  4E75                     647           RTS 
000014F6                           648  * 
000014F6                           649  ************************************************************************* 
000014F6                           650  * 
000014F6                           651  *  AUX_IN and AUX_OUT are simplified versions of CON_IN and 
000014F6                           652  *  CON_OUT for use with the port to the host processor 
000014F6                           653  * 
000014F6  43E8 000C                654  AUX_IN   LEA.L   12(A0),A1       Get pointer to aux ACIA from DCB 
000014FA  2251                     655           MOVE.L  (A1),A1         Get address of aux ACIA 
000014FC  0811 0000                656  AUX_IN1  BTST.B  #0,(A1)         Test for data ready 
00001500  67FA                     657           BEQ     AUX_IN1         Repeat until ready 
00001502  1029 0002                658           MOVE.B  2(A1),D0        Read input 
00001506  4E75                     659           RTS 
00001508                           660  * 
00001508  43E8 000C                661  AUX_OUT  LEA.L   12(A0),A1       Get pointer to aux ACIA from DCB 
0000150C  2251                     662           MOVE.L  (A1),A1         Get address of aux ACIA 
0000150E  0811 0001                663  AUX_OT1  BTST.B  #1,(A1)         Test for ready to transmit 
00001512  67FA                     664           BEQ     AUX_OT1         Repeat until transmitter ready 
00001514  1340 0002                665           MOVE.B  D0,2(A1)        Transmit data 
00001518  4E75                     666           RTS 
0000151A                           667  * 
0000151A                           668  ************************************************************************* 
0000151A                           669  * 
0000151A                           670  *  GETCHAR gets a character from the console device 
0000151A                           671  *  This is the main input routine and uses the device whose name  
0000151A                           672  *  is stored in CN_IVEC. Changing this name redirects input. 
0000151A                           673  * 
0000151A  2F08                     674  GETCHAR  MOVE.L  A0,-(A7)        Save working register 
0000151C  206E 0056                675           MOVE.L  CN_IVEC(A6),A0  A0 points to name of console DCB 
00001520  616C                     676           BSR.S   IO_OPEN         Open console (get DCB address in A0) 
00001522  0807 0003                677           BTST    #3,D7           D7(3) set if open error 
00001526  6628                     678           BNE.S   GETCH3          If error then exit now 
00001528  6100 FF4A                679           BSR     IO_REQ          Else execute I/O transaction 
0000152C  C03C 007F                680           AND.B   #$7F,D0         Strip msb of input 
00001530  4A2E 0051                681           TST.B   U_CASE(A6)      Test for upper -> lower case conversion 
00001534  660A                     682           BNE.S   GETCH2          If flag not zero do not convert case 
00001536  0800 0006                683           BTST    #6,D0           Test input for lower case 
0000153A  6704                     684           BEQ.S   GETCH2          If upper case then skip conversion 
0000153C  C03C 00DF                685           AND.B   #%11011111,D0   Else clear bit 5 for upper case conv 
00001540  4A2E 0050                686  GETCH2   TST.B   ECHO(A6)        Do we need to echo the input? 
00001544  660A                     687           BNE.S   GETCH3          If ECHO not zero then no echo
00001546  BC3C 0001                688           CMP.B   #1,D6
0000154A  6700 000A                689           BEQ     PUTASK
0000154E  6118                     690           BSR.S   PUTCHAR         Else echo the input 
00001550  205F                     691  GETCH3   MOVE.L  (A7)+,A0        Restore working register 
00001552  6000 FB52                692           BRA     GETLNR          and return 
00001556                           693  
00001556  B07C 000D                694  PUTASK   CMP     #CR,D0
0000155A  6700 0020                695           BEQ     SPUTCHAR
0000155E  1600                     696           MOVE.B  D0,D3           save D0
00001560  103C 002A                697           MOVE.B  #42,D0
00001564  6000 0016                698           BRA    SPUTCHAR
00001568                           699  
00001568                           700  * 
00001568                           701  ************************************************************************* 
00001568                           702  * 
00001568                           703  *  PUTCHAR sends a character to the console device 
00001568                           704  *  The name of the output device is in CN_OVEC. 
00001568                           705  * 
00001568  BC3C 0001                706  PUTCHAR  CMP.B   #1,D6
0000156C                           707           ;BEQ     PUTASK
0000156C  2F08                     708           MOVE.L  A0,-(A7)        Save working register
0000156E  206E 005A                709           MOVE.L  CN_OVEC(A6),A0  A0 points to name of console output 
00001572  611A                     710           BSR.S   IO_OPEN         Open console (Get address of DCB) 
00001574  6100 FEFE                711           BSR     IO_REQ          Perform output with DCB pointed at by A0 
00001578  205F                     712           MOVE.L  (A7)+,A0        Restore working register 
0000157A  4E75                     713           RTS 
0000157C                           714  
0000157C  2F08                     715  SPUTCHAR  MOVE.L  A0,-(A7)        Save working register
0000157E  206E 005A                716            MOVE.L  CN_OVEC(A6),A0  A0 points to name of console output 
00001582  610A                     717            BSR.S   IO_OPEN         Open console (Get address of DCB) 
00001584  6100 FEEE                718            BSR     IO_REQ          Perform output with DCB pointed at by A0 
00001588  205F                     719            MOVE.L  (A7)+,A0        Restore working register
0000158A  1003                     720            MOVE.B  D3,D0           restore d0
0000158C  60C2                     721            BRA     GETCH3 
0000158E                           722  
0000158E                           723  
0000158E                           724  * 
0000158E                           725  * 
0000158E                           726  ************************************************************************* 
0000158E                           727  * 
0000158E                           728  *  BUFF_IN and BUFF_OUT are two rudimentary input and output routines 
0000158E                           729  *  which input data from and output data to a buffer in RAM. These are 
0000158E                           730  *  used by DCB5 and DCB6, respectively. 
0000158E                           731  * 
0000158E                           732  *BUFF_IN  LEA.L   12(A0),A1       A1 points to I/P buffer 
0000158E                           733  *         MOVE.L  (A1),A2         A2 gets I/P pointer from buffer 
0000158E                           734  *         MOVE.B  -(A2),D0        Read char from buffer and adjust A2 
0000158E                           735  *         MOVE.L  A2,(A1)         Restore pointer in buffer 
0000158E                           736  *         RTS 
0000158E                           737  * 
0000158E                           738  *BUFF_OT  LEA.L   12(A0),A1       A1 points to O/P buffer 
0000158E                           739  *         MOVE.L  4(A1),A2        A2 gets O/P pointer from buffer 
0000158E                           740  *         MOVE.B  D0,(A2)+        Store char in buffer and adjust A2 
0000158E                           741  *         MOVE.L  A2,(A1)         Restore pointer in buffer 
0000158E                           742  *         RTS 
0000158E                           743  * 
0000158E                           744  ************************************************************************* 
0000158E                           745  * 
0000158E                           746  *  Open - opens a DCB for input or output. IO_OPEN converts the 
0000158E                           747  *  name pointed at by A0 into the address of the DCB pointed at 
0000158E                           748  *  by A0. Bit 3 of D7 is set to zero if DCB not found 
0000158E                           749  * 
0000158E  48E7 F870                750  IO_OPEN  MOVEM.L  A1-A3/D0-D4,-(A7) Save working registers 
00001592  43EE 00D8                751           LEA.L    FIRST(A6),A1   A1 points to first DCB in chain in RAM 
00001596  45D1                     752  OPEN1    LEA.L    (A1),A2        A2 = temp copy of pointer to DCB 
00001598  47D0                     753           LEA.L    (A0),A3        A3 = temp copy of pointer to DCB name 
0000159A  303C 0007                754           MOVE.W   #7,D0          Up to 8 chars of DCB name to match 
0000159E  181A                     755  OPEN2    MOVE.B   (A2)+,D4       Compare DCB name with string 
000015A0  B81B                     756           CMP.B    (A3)+,D4 
000015A2  6608                     757           BNE.S    OPEN3          If no match try next DCB 
000015A4  51C8 FFF8                758           DBRA     D0,OPEN2       Else repeat until all chars matched 
000015A8  41D1                     759           LEA.L    (A1),A0        Success - move this DCB address to A0 
000015AA  6016                     760           BRA.S    OPEN4          and return 
000015AC  =000015AC                761  OPEN3    EQU      *              Fail - calculate address of next DCB 
000015AC  3229 0010                762           MOVE.W   16(A1),D1      Get parameter block size of DCB 
000015B0  43F1 1012                763           LEA.L    18(A1,D1.W),A1 A1 points to pointer to next DCB 
000015B4  2251                     764           MOVE.L   (A1),A1        A1 now points to next DCB 
000015B6  B3FC 00000000            765           CMP.L    #0,A1          Test for end of DCB chain 
000015BC  66D8                     766           BNE      OPEN1          If not end of chain then try next DCB 
000015BE  8E3C 0008                767           OR.B     #8,D7          Else set error flag and return 
000015C2  4CDF 0E1F                768  OPEN4    MOVEM.L  (A7)+,A1-A3/D0-D4 Restore working registers 
000015C6  4E75                     769           RTS 
000015C8                           770  * 
000015C8                           771  ************************************************************************* 
000015C8                           772  * 
000015C8                           773  *  Exception vector table initialization routine 
000015C8                           774  *  All vectors not setup are loaded with uninitialized routine vector 
000015C8                           775  * 
000015C8  303C 0007                776  B_CLR   MOVE.W  #7,D0             Now clear the breakpoint table 
000015CC  41EE 00A8                777          LEA.L   BP_TAB(A6),A0     Point to table
000015D0  4E75                     778          RTS 
000015D2                           779  *X_SET2  CLR.L   (A0)+             Clear an address entry 
000015D2                           780  *        CLR.W   (A0)+             Clear the corresponding data 
000015D2                           781  *        DBRA    D0,X_SET2         Repeat until all 8 cleared 
000015D2                           782  *        RTS 
000015D2                           783  * 
000015D2                           784  ************************************************************************* 
000015D2                           785  * 
000015D2                           786  *TRAP_0  EQU     *                 User links to  TS2BUG via TRAP #0 
000015D2                           787  *FUNC0   CMP.B   #0,D1             D1 = 0 = Get character 
000015D2                           788  *        BNE.S   FUNC1           
000015D2                           789  *        BSR     GETCHAR 
000015D2                           790  *        RTE 
000015D2                           791  *FUNC1   CMP.B   #1,D1             D1 = 1 = Print character 
000015D2                           792  *        BNE.S   FUNC2 
000015D2                           793  *        BSR     PUTCHAR 
000015D2                           794  *        RTE 
000015D2                           795  *FUNC2   CMP.B   #2,D1             D1 = 2 = Newline 
000015D2                           796  *        BNE.S   FUNC3 
000015D2                           797  *        BSR     NEWLINE 
000015D2                           798  *        RTE 
000015D2                           799  *FUNC3   CMP.B   #3,D1             D1 = 3 = Get parameter from buffer 
000015D2                           800  *        BNE.S   FUNC4 
000015D2                           801  *        BSR     PARAM 
000015D2                           802  *        RTE 
000015D2                           803  *FUNC4   CMP.B   #4,D1             D1 = 4 = Print string pointed at by A4 
000015D2                           804  *        BNE.S   FUNC5 
000015D2                           805  *        BSR     PSTRING 
000015D2                           806  *        RTE 
000015D2                           807  *FUNC5   CMP.B   #5,D1             D1 = 5 = Get a hex character 
000015D2                           808  *        BNE.S   FUNC6 
000015D2                           809  *        BSR     HEX 
000015D2                           810  *        RTE 
000015D2                           811  *FUNC6   CMP.B   #6,D1             D1 = 6 = Get a hex byte 
000015D2                           812  *        BNE.S   FUNC7 
000015D2                           813  *        BSR     BYTE 
000015D2                           814  *        RTE 
000015D2                           815  *FUNC7   CMP.B   #7,D1             D1 = 7 = Get a word 
000015D2                           816  *        BNE.S   FUNC8 
000015D2                           817  *        BSR     WORD 
000015D2                           818  *        RTE 
000015D2                           819  *FUNC8   CMP.B   #8,D1             D1 = 8 = Get a longword 
000015D2                           820  *        BNE.S   FUNC9 
000015D2                           821  *        BSR     LONGWD 
000015D2                           822  *        RTE 
000015D2                           823  *FUNC9   CMP.B   #9,D1             D1 = 9 = Output hex byte 
000015D2                           824  *        BNE.S   FUNC10  
000015D2                           825  *        BSR     OUT2X 
000015D2                           826  *        RTE 
000015D2                           827  *FUNC10  CMP.B   #10,D1            D1 = 10 = Output hex word 
000015D2                           828  *        BNE.S   FUNC11 
000015D2                           829  *        BSR     OUT4X 
000015D2                           830  *        RTE 
000015D2                           831  *FUNC11  CMP.B   #11,D1            D1 = 11 = Output hex longword 
000015D2                           832  *        BNE.S   FUNC12 
000015D2                           833  *        BSR     OUT8X 
000015D2                           834  *        RTE 
000015D2                           835  *FUNC12  CMP.B   #12,D1            D1 = 12 = Print a space 
000015D2                           836  *        BNE.S   FUNC13 
000015D2                           837  *        BSR     PSPACE 
000015D2                           838  *        RTE 
000015D2                           839  *FUNC13  CMP.B   #13,D1            D1 = 13 = Get a line of text into 
000015D2                           840  *        BNE.S   FUNC14            the line buffer 
000015D2                           841  *        BSR     GETLINE 
000015D2                           842  *        RTE 
000015D2                           843  *FUNC14  CMP.B   #14,D1            D1 = 14 = Tidy up the line in the 
000015D2                           844  *        BNE.S   FUNC15            line buffer by removing leading 
000015D2                           845  *        BSR     TIDY              leading and multiple embeded spaces 
000015D2                           846  *        RTE 
000015D2                           847  *FUNC15  CMP.B   #15,D1            D1 = 15 = Execute the command in 
000015D2                           848  *        BNE.S   FUNC16            the line buffer 
000015D2                           849  *        BSR     EXECUTE 
000015D2                           850  *        RTE 
000015D2                           851  *FUNC16  CMP.B   #16,D1            D1 = 16 = Call RESTORE to transfer 
000015D2                           852  *        BNE.S   FUNC17            the registers in TSK_T to the 68000 
000015D2                           853  *        BSR     RESTORE           and therefore execute a program 
000015D2                           854  *        RTE 
000015D2                           855  *FUNC17  RTE 
000015D2                           856  * 
000015D2                           857  ************************************************************************* 
000015D2                           858  * 
000015D2                           859  *  Display exception frame (D0 - D7, A0 - A6, USP, SSP, SR, PC) 
000015D2                           860  *  EX_DIS prints registers saved after a breakpoint or exception 
000015D2                           861  *  The registers are saved in TSK_T 
000015D2                           862  * 
000015D2  4BEE 005E                863  EX_DIS  LEA.L   TSK_T(A6),A5      A5 points to display frame 
000015D6  49FA 0546                864          LEA.L   MES3(PC),A4       Point to heading 
000015DA  6100 FAB6                865          BSR     HEADING           and print it 
000015DE  3C3C 0007                866          MOVE.W  #7,D6             8 pairs of registers to display 
000015E2  4205                     867          CLR.B   D5                D5 is the line counter 
000015E4  1005                     868  EX_D1   MOVE.B  D5,D0             Put current register number in D0 
000015E6  6100 FC12                869          BSR     OUT1X             and print it 
000015EA  6100 FCA8                870          BSR     PSPACE            and a space 
000015EE  5205                     871          ADD.B   #1,D5             Update counter for next pair 
000015F0  2015                     872          MOVE.L  (A5),D0           Get data register to be displayed 
000015F2  6100 FC30                873          BSR     OUT8X             from the frame and print it 
000015F6  49FA 0544                874          LEA.L   MES4(PC),A4       Print string of spaces 
000015FA  6100 FA86                875          BSR.L   PSTRING           between data and address registers 
000015FE  202D 0020                876          MOVE.L  32(A5),D0         Get address register to be displayed 
00001602  6100 FC20                877          BSR     OUT8X             which is 32 bytes on from data reg 
00001606  6100 FA6A                878          BSR     NEWLINE 
0000160A  4BED 0004                879          LEA.L   4(A5),A5          Point to next pair (ie Di, Ai) 
0000160E  51CE FFD4                880          DBRA    D6,EX_D1          Repeat until all displayed 
00001612  4BED 0020                881          LEA.L   32(A5),A5         Adjust pointer by 8 longwords 
00001616  6100 FA5A                882          BSR     NEWLINE           to point to SSP 
0000161A  49FA 04F9                883          LEA.L   MES2A(PC),A4      Point to "SS =" 
0000161E  6100 FA62                884          BSR     PSTRING           Print it 
00001622  201D                     885          MOVE.L  (A5)+,D0          Get SSP from frame 
00001624  6100 FBFE                886          BSR     OUT8X             and display it 
00001628  6100 FA48                887          BSR     NEWLINE 
0000162C  49FA 04D5                888          LEA.L   MES1(PC),A4       Point to 'SR =' 
00001630  6100 FA50                889          BSR     PSTRING           Print it 
00001634  301D                     890          MOVE.W  (A5)+,D0          Get status register 
00001636  6100 FBE4                891          BSR     OUT4X             Display status 
0000163A  6100 FA36                892          BSR     NEWLINE 
0000163E  49FA 04CC                893          LEA.L   MES2(PC),A4       Point to 'PC =' 
00001642  6100 FA3E                894          BSR     PSTRING           Print it 
00001646  201D                     895          MOVE.L  (A5)+,D0          Get PC 
00001648  6100 FBDA                896          BSR     OUT8X             Display PC 
0000164C  6000 FA24                897          BRA     NEWLINE           Newline and return 
00001650                           898  * 
00001650                           899  ************************************************************************* 
00001650                           900  
00001650  49F9 00001C61            901  HELP     LEA.L    JUMPHELP,A4
00001656  6100 FA2A                902           BSR.W    PSTRING
0000165A  6100 FA16                903           BSR.W    NEWLINE
0000165E  49F9 00001C97            904           LEA.L    MEMHELP,A4
00001664  6100 FA1C                905           BSR.W    PSTRING
00001668  6100 FA08                906           BSR.W    NEWLINE
0000166C  49F9 00001CE4            907           LEA.L    LOADHELP,A4
00001672  6100 FA0E                908           BSR.W    PSTRING
00001676  6100 F9FA                909           BSR.W    NEWLINE
0000167A  49F9 00001D2E            910           LEA.L    TVHELP,A4
00001680  6100 FA00                911           BSR.W    PSTRING
00001684  4E75                     912           RTS
00001686                           913  
00001686                           914  *      
00001686                           915  *************************************************************************
00001686  B83C 0002                916  LOGIN    CMP.B    #2,D4
0000168A  6700 00C2                917           BEQ      QUIT
0000168E  49F9 00001D9B            918           LEA.L    LOGINM1,A4
00001694  6100 F9EC                919           BSR.W    PSTRING           
00001698  6100 F9D8                920           BSR.W    NEWLINE
0000169C  6100 F9FA                921           BSR      GETLINE
000016A0  49F9 00001D8D            922           LEA.L    UNAME,A4
000016A6  1A19                     923  LOGIN1   MOVE.B   (A1)+,D5
000016A8  BA1C                     924           CMP.B    (A4)+,D5
000016AA  67FA                     925           BEQ      LOGIN1            iterate through checking each char
000016AC  0C21 000D                926           CMP.B    #CR,-(A1)         check for carriage return
000016B0  6600 006A                927           BNE      WRONG             if not then wrong input
000016B4  0C24 0000                928           CMP.B    #NUL,-(A4)        check for end of stored string
000016B8  6600 0062                929           BNE      WRONG             if not then wrong input
000016BC  49F9 00001DD0            930           LEA.L    USRSUC,A4         print success
000016C2  6100 F9BE                931           BSR.W    PSTRING
000016C6  6100 F9AA                932           BSR.W    NEWLINE
000016CA  49F9 00001DAC            933           LEA.L    LOGINM2,A4
000016D0  6100 F9B0                934           BSR.W    PSTRING
000016D4  6100 F99C                935           BSR.W    NEWLINE
000016D8  1C3C 0001                936           MOVE.B   #1,D6
000016DC  6100 F9BA                937           BSR.W    GETLINE
000016E0  1C3C 0000                938           MOVE.B   #0,D6
000016E4  49F9 00001D92            939           LEA.L    PWORD,A4
000016EA  1A19                     940  LOGIN2   MOVE.B   (A1)+,D5
000016EC  BA1C                     941           CMP.B    (A4)+,D5
000016EE  67FA                     942           BEQ      LOGIN2            iterate through checking each char
000016F0  0C21 000D                943           CMP.B    #CR,-(A1)          check for carriage return
000016F4  6600 0026                944           BNE      WRONG             if not then wrong input
000016F8  0C24 0000                945           CMP.B    #NUL,-(A4)            check for end of stored string
000016FC  6600 0032                946           BNE      WRONGPW             if not then wrong input
00001700  49F9 00001DF4            947           LEA.L    PWSUC,A4
00001706  6000 F97A                948           BRA      PSTRING
0000170A  49F9 00001D9B            949           LEA.L    LOGINM1,A4
00001710  6100 F970                950           BSR.W    PSTRING           print success
00001714  6100 F95C                951           BSR.W    NEWLINE
00001718  6000 F932                952           BRA      WARM
0000171C                           953  
0000171C  49F9 00001DBD            954  WRONG    LEA.L    USRERR,A4   
00001722  6100 F95E                955           BSR.W    PSTRING
00001726  6100 F94A                956           BSR.W    NEWLINE
0000172A  5204                     957           ADD.B    #1,D4
0000172C  6000 FF58                958           BRA      LOGIN
00001730                           959  
00001730  49F9 00001DE1            960  WRONGPW  LEA.L    PWERR,A4   
00001736  6100 F94A                961           BSR.W    PSTRING
0000173A  6100 F936                962           BSR.W    NEWLINE
0000173E  5204                     963           ADD.B    #1,D4
00001740  6000 FF44                964           BRA      LOGIN
00001744                           965  
00001744  49F9 00001DD0            966  UPASS    LEA.L    USRSUC,A4
0000174A  6000 F936                967           BRA      PSTRING  
0000174E                           968  
0000174E  4EF8 174E                969  QUIT     JMP      QUIT
00001752                           970  
00001752                           971  *
00001752                           972  ************************************************************************* 
00001752  2878 03D8                973  TV       MOVE.L   MIN_RAM,A4
00001756  1C3C 0000                974           MOVE.B   #0,D6
0000175A  323C 0000                975  LOOPRAM  MOVE.W   #0,D1
0000175E  3881                     976           MOVE.W   D1,(A4)
00001760  49EC 0002                977           LEA.L    2(A4),A4          Point to next address to display
00001764  B9F8 03DC                978           CMP.L    MAX_RAM,A4
00001768  66F0                     979           BNE      LOOPRAM
0000176A  2878 03D8                980           MOVE.L   MIN_RAM,A4
0000176E  3214                     981  CHECK1   MOVE.W   (A4),D1
00001770  B27C 0000                982           CMP.W    #0,D1
00001774  6600 0042                983           BNE      MEMFAIL           
00001778  49EC 0002                984  CHECK2   LEA.L    2(A4),A4          Point to next address to read
0000177C  B9F8 03DC                985           CMP.L    MAX_RAM,A4
00001780  66EC                     986           BNE      CHECK1
00001782  2878 03D8                987           MOVE.L   MIN_RAM,A4
00001786  323C FFFF                988  LOOPRAM1 MOVE.W   #65535,D1
0000178A  3881                     989           MOVE.W   D1,(A4)
0000178C  49EC 0002                990           LEA.L    2(A4),A4          Point to next address to display
00001790  B9F8 03DC                991           CMP.L    MAX_RAM,A4
00001794  66F0                     992           BNE      LOOPRAM1
00001796  2878 03D8                993           MOVE.L   MIN_RAM,A4
0000179A  3214                     994  CHECK3   MOVE.W   (A4),D1
0000179C  B27C FFFF                995           CMP.W    #65535,D1
000017A0  6600 0032                996           BNE      MEMFAIL2
000017A4  49EC 0002                997  CHECK4   LEA.L    2(A4),A4          Point to next address to read
000017A8  B9F8 03DC                998           CMP.L    MAX_RAM,A4
000017AC  66EC                     999           BNE      CHECK3
000017AE  BC3C 0000               1000           CMP.B    #0,D6
000017B2  6700 003C               1001           BEQ      MEMGOOD
000017B6  4E75                    1002           RTS
000017B8                          1003  
000017B8  2F0C                    1004  MEMFAIL  MOVE.L  A4,-(A7)          Save A4 
000017BA  7C01                    1005           MOVE.L  #1,D6
000017BC  6100 F8B4               1006           BSR.W   NEWLINE
000017C0  49F9 00001E05           1007           LEA.L   MEMFMSG,A4
000017C6  6100 F8BA               1008           BSR.W   PSTRING
000017CA  285F                    1009           MOVE.L  (A7)+,A4          Restore A4
000017CC  200C                    1010           MOVE.L  A4,D0
000017CE  6100 FA54               1011           BSR.W    OUT8X 
000017D2  60A4                    1012           BRA     CHECK2
000017D4                          1013  
000017D4  2F0C                    1014  MEMFAIL2 MOVE.L  A4,-(A7)          Save A4 
000017D6  7C01                    1015           MOVE.L  #1,D6
000017D8  6100 F898               1016           BSR.W   NEWLINE
000017DC  49F9 00001E05           1017           LEA.L   MEMFMSG,A4
000017E2  6100 F89E               1018           BSR.W   PSTRING
000017E6  285F                    1019           MOVE.L  (A7)+,A4          Restore A4
000017E8  200C                    1020           MOVE.L  A4,D0
000017EA  6100 FA38               1021           BSR.W    OUT8X 
000017EE  60B4                    1022           BRA     CHECK4         
000017F0                          1023   
000017F0  49F9 00001E15           1024  MEMGOOD  LEA.L  MEMGMSG,A4
000017F6  6100 F88A               1025           BSR.W  PSTRING
000017FA  4E75                    1026           RTS
000017FC                          1027  *************************************************************************
000017FC                          1028  * 
000017FC                          1029  *  Exception handling routines 
000017FC                          1030  * 
000017FC  =000017FC               1031  IL_ER   EQU      *                Illegal instruction exception 
000017FC  2F0C                    1032          MOVE.L  A4,-(A7)          Save A4 
000017FE  49FA 0366               1033          LEA.L   MES10(PC),A4      Point to heading 
00001802  6100 F88E               1034          BSR     HEADING           Print it 
00001806  285F                    1035          MOVE.L  (A7)+,A4          Restore A4 
00001808  6176                    1036          BSR.S   GROUP2            Save registers in display frame 
0000180A  6100 FDC6               1037          BSR     EX_DIS            Display registers saved in frame 
0000180E  6000 F83C               1038          BRA     WARM              Abort from illegal instruction 
00001812                          1039  * 
00001812  =00001812               1040  BUS_ER  EQU     *                 Bus error (group 1) exception 
00001812  2F0C                    1041          MOVE.L  A4,-(A7)          Save A4 
00001814  49FA 0330               1042          LEA.L   MES8(PC),A4       Point to heading 
00001818  6100 F878               1043          BSR     HEADING           Print it 
0000181C  285F                    1044          MOVE.L  (A7)+,A4          Restore A4 
0000181E  602C                    1045          BRA.S   GROUP1            Deal with group 1 exception 
00001820                          1046  * 
00001820  =00001820               1047  ADD_ER  EQU     *                 Address error (group 1) exception 
00001820  2F0C                    1048          MOVE.L  A4,-(A7)          Save A4 
00001822  49FA 0330               1049          LEA.L   MES9(PC),A4       Point to heading 
00001826  6100 F86A               1050          BSR     HEADING           Print it 
0000182A  285F                    1051          MOVE.L  (A7)+,A4          Restore A4 
0000182C  601E                    1052          BRA.S   GROUP1            Deal with group 1 exception 
0000182E                          1053  * 
0000182E  =0000182E               1054  BRKPT   EQU     *                   Deal with breakpoint 
0000182E  48E7 FFFE               1055          MOVEM.L D0-D7/A0-A6,-(A7)   Save all registers 
00001832  6100 0180               1056          BSR     BR_CLR              Clear breakpoints in code 
00001836  4CDF 7FFF               1057          MOVEM.L (A7)+,D0-D7/A0-A6   Restore registers 
0000183A  6144                    1058          BSR.S   GROUP2            Treat as group 2 exception 
0000183C  49FA 033E               1059          LEA.L   MES11(PC),A4      Point to heading 
00001840  6100 F850               1060          BSR     HEADING           Print it 
00001844  6100 FD8C               1061          BSR     EX_DIS            Display saved registers 
00001848  6000 F802               1062          BRA     WARM              Return to monitor 
0000184C                          1063  * 
0000184C                          1064  *       GROUP1 is called by address and bus error exceptions 
0000184C                          1065  *       These are "turned into group 2" exceptions (eg TRAP) 
0000184C                          1066  *       by modifying the stack frame saved by a group 1 exception 
0000184C                          1067  * 
0000184C  48E7 8080               1068  GROUP1  MOVEM.L D0/A0,-(A7)       Save working registers 
00001850  206F 0012               1069          MOVE.L  18(A7),A0         Get PC from group 1 stack frame 
00001854  302F 000E               1070          MOVE.W  14(A7),D0         Get instruction from stack frame 
00001858  B060                    1071          CMP.W   -(A0),D0          Now backtrack to find the "correct PC" 
0000185A  670E                    1072          BEQ.S   GROUP1A           by matching the op-code on the stack 
0000185C  B060                    1073          CMP.W   -(A0),D0          with the code in the region of the 
0000185E  670A                    1074          BEQ.S   GROUP1A           PC on the stack 
00001860  B060                    1075          CMP.W   -(A0),D0 
00001862  6706                    1076          BEQ.S   GROUP1A 
00001864  B060                    1077          CMP.W   -(A0),D0 
00001866  6702                    1078          BEQ.S   GROUP1A 
00001868  5588                    1079          SUBQ.L  #2,A0 
0000186A  2F48 0012               1080  GROUP1A MOVE.L  A0,18(A7)          Restore modified PC to stack frame 
0000186E  4CDF 0101               1081          MOVEM.L (A7)+,D0/A0        Restore working registers 
00001872  4FEF 0008               1082          LEA.L   8(A7),A7           Adjust stack pointer to group 1 type 
00001876  6108                    1083          BSR.S   GROUP2             Now treat as group 1 exception 
00001878  6100 FD58               1084          BSR     EX_DIS             Display contents of exception frame 
0000187C  6000 F7CE               1085          BRA     WARM               Exit to monitor - no RTE from group 2 
00001880                          1086  * 
00001880  =00001880               1087  GROUP2  EQU     *                 Deal with group 2 exceptions 
00001880  48E7 FFFF               1088          MOVEM.L A0-A7/D0-D7,-(A7) Save all registers on the stack 
00001884  303C 000E               1089          MOVE.W  #14,D0            Transfer D0 - D7, A0 - A6 from 
00001888  41EE 005E               1090          LEA.L   TSK_T(A6),A0      the stack to the display frame 
0000188C  20DF                    1091  GROUP2A MOVE.L  (A7)+,(A0)+       Move a register from stack to frame 
0000188E  51C8 FFFC               1092          DBRA    D0,GROUP2A        and repeat until D0-D7/A0-A6 moved 
00001892  4E6A                    1093          MOVE.L  USP,A2            Get the user stack pointer and put it 
00001894  20CA                    1094          MOVE.L  A2,(A0)+          in the A7 position in the frame 
00001896  201F                    1095          MOVE.L  (A7)+,D0          Now transfer the SSP to the frame, 
00001898  0480 0000000A           1096          SUB.L   #10,D0            remembering to account for the 
0000189E  20C0                    1097          MOVE.L  D0,(A0)+          data pushed on the stack to this point 
000018A0  225F                    1098          MOVE.L  (A7)+,A1          Copy TOS (return address) to A1 
000018A2  30DF                    1099          MOVE.W  (A7)+,(A0)+       Move SR to display frame 
000018A4  201F                    1100          MOVE.L  (A7)+,D0          Get PC in D0 
000018A6  5580                    1101          SUBQ.L  #2,D0             Move back to current instruction 
000018A8  20C0                    1102          MOVE.L  D0,(A0)+          Put adjusted PC in display frame 
000018AA  4ED1                    1103          JMP     (A1)              Return from subroutine 
000018AC                          1104  * 
000018AC                          1105  ************************************************************************* 
000018AC                          1106  * 
000018AC                          1107  *  GO executes a program either from a supplied address or 
000018AC                          1108  *  by using the data in the display frame 
000018AC  6100 F908               1109  GO       BSR     PARAM               Get entry address (if any) 
000018B0  4A07                    1110           TST.B   D7                  Test for error in input 
000018B2  6708                    1111           BEQ.S   GO1                 If D7 zero then OK 
000018B4  49FA 032B               1112           LEA.L   ERMES1(PC),A4       Else point to error message, 
000018B8  6000 F7C8               1113           BRA     PSTRING             print it and return 
000018BC  4A80                    1114  GO1      TST.L   D0                  If no address entered then get 
000018BE  670A                    1115           BEQ.S   GO2                 address from display frame 
000018C0  2D40 00A4               1116           MOVE.L  D0,TSK_T+70(A6)     Else save address in display frame 
000018C4  3D7C 0700 00A2          1117           MOVE.W  #$0700,TSK_T+68(A6) Store dummy status in frame 
000018CA  6006                    1118  GO2      BRA.S   RESTORE             Restore volatile environment and go 
000018CC                          1119  * 
000018CC  6100 007A               1120  GB       BSR     BR_SET              Same as go but presets breakpoints 
000018D0  60DA                    1121           BRA.S   GO                  Execute program 
000018D2                          1122  * 
000018D2                          1123  *        RESTORE moves the volatile environment from the display 
000018D2                          1124  *        frame and transfers it to the 68000's registers. This 
000018D2                          1125  *        re-runs a program suspended after an exception 
000018D2                          1126  * 
000018D2  47EE 005E               1127  RESTORE  LEA.L   TSK_T(A6),A3        A3 points to display frame 
000018D6  47EB 004A               1128           LEA.L   74(A3),A3           A3 now points to end of frame + 4 
000018DA  4FEF 0004               1129           LEA.L   4(A7),A7            Remove return address from stack 
000018DE  303C 0024               1130           MOVE.W  #36,D0              Counter for 37 words to be moved 
000018E2  3F23                    1131  REST1    MOVE.W  -(A3),-(A7)         Move word from display frame to stack 
000018E4  51C8 FFFC               1132           DBRA    D0,REST1            Repeat until entire frame moved 
000018E8  4CDF 00FF               1133           MOVEM.L (A7)+,D0-D7         Restore old data registers from stack 
000018EC  4CDF 7F00               1134           MOVEM.L (A7)+,A0-A6         Restore old address registers 
000018F0  4FEF 0008               1135           LEA.L   8(A7),A7            Except SSP/USP - so adjust stack 
000018F4  4E73                    1136           RTE                         Return from exception to run program 
000018F6                          1137  * 
000018F6  =000018F6               1138  TRACE    EQU     *                   TRACE exception (rudimentary version) 
000018F6  287A 0292               1139           MOVE.L  MES12(PC),A4        Point to heading 
000018FA  6100 F796               1140           BSR     HEADING             Print it 
000018FE  6100 FF4C               1141           BSR     GROUP1              Save volatile environment 
00001902  6100 FCCE               1142           BSR     EX_DIS              Display it 
00001906  6000 F744               1143           BRA     WARM                Return to monitor 
0000190A                          1144  * 
0000190A                          1145  ************************************************************************* 
0000190A                          1146  *  Breakpoint routines: BR_GET gets the address of a breakpoint and 
0000190A                          1147  *  puts it in the breakpoint table. It does not plant it in the code. 
0000190A                          1148  *  BR_SET plants all breakpoints in the code. NOBR removes one or all 
0000190A                          1149  *  breakpoints from the table. KILL removes breakpoints from the code. 
0000190A                          1150  * 
0000190A  6100 F8AA               1151  BR_GET   BSR     PARAM               Get breakpoint address in table 
0000190E  4A07                    1152           TST.B   D7                  Test for input error 
00001910  6708                    1153           BEQ.S   BR_GET1             If no error then continue 
00001912  49FA 02CD               1154           LEA.L   ERMES1(PC),A4       Else display error 
00001916  6000 F76A               1155           BRA     PSTRING             and return 
0000191A  47EE 00A8               1156  BR_GET1  LEA.L   BP_TAB(A6),A3       A6 points to breakpoint table 
0000191E  2A40                    1157           MOVE.L  D0,A5               Save new BP address in A5 
00001920  2C00                    1158           MOVE.L  D0,D6               and in D6 because D0 gets corrupted 
00001922  3A3C 0007               1159           MOVE.W  #7,D5               Eight entries to test 
00001926  201B                    1160  BR_GET2  MOVE.L  (A3)+,D0            Read entry from breakpoint table 
00001928  660C                    1161           BNE.S   BR_GET3             If not zero display existing BP 
0000192A  4A86                    1162           TST.L   D6                  Only store a non-zero breakpoint 
0000192C  6710                    1163           BEQ.S   BR_GET4 
0000192E  274D FFFC               1164           MOVE.L  A5,-4(A3)           Store new breakpoint in table 
00001932  3695                    1165           MOVE.W  (A5),(A3)           Save code at BP address in table 
00001934  4286                    1166           CLR.L   D6                  Clear D6 to avoid repetition 
00001936  6100 F8EC               1167  BR_GET3  BSR     OUT8X               Display this breakpoint 
0000193A  6100 F736               1168           BSR     NEWLINE 
0000193E  47EB 0002               1169  BR_GET4  LEA.L   2(A3),A3            Step past stored op-code 
00001942  51CD FFE2               1170           DBRA    D5,BR_GET2          Repeat until all entries tested 
00001946  4E75                    1171           RTS                         Return 
00001948                          1172  * 
00001948  =00001948               1173  BR_SET   EQU     *                   Plant any breakpoints in user code 
00001948  41EE 00A8               1174           LEA.L   BP_TAB(A6),A0       A0 points to BP table 
0000194C  45EE 00A4               1175           LEA.L   TSK_T+70(A6),A2     A2 points to PC in display frame 
00001950  2452                    1176           MOVE.L  (A2),A2             Now A2 contains value of PC 
00001952  303C 0007               1177           MOVE.W  #7,D0               Up to eight entries to plant 
00001956  2218                    1178  BR_SET1  MOVE.L  (A0)+,D1            Read breakpoint address from table 
00001958  670A                    1179           BEQ.S   BR_SET2             If zero then skip planting 
0000195A  B28A                    1180           CMP.L   A2,D1               Don't want to plant BP at current PC 
0000195C  6706                    1181           BEQ.S   BR_SET2             location, so skip planting if same 
0000195E  2241                    1182           MOVE.L  D1,A1               Transfer BP address to address reg 
00001960  32BC 4E4E               1183           MOVE.W  #TRAP_14,(A1)       Plant op-code for TRAP #14 in code 
00001964  41E8 0002               1184  BR_SET2  LEA.L   2(A0),A0            Skip past op-code field in table 
00001968  51C8 FFEC               1185           DBRA    D0,BR_SET1          Repeat until all entries tested 
0000196C  4E75                    1186           RTS 
0000196E                          1187  * 
0000196E  =0000196E               1188  NOBR     EQU     *                   Clear one or all breakpoints 
0000196E  6100 F846               1189           BSR     PARAM               Get BP address (if any) 
00001972  4A07                    1190           TST.B   D7                  Test for input error 
00001974  6708                    1191           BEQ.S   NOBR1               If no error then skip abort 
00001976  49FA 0269               1192           LEA.L   ERMES1(PC),A4       Point to error message 
0000197A  6000 F706               1193           BRA     PSTRING             Display it and return 
0000197E  4A80                    1194  NOBR1    TST.L   D0                  Test for null address (clear all) 
00001980  6720                    1195           BEQ.S   NOBR4               If no address then clear all entries 
00001982  2240                    1196           MOVE.L  D0,A1               Else just clear breakpoint in A1 
00001984  41EE 00A8               1197           LEA.L   BP_TAB(A6),A0       A0 points to BP table 
00001988  303C 0007               1198           MOVE.W  #7,D0               Up to eight entries to test 
0000198C  2218                    1199  NOBR2    MOVE.L  (A0)+,D1            Get entry and 
0000198E  41E8 0002               1200           LEA.L   2(A0),A0            skip past op-code field 
00001992  B289                    1201           CMP.L   A1,D1               Is this the one? 
00001994  6706                    1202           BEQ.S   NOBR3               If so go and clear entry 
00001996  51C8 FFF4               1203           DBRA    D0,NOBR2            Repeat until all tested 
0000199A  4E75                    1204           RTS 
0000199C  42A8 FFFA               1205  NOBR3    CLR.L   -6(A0)              Clear address in BP table 
000019A0  4E75                    1206           RTS 
000019A2  41EE 00A8               1207  NOBR4    LEA.L   BP_TAB(A6),A0       Clear all 8 entries in BP table 
000019A6  303C 0007               1208           MOVE.W  #7,D0               Eight entries to clear 
000019AA  4298                    1209  NOBR5    CLR.L   (A0)+               Clear breakpoint address 
000019AC  4258                    1210           CLR.W   (A0)+               Clear op-code field 
000019AE  51C8 FFFA               1211           DBRA    D0,NOBR5            Repeat until all done 
000019B2  4E75                    1212           RTS 
000019B4                          1213  * 
000019B4  =000019B4               1214  BR_CLR   EQU     *                   Remove breakpoints from code 
000019B4  41EE 00A8               1215           LEA.L   BP_TAB(A6),A0       A0 points to breakpoint table 
000019B8  303C 0007               1216           MOVE.W  #7,D0               Up to eight entries to clear 
000019BC  2218                    1217  BR_CLR1  MOVE.L  (A0)+,D1            Get address of BP in D1 
000019BE  2241                    1218           MOVE.L  D1,A1               and put copy in A1 
000019C0  4A81                    1219           TST.L   D1                  Test this breakpoint 
000019C2  6702                    1220           BEQ.S   BR_CLR2             If zero then skip BP clearing 
000019C4  3290                    1221           MOVE.W  (A0),(A1)           Else restore op-code 
000019C6  41E8 0002               1222  BR_CLR2  LEA.L   2(A0),A0            Skip past op-code field 
000019CA  51C8 FFF0               1223           DBRA    D0,BR_CLR1          Repeat until all tested 
000019CE  4E75                    1224           RTS 
000019D0                          1225  * 
000019D0                          1226  *  REG_MOD modifies a register in the display frame. The command 
000019D0                          1227  *  format is REG <reg> <value>. E.g. REG D3 1200 
000019D0                          1228  * 
000019D0  4281                    1229  REG_MOD  CLR.L   D1                  D1 to hold name of register 
000019D2  41EE 0048               1230           LEA.L   BUFFPT(A6),A0       A0 contains address of buffer pointer 
000019D6  2050                    1231           MOVE.L  (A0),A0             A0 now points to next char in buffer 
000019D8  1218                    1232           MOVE.B  (A0)+,D1            Put first char of name in D1 
000019DA  E159                    1233           ROL.W   #8,D1               Move char one place left 
000019DC  1218                    1234           MOVE.B  (A0)+,D1            Get second char in D1 
000019DE  41E8 0001               1235           LEA.L   1(A0),A0            Move pointer past space in buffer 
000019E2  2D48 0048               1236           MOVE.L  A0,BUFFPT(A6)       Update buffer pointer 
000019E6  4282                    1237           CLR.L   D2                  D2 is the character pair counter 
000019E8  41FA 01CE               1238           LEA.L   REGNAME(PC),A0      A0 points to string of character pairs 
000019EC  43D0                    1239           LEA.L   (A0),A1             A1 also points to string 
000019EE  B258                    1240  REG_MD1  CMP.W   (A0)+,D1            Compare a char pair with input 
000019F0  6712                    1241           BEQ.S   REG_MD2             If match then exit loop 
000019F2  5282                    1242           ADD.L   #1,D2               Else increment match counter 
000019F4  B4BC 00000013           1243           CMP.L   #19,D2              Test for end of loop 
000019FA  66F2                    1244           BNE     REG_MD1             Continue until all pairs matched 
000019FC  49FA 01E3               1245           LEA.L   ERMES1(PC),A4       If here then error 
00001A00  6000 F680               1246           BRA     PSTRING             Display error and return 
00001A04  43EE 005E               1247  REG_MD2  LEA.L   TSK_T(A6),A1        A1 points to display frame 
00001A08  E582                    1248           ASL.L   #2,D2               Multiply offset by 4 (4 bytes/entry) 
00001A0A  B4BC 00000048           1249           CMP.L   #72,D2              Test for address of PC 
00001A10  6602                    1250           BNE.S   REG_MD3             If not PC then all is OK 
00001A12  5582                    1251           SUB.L   #2,D2               else dec PC pointer as Sr is a word 
00001A14  45F1 2000               1252  REG_MD3  LEA.L   (A1,D2),A2          Calculate address of entry in disptable 
00001A18  2012                    1253           MOVE.L  (A2),D0             Get old contents 
00001A1A  6100 F808               1254           BSR     OUT8X               Display them 
00001A1E  6100 F652               1255           BSR     NEWLINE 
00001A22  6100 F792               1256           BSR     PARAM               Get new data 
00001A26  4A07                    1257           TST.B   D7                  Test for input error 
00001A28  6708                    1258           BEQ.S   REG_MD4             If no error then go and store data 
00001A2A  49FA 01B5               1259           LEA.L   ERMES1(PC),A4       Else point to error message 
00001A2E  6000 F652               1260           BRA     PSTRING             print it and return 
00001A32  B4BC 00000044           1261  REG_MD4  CMP.L   #68,D2              If this address is the SR then 
00001A38  6704                    1262           BEQ.S   REG_MD5             we have only a word to store 
00001A3A  2480                    1263           MOVE.L  D0,(A2)             Else store new data in display frame 
00001A3C  4E75                    1264           RTS 
00001A3E  3480                    1265  REG_MD5  MOVE.W  D0,(A2)             Store SR (one word) 
00001A40  4E75                    1266           RTS 
00001A42                          1267  * 
00001A42                          1268  ************************************************************************* 
00001A42                          1269  * 
00001A42  =00001A42               1270  X_UN    EQU     *                 Uninitialized exception vector routine 
00001A42  49FA 0203               1271          LEA.L   ERMES6(PC),A4     Point to error message 
00001A46  6100 F63A               1272          BSR     PSTRING           Display it 
00001A4A  6100 FB86               1273          BSR     EX_DIS            Display registers 
00001A4E  6000 F5FC               1274          BRA     WARM              Abort 
00001A52                          1275  * 
00001A52                          1276  ************************************************************************* 
00001A52                          1277  * 
00001A52                          1278  *  All strings and other fixed parameters here 
00001A52                          1279  * 
00001A52= 54 53 42 55 47 20 ...   1280  BANNER   DC.B     'TSBUG 2 Version 23.07.86',0,0
00001A6C= 4D 6F 64 69 66 69 ...   1281  MODIFY    DC.B   'Modified by Eugene A. Rockey Jr. Jan.05.2010',0,0
00001A9A= 66 6F 72 20 75 73 ...   1282  WHY      DC.B     'for use with the M68000 Minimal Computer Configuration',0,0 
00001AD2= 55 6E 69 76 65 72 ...   1283  WHERE    DC.B     'University of Louisville',0,0
00001AEC= 0D 0A 54 53 32 4D ...   1284  CRLF     DC.B     CR,LF,'TS2MON >',0 
00001AF7= 0D 0A 53 31 00 00       1285  HEADER   DC.B     CR,LF,'S','1',0,0 
00001AFD= 53 39 20 20 00 00       1286  TAIL     DC.B     'S9  ',0,0 
00001B03= 20 53 52 20 20 3D ...   1287  MES1     DC.B     ' SR  =  ',0 
00001B0C= 20 50 43 20 20 3D ...   1288  MES2     DC.B     ' PC  =  ',0 
00001B15= 20 53 53 20 20 3D ...   1289  MES2A    DC.B     ' SS  =  ',0 
00001B1E= 20 20 44 61 74 61 ...   1290  MES3     DC.B     '  Data reg       Address reg',0,0 
00001B3C= 20 20 20 20 20 20 ...   1291  MES4     DC.B     '        ',0,0 
00001B46= 42 75 73 20 65 72 ...   1292  MES8     DC.B     'Bus error   ',0,0 
00001B54= 41 64 64 72 65 73 ...   1293  MES9     DC.B     'Address error   ',0,0 
00001B66= 49 6C 6C 65 67 61 ...   1294  MES10    DC.B     'Illegal instruction ',0,0 
00001B7C= 42 72 65 61 6B 70 ...   1295  MES11    DC.B     'Breakpoint  ',0,0 
00001B8A= 54 72 61 63 65 20 ...   1296  MES12    DC.B     'Trace   ',0 
00001B93= 44 69 76 69 64 65 ...   1297  MES13    DC.B     'Divide by zero error', 0
00001BA8= 50 72 69 76 69 6C ...   1298  MES14    DC.B     'Privilege error', 0
00001BB8= 44 30 44 31 44 32 ...   1299  REGNAME  DC.B     'D0D1D2D3D4D5D6D7' 
00001BC8= 41 30 41 31 41 32 ...   1300           DC.B     'A0A1A2A3A4A5A6A7' 
00001BD8= 53 53 53 52             1301           DC.B     'SSSR' 
00001BDC= 50 43 20 20 00          1302           DC.B     'PC  ',0 
00001BE1= 4E 6F 6E 2D 76 61 ...   1303  ERMES1   DC.B     'Non-valid hexadecimal input  ',0 
00001BFF= 49 6E 76 61 6C 69 ...   1304  ERMES2   DC.B     'Invalid command  ',0 
00001C11= 4C 6F 61 64 69 6E ...   1305  ERMES3   DC.B     'Loading error',0 
00001C1F= 54 61 62 6C 65 20 ...   1306  ERMES4   DC.B     'Table full  ',0,0 
00001C2D= 42 72 65 61 6B 70 ...   1307  ERMES5   DC.B     'Breakpoint not active   ',0,0 
00001C47= 55 6E 69 6E 69 74 ...   1308  ERMES6   DC.B     'Uninitialized exception ',0,0 
00001C61= 4A 55 4D 50 20 3C ...   1309  JUMPHELP DC.B     'JUMP <address> causes execution to begin at <address>',0   
00001C97= 4D 45 4D 4F 52 59 ...   1310  MEMHELP  DC.B     'MEMORY <address> examines contents of address> and allows them to be changed', 0   
00001CE4= 4C 4F 41 44 20 3C ...   1311  LOADHELP DC.B     'LOAD <string> loads S1/S2 records from the host. <string> is sent to host', 0
00001D2E= 54 56 20 63 68 65 ...   1312  TVHELP   DC.B     'TV checks all RAM addresses from $4000 to $40FE. Reports corrupt memory addresses', 0
00001D80= 20 52 61 6E 67 65 ...   1313  ERMES7   DC.B     ' Range error',0
00001D8D= 55 53 45 52 00          1314  UNAME    DC.B     'USER', 0
00001D92= 50 41 53 53 57 4F ...   1315  PWORD    DC.B     'PASSWORD',0
00001D9B= 45 6E 74 65 72 20 ...   1316  LOGINM1  DC.B     'Enter username: ', 0
00001DAC= 45 6E 74 65 72 20 ...   1317  LOGINM2  DC.B     'Enter password: ', 0
00001DBD= 49 6E 63 6F 72 72 ...   1318  USRERR   DC.B     'Incorrect username', 0
00001DD0= 43 6F 72 72 65 63 ...   1319  USRSUC   DC.B     'Correct Username', 0
00001DE1= 49 6E 63 6F 72 72 ...   1320  PWERR   DC.B     'Incorrect password', 0
00001DF4= 43 6F 72 72 65 63 ...   1321  PWSUC    DC.B     'Correct Password', 0
00001E05= 4D 45 4D 4F 52 59 ...   1322  MEMFMSG  DC.B     'MEMORY BAD AT: ',0
00001E15= 41 4C 4C 20 52 41 ...   1323  MEMGMSG  DC.B      'ALL RAM GOOD', 0
00001E22                          1324  * 
00001E22                          1325  *  COMTAB is the built-in command table. All entries are made up of 
00001E22                          1326  *         a string length + number of characters to match + the string 
00001E22                          1327  *         plus the address of the command relative to COMTAB 
00001E22                          1328  * 
00002000                          1329           ORG      $2000
00002000= 04 04                   1330  COMTAB   DC.B     4,4              JUMP <address> causes execution to 
00002002= 4A 55 4D 50             1331           DC.B     'JUMP'           begin at <address> 
00002006= FFFFF22C                1332           DC.L     JUMP-COMTAB                                           
0000200A= 08 03                   1333           DC.B     8,3              MEMORY <address> examines contents of 
0000200C= 4D 45 4D 4F 52 59 ...   1334           DC.B     'MEMORY  '       <address> and allows them to be changed 
00002014= FFFFF242                1335           DC.L     MEMORY-COMTAB 
00002018= 04 02                   1336           DC.B     4,2              LOAD <string> loads S1/S2 records 
0000201A= 4C 4F 41 44             1337           DC.B     'LOAD'           from the host. <string> is sent to host 
0000201E= FFFFF2A2                1338           DC.L     LOAD-COMTAB 
00002022= 04 04                   1339           DC.B    4,4               HELP 
00002024= 48 45 4C 50             1340           DC.B    'HELP'            
00002028= FFFFF650                1341           DC.L    HELP-COMTAB      
0000202C= 02 02                   1342           DC.B    2,2
0000202E= 54 56                   1343           DC.B    'TV'
00002030= FFFFF752                1344           DC.L    TV-COMTAB
00002034= 00 00                   1345           DC.B    0,0 
00002036                          1346  * 
00002036                          1347  ************************************************************************* 
00002036                          1348  ** 
00002036                          1349  *  This is a list of the information needed to setup the DCBs 
00002036                          1350  * 
00002036  =00002036               1351  DCB_LST  EQU     * 
00002036= 43 4F 4E 5F 49 4E ...   1352  DCB1     DC.B    'CON_IN  '          Device name (8 bytes) 
0000203E= 00001486 00008001       1353           DC.L    CON_IN,ACIA_1       Address of driver routine, device 
00002046= 0002                    1354           DC.W    2                   Number of words in parameter field 
00002048= 43 4F 4E 5F 4F 55 ...   1355  DCB2     DC.B    'CON_OUT ' 
00002050= 000014B6 00008001       1356           DC.L    CON_OUT,ACIA_1 
00002058= 0002                    1357           DC.W    2 
0000205A= 41 55 58 5F 49 4E ...   1358  DCB3     DC.B    'AUX_IN  ' 
00002062= 000014F6 00008001       1359           DC.L    AUX_IN,ACIA_2 
0000206A= 0002                    1360           DC.W    2 
0000206C= 41 55 58 5F 4F 55 ...   1361  DCB4     DC.B    'AUX_OUT ' 
00002074= 00001508 00008001       1362           DC.L    AUX_OUT,ACIA_2 
0000207C= 0002                    1363           DC.W    2 
0000207E                          1364  *DCB5     DC.B    'BUFF_IN ' 
0000207E                          1365  *         DC.L    BUFF_IN,BUFFER 
0000207E                          1366  *         DC.W    2 
0000207E                          1367  *DCB6     DC.B    'BUFF_OUT' 
0000207E                          1368  *         DC.L    BUFF_OT,BUFFER 
0000207E                          1369  *         DC.W    2 
0000207E                          1370  * 
0000207E                          1371  ************************************************************************* 
0000207E                          1372  * 
0000207E                          1373  *  DCB structure 
0000207E                          1374  * 
0000207E                          1375  *              ----------------------- 
0000207E                          1376  *       0 ->   | DCB  name           | 
0000207E                          1377  *              |---------------------| 
0000207E                          1378  *       8 ->   | Device driver       | 
0000207E                          1379  *              |---------------------| 
0000207E                          1380  *      12 ->   | Device address      | 
0000207E                          1381  *              |---------------------| 
0000207E                          1382  *      16 ->   |Size of param block  | 
0000207E                          1383  *              |---------------------| --- 
0000207E                          1384  *      18 ->   |      Status         |   | 
0000207E                          1385  *              | logical  | physical |   | S 
0000207E                          1386  *              |---------------------|   | 
0000207E                          1387  *              .                     .   . 
0000207E                          1388  *              |---------------------| --- 
0000207E                          1389  *    18+S ->   | Pointer to next DCB | 
0000207E                          1390  * 
0000207E                          1391           END RESET 

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ACIA_1              8001
ACIA_2              8001
ADD_ER              1820
ADR_DAT             1280
AUX_IN              14F6
AUX_IN1             14FC
AUX_OT1             150E
AUX_OUT             1508
BANNER              1A52
BP_TAB              A8
BRKPT               182E
BR_CLR              19B4
BR_CLR1             19BC
BR_CLR2             19C6
BR_GET              190A
BR_GET1             191A
BR_GET2             1926
BR_GET3             1936
BR_GET4             193E
BR_SET              1948
BR_SET1             1956
BR_SET2             1964
BS                  8
BUFFEND             47
BUFFER              2D8
BUFFPT              48
BUS_ER              1812
BYTE                119A
B_CLR               15C8
CHECK1              176E
CHECK2              1778
CHECK3              179A
CHECK4              17A4
CN_IVEC             56
CN_OVEC             5A
COMTAB              2000
CON_I1              1494
CON_I2              14AC
CON_IN              1486
CON_OT1             14C4
CON_OT2             14DA
CON_OT3             14E2
CON_OUT             14B6
CR                  D
CRLF                1AEC
CTRL_A              1
DATA                4800
DCB1                2036
DCB2                2048
DCB3                205A
DCB4                206C
DCB_LST             2036
DELAY               1416
DELAY1              1420
DUMP                1376
DUMP1               1386
DUMP2               1392
DUMP3               13A0
DUMP4               13B4
DUMP5               13C2
DUMP6               13DC
DUMP7               1400
ECHO                50
ERMES1              1BE1
ERMES2              1BFF
ERMES3              1C11
ERMES4              1C1F
ERMES5              1C2D
ERMES6              1C47
ERMES7              1D80
ESC                 1B
EXEC1               1122
EXEC2               1132
EXECUTE             1110
EX_D1               15E4
EX_DIS              15D2
FIRST               D8
GB                  18CC
GETCH2              1540
GETCH3              1550
GETCHAR             151A
GETLINE             1098
GETLN2              10A2
GETLN3              10BC
GETLN4              10C6
GETLN5              10CA
GETLNR              10A6
GO                  18AC
GO1                 18BC
GO2                 18CA
GROUP1              184C
GROUP1A             186A
GROUP2              1880
GROUP2A             188C
HEADER              1AF7
HEADING             1092
HELP                1650
HEX                 117C
HEX_OK              1198
IL_ER               17FC
IO_OPEN             158E
IO_REQ              1474
JUMP                122C
JUMP1               123A
JUMPHELP            1C61
LF                  A
LNBUFF              8
LOAD                12A2
LOAD1               12CE
LOAD2               12DE
LOAD3               12F8
LOAD4               1312
LOAD5               1320
LOAD6               1322
LOAD6A              1346
LOAD7               1358
LOAD8               136E
LOADHELP            1CE4
LOGIN               1686
LOGIN1              16A6
LOGIN2              16EA
LOGINM1             1D9B
LOGINM2             1DAC
LONGWD              11B0
LOOPRAM             175A
LOOPRAM1            1786
MAXCHR              40
MAX_RAM             3DC
MEM1                124C
MEM2                126A
MEM3                127E
MEMFAIL             17B8
MEMFAIL2            17D4
MEMFMSG             1E05
MEMGMSG             1E15
MEMGOOD             17F0
MEMHELP             1C97
MEMORY              1242
MES1                1B03
MES10               1B66
MES11               1B7C
MES12               1B8A
MES13               1B93
MES14               1BA8
MES2                1B0C
MES2A               1B15
MES3                1B1E
MES4                1B3C
MES8                1B46
MES9                1B54
MIN_RAM             3D8
MODIFY              1A6C
NEWLINE             1072
NOBR                196E
NOBR1               197E
NOBR2               198C
NOBR3               199C
NOBR4               19A2
NOBR5               19AA
NOT_HEX             1194
NO_EXT              1040
NUL                 0
OPEN1               1596
OPEN2               159E
OPEN3               15AC
OPEN4               15C2
OUT1X               11FA
OUT1X1              120C
OUT2X               1214
OUT4X               121C
OUT8X               1224
PARAM               11B6
PARAM1              11BE
PARAM3              11E2
PARAM4              11E6
PARAM5              11F2
PARAM6              11F6
PARAMTR             4C
PS1                 1084
PS2                 108E
PSPACE              1294
PSTRING             1082
PUTASK              1556
PUTCHAR             1568
PWERR               1DE1
PWORD               1D92
PWSUC               1DF4
QUIT                174E
RANGE               1406
REGNAME             1BB8
REG_MD1             19EE
REG_MD2             1A04
REG_MD3             1A14
REG_MD4             1A32
REG_MD5             1A3E
REG_MOD             19D0
RESET               1000
REST1               18E2
RESTORE             18D2
SEARCH              113C
SETACIA             105C
SET_DCB             142A
SPACE               20
SPUTCHAR            157C
SRCH2               1156
SRCH3               115A
SRCH4               1162
SRCH6               116C
SRCH7               1176
STACK               4400
ST_DCB1             143A
ST_DCB2             143E
TAIL                1AFD
TIDY                10CE
TIDY1               10D4
TIDY2               10E0
TIDY3               10EA
TIDY4               10F4
TIDY5               10FE
TIDY6               110A
TRACE               18F6
TRAP_14             4E4E
TSK_T               5E
TV                  1752
TVHELP              1D2E
UNAME               1D8D
UPASS               1744
USRERR              1DBD
USRSUC              1DD0
UTAB                52
U_CASE              51
WAIT                57
WARM                104C
WHERE               1AD2
WHY                 1A9A
WORD                11AA
WRONG               171C
WRONGPW             1730
X_UN                1A42
