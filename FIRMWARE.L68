00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.15.02
Created On: 10/30/2015 4:10:39 PM

00000000                             1  *        TSBUG2 - 68000 monitor - version of 05 January 2010 
00000000                             2  
00000000                             3       ORG      $0
00000000= 00004400 00001000 ...      4           DC.L STACK,RESET,BUS_ER,ADD_ER,IL_ER,DIV0_ER,X_UN,X_UN,PRIV_ER,X_UN,X_UN,FTRAP,X_UN,X_UN,X_UN,X_UN
00000040= 00001D2E 00001D2E ...      5           DC.L X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN
00000080= 000016CE 00001D2E ...      6           DC.L TRAP_0,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,BRKPT,TRAP_15,X_UN
000000C4                             7  *         DC.L X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN
000000C4                             8  *         DC.L X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN
000000C4                             9  *         DC.L X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN
000000C4                            10  *         DC.L X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN
000000C4                            11  *         DC.L X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN
000000C4                            12  *         DC.L X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN
000000C4                            13  *         DC.L X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN
000000C4                            14  *         DC.L X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN
000000C4                            15  *         DC.L X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN
000000C4                            16  *         DC.L X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN
000000C4                            17  *         DC.L X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN
000000C4                            18  *         DC.L X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN
000000C4                            19  *         DC.L X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN
000000C4                            20  
000000C4                            21  *                                   Symbol equates 
000000C4  =00000008                 22  BS       EQU      $08               Back_space 
000000C4  =0000000D                 23  CR       EQU      $0D               Carriage_return 
000000C4  =00000000                 24  NUL      EQU      $00               NUL character
000000C4  =0000000A                 25  LF       EQU      $0A               Line_feed 
000000C4  =00000020                 26  SPACE    EQU      $20               Space 
000000C4  =00000057                 27  WAIT     EQU      'W'               Wait character (to suspend output) 
000000C4  =0000001B                 28  ESC      EQU      $1B               ASCII escape character (used by TM) 
000000C4  =00000001                 29  CTRL_A   EQU      $01               Control_A forces return to monitor 
000000C4                            30  *                                   Device addresses 
000000C4  =00004400                 31  STACK    EQU      $4400             Stack_pointer
000000C4  =00008001                 32  ACIA_1   EQU      $8001             Console ACIA control 
000000C4  =00008001                 33  ACIA_2   EQU      ACIA_1            Auxilary ACIA control 
000000C4  =00004E4E                 34  TRAP_16  EQU      $4E4E             Code for TRAP #16 
000000C4  =00000040                 35  MAXCHR   EQU      64                Length of input line buffer  
000000C4                            36  * 
000000C4  =00004800                 37  DATA     EQU      $4800             Data origin 
000000C4                            38  LNBUFF   DS.B     MAXCHR            Input line buffer
00000104  =00000103                 39  BUFFEND  EQU      LNBUFF+MAXCHR-1   End of line buffer 
00000104                            40  BUFFPT   DS.L     1                 Pointer to line buffer 
00000108                            41  PARAMTR  DS.L     1                 Last parameter from line buffer 
0000010C                            42  ECHO     DS.B     1                 When clear this enable input echo 
0000010D                            43  U_CASE   DS.B     1                 Flag for upper case conversion 
0000010E                            44  UTAB     DS.L     1                 Pointer to user command table 
00000112                            45  CN_IVEC  DS.L     1                 Pointer to console input DCB 
00000116                            46  CN_OVEC  DS.L     1                 Pointer to console output DCB 
0000011A                            47  TSK_T    DS.W     37                Frame for D0-D7, A0-A6, USP, SSP, SW, PC 
00000164                            48  BP_TAB   DS.W     24                Breakpoint table 
00000194                            49  FIRST    DS.B     512               DCB area 
00000394                            50  BUFFER   DS.B     256               256 bytes for I/O buffer 
00000494= 00004000                  51  MIN_RAM  DC.L     $004000           minimum RAM address to be checked
00000498= 00004100                  52  MAX_RAM  DC.L     $004100           maximum RAM address to be checked
0000049C                            53  
0000049C  =00080000                 54  MC68881  EQU    $80000              MC68881 BASE ADDRESS
0000049C  =0000000A                 55  COMMAND  EQU    $0A                 COMMAND REGISTER
0000049C  =00000000                 56  RESPONSE EQU    $00                 RESPONSE REGISTER
0000049C  =00000010                 57  OPER     EQU    $10                 OPERAND REGISTER
0000049C                            58  
0000049C                            59  * 
0000049C                            60  ************************************************************************* 
0000049C                            61  * 
0000049C                            62  *  This is the main program which assembles a command in the line 
0000049C                            63  *  buffer, removes leading/embedded spaces and interprets it by matching 
0000049C                            64  *  it with a command in the user table or the built-in table COMTAB 
0000049C                            65  *  All variables are specified with respect to A6 
0000049C                            66  *
00001000                            67           ORG      $1000             Monitor Origin
00001000  =00001000                 68  RESET:   EQU      *
00001000  4DF8 4800                 69           LEA.L    DATA,A6           A6 points to data area 
00001004  2D4E 0152                 70           MOVE.L A6,TSK_T+56(A6)   initialize A6 in the regster Frame
00001008  42AE 010E                 71           CLR.L    UTAB(A6)          Reset pointer to user extension table 
0000100C  422E 010C                 72           CLR.B    ECHO(A6)          Set automatic character echo 
00001010  422E 010D                 73           CLR.B    U_CASE(A6)        Clear case conversion flag (UC<-LC) 
00001014  613E                      74           BSR.S    SETACIA           Setup ACIAs 
00001016  6100 0592                 75           BSR.L     B_CLR                 what change did i do here
0000101A  6100 0416                 76           BSR.L    SET_DCB           Setup DCB table in RAM
0000101E  614A                      77           BSR.S    NEWLINE
00001020  49FA 0D1C                 78           LEA.L    BANNER(PC),A4    
00001024  6154                      79           BSR.S    PSTRING
00001026  6142                      80           BSR.S    NEWLINE           
00001028  49FA 0D2E                 81           LEA.L     MODIFY(PC),A4
0000102C  614C                      82           BSR.S    PSTRING
0000102E  613A                      83           BSR.S    NEWLINE
00001030  49FA 0D54                 84           LEA.L     WHY(PC),A4
00001034  6144                      85           BSR.S    PSTRING
00001036  6132                      86           BSR.S    NEWLINE
00001038  49FA 0D84                 87           LEA.L     WHERE(PC),A4
0000103C  613C                      88           BSR.S    PSTRING
0000103E  612A                      89           BSR.S    NEWLINE
00001040  4E71                      90  NO_EXT:  NOP                        Two NOPs to allow for a future 
00001042  4E71                      91           NOP                        call to an initialization routine 
00001044  4287                      92  WARM:    CLR.L    D7                Warm entry point - clear error flag 
00001046  6122                      93           BSR.S    NEWLINE           Print a newline 
00001048  6146                      94           BSR.S    GETLINE           Get a command line 
0000104A  6100 007A                 95           BSR      TIDY              Tidy up input buffer contents 
0000104E  6100 00B8                 96           BSR      EXECUTE           Interpret command 
00001052  60F0                      97           BRA      WARM              Repeat indefinitely 
00001054                            98  * 
00001054                            99  ************************************************************************* 
00001054                           100  * 
00001054                           101  *  Some initialization and basic routines 
00001054                           102  * 
00001054  =00001054                103  SETACIA  EQU      *                 Setup ACIA parameters 
00001054  41F9 00008001            104           LEA.L    ACIA_1,A0         A0 points to console ACIA 
0000105A  10BC 0003                105           MOVE.B   #$03,(A0)         Reset ACIA1 
0000105E  10BC 0019                106           MOVE.B   #$19,(A0)         Set up ACIA1 constants (no IRQ, 
00001062  117C 0019 0001           107           MOVE.B   #$19,1(A0)        RTS* low, 8 bit, no parity, 1 stop) 
00001068  4E75                     108           RTS                        Return 
0000106A                           109  * 
0000106A  =0000106A                110  NEWLINE  EQU      *                 Move cursor to start of newline 
0000106A  48E7 0008                111           MOVEM.L  A4,-(A7)          Save A4 
0000106E  49FA 0D68                112           LEA.L    CRLF(PC),A4       Point to CR/LF string 
00001072  6106                     113           BSR.S    PSTRING           Print it 
00001074  4CDF 1000                114           MOVEM.L  (A7)+,A4          Restore A4 
00001078  4E75                     115           RTS                        Return 
0000107A                           116  * 
0000107A  =0000107A                117  PSTRING  EQU      *                 Display the string pointed at by A4 
0000107A  2F00                     118           MOVE.L   D0,-(A7)          Save D0 
0000107C  101C                     119  PS1      MOVE.B   (A4)+,D0          Get character to be printed 
0000107E  6706                     120           BEQ.S    PS2               If null then return 
00001080  6100 04C8                121           BSR      PUTCHAR           Else print it 
00001084  60F6                     122           BRA      PS1               Continue 
00001086  201F                     123  PS2      MOVE.L   (A7)+,D0          Restore D0 and exit 
00001088  4E75                     124           RTS 
0000108A                           125  * 
0000108A  61DE                     126  HEADING  BSR      NEWLINE           Same as PSTRING but with newline 
0000108C  61EC                     127           BSR      PSTRING 
0000108E  60DA                     128           BRA      NEWLINE 
00001090                           129  * 
00001090                           130  ************************************************************************* 
00001090                           131  * 
00001090                           132  *  GETLINE  inputs a string of characters into a line buffer
00001090                           133  *           A3 points to next free entry in line buffer 
00001090                           134  *           A2 points to end of buffer 
00001090                           135  *           A1 points to start of buffer 
00001090                           136  *           D0 holds character to be stored 
00001090                           137  * 
00001090  43EE 00C4                138  GETLINE  LEA.L    LNBUFF(A6),A1     A1 points to start of line buffer 
00001094  47D1                     139           LEA.L    (A1),A3           A3 points to start (initially) 
00001096  45E9 0040                140           LEA.L    MAXCHR(A1),A2     A2 points to end of buffer 
0000109A  6100 0462                141  GETLN2   BSR      GETCHAR           Get a character 
0000109E  B03C 0001                142           CMP.B    #CTRL_A,D0        If control_A then reject this line 
000010A2  671E                     143           BEQ.S    GETLN5            and get another line 
000010A4  B03C 0008                144           CMP.B    #BS,D0            If back_space then move back pointer 
000010A8  660A                     145           BNE.S    GETLN3            Else skip past wind-back routine 
000010AA  B7C9                     146           CMP.L    A1,A3             First check for empty buffer 
000010AC  67EC                     147           BEQ      GETLN2            If buffer empty then continue 
000010AE  47EB FFFF                148           LEA      -1(A3),A3         Else decrement buffer pointer 
000010B2  60E6                     149           BRA      GETLN2            and continue with next character 
000010B4  16C0                     150  GETLN3   MOVE.B   D0,(A3)+          Store character and update pointer 
000010B6  B03C 000D                151           CMP.B    #CR,D0            Test for command terminator 
000010BA  6602                     152           BNE.S    GETLN4            If not CR then skip past exit 
000010BC  60AC                     153           BRA      NEWLINE           Else new line before next operation 
000010BE  B7CA                     154  GETLN4   CMP.L    A2,A3             Test for buffer overflow 
000010C0  66D8                     155           BNE      GETLN2            If buffer not full then continue 
000010C2  61A6                     156  GETLN5   BSR      NEWLINE           Else move to next line and 
000010C4  60CA                     157           BRA      GETLINE           repeat this routine 
000010C6                           158  * 
000010C6                           159  ************************************************************************* 
000010C6                           160  * 
000010C6                           161  *  TIDY cleans up the line buffer by removing leading spaces and multiple 
000010C6                           162  *       spaces between parameters. At the end of TIDY, BUFFPT points to 
000010C6                           163  *       the first parameter following the command. 
000010C6                           164  *       A0 = pointer to line buffer. A1 = pointer to cleaned up buffer 
000010C6                           165  * 
000010C6  41EE 00C4                166  TIDY     LEA.L    LNBUFF(A6),A0     A0 points to line buffer 
000010CA  43D0                     167           LEA.L    (A0),A1           A1 points to start of line buffer 
000010CC  1018                     168  TIDY1    MOVE.B   (A0)+,D0          Read character from line buffer 
000010CE  B03C 0020                169           CMP.B    #SPACE,D0         Repeat until the first non-space 
000010D2  67F8                     170           BEQ      TIDY1             character is found 
000010D4  41E8 FFFF                171           LEA.L    -1(A0),A0         Move pointer back to first char 
000010D8  1018                     172  TIDY2    MOVE.B   (A0)+,D0          Move the string left to remove 
000010DA  12C0                     173           MOVE.B   D0,(A1)+          any leading spaces 
000010DC  B03C 0020                174           CMP.B    #SPACE,D0         Test for embedded space 
000010E0  660A                     175           BNE.S    TIDY4             If not space then test for EOL 
000010E2  0C18 0020                176  TIDY3    CMP.B    #SPACE,(A0)+      If space skip multiple embedded 
000010E6  67FA                     177           BEQ      TIDY3             spaces 
000010E8  41E8 FFFF                178           LEA.L    -1(A0),A0         Move back pointer 
000010EC  B03C 000D                179  TIDY4    CMP.B    #CR,D0            Test for end_of_line (EOL) 
000010F0  66E6                     180           BNE      TIDY2             If not EOL then read next char 
000010F2  41EE 00C4                181           LEA.L    LNBUFF(A6),A0     Restore buffer pointer 
000010F6  0C10 000D                182  TIDY5    CMP.B    #CR,(A0)          Test for EOL 
000010FA  6706                     183           BEQ.S    TIDY6             If EOL then exit 
000010FC  0C18 0020                184           CMP.B    #SPACE,(A0)+      Test for delimiter 
00001100  66F4                     185           BNE      TIDY5             Repeat until delimiter or EOL 
00001102  2D48 0104                186  TIDY6    MOVE.L   A0,BUFFPT(A6)     Update buffer pointer 
00001106  4E75                     187           RTS 
00001108                           188  * 
00001108                           189  ************************************************************************* 
00001108                           190  * 
00001108                           191  *  EXECUTE matches the first command in the line buffer with the 
00001108                           192  *  commands in a command table. An external table pointed at by 
00001108                           193  *  UTAB is searched first and then the in-built table, COMTAB. 
00001108                           194  * 
00001108  4AAE 010E                195  EXECUTE  TST.L    UTAB(A6)          Test pointer to user table 
0000110C  670C                     196           BEQ.S    EXEC1             If clear then try built-in table 
0000110E  266E 010E                197           MOVE.L   UTAB(A6),A3       Else pick up pointer to user table 
00001112  6120                     198           BSR.S    SEARCH            Look for command in user table 
00001114  6404                     199           BCC.S    EXEC1             If not found then try internal table 
00001116  2653                     200           MOVE.L   (A3),A3           Else get absolute address of command 
00001118  4ED3                     201           JMP      (A3)              from user table and execute it 
0000111A                           202  * 
0000111A  47FA 0EE4                203  EXEC1    LEA.L    COMTAB(PC),A3     Try built-in command table 
0000111E  6114                     204           BSR.S    SEARCH            Look for command in built-in table 
00001120  6508                     205           BCS.S    EXEC2             If found then execute command 
00001122  49FA 0DC7                206           LEA.L    ERMES2(PC),A4     Else print "invalid command" 
00001126  6000 FF52                207           BRA.L    PSTRING           and return 
0000112A  2653                     208  EXEC2    MOVE.L   (A3),A3           Get the relative command address 
0000112C  49FA 0ED2                209           LEA.L    COMTAB(PC),A4     pointed at by A3 and add it to 
00001130  D7CC                     210           ADD.L    A4,A3             the PC to generate the actual 
00001132  4ED3                     211           JMP      (A3)              command address. Then execute it. 
00001134                           212  * 
00001134  =00001134                213  SEARCH   EQU      *                 Match the command in the line buffer 
00001134  4280                     214           CLR.L    D0                with command table pointed at by A3 
00001136  1013                     215           MOVE.B   (A3),D0           Get the first character in the 
00001138  6734                     216           BEQ.S    SRCH7             current entry. If zero then exit 
0000113A  49F3 0006                217           LEA.L    6(A3,D0.W),A4     Else calculate address of next entry 
0000113E  122B 0001                218           MOVE.B   1(A3),D1          Get number of characters to match 
00001142  4BEE 00C4                219           LEA.L    LNBUFF(A6),A5     A5 points to command in line buffer 
00001146  142B 0002                220           MOVE.B   2(A3),D2          Get first character in this entry 
0000114A  B41D                     221           CMP.B    (A5)+,D2          from the table and match with buffer 
0000114C  6704                     222           BEQ.S    SRCH3             If match then try rest of string 
0000114E  264C                     223  SRCH2    MOVE.L   A4,A3             Else get address of next entry 
00001150  60E2                     224           BRA      SEARCH            and try the next entry in the table 
00001152  5301                     225  SRCH3    SUB.B    #1,D1             One less character to match 
00001154  670E                     226           BEQ.S    SRCH6             If match counter zero then all done 
00001156  47EB 0003                227           LEA.L    3(A3),A3          Else point to next character in table 
0000115A  141B                     228  SRCH4    MOVE.B   (A3)+,D2          Now match a pair of characters 
0000115C  B41D                     229           CMP.B    (A5)+,D2 
0000115E  66EE                     230           BNE      SRCH2             If no match then try next entry 
00001160  5301                     231           SUB.B    #1,D1             Else decrement match counter and 
00001162  66F6                     232           BNE      SRCH4             repeat until no chars left to match 
00001164  47EC FFFC                233  SRCH6    LEA.L    -4(A4),A3         Calculate address of command entry 
00001168  003C 0001                234           OR.B     #1,CCR            point. Mark carry flag as success 
0000116C  4E75                     235           RTS                        and return 
0000116E  023C 00FE                236  SRCH7    AND.B    #$FE,CCR          Fail - clear carry to indicate 
00001172  4E75                     237           RTS                        command not found and return 
00001174                           238  * 
00001174                           239  ************************************************************************* 
00001174                           240  * 
00001174                           241  *  Basic input routines 
00001174                           242  *  HEX    =  Get one   hexadecimal character  into D0 
00001174                           243  *  BYTE   =  Get two   hexadecimal characters into D0 
00001174                           244  *  WORD   =  Get four  hexadecimal characters into D0 
00001174                           245  *  LONGWD =  Get eight hexadecimal characters into D0 
00001174                           246  *  PARAM  =  Get a longword from the line buffer into D0 
00001174                           247  *  Bit 0 of D7 is set to indicate a hexadecimal input error 
00001174                           248  * 
00001174  6100 0388                249  HEX      BSR      GETCHAR           Get a character from input device 
00001178  0400 0030                250           SUB.B    #$30,D0           Convert to binary 
0000117C  6B0E                     251           BMI.S    NOT_HEX           If less than $30 then exit with error 
0000117E  B03C 0009                252           CMP.B    #$09,D0           Else test for number (0 to 9) 
00001182  6F0C                     253           BLE.S    HEX_OK            If number then exit - success 
00001184  5F00                     254           SUB.B    #$07,D0           Else convert letter to hex 
00001186  B03C 000F                255           CMP.B    #$0F,D0           If character in range "A" to "F" 
0000118A  6F04                     256           BLE.S    HEX_OK            then exit successfully 
0000118C  8E3C 0001                257  NOT_HEX  OR.B     #1,D7             Else set error flag 
00001190  4E75                     258  HEX_OK   RTS                        and return 
00001192                           259  * 
00001192  2F01                     260  BYTE     MOVE.L   D1,-(A7)          Save D1 
00001194  61DE                     261           BSR      HEX               Get first hex character 
00001196  E900                     262           ASL.B    #4,D0             Move it to MS nybble position 
00001198  1200                     263           MOVE.B   D0,D1             Save MS nybble in D1 
0000119A  61D8                     264           BSR      HEX               Get second hex character 
0000119C  D001                     265           ADD.B    D1,D0             Merge MS and LS nybbles 
0000119E  221F                     266           MOVE.L   (A7)+,D1          Restore D1 
000011A0  4E75                     267           RTS 
000011A2                           268  * 
000011A2  61EE                     269  WORD     BSR      BYTE              Get upper order byte 
000011A4  E140                     270           ASL.W    #8,D0             Move it to MS position 
000011A6  60EA                     271           BRA      BYTE              Get LS byte and return 
000011A8                           272  * 
000011A8  61F8                     273  LONGWD   BSR      WORD              Get upper order word 
000011AA  4840                     274           SWAP     D0                Move it to MS position 
000011AC  60F4                     275           BRA      WORD              Get lower order word and return 
000011AE                           276  * 
000011AE                           277  *  PARAM reads a parameter from the line buffer and puts it in both 
000011AE                           278  *  PARAMTR(A6) and D0. Bit 1 of D7 is set on error. 
000011AE                           279  * 
000011AE  2F01                     280  PARAM    MOVE.L   D1,-(A7)          Save D1 
000011B0  4281                     281           CLR.L    D1                Clear input accumulator 
000011B2  206E 0104                282           MOVE.L   BUFFPT(A6),A0     A0 points to parameter in buffer 
000011B6  1018                     283  PARAM1   MOVE.B   (A0)+,D0          Read character from line buffer 
000011B8  B03C 0020                284           CMP.B    #SPACE,D0         Test for delimiter 
000011BC  6720                     285           BEQ.S    PARAM4            The permitted delimiter is a 
000011BE  B03C 000D                286           CMP.B    #CR,D0            space or a carriage return 
000011C2  671A                     287           BEQ.S    PARAM4            Exit on either space or C/R 
000011C4  E981                     288           ASL.L    #4,D1             Shift accumulated result 4 bits left 
000011C6  0400 0030                289           SUB.B    #$30,D0           Convert new character to hex 
000011CA  6B1E                     290           BMI.S    PARAM5            If less than $30 then not-hex 
000011CC  B03C 0009                291           CMP.B    #$09,D0           If less than 10 
000011D0  6F08                     292           BLE.S    PARAM3            then continue 
000011D2  5F00                     293           SUB.B    #$07,D0           Else assume $A - $F 
000011D4  B03C 000F                294           CMP.B    #$0F,D0           If more than $F 
000011D8  6E10                     295           BGT.S    PARAM5            then exit to error on not-hex 
000011DA  D200                     296  PARAM3   ADD.B    D0,D1             Add latest nybble to total in D1 
000011DC  60D8                     297           BRA      PARAM1            Repeat until delimiter found 
000011DE  2D48 0104                298  PARAM4   MOVE.L   A0,BUFFPT(A6)     Save pointer in memory 
000011E2  2D41 0108                299           MOVE.L   D1,PARAMTR(A6)    Save parameter in memory 
000011E6  2001                     300           MOVE.L   D1,D0             Put parameter in D0 for return 
000011E8  6004                     301           BRA.S    PARAM6            Return without error 
000011EA  8E3C 0002                302  PARAM5   OR.B     #2,D7             Set error flag before return 
000011EE  221F                     303  PARAM6   MOVE.L   (A7)+,D1          Restore working register 
000011F0  4E75                     304           RTS                        Return with error 
000011F2                           305  * 
000011F2                           306  ************************************************************************* 
000011F2                           307  * 
000011F2                           308  *  Output routines 
000011F2                           309  *  OUT1X   = print one   hexadecimal character 
000011F2                           310  *  OUT2X   = print two   hexadecimal characters 
000011F2                           311  *  OUT4X   = print four  hexadecimal characters 
000011F2                           312  *  OUT8X   = print eight hexadecimal characters 
000011F2                           313  *  In each case, the data to be printed is in D0 
000011F2                           314  * 
000011F2  3F00                     315  OUT1X    MOVE.W   D0,-(A7)          Save D0 
000011F4  C03C 000F                316           AND.B    #$0F,D0           Mask off MS nybble 
000011F8  0600 0030                317           ADD.B    #$30,D0           Convert to ASCII 
000011FC  B03C 0039                318           CMP.B    #$39,D0           ASCII = HEX + $30 
00001200  6302                     319           BLS.S    OUT1X1            If ASCII <= $39 then print and exit 
00001202  5E00                     320           ADD.B    #$07,D0           Else ASCII := HEX + 7 
00001204  6100 0344                321  OUT1X1   BSR      PUTCHAR           Print the character 
00001208  301F                     322           MOVE.W   (A7)+,D0          Restore D0 
0000120A  4E75                     323           RTS 
0000120C                           324  * 
0000120C  E818                     325  OUT2X    ROR.B    #4,D0             Get MS nybble in LS position 
0000120E  61E2                     326           BSR      OUT1X             Print MS nybble 
00001210  E918                     327           ROL.B    #4,D0             Restore LS nybble 
00001212  60DE                     328           BRA      OUT1X             Print LS nybble and return 
00001214                           329  * 
00001214  E058                     330  OUT4X    ROR.W    #8,D0             Get MS byte in LS position 
00001216  61F4                     331           BSR      OUT2X             Print MS byte 
00001218  E158                     332           ROL.W    #8,D0             Restore LS byte 
0000121A  60F0                     333           BRA      OUT2X             Print LS byte and return 
0000121C                           334  * 
0000121C  4840                     335  OUT8X    SWAP     D0                Get MS word in LS position 
0000121E  61F4                     336           BSR      OUT4X             Print MS word 
00001220  4840                     337           SWAP     D0                Restore LS word 
00001222  60F0                     338           BRA      OUT4X             Print LS word and return 
00001224                           339  * 
00001224                           340  ************************************************************************* 
00001224                           341  * 
00001224                           342  * JUMP causes execution to begin at the address in the line buffer 
00001224                           343  * 
00001224  6188                     344  JUMP     BSR     PARAM              Get address from buffer 
00001226  4A07                     345           TST.B   D7                 Test for input error 
00001228  6608                     346           BNE.S   JUMP1              If error flag not zero then exit 
0000122A  4A80                     347           TST.L   D0                 Else test for missing address 
0000122C  6704                     348           BEQ.S   JUMP1              field. If no address then exit 
0000122E  2040                     349           MOVE.L  D0,A0              Put jump address in A0 and call the 
00001230  4ED0                     350           JMP     (A0)               subroutine. User to supply RTS!! 
00001232  49FA 0C99                351  JUMP1    LEA.L   ERMES1(PC),A4      Here for error - display error 
00001236  6000 FE42                352           BRA     PSTRING            message and return 
0000123A                           353  * 
0000123A                           354  ************************************************************************* 
0000123A                           355  * 
0000123A                           356  *  Display the contents of a memory location and modify it 
0000123A                           357  * 
0000123A  6100 FF72                358  MEMORY   BSR      PARAM             Get start address from line buffer 
0000123E  4A07                     359           TST.B    D7                Test for input error 
00001240  6634                     360           BNE.S    MEM3              If error then exit 
00001242  2640                     361           MOVE.L   D0,A3             A3 points to location to be opened 
00001244  6100 FE24                362  MEM1     BSR      NEWLINE 
00001248  612E                     363           BSR.S    ADR_DAT           Print current address and contents 
0000124A  6140                     364           BSR.S    PSPACE             update pointer, A3, and O/P space 
0000124C  6100 02B0                365           BSR      GETCHAR           Input char to decide next action 
00001250  B03C 000D                366           CMP.B    #CR,D0            If carriage return then exit 
00001254  6720                     367           BEQ.S    MEM3              Exit 
00001256  B03C 002D                368           CMP.B    #'-',D0           If "-" then move back 
0000125A  6606                     369           BNE.S    MEM2              Else skip wind-back procedure 
0000125C  47EB FFFC                370           LEA.L    -4(A3),A3         Move pointer back 2+2 
00001260  60E2                     371           BRA      MEM1              Repeat until carriage return 
00001262  B03C 0020                372  MEM2     CMP.B    #SPACE,D0         Test for space (= new entry) 
00001266  66DC                     373           BNE.S    MEM1              If not space then repeat 
00001268  6100 FF38                374           BSR      WORD              Else get new word to store 
0000126C  4A07                     375           TST.B    D7                Test for input error 
0000126E  6606                     376           BNE.S    MEM3              If error then exit 
00001270  3740 FFFE                377           MOVE.W   D0,-2(A3)         Store new word 
00001274  60CE                     378           BRA      MEM1              Repeat until carriage return 
00001276  4E75                     379  MEM3     RTS 
00001278                           380  * 
00001278  2F00                     381  ADR_DAT  MOVE.L   D0,-(A7)          Print the contents of A3 and the 
0000127A  200B                     382           MOVE.L   A3,D0             word pointed at by A3. 
0000127C  619E                     383           BSR      OUT8X              and print current address 
0000127E  610C                     384           BSR.S    PSPACE            Insert delimiter 
00001280  3013                     385           MOVE.W   (A3),D0           Get data at this address in D0 
00001282  6190                     386           BSR      OUT4X              and print it 
00001284  47EB 0002                387           LEA.L    2(A3),A3          Point to next address to display 
00001288  201F                     388           MOVE.L   (A7)+,D0          Restore D0 
0000128A  4E75                     389           RTS 
0000128C                           390  * 
0000128C  1F00                     391  PSPACE   MOVE.B   D0,-(A7)          Print a single space 
0000128E  103C 0020                392           MOVE.B   #SPACE,D0
00001292  6100 02B6                393           BSR      PUTCHAR 
00001296  101F                     394           MOVE.B   (A7)+,D0 
00001298  4E75                     395           RTS 
0000129A                           396  * 
0000129A                           397  ************************************************************************* 
0000129A                           398  * 
0000129A                           399  *  LOAD  Loads data formatted in hexadecimal "S". format from Port 2 
0000129A                           400  *        NOTE - I/O is automatically redirected to the aux port for 
0000129A                           401  *        loader functions. S1 or S2 records accepted 
0000129A                           402  * 
0000129A  2F2E 0116                403  LOAD     MOVE.L   CN_OVEC(A6),-(A7) Save current output device name 
0000129E  2F2E 0112                404           MOVE.L   CN_IVEC(A6),-(A7) Save current input device name 
000012A2  522E 010C                405           ADD.B    #1,ECHO(A6)       Turn off character echo 
000012A6  6100 FDC2                406           BSR      NEWLINE           Send newline to host 
000012AA  6100 014E                407           BSR      DELAY             Wait for host to "settle" 
000012AE  6100 014A                408           BSR      DELAY 
000012B2  286E 0104                409           MOVE.L   BUFFPT(A6),A4     Any string in the line buffer is 
000012B6  101C                     410  LOAD1    MOVE.B   (A4)+,D0          transmitted to the host computer 
000012B8                           411           *sBSR      PUTCHAR           before the loading begins 
000012B8  B03C 000D                412           CMP.B    #CR,D0            Read from the buffer until EOL 
000012BC  66F8                     413           BNE      LOAD1 
000012BE  6100 FDAA                414           BSR      NEWLINE           Send newline before loading 
000012C2  6100 023A                415  LOAD2    BSR      GETCHAR           Records from the host must begin 
000012C6  B03C 0053                416           CMP.B    #'S',D0           with S1/S2 (data) or S9/S8 (term) 
000012CA  66F6                     417           BNE.S    LOAD2             Repeat GETCHAR until char = "S" 
000012CC  6100 0230                418           BSR      GETCHAR           Get character after "S" 
000012D0  B03C 0039                419           CMP.B    #'9',D0           Test for the two terminators S9/S8 
000012D4  6706                     420           BEQ.S    LOAD3             If S9 record then exit else test 
000012D6  B03C 0038                421           CMP.B    #'8',D0           for S8 terminator. Fall through to 
000012DA  662A                     422           BNE.S    LOAD6             exit on S8 else continue search 
000012DC  =000012DC                423  LOAD3    EQU      *                 Exit point from LOAD 
000012DC  2D5F 0112                424           MOVE.L   (A7)+,CN_IVEC(A6) Clean up by restoring input device 
000012E0  2D5F 0116                425           MOVE.L   (A7)+,CN_OVEC(A6) and output device name 
000012E4  422E 010C                426           CLR.B    ECHO(A6)          Restore input character echo 
000012E8  0807 0000                427           BTST     #0,D7             Test for input errors 
000012EC  6708                     428           BEQ.S    LOAD4             If no I/P error then look at checksum 
000012EE  49FA 0BDD                429           LEA.L    ERMES1(PC),A4     Else point to error message 
000012F2  6100 FD86                430           BSR      PSTRING           Print it 
000012F6  0807 0003                431  LOAD4    BTST     #3,D7             Test for checksum error 
000012FA  6708                     432           BEQ.S    LOAD5             If clear then exit 
000012FC  49FA 0BFF                433           LEA.L    ERMES3(PC),A4     Else point to error message 
00001300  6100 FD78                434           BSR      PSTRING           Print it and return 
00001304  4E75                     435  LOAD5    RTS 
00001306                           436  * 
00001306  B03C 0031                437  LOAD6    CMP.B    #'1',D0           Test for S1 record 
0000130A  671E                     438           BEQ.S    LOAD6A            If S1 record then read it 
0000130C  B03C 0032                439           CMP.B    #'2',D0           Else test for S2 record 
00001310  66B0                     440           BNE.S    LOAD2             Repeat until valid header found 
00001312  4203                     441           CLR.B    D3                Read the S2 byte count and address, 
00001314  613C                     442           BSR.S    LOAD8             clear the checksum 
00001316  5900                     443           SUB.B    #4,D0             Calculate size of data field 
00001318  1400                     444           MOVE.B   D0,D2             D2 contains data bytes to read 
0000131A  4280                     445           CLR.L    D0                Clear address accumulator 
0000131C  6134                     446           BSR.S    LOAD8             Read most sig byte of address 
0000131E  E180                     447           ASL.L    #8,D0             Move it one byte left 
00001320  6130                     448           BSR.S    LOAD8             Read the middle byte of address 
00001322  E180                     449           ASL.L    #8,D0             Move it one byte left 
00001324  612C                     450           BSR.S    LOAD8             Read least sig byte of address 
00001326  2440                     451           MOVE.L   D0,A2             A2 points to destination of record 
00001328  6012                     452           BRA.S    LOAD7             Skip past S1 header loader 
0000132A  4203                     453  LOAD6A   CLR.B    D3                S1 record found - clear checksum 
0000132C  6124                     454           BSR.S    LOAD8             Get byte and update checksum 
0000132E  5700                     455           SUB.B    #3,D0             Subtract 3 from record length 
00001330  1400                     456           MOVE.B   D0,D2             Save byte count in D2 
00001332  4280                     457           CLR.L    D0                Clear address accumulator 
00001334  611C                     458           BSR.S    LOAD8             Get MS byte of load address 
00001336  E180                     459           ASL.L    #8,D0             Move it to MS position 
00001338  6118                     460           BSR.S    LOAD8             Get LS byte in D2 
0000133A  2440                     461           MOVE.L   D0,A2             A2 points to destination of data 
0000133C  6114                     462  LOAD7    BSR.S    LOAD8             Get byte of data for loading 
0000133E  14C0                     463           MOVE.B   D0,(A2)+          Store it 
00001340  5302                     464           SUB.B    #1,D2             Decrement byte counter 
00001342  66F8                     465           BNE      LOAD7             Repeat until count = 0 
00001344  610C                     466           BSR.S    LOAD8             Read checksum 
00001346  5203                     467           ADD.B    #1,D3             Add 1 to total checksum 
00001348  6700 FF78                468           BEQ      LOAD2             If zero then start next record 
0000134C  8E3C 0008                469           OR.B     #%00001000,D7     Else set checksum error bit, 
00001350  608A                     470           BRA      LOAD3             restore I/O devices and return 
00001352                           471  * 
00001352  6100 FE3E                472  LOAD8    BSR     BYTE               Get a byte 
00001356  D600                     473           ADD.B   D0,D3              Update checksum 
00001358  4E75                     474           RTS                         and return 
0000135A                           475  *************************************************************************** 
0000135A                           476  * 
0000135A                           477  *  DUMP   Transmit S1 formatted records to host computer 
0000135A                           478  *         A3 = Starting address of data block 
0000135A                           479  *         A2 = End address of data block 
0000135A                           480  *         D1 = Checksum, D2 = current record length 
0000135A                           481  * 
0000135A  6100 008E                482  DUMP     BSR      RANGE             Get start and end address 
0000135E  4A07                     483           TST.B    D7                Test for input error 
00001360  6708                     484           BEQ.S    DUMP1             If no error then continue 
00001362  49FA 0B69                485           LEA.L    ERMES1(PC),A4     Else point to error message, 
00001366  6000 FD12                486           BRA      PSTRING           print it and return 
0000136A  B08B                     487  DUMP1    CMP.L    A3,D0             Compare start and end addresses 
0000136C  6A08                     488           BPL.S    DUMP2             If positive then start < end 
0000136E  49FA 0CFC                489           LEA.L    ERMES7(PC),A4     Else print error message 
00001372  6000 FD06                490           BRA      PSTRING           and return 
00001376  2F2E 0116                491  DUMP2    MOVE.L   CN_OVEC(A6),-(A7) Save name of current output device 
0000137A                           492  *         MOVE.L   #DCB4,CN_OVEC(A6) Set up Port 2 as output device 
0000137A  6100 FCEE                493           BSR      NEWLINE           Send newline to host and wait 
0000137E  617A                     494           BSR.S    DELAY 
00001380  286E 0104                495           MOVE.L   BUFFPT(A6),A4     Before dumping, send any string 
00001384  101C                     496  DUMP3    MOVE.B   (A4)+,D0          in the input buffer to the host 
00001386  6100 01C2                497           BSR      PUTCHAR           Repeat 
0000138A  B03C 000D                498           CMP.B    #CR,D0            Transmit char from buffer to host 
0000138E  66F4                     499           BNE      DUMP3             Until char = C/R 
00001390  6100 FCD8                500           BSR      NEWLINE 
00001394  6164                     501           BSR.S    DELAY             Allow time for host to settle 
00001396  528A                     502           ADDQ.L   #1,A2             A2 contains length of record + 1 
00001398  240A                     503  DUMP4    MOVE.L   A2,D2             D2 points to end address 
0000139A  948B                     504           SUB.L    A3,D2             D2 contains bytes left to print 
0000139C  B4BC 00000011            505           CMP.L    #17,D2            If this is not a full record of 16 
000013A2  6502                     506           BCS.S    DUMP5             then load D2 with record size 
000013A4  7410                     507           MOVEQ    #16,D2            Else preset byte count to 16 
000013A6  49FA 0A3B                508  DUMP5    LEA.L    HEADER(PC),A4     Point to record header 
000013AA  6100 FCCE                509           BSR      PSTRING           Print header 
000013AE  4201                     510           CLR.B    D1                Clear checksum 
000013B0  1002                     511           MOVE.B   D2,D0             Move record length to output register 
000013B2  5600                     512           ADD.B    #3,D0             Length includes address + count 
000013B4  612E                     513           BSR.S    DUMP7             Print number of bytes in record 
000013B6  200B                     514           MOVE.L   A3,D0             Get start address to be printed 
000013B8  E158                     515           ROL.W    #8,D0             Get MS byte in LS position 
000013BA  6128                     516           BSR.S    DUMP7             Print MS byte of address 
000013BC  E058                     517           ROR.W    #8,D0             Restore LS byte 
000013BE  6124                     518           BSR.S    DUMP7             Print LS byte of address 
000013C0  101B                     519  DUMP6    MOVE.B   (A3)+,D0          Get data byte to be printed 
000013C2  6120                     520           BSR.S    DUMP7             Print it 
000013C4  5302                     521           SUB.B    #1,D2             Decrement byte count 
000013C6  66F8                     522           BNE      DUMP6             Repeat until all this record printed 
000013C8  4601                     523           NOT.B    D1                Complement checksum 
000013CA  1001                     524           MOVE.B   D1,D0             Move to output register 
000013CC  6116                     525           BSR.S    DUMP7             Print checksum 
000013CE  6100 FC9A                526           BSR      NEWLINE 
000013D2  B7CA                     527           CMP.L    A2,A3             Have all records been printed? 
000013D4  66C2                     528           BNE      DUMP4             Repeat until all done 
000013D6  49FA 0A11                529           LEA.L    TAIL(PC),A4       Point to message tail (S9 record) 
000013DA  6100 FC9E                530           BSR      PSTRING           Print it 
000013DE  2D5F 0116                531           MOVE.L   (A7)+,CN_OVEC(A6) Restore name of output device 
000013E2  4E75                     532           RTS                        and return 
000013E4                           533  * 
000013E4  D200                     534  DUMP7    ADD.B    D0,D1             Update checksum, transmit byte 
000013E6  6000 FE24                535           BRA      OUT2X             to host and return 
000013EA                           536  * 
000013EA  =000013EA                537  RANGE    EQU      *                 Get the range of addresses to be 
000013EA  4207                     538           CLR.B    D7                transmitted from the buffer 
000013EC  6100 FDC0                539           BSR      PARAM             Get starting address 
000013F0  2640                     540           MOVE.L   D0,A3             Set up start address in A3 
000013F2  6100 FDBA                541           BSR      PARAM             Get end address 
000013F6  2440                     542           MOVE.L   D0,A2             Set up end address in A2 
000013F8  4E75                     543           RTS 
000013FA                           544  * 
000013FA  =000013FA                545  DELAY    EQU       *                Provide a time delay for the host 
000013FA  48E7 8008                546           MOVEM.L   D0/A4,-(A7)      to settle. Save working registers 
000013FE  203C 00004000            547           MOVE.L    #$4000,D0        Set up delay constant 
00001404  5380                     548  DELAY1   SUB.L     #1,D0            Count down         (8 clk cycles) 
00001406  66FC                     549           BNE       DELAY1           Repeat until zero  (10 clk cycles) 
00001408  4CDF 1001                550           MOVEM.L   (A7)+,D0/A4      Restore working registers 
0000140C  4E75                     551           RTS 
0000140E                           552  * 
0000140E                           553  * AUX_IN and AUX_OUT are simplified versions of CON_IN and 
0000140E                           554  * CON_OUT for use with the port to the host processor 
0000140E                           555  
0000140E  43E8 000C                556  AUX_IN    LEA.L   12(A0),A1       Get pointer to aux ACIA from DCB 
00001412  2251                     557            MOVE.L  (A1),A1         Get address of aux ACIA 
00001414  0811 0000                558  AUX_IN1   BTST.B  #0,(A1)         Test for data ready 
00001418  67FA                     559            BEQ     AUX_IN1         Repeat until ready 
0000141A  1029 0002                560            MOVE.B  2(A1),D0        Read input 
0000141E  4E75                     561            RTS 
00001420                           562    
00001420  43E8 000C                563  AUX_OUT   LEA.L   12(A0),A1       Get pointer to aux ACIA from DCB 
00001424  2251                     564            MOVE.L  (A1),A1         Get address of aux ACIA 
00001426  0811 0001                565  AUX_OT1   BTST.B  #1,(A1)         Test for ready to transmit 
0000142A  67FA                     566            BEQ     AUX_OT1         Repeat until transmitter ready 
0000142C  1340 0002                567            MOVE.B  D0,2(A1)        Transmit data 
00001430  4E75                     568            RTS 
00001432                           569  ************************************************************************* 
00001432                           570  * 
00001432                           571  *  This routine sets up the system DCBs in RAM using the information 
00001432                           572  *  stored in ROM at address DCB_LST. This is called at initialization. 
00001432                           573  *  CN_IVEC contains the name "DCB1" and IO_VEC the name "DCB2" 
00001432                           574  * 
00001432  48E7 F0F0                575  SET_DCB  MOVEM.L A0-A3/D0-D3,-(A7) Save all working registers 
00001436  41EE 0194                576           LEA.L   FIRST(A6),A0    Pointer to first DCB destination in RAM 
0000143A  43FA 0BFC                577           LEA.L   DCB_LST(PC),A1  A1 points to DCB info block in ROM 
0000143E  303C 0003                578           MOVE.W  #3,D0           4 DCBs to set up 
00001442  323C 000F                579  ST_DCB1  MOVE.W  #15,D1          16 bytes to move per DCB header 
00001446  10D9                     580  ST_DCB2  MOVE.B  (A1)+,(A0)+     Move the 16 bytes of a DCB header 
00001448  51C9 FFFC                581           DBRA    D1,ST_DCB2      from ROM to RAM 
0000144C  3619                     582           MOVE.W  (A1)+,D3        Get size of parameter block (bytes) 
0000144E  3083                     583           MOVE.W  D3,(A0)         Store size in DCB in RAM 
00001450  41F0 3002                584           LEA.L   2(A0,D3.W),A0   A0 points to tail of DCB in RAM 
00001454  47E8 0004                585           LEA.L   4(A0),A3        A3 contains address of next DCB in RAM 
00001458  208B                     586           MOVE.L  A3,(A0)         Store pointer to next DCB in this DCB 
0000145A  41D3                     587           LEA.L   (A3),A0         A0 now points at next DCB in RAM 
0000145C  51C8 FFE4                588           DBRA    D0,ST_DCB1      Repeat until all DCBs set up 
00001460  47EB FFFC                589           LEA.L   -4(A3),A3       Adjust A3 to point to last DCB pointer 
00001464  4293                     590           CLR.L   (A3)            and force last pointer to zero 
00001466  2D7C 00002038 0112       591           MOVE.L  #DCB1,CN_IVEC(A6) Set up vector to console input DCB 
0000146E  2D7C 0000204A 0116       592           MOVE.L  #DCB2,CN_OVEC(A6) Set up vector to console output DCB 
00001476  4CDF 0F0F                593           MOVEM.L (A7)+,A0-A3/D0-D3 Restore registers 
0000147A  4E75                     594           RTS 
0000147C                           595  * 
0000147C                           596  ************************************************************************* 
0000147C                           597  * 
0000147C                           598  *  IO_REQ handles all input/output transactions. A0 points to DCB on 
0000147C                           599  *  entry. IO_REQ calls the device driver whose address is in the DCB. 
0000147C                           600  * 
0000147C  48E7 00C0                601  IO_REQ   MOVEM.L A0-A1,-(A7)     Save working registers 
00001480  43E8 0008                602           LEA.L   8(A0),A1        A1 points to device handler field in DCB 
00001484  2251                     603           MOVE.L  (A1),A1         A1 contains device handler address 
00001486  4E91                     604           JSR     (A1)            Call device handler 
00001488  4CDF 0300                605           MOVEM.L (A7)+,A0-A1     Restore working registers 
0000148C  4E75                     606           RTS 
0000148E                           607  * 
0000148E                           608  ************************************************************************* 
0000148E                           609  * 
0000148E                           610  *  CON_IN handles input from the console device 
0000148E                           611  *  This is the device driver used by DCB1. Exit with input in D0 
0000148E                           612  * 
0000148E  48E7 4040                613  CON_IN   MOVEM.L D1/A1,-(A7)     Save working registers 
00001492  43E8 000C                614           LEA.L   12(A0),A1       Get pointer to ACIA from DCB 
00001496  2251                     615           MOVE.L  (A1),A1         Get address of ACIA in A1 
00001498  4228 0013                616           CLR.B   19(A0)          Clear logical error in DCB 
0000149C  1211                     617  CON_I1   MOVE.B  (A1),D1         Read ACIA status 
0000149E  0801 0000                618           BTST  #0,D1           Test RDRF 
000014A2  67F8                     619           BEQ     CON_I1          Repeat until RDRF true 
000014A4  1141 0012                620           MOVE.B  D1,18(A0)       Store physical status in DCB 
000014A8  C23C 00F4                621           AND.B   #%011110100,D1  Mask to input error bits 
000014AC  6706                     622           BEQ.S   CON_I2          If no error then skip update 
000014AE  117C 0001 0013           623           MOVE.B  #1,19(A0)       Else update logical error 
000014B4  1029 0002                624  CON_I2   MOVE.B  2(A1),D0        Read input from ACIA 
000014B8  4CDF 0202                625           MOVEM.L (A7)+,A1/D1     Restore working registers 
000014BC  4E75                     626           RTS 
000014BE                           627  * 
000014BE                           628  ************************************************************************* 
000014BE                           629  * 
000014BE                           630  *   This is the device driver used by DCB2. Output in D0 
000014BE                           631  *   The output can be halted or suspended 
000014BE                           632  * 
000014BE  48E7 6040                633  CON_OUT  MOVEM.L A1/D1-D2,-(A7)  Save working registers 
000014C2  43E8 000C                634           LEA.L   12(A0),A1       Get pointer to ACIA from DCB 
000014C6  2251                     635           MOVE.L  (A1),A1         Get address of ACIA in A1 
000014C8  4228 0013                636           CLR.B   19(A0)          Clear logical error in DCB 
000014CC  1211                     637  CON_OT1  MOVE.B  (A1),D1         Read ACIA status 
000014CE  0801 0000                638           BTST  #0,D1           Test RDRF bit (any input?) 
000014D2  6716                     639           BEQ.S   CON_OT3         If no input then test output status 
000014D4  1429 0002                640           MOVE.B  2(A1),D2        Else read the input 
000014D8  C43C 005F                641           AND.B   #%01011111,D2   Strip parity and bit 5 
000014DC  B43C 0057                642           CMP.B   #WAIT,D2        and test for a wait condition 
000014E0  6608                     643           BNE.S   CON_OT3         If not wait then ignore and test O/P 
000014E2  1411                     644  CON_OT2  MOVE.B  (A1),D2         Else read ACIA status register 
000014E4  0802 0000                645           BTST  #0,D2           and poll ACIA until next char received 
000014E8  67F8                     646           BEQ     CON_OT2 
000014EA  0801 0001                647  CON_OT3  BTST  #1,D1           Repeat 
000014EE  67DC                     648           BEQ     CON_OT1          until ACIA Tx ready 
000014F0  1141 0012                649           MOVE.B  D1,18(A0)       Store status in DCB physical error 
000014F4  1340 0002                650           MOVE.B  D0,2(A1)        Transmit output 
000014F8  4CDF 0206                651           MOVEM.L (A7)+,A1/D1-D2  Restore working registers 
000014FC  4E75                     652           RTS 
000014FE                           653  * 
000014FE                           654  ************************************************************************* 
000014FE                           655  * 
000014FE                           656  *  GETCHAR gets a character from the console device 
000014FE                           657  *  This is the main input routine and uses the device whose name  
000014FE                           658  *  is stored in CN_IVEC. Changing this name redirects input. 
000014FE                           659  * 
000014FE  2F08                     660  GETCHAR  MOVE.L  A0,-(A7)        Save working register 
00001500  206E 0112                661           MOVE.L  CN_IVEC(A6),A0  A0 points to name of console DCB 
00001504  616A                     662           BSR.S   IO_OPEN         Open console (get DCB address in A0) 
00001506  0807 0003                663           BTST    #3,D7           D7(3) set if open error 
0000150A  6628                     664           BNE.S   GETCH3          If error then exit now 
0000150C  6100 FF6E                665           BSR     IO_REQ          Else execute I/O transaction 
00001510  C03C 007F                666           AND.B   #$7F,D0         Strip msb of input 
00001514  4A2E 010D                667           TST.B   U_CASE(A6)      Test for upper -> lower case conversion 
00001518  660A                     668           BNE.S   GETCH2          If flag not zero do not convert case 
0000151A  0800 0006                669           BTST    #6,D0           Test input for lower case 
0000151E  6704                     670           BEQ.S   GETCH2          If upper case then skip conversion 
00001520  C03C 00DF                671           AND.B   #%11011111,D0   Else clear bit 5 for upper case conv 
00001524  4A2E 010C                672  GETCH2   TST.B   ECHO(A6)        Do we need to echo the input? 
00001528  660A                     673           BNE.S   GETCH3          If ECHO not zero then no echo
0000152A  BC3C 0001                674           CMP.B   #1,D6
0000152E  6700 0008                675           BEQ     PUTASK
00001532  6116                     676           BSR.S   PUTCHAR         Else echo the input 
00001534  205F                     677  GETCH3   MOVE.L  (A7)+,A0        Restore working register 
00001536  4E75                     678           RTS                     and return 
00001538                           679  
00001538  1600                     680  PUTASK   MOVE.B  D0,D3           save D0
0000153A  B07C 000D                681           CMP     #CR,D0          if Carriage_return 
0000153E  6700 001E                682           BEQ     SPUTCHAR        then PUTCHAR
00001542  103C 002A                683           MOVE.B  #42,D0          else PUTASK to hide password
00001546  6000 0016                684           BRA     SPUTCHAR
0000154A                           685  
0000154A                           686  * 
0000154A                           687  ************************************************************************* 
0000154A                           688  * 
0000154A                           689  *  PUTCHAR sends a character to the console device 
0000154A                           690  *  The name of the output device is in CN_OVEC. 
0000154A                           691  * 
0000154A  BC3C 0001                692  PUTCHAR  CMP.B   #1,D6
0000154E  2F08                     693           MOVE.L  A0,-(A7)        Save working register
00001550  206E 0116                694           MOVE.L  CN_OVEC(A6),A0  A0 points to name of console output 
00001554  611A                     695           BSR.S   IO_OPEN         Open console (Get address of DCB) 
00001556  6100 FF24                696           BSR     IO_REQ          Perform output with DCB pointed at by A0 
0000155A  205F                     697           MOVE.L  (A7)+,A0        Restore working register 
0000155C  4E75                     698           RTS 
0000155E                           699  
0000155E  2F08                     700  SPUTCHAR  MOVE.L  A0,-(A7)        Save working register
00001560  206E 0116                701            MOVE.L  CN_OVEC(A6),A0  A0 points to name of console output 
00001564  610A                     702            BSR.S   IO_OPEN         Open console (Get address of DCB) 
00001566  6100 FF14                703            BSR     IO_REQ          Perform output with DCB pointed at by A0 
0000156A  205F                     704            MOVE.L  (A7)+,A0        Restore working register
0000156C  1003                     705            MOVE.B  D3,D0           restore d0
0000156E  60C4                     706            BRA     GETCH3 
00001570                           707  * 
00001570                           708  ************************************************************************* 
00001570                           709  * 
00001570                           710  *  Open - opens a DCB for input or output. IO_OPEN converts the 
00001570                           711  *  name pointed at by A0 into the address of the DCB pointed at 
00001570                           712  *  by A0. Bit 3 of D7 is set to zero if DCB not found 
00001570                           713  * 
00001570  48E7 F870                714  IO_OPEN  MOVEM.L  A1-A3/D0-D4,-(A7) Save working registers 
00001574  43EE 0194                715           LEA.L    FIRST(A6),A1   A1 points to first DCB in chain in RAM 
00001578  45D1                     716  OPEN1    LEA.L    (A1),A2        A2 = temp copy of pointer to DCB 
0000157A  47D0                     717           LEA.L    (A0),A3        A3 = temp copy of pointer to DCB name 
0000157C  303C 0007                718           MOVE.W   #7,D0          Up to 8 chars of DCB name to match 
00001580  181A                     719  OPEN2    MOVE.B   (A2)+,D4       Compare DCB name with string 
00001582  B81B                     720           CMP.B    (A3)+,D4 
00001584  6608                     721           BNE.S    OPEN3          If no match try next DCB 
00001586  51C8 FFF8                722           DBRA     D0,OPEN2       Else repeat until all chars matched 
0000158A  41D1                     723           LEA.L    (A1),A0        Success - move this DCB address to A0 
0000158C  6016                     724           BRA.S    OPEN4          and return 
0000158E  =0000158E                725  OPEN3    EQU      *              Fail - calculate address of next DCB 
0000158E  3229 0010                726           MOVE.W   16(A1),D1      Get parameter block size of DCB 
00001592  43F1 1012                727           LEA.L    18(A1,D1.W),A1 A1 points to pointer to next DCB 
00001596  2251                     728           MOVE.L   (A1),A1        A1 now points to next DCB 
00001598  B3FC 00000000            729           CMP.L    #0,A1          Test for end of DCB chain 
0000159E  66D8                     730           BNE      OPEN1          If not end of chain then try next DCB 
000015A0  8E3C 0008                731           OR.B     #8,D7          Else set error flag and return 
000015A4  4CDF 0E1F                732  OPEN4    MOVEM.L  (A7)+,A1-A3/D0-D4 Restore working registers 
000015A8  4E75                     733           RTS 
000015AA                           734  * 
000015AA                           735  ************************************************************************* 
000015AA                           736  * 
000015AA                           737  *  Exception vector table initialization routine 
000015AA                           738  *  All vectors not setup are loaded with uninitialized routine vector 
000015AA                           739  * 
000015AA  303C 0007                740  B_CLR   MOVE.W  #7,D0             Now clear the breakpoint table 
000015AE  41EE 0164                741          LEA.L   BP_TAB(A6),A0     Point to table
000015B2  4E75                     742          RTS 
000015B4                           743  * 
000015B4                           744  *************************************************************************
000015B4  DA04                     745  ADD_0   ADD.B     D4,D5           adding Bytes inputted to D4 and D5
000015B6  1605                     746          MOVE.B    D5,D3           moving D5 to D3
000015B8  183C 0000                747          MOVE.B    #0,D4           resetting neg flag
000015BC  6B00 0040                748          BMI       SETNEG          if negative set neg flag
000015C0  4E75                     749          RTS
000015C2                           750  
000015C2  9A04                     751  SUB_0   SUB.B     D4,D5           subtracting Bytes inputted to D4 and D5
000015C4  183C 0000                752          MOVE.B    #0,D4           resetting neg flag
000015C8  1605                     753          MOVE.B    D5,D3           moving D5 to D3
000015CA  6B00 0032                754          BMI       SETNEG          if negative set neg flag
000015CE  4E75                     755          RTS
000015D0                           756          
000015D0  CBC4                     757  MUL_0   MULS      D4,D5           multiplying Bytes inputted to D4 and D5
000015D2  383C 0000                758          MOVE.W    #0,D4           resetting neg flag
000015D6  2605                     759          MOVE.L    D5,D3           moving D5 to D3
000015D8  6B00 0034                760          BMI       MULNEG          if negative set neg flag
000015DC  4E75                     761          RTS
000015DE                           762  
000015DE  8BC4                     763  DIV_0   DIVS      D4,D5           dividing Bytes inputted to D4 and D5
000015E0  183C 0000                764          MOVE.B    #0,D4           resetting neg flag
000015E4  1605                     765          MOVE.B    D5,D3           moving D5 to D3
000015E6  4603                     766          NOT.B     D3              converting result from twos Complement
000015E8  C63C 007F                767          AND.B     #%01111111,D3   to regular hex values
000015EC  5203                     768          ADD.B     #1,D3           finishing process
000015EE  BA7C 007F                769          CMP.W     #127,D5         if greater than, it is negative
000015F2  6500 0004                770          BCS       DIVNEG          if negative set neg flag
000015F6  4E75                     771          RTS
000015F8                           772  
000015F8  183C 0001                773  DIVNEG  MOVE.B    #1,D4           set neg flag
000015FC  4E75                     774          RTS
000015FE                           775  
000015FE  183C 00FF                776  SETNEG  MOVE.B    #255,D4         convert twos comliment conversion
00001602  9803                     777          SUB.B     D3,D4           result to regular hex
00001604  1604                     778          MOVE.B    D4,D3           moving D4 to D3
00001606  5203                     779          ADD.B     #1,D3           set neg flag
00001608  183C 0001                780          MOVE.B    #1,D4           set neg flag
0000160C  4E75                     781          RTS
0000160E                           782  
0000160E  183C 0001                783  MULNEG  MOVE.B    #1,D4           setting neg flag
00001612  4683                     784          NOT.L     D3              since a neg product is twos comliment this must 
00001614  C6BC 7FFFFFFF            785          AND.L     #%01111111111111111111111111111111,D3       be converted to hex
0000161A  5203                     786          ADD.B     #1,D3
0000161C  4E75                     787          RTS
0000161E                           788  
0000161E                           789  *************************************************************************
0000161E  =0000161E                790  FTRAP   EQU *
0000161E  202F 0002                791          MOVE.L    2(A7),D0        Get PC from system stack.
00001622  2040                     792          MOVEA.L   D0,A0           COPY to A0 to become an address for later use.
00001624  5C80                     793          ADD.L     #6,D0           Calculate address of next instruction
00001626  2F40 0002                794          MOVE.L    D0,2(A7)        Update PC on system stack for FMOVE instruction
0000162A  2010                     795          MOVE.L    (A0),D0         Get FPU opcode/command.
0000162C  C0BC 00380000            796          AND.L     #$380000,D0     Mask opcode/command to get effective address mode.
00001632  B0BC 00000000            797          CMP.L     #0,D0           What is the addressing mode used in the FPU instruction?
00001638  6700 0070                798          BEQ       RTOR            Is it Dn or FPn register mode?
0000163C  2010                     799          MOVE.L    (A0),D0         Must be An or (An) mode
0000163E  0800 000D                800          BTST      #13,D0          Test bit 13 or dir of the FPU command word
00001642  6600 0034                801          BNE       RTOM            Is it register to memory operation or memory to register operation        
00001646                           802          
00001646  33C0 0008000A            803  MTOR    MOVE.W    D0, MC68881+COMMAND       Move command word into command reg.
0000164C  0C79 8900 00080000       804  NULCA   CMPI      #$8900, MC68881+RESPONSE  Test for response from FPU
00001654  67F6                     805          BEQ.S     NULCA                     Keep testing
00001656  23F8 4000 00080010       806          MOVE.L    $4000, MC68881+OPER       Move the first 4 Bytes into operand reg.
0000165E  23F8 4004 00080010       807          MOVE.L    $4004, MC68881+OPER       Move the second 4 Bytes
00001666  23F8 4008 00080010       808          MOVE.L    $4008, MC68881+OPER       Move the third 4 Bytes
0000166E  4A39 00080000            809  NULREL  TST.B     MC68881+RESPONSE
00001674  6BF8                     810          BMI.S     NULREL
00001676  4E73                     811          RTE
00001678                           812          
00001678  33C0 0008000A            813  RTOM    MOVE.W  D0, MC68881+COMMAND
0000167E  0C79 8900 00080000       814  NULCA1  CMPI    #$8900, MC68881+RESPONSE
00001686  67F6                     815          BEQ.S   NULCA1
00001688  21F9 00080010 4000       816          MOVE.L  MC68881+OPER, $4000
00001690  21F9 00080010 4004       817          MOVE.L  MC68881+OPER, $4004
00001698  21F9 00080010 4008       818          MOVE.L  MC68881+OPER, $4008
000016A0  4A39 00080000            819  NULREL1 TST.B   MC68881+RESPONSE
000016A6  6BF8                     820          BMI.S   NULREL1
000016A8  4E73                     821          RTE
000016AA                           822          
000016AA  49F9 00002079            823  RTOR    LEA.L   TEST,A4    
000016B0  6100 F9C8                824          BSR     PSTRING
000016B4  33C0 0008000A            825          MOVE.W  D0, MC68881+COMMAND
000016BA  4A39 00080000            826  NULCA2  TST.B   MC68881+RESPONSE
000016C0  6BF8                     827          BMI.S   NULCA2
000016C2                           828          
000016C2  202F 0002                829          MOVE.L  2(A7),D0          Get PC from system stack.
000016C6  5880                     830          ADD.L   #4,D0             Calculate address of next instruction
000016C8  2F40 0002                831          MOVE.L  D0,2(A7)          Update PC on system stack for FADD instruction
000016CC  4E73                     832          RTE
000016CE                           833  
000016CE                           834  ************************************************************************* 
000016CE                           835  * 
000016CE                           836  * 
000016CE  =000016CE                837  TRAP_0  EQU     *                 User links to  TS2BUG via TRAP #0 
000016CE  B23C 0000                838          CMP.B   #0,D1             D1 = 0 = Get character 
000016D2  6606                     839          BNE.S   FOO1           
000016D4  6100 FE28                840          BSR     GETCHAR 
000016D8  4E73                     841          RTE 
000016DA  B23C 0001                842  FOO1    CMP.B   #1,D1             D1 = 1 = Print character 
000016DE  6606                     843          BNE.S   FOO2 
000016E0  6100 FE68                844          BSR     PUTCHAR 
000016E4  4E73                     845          RTE 
000016E6  B23C 0002                846  FOO2    CMP.B   #2,D1             D1 = 2 = Newline 
000016EA  6606                     847          BNE.S   FOO3 
000016EC  6100 F97C                848          BSR     NEWLINE 
000016F0  4E73                     849          RTE 
000016F2  B23C 0003                850  FOO3    CMP.B   #3,D1             D1 = 3 = Get parameter from buffer 
000016F6  6606                     851          BNE.S   FOO4 
000016F8  6100 FAB4                852          BSR     PARAM 
000016FC  4E73                     853          RTE 
000016FE  B23C 0004                854  FOO4    CMP.B   #4,D1             D1 = 4 = Print string pointed at by A4 
00001702  6606                     855          BNE.S   FOO5 
00001704  6100 F974                856          BSR     PSTRING 
00001708  4E73                     857          RTE 
0000170A  B23C 0005                858  FOO5    CMP.B   #5,D1             D1 = 5 = Get a hex character 
0000170E  6606                     859          BNE.S   FOO6 
00001710  6100 FA62                860          BSR     HEX 
00001714  4E73                     861          RTE 
00001716  B23C 0006                862  FOO6    CMP.B   #6,D1             D1 = 6 = Get a hex byte 
0000171A  6606                     863          BNE.S   FOO7 
0000171C  6100 FA74                864          BSR     BYTE 
00001720  4E73                     865          RTE 
00001722  B23C 0007                866  FOO7    CMP.B   #7,D1             D1 = 7 = Get a word 
00001726  6606                     867          BNE.S   FOO8 
00001728  6100 FA78                868          BSR     WORD 
0000172C  4E73                     869          RTE 
0000172E  B23C 0008                870  FOO8    CMP.B   #8,D1             D1 = 8 = Get a longword 
00001732  6606                     871          BNE.S   FOO9 
00001734  6100 FA72                872          BSR     LONGWD 
00001738  4E73                     873          RTE 
0000173A  B23C 0009                874  FOO9    CMP.B   #9,D1             D1 = 9 = Output hex byte 
0000173E  6606                     875          BNE.S   FOO10  
00001740  6100 FACA                876          BSR     OUT2X 
00001744  4E73                     877          RTE 
00001746  B23C 000A                878  FOO10   CMP.B   #10,D1            D1 = 10 = Output hex word 
0000174A  6606                     879          BNE.S   FOO11 
0000174C  6100 FAC6                880          BSR     OUT4X 
00001750  4E73                     881          RTE 
00001752  B23C 000B                882  FOO11   CMP.B   #11,D1            D1 = 11 = Output hex longword 
00001756  6606                     883          BNE.S   FOO12 
00001758  6100 FAC2                884          BSR     OUT8X 
0000175C  4E73                     885          RTE 
0000175E  B23C 000C                886  FOO12   CMP.B   #12,D1            D1 = 12 = Print a space 
00001762  6606                     887          BNE.S   FOO13 
00001764  6100 FB26                888          BSR     PSPACE 
00001768  4E73                     889          RTE 
0000176A  B23C 000D                890  FOO13   CMP.B   #13,D1            D1 = 13 = Get a line of text into 
0000176E  6606                     891          BNE.S   FOO14            the line buffer 
00001770  6100 F91E                892          BSR     GETLINE 
00001774  4E73                     893          RTE 
00001776  B23C 000E                894  FOO14   CMP.B   #14,D1            D1 = 14 = Tidy up the line in the 
0000177A  6606                     895          BNE.S   FOO15            line buffer by removing leading 
0000177C  6100 F948                896          BSR     TIDY              leading and multiple embeded spaces 
00001780  4E73                     897          RTE 
00001782  B23C 000F                898  FOO15   CMP.B   #15,D1            D1 = 15 = Execute the command in 
00001786  6606                     899          BNE.S   FOO16            the line buffer 
00001788  6100 F97E                900          BSR     EXECUTE 
0000178C  4E73                     901          RTE 
0000178E  B23C 0010                902  FOO16   CMP.B   #16,D1            D1 = 16 = Call RESTORE to transfer 
00001792  6606                     903          BNE.S   FOO17            the registers in TSK_T to the 68000 
00001794  6100 0428                904          BSR     RESTORE           and therefore execute a program 
00001798  4E73                     905          RTE 
0000179A  B23C 0011                906  FOO17   CMP.B   #17,D1            D1 = 17 = Call ADD_0
0000179E  6606                     907          BNE.S   FOO18            
000017A0  6100 FE12                908          BSR     ADD_0            
000017A4  4E73                     909          RTE 
000017A6  B23C 0012                910  FOO18   CMP.B   #18,D1            D1 = 18 = Call SUB_0
000017AA  6606                     911          BNE.S   FOO19            
000017AC  6100 FE14                912          BSR     SUB_0            
000017B0  4E73                     913          RTE 
000017B2  B23C 0013                914  FOO19   CMP.B   #19,D1            D1 = 19 = Call MUL_0
000017B6  6606                     915          BNE.S   FOO20            
000017B8  6100 FE16                916          BSR     MUL_0            
000017BC  4E73                     917          RTE 
000017BE  B23C 0014                918  FOO20   CMP.B   #20,D1            D1 = 20 = Call DIV_0
000017C2  6606                     919          BNE.S   FOO21            
000017C4  6100 FE18                920          BSR     DIV_0            
000017C8  4E73                     921          RTE
000017CA  B23C 0015                922  FOO21   CMP.B   #21,D1            D1 = 20 = Call GETLINE to get two digit input
000017CE  6618                     923          BNE.S   FOO22
000017D0  6100 F8BE                924          BSR     GETLINE
000017D4  1219                     925          MOVE.B  (A1)+,D1          get first digit
000017D6  1611                     926          MOVE.B  (A1),D3           get second digit
000017D8  0441 0030                927          subi    #48,d1            convert to number
000017DC  0443 0030                928          subi    #48,d3            convert to number
000017E0  C2FC 000A                929          MULU    #10,D1            Multiply first digit by 10
000017E4  D601                     930          ADD.B   D1,D3             add digits
000017E6  4E73                     931          RTE
000017E8  B23C 0016                932  FOO22   CMP.B   #22,D1            D1 = 20 = Call DIV_0
000017EC  660A                     933          BNE.S   FOO23            
000017EE  6100 F87A                934          BSR     NEWLINE
000017F2  1003                     935          MOVE.B  D3,D0             loading answer to D0
000017F4  6100 FA16                936          BSR     OUT2X             print D0
000017F8  B23C 0017                937  FOO23   CMP.B   #23,D1            D1 = 20 = Call DIV_0
000017FC  660A                     938          BNE.S   FOO24
000017FE  6100 F86A                939          BSR     NEWLINE
00001802  1003                     940          MOVE.B  D3,D0
00001804  6100 FA0E                941          BSR     OUT4X             print D0
00001808  B23C 0018                942  FOO24   CMP.B   #24,D1            D1 = 20 = Call DIV_0
0000180C  660C                     943          BNE.S   FOO25
0000180E  6100 F880                944          BSR     GETLINE
00001812  6100 F8B2                945          BSR     TIDY
00001816  6100 001A                946          BSR     AtoBCD
0000181A  B23C 0019                947  FOO25   CMP.B   #25,D1            D1 = 20 = Call DIV_0
0000181E  6604                     948          BNE.S   FOO26
00001820  6100 00D2                949          BSR     BCDtoA
00001824  4E73                     950  FOO26   RTE         
00001826                           951  * 
00001826                           952  ************************************************************************* 
00001826  =00001826                953  TRAP_14  EQU     *
00001826  6000 02FE                954           BRA     BRKPT            User application breakpoint
0000182A  4E73                     955           RTE
0000182C                           956  *
0000182C                           957  ************************************************************************* 
0000182C  6000 F816                958  TRAP_15  BRA     WARM              
00001830  4E73                     959           RTE
00001832                           960  *
00001832                           961  ************************************************************************* 
00001832  =00001832                962  AtoBCD  EQU *
00001832  41F8 4000                963          LEA.L   $4000,A0
00001836  4298                     964          CLR.L   (A0)+         Clear $4000 to $400B
00001838  4298                     965          CLR.L   (A0)+
0000183A  4290                     966          CLR.L   (A0)
0000183C  4280                     967          CLR.L   D0
0000183E  4281                     968          CLR.L   D1
00001840  41EE 00C4                969          LEA.L   LNBUFF(A6),A0     A0 points to line buffer  
00001844  1018                     970          MOVE.B  (A0)+,D0          Read ASCII character from line buffer
00001846  B03C 002D                971          CMP.B   #'-',D0       Is the first character in the FP string a minus?
0000184A  6600 000C                972          BNE NUM3          if not a minus then it is the single integer number
0000184E  11FC 0080 4000           973          MOVE.B  #$80,$4000
00001854  1010                     974          MOVE.B  (A0),D0       assemble minus
00001856  5288                     975          ADDA.L  #1,A0
00001858  0400 0030                976  NUM3    SUB.B   #48,D0        convert ASCII to Number
0000185C  11C0 4003                977          MOVE.B  D0,$4003      assemble integer part
00001860  5288                     978          ADDA.L  #1,A0         skip decimal point
00001862  227C 00004004            979          MOVEA.L #$4004,A1     set assemble address at fraction part
00001868  1018                     980  AGAIN3  MOVE.B  (A0)+,D0      get first ASCII number
0000186A  B03C 0045                981          CMP.B   #'E',D0       is it the end of the fractional part
0000186E  6700 0024                982          BEQ EXP3          goto exponent section if true
00001872  0400 0030                983          SUB.B   #48,D0        convert first ASCII to number
00001876  E908                     984          LSL.B   #4,D0         shift first number left 4 bits in D0
00001878  1210                     985          MOVE.B  (A0),D1       get second ASCII number in D2
0000187A  B23C 0045                986          CMP.B   #'E',D1       is it the end of the fractional part
0000187E  6700 0010                987          BEQ DONE3         goto exponent section if true
00001882  0401 0030                988          SUB.B   #48,D1        convert second ASCII to number in D2
00001886  8001                     989          OR.B    D1,D0         pack the two numbers in D0
00001888  1280                     990          MOVE.B  D0,(A1)       store the packed BCD to its corresponding address
0000188A  5289                     991          ADDA.L  #1,A1         point A1 to the next packed BCD location
0000188C  5288                     992          ADDA.L  #1,A0       point A0 to the next ASCII character
0000188E  60D8                     993          BRA AGAIN3      Repeat until all fractional numbers are converted from ASCII to packed BCD
00001890  1280                     994  DONE3   MOVE.B  D0,(A1)     Finish the last number
00001892  5288                     995          ADDA.L  #1,A0       advance the pointer past the last fractional number
00001894  1010                     996  EXP3    MOVE.B  (A0),D0     test for minus or number then point to next number
00001896  B03C 002D                997          CMP.B   #'-',D0
0000189A  6600 000A                998          BNE EXP12       if not minus then first exp number
0000189E  0638 0040 4000           999          ADD.B   #$40,$4000  it is a minus exp so set it
000018A4  5288                    1000          ADDA.L  #1,A0
000018A6  4281                    1001  EXP12   CLR.L   D1
000018A8  1010                    1002  EXP13   MOVE.B  (A0),D0
000018AA  B03C 000D               1003          CMP.B   #CR,D0      is it a carriage return?
000018AE  6700 0008               1004          BEQ REV3
000018B2  5201                    1005          ADD.B   #1,D1
000018B4  5288                    1006          ADDA.L  #1,A0       point to next exponent number
000018B6  60F0                    1007          BRA EXP13
000018B8  B23C 0001               1008  REV3    CMP.B   #1,D1
000018BC  6600 000E               1009          BNE TWOOR3
000018C0  1020                    1010          MOVE.B  -(A0),D0
000018C2  0400 0030               1011          SUB.B   #48,D0
000018C6  11C0 4001               1012          MOVE.B  D0,$4001
000018CA  4E75                    1013          RTS
000018CC  1020                    1014  TWOOR3  MOVE.B  -(A0),D0
000018CE  1420                    1015          MOVE.B  -(A0),D2
000018D0  0400 0030               1016          SUB.B   #48,D0
000018D4  0402 0030               1017          SUB.B   #48,D2
000018D8  E90A                    1018          LSL.B   #4,D2
000018DA  8002                    1019          OR.B    D2,D0
000018DC  11C0 4001               1020          MOVE.B  D0,$4001
000018E0  B23C 0003               1021          CMP.B   #3,D1
000018E4  6600 000C               1022          BNE EXIT3
000018E8  1020                    1023          MOVE.B  -(A0),D0
000018EA  0400 0030               1024          SUB.B   #48,D0
000018EE  8138 4000               1025          OR.B    D0,$4000
000018F2  4E75                    1026  EXIT3   RTS
000018F4                          1027  *
000018F4                          1028  
000018F4                          1029  
000018F4                          1030  ************************************************************************* 
000018F4                          1031  
000018F4                          1032  *
000018F4  =000018F4               1033  BCDtoA  EQU *
000018F4  3038 4000               1034          MOVE.W  $4000,D0    Check for Not A Number or Infinity
000018F8  C07C 7FFF               1035          AND.W   #$7FFF,D0
000018FC  B07C 7FFF               1036          CMP.W   #$7FFF,D0
00001900  6600 0008               1037          BNE CONVERT
00001904  6100 F764               1038          BSR NEWLINE
00001908                          1039          *LEA.L  $4000,A4
00001908                          1040          *BSR    PSTRING
00001908                          1041          *BSR    NEWLINE
00001908  4E75                    1042          RTS 
0000190A  1038 4000               1043  CONVERT MOVE.B  $4000,D0
0000190E  C03C 00C0               1044          AND.B   #$C0,D0
00001912  B03C 0040               1045          CMP.B   #$40,D0     Negative Exponent Positive Mantissa
00001916  6600 0020               1046          BNE SM
0000191A  6100 0096               1047          BSR MAN
0000191E  103C 0045               1048          MOVE.B  #'E',D0
00001922  6100 FC26               1049          BSR PUTCHAR
00001926  103C 002D               1050          MOVE.B  #'-',D0
0000192A  6100 FC1E               1051          BSR PUTCHAR
0000192E  6100 00C6               1052          BSR EXPO
00001932  6100 F736               1053          BSR NEWLINE
00001936  4E75                    1054          RTS
00001938  B03C 0080               1055  SM      CMP.B   #$80,D0     Negative Mantissa Positive Exponent
0000193C  6600 0028               1056          BNE SEM
00001940  103C 002D               1057          MOVE.B  #'-',D0
00001944  6100 FC04               1058          BSR PUTCHAR
00001948  6100 0068               1059          BSR MAN
0000194C  103C 0045               1060          MOVE.B  #'E',D0
00001950  6100 FBF8               1061          BSR PUTCHAR
00001954  103C 002B               1062          MOVE.B  #'+',D0
00001958  6100 FBF0               1063          BSR PUTCHAR
0000195C  6100 0098               1064          BSR EXPO
00001960  6100 F708               1065          BSR NEWLINE
00001964  4E75                    1066          RTS
00001966  B03C 00C0               1067  SEM     CMP.B   #$C0 ,D0    Negative Exponent Negative Mantissa
0000196A  6600 0028               1068          BNE POS
0000196E  103C 002D               1069          MOVE.B  #'-',D0
00001972  6100 FBD6               1070          BSR PUTCHAR
00001976  6100 003A               1071          BSR MAN
0000197A  103C 0045               1072          MOVE.B  #'E',D0
0000197E  6100 FBCA               1073          BSR PUTCHAR
00001982  103C 002D               1074          MOVE.B  #'-',D0
00001986  6100 FBC2               1075          BSR PUTCHAR
0000198A  6100 006A               1076          BSR EXPO
0000198E  6100 F6DA               1077          BSR NEWLINE
00001992  4E75                    1078          RTS
00001994  6100 001C               1079  POS     BSR MAN         Positive Exponent Positive Mantissa
00001998  103C 0045               1080          MOVE.B  #'E',D0
0000199C  6100 FBAC               1081          BSR PUTCHAR
000019A0  103C 002B               1082          MOVE.B  #'+',D0
000019A4  6100 FBA4               1083          BSR PUTCHAR
000019A8  6100 004C               1084          BSR EXPO
000019AC  6100 F6BC               1085          BSR NEWLINE
000019B0  4E75                    1086          RTS
000019B2  1038 4003               1087  MAN     MOVE.B  $4003,D0
000019B6  0600 0030               1088          ADD.B   #48,D0
000019BA  6100 FB8E               1089          BSR PUTCHAR
000019BE  103C 002E               1090          MOVE.B  #'.',D0
000019C2  6100 FB86               1091          BSR PUTCHAR
000019C6  207C 00004004           1092          MOVEA.L #$4004,A0
000019CC  1010                    1093  MAN1    MOVE.B  (A0),D0
000019CE  C03C 00F0               1094          AND.B   #$F0,D0
000019D2  E808                    1095          LSR.B   #4,D0
000019D4  0600 0030               1096          ADD.B   #48,D0
000019D8  6100 FB70               1097          BSR PUTCHAR
000019DC  1010                    1098          MOVE.B  (A0),D0
000019DE  C03C 000F               1099          AND.B   #$0F,D0
000019E2  0600 0030               1100          ADD.B   #48,D0
000019E6  6100 FB62               1101          BSR PUTCHAR
000019EA  5288                    1102          ADDA.L  #1,A0
000019EC  B1FC 0000400C           1103          CMPA.L  #$400C,A0
000019F2  66D8                    1104          BNE MAN1
000019F4  4E75                    1105          RTS
000019F6  223C 00000F00           1106  EXPO    MOVE.L  #$0F00,D1
000019FC  7408                    1107          MOVE.L  #$8,D2
000019FE  3038 4000               1108  AGAIN1  MOVE.W  $4000,D0
00001A02  C041                    1109          AND.W   D1,D0
00001A04  E889                    1110          LSR.L   #4,D1
00001A06  E468                    1111          LSR.W   D2,D0
00001A08  0600 0030               1112          ADD.B   #48,D0
00001A0C  6100 FB3C               1113          BSR PUTCHAR
00001A10  5982                    1114          SUB.L   #4,D2
00001A12  6B00 0004               1115          BMI QUIT
00001A16  60E6                    1116          BRA AGAIN1
00001A18  4E75                    1117  QUIT    RTS
00001A1A                          1118  ************************************************************************* 
00001A1A                          1119  * 
00001A1A                          1120  *  Display exception frame (D0 - D7, A0 - A6, USP, SSP, SR, PC) 
00001A1A                          1121  *  EX_DIS prints registers saved after a breakpoint or exception 
00001A1A                          1122  *  The registers are saved in TSK_T 
00001A1A                          1123  * 
00001A1A  4BEE 011A               1124  EX_DIS  LEA.L   TSK_T(A6),A5      A5 points to display frame 
00001A1E  49FA 03EA               1125          LEA.L   MES3(PC),A4       Point to heading 
00001A22  6100 F666               1126          BSR     HEADING           and print it 
00001A26  3C3C 0007               1127          MOVE.W  #7,D6             8 pairs of registers to display 
00001A2A  4205                    1128          CLR.B   D5                D5 is the line counter 
00001A2C  1005                    1129  EX_D1   MOVE.B  D5,D0             Put current register number in D0 
00001A2E  6100 F7C2               1130          BSR     OUT1X             and print it 
00001A32  6100 F858               1131          BSR     PSPACE            and a space 
00001A36  5205                    1132          ADD.B   #1,D5             Update counter for next pair 
00001A38  2015                    1133          MOVE.L  (A5),D0           Get data register to be displayed 
00001A3A  6100 F7E0               1134          BSR     OUT8X             from the frame and print it 
00001A3E  49FA 03E8               1135          LEA.L   MES4(PC),A4       Print string of spaces 
00001A42  6100 F636               1136          BSR.L   PSTRING           between data and address registers 
00001A46  202D 0020               1137          MOVE.L  32(A5),D0         Get address register to be displayed 
00001A4A  6100 F7D0               1138          BSR     OUT8X             which is 32 bytes on from data reg 
00001A4E  6100 F61A               1139          BSR     NEWLINE 
00001A52  4BED 0004               1140          LEA.L   4(A5),A5          Point to next pair (ie Di, Ai) 
00001A56  51CE FFD4               1141          DBRA    D6,EX_D1          Repeat until all displayed 
00001A5A  4BED 0020               1142          LEA.L   32(A5),A5         Adjust pointer by 8 longwords 
00001A5E  6100 F60A               1143          BSR     NEWLINE           to point to SSP 
00001A62  49FA 039D               1144          LEA.L   MES2A(PC),A4      Point to "SS =" 
00001A66  6100 F612               1145          BSR     PSTRING           Print it 
00001A6A  201D                    1146          MOVE.L  (A5)+,D0          Get SSP from frame 
00001A6C  6100 F7AE               1147          BSR     OUT8X             and display it 
00001A70  6100 F5F8               1148          BSR     NEWLINE 
00001A74  49FA 0379               1149          LEA.L   MES1(PC),A4       Point to 'SR =' 
00001A78  6100 F600               1150          BSR     PSTRING           Print it 
00001A7C  301D                    1151          MOVE.W  (A5)+,D0          Get status register 
00001A7E  6100 F794               1152          BSR     OUT4X             Display status 
00001A82  6100 F5E6               1153          BSR     NEWLINE 
00001A86  49FA 0370               1154          LEA.L   MES2(PC),A4       Point to 'PC =' 
00001A8A  6100 F5EE               1155          BSR     PSTRING           Print it 
00001A8E  201D                    1156          MOVE.L  (A5)+,D0          Get PC 
00001A90  6100 F78A               1157          BSR     OUT8X             Display PC 
00001A94  6000 F5D4               1158          BRA     NEWLINE           Newline and return 
00001A98                          1159  * 
00001A98                          1160  ************************************************************************* 
00001A98                          1161  
00001A98  49F9 00001F4D           1162  HELP     LEA.L    JUMPHELP,A4     printing strings for command help
00001A9E  6100 F5DA               1163           BSR.W    PSTRING
00001AA2  6100 F5C6               1164           BSR.W    NEWLINE
00001AA6  49F9 00001F83           1165           LEA.L    MEMHELP,A4
00001AAC  6100 F5CC               1166           BSR.W    PSTRING
00001AB0  6100 F5B8               1167           BSR.W    NEWLINE
00001AB4  49F9 00001FD0           1168           LEA.L    LOADHELP,A4
00001ABA  6100 F5BE               1169           BSR.W    PSTRING
00001ABE  6100 F5AA               1170           BSR.W    NEWLINE
00001AC2  49F9 0000201A           1171           LEA.L    TVHELP,A4
00001AC8  6100 F5B0               1172           BSR.W    PSTRING
00001ACC  4E75                    1173           RTS
00001ACE                          1174  
00001ACE                          1175  * 
00001ACE                          1176  *************************************************************************         
00001ACE                          1177  * 
00001ACE                          1178  *  Exception handling routines 
00001ACE                          1179  * 
00001ACE  =00001ACE               1180  IL_ER   EQU      *                Illegal instruction exception 
00001ACE  2F0C                    1181          MOVE.L  A4,-(A7)          Save A4 
00001AD0  49FA 0380               1182          LEA.L   MES10(PC),A4      Point to heading 
00001AD4  6100 F5B4               1183          BSR     HEADING           Print it 
00001AD8  285F                    1184          MOVE.L  (A7)+,A4          Restore A4 
00001ADA  6100 0090               1185          BSR.W   GROUP2            Save registers in display frame 
00001ADE  6100 FF3A               1186          BSR     EX_DIS            Display registers saved in frame 
00001AE2  6000 F560               1187          BRA     WARM              Abort from illegal instruction 
00001AE6                          1188  * 
00001AE6  =00001AE6               1189  BUS_ER  EQU     *                 Bus error (group 1) exception 
00001AE6  2F0C                    1190          MOVE.L  A4,-(A7)          Save A4 
00001AE8  49FA 0348               1191          LEA.L   MES8(PC),A4       Point to heading 
00001AEC  6100 F59C               1192          BSR     HEADING           Print it 
00001AF0  285F                    1193          MOVE.L  (A7)+,A4          Restore A4  
00001AF2  6044                    1194          BRA.S   GROUP1            Deal with group 1 exception 
00001AF4                          1195  * 
00001AF4  =00001AF4               1196  ADD_ER  EQU     *                 Address error (group 1) exception 
00001AF4  2F0C                    1197          MOVE.L  A4,-(A7)          Save A4 
00001AF6  49FA 0348               1198          LEA.L   MES9(PC),A4       Point to heading 
00001AFA  6100 F58E               1199          BSR     HEADING           Print it 
00001AFE  285F                    1200          MOVE.L  (A7)+,A4          Restore A4
00001B00  6036                    1201          BRA.S   GROUP1            Deal with group 1 exception 
00001B02                          1202  * 
00001B02  =00001B02               1203  DIV0_ER  EQU     *                   Divide By Zero Exception
00001B02  2F0C                    1204          MOVE.L  A4,-(A7)          Save A4 
00001B04  49FA 0379               1205          LEA.L   MES13(PC),A4       Point to heading 
00001B08  6100 F580               1206          BSR     HEADING           Print it 
00001B0C  285F                    1207          MOVE.L  (A7)+,A4          Restore A4
00001B0E  6028                    1208          BRA.S   GROUP1            Deal with group 1 exception 
00001B10                          1209  *
00001B10  =00001B10               1210  PRIV_ER   EQU     *                 Privilege Violation Exception
00001B10  2F0C                    1211          MOVE.L  A4,-(A7)          Save A4 
00001B12  49FA 0380               1212          LEA.L   MES14(PC),A4      Point to heading 
00001B16  6100 F572               1213          BSR     HEADING           Print it 
00001B1A  285F                    1214          MOVE.L  (A7)+,A4          Restore A4
00001B1C  6100 FEFC               1215          BSR     EX_DIS
00001B20  6000 F522               1216          BRA     WARM
00001B24  6012                    1217          BRA.S   GROUP1            Deal with group 1 exception 
00001B26                          1218  * 
00001B26  =00001B26               1219  BRKPT   EQU     *                   Deal with breakpoint 
00001B26                          1220          *MOVEM.L D0-D7/A0-A6,-(A7)   Save all registers 
00001B26                          1221          *BSR     BR_CLR              Clear breakpoints in code 
00001B26                          1222          *MOVEM.L (A7)+,D0-D7/A0-A6   Restore registers 
00001B26  6144                    1223          BSR.S   GROUP2            Treat as group 2 exception 
00001B28  49FA 033E               1224          LEA.L   MES11(PC),A4      Point to heading 
00001B2C  6100 F55C               1225          BSR     HEADING           Print it 
00001B30  6100 FEE8               1226          BSR     EX_DIS            Display saved registers 
00001B34  6000 F50E               1227          BRA     WARM              Return to monitor 
00001B38                          1228  * 
00001B38                          1229  *       GROUP1 is called by address and bus error exceptions 
00001B38                          1230  *       These are "turned into group 2" exceptions (eg TRAP) 
00001B38                          1231  *       by modifying the stack frame saved by a group 1 exception 
00001B38                          1232  * 
00001B38  48E7 8080               1233  GROUP1  MOVEM.L D0/A0,-(A7)       Save working registers 
00001B3C  206F 0012               1234          MOVE.L  18(A7),A0         Get PC from group 1 stack frame 
00001B40  302F 000E               1235          MOVE.W  14(A7),D0         Get instruction from stack frame 
00001B44  B060                    1236          CMP.W   -(A0),D0          Now backtrack to find the "correct PC" 
00001B46  670E                    1237          BEQ.S   GROUP1A           by matching the op-code on the stack 
00001B48  B060                    1238          CMP.W   -(A0),D0          with the code in the region of the 
00001B4A  670A                    1239          BEQ.S   GROUP1A           PC on the stack 
00001B4C  B060                    1240          CMP.W   -(A0),D0 
00001B4E  6706                    1241          BEQ.S   GROUP1A 
00001B50  B060                    1242          CMP.W   -(A0),D0 
00001B52  6702                    1243          BEQ.S   GROUP1A 
00001B54  5588                    1244          SUBQ.L  #2,A0 
00001B56  2F48 0012               1245  GROUP1A MOVE.L  A0,18(A7)          Restore modified PC to stack frame 
00001B5A  4CDF 0101               1246          MOVEM.L (A7)+,D0/A0        Restore working registers 
00001B5E  4FEF 0008               1247          LEA.L   8(A7),A7           Adjust stack pointer to group 1 type 
00001B62  6108                    1248          BSR.S   GROUP2             Now treat as group 1 exception 
00001B64  6100 FEB4               1249          BSR     EX_DIS             Display contents of exception frame 
00001B68  6000 F4DA               1250          BRA     WARM               Exit to monitor - no RTE from group 2 
00001B6C                          1251  * 
00001B6C  =00001B6C               1252  GROUP2  EQU     *                 Deal with group 2 exceptions 
00001B6C  48E7 FFFF               1253          MOVEM.L A0-A7/D0-D7,-(A7) Save all registers on the stack 
00001B70  303C 000E               1254          MOVE.W  #14,D0            Transfer D0 - D7, A0 - A6 from 
00001B74  41EE 011A               1255          LEA.L   TSK_T(A6),A0      the stack to the display frame 
00001B78  20DF                    1256  GROUP2A MOVE.L  (A7)+,(A0)+       Move a register from stack to frame 
00001B7A  51C8 FFFC               1257          DBRA    D0,GROUP2A        and repeat until D0-D7/A0-A6 moved 
00001B7E  4E6A                    1258          MOVE.L  USP,A2            Get the user stack pointer and put it 
00001B80  20CA                    1259          MOVE.L  A2,(A0)+          in the A7 position in the frame 
00001B82  201F                    1260          MOVE.L  (A7)+,D0          Now transfer the SSP to the frame, 
00001B84  0480 0000000A           1261          SUB.L   #10,D0            remembering to account for the 
00001B8A  20C0                    1262          MOVE.L  D0,(A0)+          data pushed on the stack to this point 
00001B8C  225F                    1263          MOVE.L  (A7)+,A1          Copy TOS (return address) to A1 
00001B8E  30DF                    1264          MOVE.W  (A7)+,(A0)+       Move SR to display frame 
00001B90  201F                    1265          MOVE.L  (A7)+,D0          Get PC in D0 
00001B92  5580                    1266          SUBQ.L  #2,D0             Move back to current instruction 
00001B94  20C0                    1267          MOVE.L  D0,(A0)+          Put adjusted PC in display frame 
00001B96  4ED1                    1268          JMP     (A1)              Return from subroutine 
00001B98                          1269  * 
00001B98                          1270  ************************************************************************* 
00001B98                          1271  * 
00001B98                          1272  *  GO executes a program either from a supplied address or 
00001B98                          1273  *  by using the data in the display frame 
00001B98  6100 F614               1274  GO       BSR     PARAM               Get entry address (if any) 
00001B9C  4A07                    1275           TST.B   D7                  Test for error in input 
00001B9E  6708                    1276           BEQ.S   GO1                 If D7 zero then OK 
00001BA0  49FA 032B               1277           LEA.L   ERMES1(PC),A4       Else point to error message, 
00001BA4  6000 F4D4               1278           BRA     PSTRING             print it and return 
00001BA8  4A80                    1279  GO1      TST.L   D0                  If no address entered then get 
00001BAA  670A                    1280           BEQ.S   GO2                 address from display frame 
00001BAC  2D40 0160               1281           MOVE.L  D0,TSK_T+70(A6)     Else save address in display frame 
00001BB0  3D7C 0700 015E          1282           MOVE.W  #$0700,TSK_T+68(A6) Store dummy status in frame 
00001BB6  6006                    1283  GO2      BRA.S   RESTORE             Restore volatile environment and go 
00001BB8                          1284  * 
00001BB8  6100 007A               1285  GB       BSR     BR_SET              Same as go but presets breakpoints 
00001BBC  60DA                    1286           BRA.S   GO                  Execute program 
00001BBE                          1287  * 
00001BBE                          1288  *        RESTORE moves the volatile environment from the display 
00001BBE                          1289  *        frame and transfers it to the 68000's registers. This 
00001BBE                          1290  *        re-runs a program suspended after an exception 
00001BBE                          1291  * 
00001BBE  47EE 011A               1292  RESTORE  LEA.L   TSK_T(A6),A3        A3 points to display frame 
00001BC2  47EB 004A               1293           LEA.L   74(A3),A3           A3 now points to end of frame + 4 
00001BC6  4FEF 0004               1294           LEA.L   4(A7),A7            Remove return address from stack 
00001BCA  303C 0024               1295           MOVE.W  #36,D0              Counter for 37 words to be moved 
00001BCE  3F23                    1296  REST1    MOVE.W  -(A3),-(A7)         Move word from display frame to stack 
00001BD0  51C8 FFFC               1297           DBRA    D0,REST1            Repeat until entire frame moved 
00001BD4  4CDF 00FF               1298           MOVEM.L (A7)+,D0-D7         Restore old data registers from stack 
00001BD8  4CDF 7F00               1299           MOVEM.L (A7)+,A0-A6         Restore old address registers 
00001BDC  4FEF 0008               1300           LEA.L   8(A7),A7            Except SSP/USP - so adjust stack 
00001BE0  4E73                    1301           RTE                         Return from exception to run program 
00001BE2                          1302  * 
00001BE2  =00001BE2               1303  TRACE    EQU     *                   TRACE exception (rudimentary version) 
00001BE2  287A 0292               1304           MOVE.L  MES12(PC),A4        Point to heading 
00001BE6  6100 F4A2               1305           BSR     HEADING             Print it 
00001BEA  6100 FF4C               1306           BSR     GROUP1              Save volatile environment 
00001BEE  6100 FE2A               1307           BSR     EX_DIS              Display it 
00001BF2  6000 F450               1308           BRA     WARM                Return to monitor 
00001BF6                          1309  * 
00001BF6                          1310  ************************************************************************* 
00001BF6                          1311  *  Breakpoint routines: BR_GET gets the address of a breakpoint and 
00001BF6                          1312  *  puts it in the breakpoint table. It does not plant it in the code. 
00001BF6                          1313  *  BR_SET plants all breakpoints in the code. NOBR removes one or all 
00001BF6                          1314  *  breakpoints from the table. KILL removes breakpoints from the code. 
00001BF6                          1315  * 
00001BF6  6100 F5B6               1316  BR_GET   BSR     PARAM               Get breakpoint address in table 
00001BFA  4A07                    1317           TST.B   D7                  Test for input error 
00001BFC  6708                    1318           BEQ.S   BR_GET1             If no error then continue 
00001BFE  49FA 02CD               1319           LEA.L   ERMES1(PC),A4       Else display error 
00001C02  6000 F476               1320           BRA     PSTRING             and return 
00001C06  47EE 0164               1321  BR_GET1  LEA.L   BP_TAB(A6),A3       A6 points to breakpoint table 
00001C0A  2A40                    1322           MOVE.L  D0,A5               Save new BP address in A5 
00001C0C  2C00                    1323           MOVE.L  D0,D6               and in D6 because D0 gets corrupted 
00001C0E  3A3C 0007               1324           MOVE.W  #7,D5               Eight entries to test 
00001C12  201B                    1325  BR_GET2  MOVE.L  (A3)+,D0            Read entry from breakpoint table 
00001C14  660C                    1326           BNE.S   BR_GET3             If not zero display existing BP 
00001C16  4A86                    1327           TST.L   D6                  Only store a non-zero breakpoint 
00001C18  6710                    1328           BEQ.S   BR_GET4 
00001C1A  274D FFFC               1329           MOVE.L  A5,-4(A3)           Store new breakpoint in table 
00001C1E  3695                    1330           MOVE.W  (A5),(A3)           Save code at BP address in table 
00001C20  4286                    1331           CLR.L   D6                  Clear D6 to avoid repetition 
00001C22  6100 F5F8               1332  BR_GET3  BSR     OUT8X               Display this breakpoint 
00001C26  6100 F442               1333           BSR     NEWLINE 
00001C2A  47EB 0002               1334  BR_GET4  LEA.L   2(A3),A3            Step past stored op-code 
00001C2E  51CD FFE2               1335           DBRA    D5,BR_GET2          Repeat until all entries tested 
00001C32  4E75                    1336           RTS                         Return 
00001C34                          1337  * 
00001C34  =00001C34               1338  BR_SET   EQU     *                   Plant any breakpoints in user code 
00001C34  41EE 0164               1339           LEA.L   BP_TAB(A6),A0       A0 points to BP table 
00001C38  45EE 0160               1340           LEA.L   TSK_T+70(A6),A2     A2 points to PC in display frame 
00001C3C  2452                    1341           MOVE.L  (A2),A2             Now A2 contains value of PC 
00001C3E  303C 0007               1342           MOVE.W  #7,D0               Up to eight entries to plant 
00001C42  2218                    1343  BR_SET1  MOVE.L  (A0)+,D1            Read breakpoint address from table 
00001C44  670A                    1344           BEQ.S   BR_SET2             If zero then skip planting 
00001C46  B28A                    1345           CMP.L   A2,D1               Don't want to plant BP at current PC 
00001C48  6706                    1346           BEQ.S   BR_SET2             location, so skip planting if same 
00001C4A  2241                    1347           MOVE.L  D1,A1               Transfer BP address to address reg 
00001C4C  32BC 4E4E               1348           MOVE.W  #TRAP_16,(A1)       Plant op-code for TRAP #14 in code 
00001C50  41E8 0002               1349  BR_SET2  LEA.L   2(A0),A0            Skip past op-code field in table 
00001C54  51C8 FFEC               1350           DBRA    D0,BR_SET1          Repeat until all entries tested 
00001C58  4E75                    1351           RTS 
00001C5A                          1352  * 
00001C5A  =00001C5A               1353  NOBR     EQU     *                   Clear one or all breakpoints 
00001C5A  6100 F552               1354           BSR     PARAM               Get BP address (if any) 
00001C5E  4A07                    1355           TST.B   D7                  Test for input error 
00001C60  6708                    1356           BEQ.S   NOBR1               If no error then skip abort 
00001C62  49FA 0269               1357           LEA.L   ERMES1(PC),A4       Point to error message 
00001C66  6000 F412               1358           BRA     PSTRING             Display it and return 
00001C6A  4A80                    1359  NOBR1    TST.L   D0                  Test for null address (clear all) 
00001C6C  6720                    1360           BEQ.S   NOBR4               If no address then clear all entries 
00001C6E  2240                    1361           MOVE.L  D0,A1               Else just clear breakpoint in A1 
00001C70  41EE 0164               1362           LEA.L   BP_TAB(A6),A0       A0 points to BP table 
00001C74  303C 0007               1363           MOVE.W  #7,D0               Up to eight entries to test 
00001C78  2218                    1364  NOBR2    MOVE.L  (A0)+,D1            Get entry and 
00001C7A  41E8 0002               1365           LEA.L   2(A0),A0            skip past op-code field 
00001C7E  B289                    1366           CMP.L   A1,D1               Is this the one? 
00001C80  6706                    1367           BEQ.S   NOBR3               If so go and clear entry 
00001C82  51C8 FFF4               1368           DBRA    D0,NOBR2            Repeat until all tested 
00001C86  4E75                    1369           RTS 
00001C88  42A8 FFFA               1370  NOBR3    CLR.L   -6(A0)              Clear address in BP table 
00001C8C  4E75                    1371           RTS 
00001C8E  41EE 0164               1372  NOBR4    LEA.L   BP_TAB(A6),A0       Clear all 8 entries in BP table 
00001C92  303C 0007               1373           MOVE.W  #7,D0               Eight entries to clear 
00001C96  4298                    1374  NOBR5    CLR.L   (A0)+               Clear breakpoint address 
00001C98  4258                    1375           CLR.W   (A0)+               Clear op-code field 
00001C9A  51C8 FFFA               1376           DBRA    D0,NOBR5            Repeat until all done 
00001C9E  4E75                    1377           RTS 
00001CA0                          1378  * 
00001CA0  =00001CA0               1379  BR_CLR   EQU     *                   Remove breakpoints from code 
00001CA0  41EE 0164               1380           LEA.L   BP_TAB(A6),A0       A0 points to breakpoint table 
00001CA4  303C 0007               1381           MOVE.W  #7,D0               Up to eight entries to clear 
00001CA8  2218                    1382  BR_CLR1  MOVE.L  (A0)+,D1            Get address of BP in D1 
00001CAA  2241                    1383           MOVE.L  D1,A1               and put copy in A1 
00001CAC  4A81                    1384           TST.L   D1                  Test this breakpoint 
00001CAE  6702                    1385           BEQ.S   BR_CLR2             If zero then skip BP clearing 
00001CB0  3290                    1386           MOVE.W  (A0),(A1)           Else restore op-code 
00001CB2  41E8 0002               1387  BR_CLR2  LEA.L   2(A0),A0            Skip past op-code field 
00001CB6  51C8 FFF0               1388           DBRA    D0,BR_CLR1          Repeat until all tested 
00001CBA  4E75                    1389           RTS 
00001CBC                          1390  * 
00001CBC                          1391  *  REG_MOD modifies a register in the display frame. The command 
00001CBC                          1392  *  format is REG <reg> <value>. E.g. REG D3 1200 
00001CBC                          1393  * 
00001CBC  4281                    1394  REG_MOD  CLR.L   D1                  D1 to hold name of register 
00001CBE  41EE 0104               1395           LEA.L   BUFFPT(A6),A0       A0 contains address of buffer pointer 
00001CC2  2050                    1396           MOVE.L  (A0),A0             A0 now points to next char in buffer 
00001CC4  1218                    1397           MOVE.B  (A0)+,D1            Put first char of name in D1 
00001CC6  E159                    1398           ROL.W   #8,D1               Move char one place left 
00001CC8  1218                    1399           MOVE.B  (A0)+,D1            Get second char in D1 
00001CCA  41E8 0001               1400           LEA.L   1(A0),A0            Move pointer past space in buffer 
00001CCE  2D48 0104               1401           MOVE.L  A0,BUFFPT(A6)       Update buffer pointer 
00001CD2  4282                    1402           CLR.L   D2                  D2 is the character pair counter 
00001CD4  41FA 01CE               1403           LEA.L   REGNAME(PC),A0      A0 points to string of character pairs 
00001CD8  43D0                    1404           LEA.L   (A0),A1             A1 also points to string 
00001CDA  B258                    1405  REG_MD1  CMP.W   (A0)+,D1            Compare a char pair with input 
00001CDC  6712                    1406           BEQ.S   REG_MD2             If match then exit loop 
00001CDE  5282                    1407           ADD.L   #1,D2               Else increment match counter 
00001CE0  B4BC 00000013           1408           CMP.L   #19,D2              Test for end of loop 
00001CE6  66F2                    1409           BNE     REG_MD1             Continue until all pairs matched 
00001CE8  49FA 01E3               1410           LEA.L   ERMES1(PC),A4       If here then error 
00001CEC  6000 F38C               1411           BRA     PSTRING             Display error and return 
00001CF0  43EE 011A               1412  REG_MD2  LEA.L   TSK_T(A6),A1        A1 points to display frame 
00001CF4  E582                    1413           ASL.L   #2,D2               Multiply offset by 4 (4 bytes/entry) 
00001CF6  B4BC 00000048           1414           CMP.L   #72,D2              Test for address of PC 
00001CFC  6602                    1415           BNE.S   REG_MD3             If not PC then all is OK 
00001CFE  5582                    1416           SUB.L   #2,D2               else dec PC pointer as Sr is a word 
00001D00  45F1 2000               1417  REG_MD3  LEA.L   (A1,D2),A2          Calculate address of entry in disptable 
00001D04  2012                    1418           MOVE.L  (A2),D0             Get old contents 
00001D06  6100 F514               1419           BSR     OUT8X               Display them 
00001D0A  6100 F35E               1420           BSR     NEWLINE 
00001D0E  6100 F49E               1421           BSR     PARAM               Get new data 
00001D12  4A07                    1422           TST.B   D7                  Test for input error 
00001D14  6708                    1423           BEQ.S   REG_MD4             If no error then go and store data 
00001D16  49FA 01B5               1424           LEA.L   ERMES1(PC),A4       Else point to error message 
00001D1A  6000 F35E               1425           BRA     PSTRING             print it and return 
00001D1E  B4BC 00000044           1426  REG_MD4  CMP.L   #68,D2              If this address is the SR then 
00001D24  6704                    1427           BEQ.S   REG_MD5             we have only a word to store 
00001D26  2480                    1428           MOVE.L  D0,(A2)             Else store new data in display frame 
00001D28  4E75                    1429           RTS 
00001D2A  3480                    1430  REG_MD5  MOVE.W  D0,(A2)             Store SR (one word) 
00001D2C  4E75                    1431           RTS 
00001D2E                          1432  * 
00001D2E                          1433  ************************************************************************* 
00001D2E                          1434  * 
00001D2E  =00001D2E               1435  X_UN    EQU     *                 Uninitialized exception vector routine 
00001D2E  49FA 0203               1436          LEA.L   ERMES6(PC),A4     Point to error message 
00001D32  6100 F346               1437          BSR     PSTRING           Display it 
00001D36  6100 FCE2               1438          BSR     EX_DIS            Display registers 
00001D3A  6000 F308               1439          BRA     WARM              Abort 
00001D3E                          1440  * 
00001D3E                          1441  ************************************************************************* 
00001D3E                          1442  * 
00001D3E                          1443  *  All strings and other fixed parameters here 
00001D3E                          1444  * 
00001D3E= 54 53 42 55 47 20 ...   1445  BANNER   DC.B     'TSBUG 2 Version 23.07.86',0,0
00001D58= 4D 6F 64 69 66 69 ...   1446  MODIFY    DC.B   'Modified by Eugene A. Rockey Jr. Jan.05.2010',0,0
00001D86= 66 6F 72 20 75 73 ...   1447  WHY      DC.B     'for use with the M68000 Minimal Computer Configuration',0,0 
00001DBE= 55 6E 69 76 65 72 ...   1448  WHERE    DC.B     'University of Louisville',0,0
00001DD8= 0D 0A 54 53 32 4D ...   1449  CRLF     DC.B     CR,LF,'TS2MON >',0 
00001DE3= 0D 0A 53 31 00 00       1450  HEADER   DC.B     CR,LF,'S','1',0,0 
00001DE9= 53 39 20 20 00 00       1451  TAIL     DC.B     'S9  ',0,0 
00001DEF= 20 53 52 20 20 3D ...   1452  MES1     DC.B     ' SR  =  ',0 
00001DF8= 20 50 43 20 20 3D ...   1453  MES2     DC.B     ' PC  =  ',0 
00001E01= 20 53 53 20 20 3D ...   1454  MES2A    DC.B     ' SS  =  ',0 
00001E0A= 20 20 44 61 74 61 ...   1455  MES3     DC.B     '  Data reg       Address reg',0,0 
00001E28= 20 20 20 20 20 20 ...   1456  MES4     DC.B     '        ',0,0 
00001E32= 42 75 73 20 65 72 ...   1457  MES8     DC.B     'Bus error   ',0,0 
00001E40= 41 64 64 72 65 73 ...   1458  MES9     DC.B     'Address error   ',0,0 
00001E52= 49 6C 6C 65 67 61 ...   1459  MES10    DC.B     'Illegal instruction ',0,0 
00001E68= 42 72 65 61 6B 70 ...   1460  MES11    DC.B     'Breakpoint  ',0,0 
00001E76= 54 72 61 63 65 20 ...   1461  MES12    DC.B     'Trace   ',0 
00001E7F= 44 69 76 69 64 65 ...   1462  MES13    DC.B     'Divide by zero error', 0
00001E94= 50 72 69 76 69 6C ...   1463  MES14    DC.B     'Privilege error', 0
00001EA4= 44 30 44 31 44 32 ...   1464  REGNAME  DC.B     'D0D1D2D3D4D5D6D7' 
00001EB4= 41 30 41 31 41 32 ...   1465           DC.B     'A0A1A2A3A4A5A6A7' 
00001EC4= 53 53 53 52             1466           DC.B     'SSSR' 
00001EC8= 50 43 20 20 00          1467           DC.B     'PC  ',0 
00001ECD= 4E 6F 6E 2D 76 61 ...   1468  ERMES1   DC.B     'Non-valid hexadecimal input  ',0 
00001EEB= 49 6E 76 61 6C 69 ...   1469  ERMES2   DC.B     'Invalid Command  ',0 
00001EFD= 4C 6F 61 64 69 6E ...   1470  ERMES3   DC.B     'Loading error',0 
00001F0B= 54 61 62 6C 65 20 ...   1471  ERMES4   DC.B     'Table full  ',0,0 
00001F19= 42 72 65 61 6B 70 ...   1472  ERMES5   DC.B     'Breakpoint not active   ',0,0 
00001F33= 55 6E 69 6E 69 74 ...   1473  ERMES6   DC.B     'Uninitialized exception ',0,0 
00001F4D= 4A 55 4D 50 20 3C ...   1474  JUMPHELP DC.B     'JUMP <address> causes execution to begin at <address>',0   
00001F83= 4D 45 4D 4F 52 59 ...   1475  MEMHELP  DC.B     'MEMORY <address> examines contents of address> and allows them to be changed', 0   
00001FD0= 4C 4F 41 44 20 3C ...   1476  LOADHELP DC.B     'LOAD <string> loads S1/S2 records from the host. <string> is sent to host', 0
0000201A= 54 56 20 63 68 65 ...   1477  TVHELP   DC.B     'TV checks all RAM addresses from $4000 to $40FE. Reports corrupt memory addresses', 0
0000206C= 20 52 61 6E 67 65 ...   1478  ERMES7   DC.B     ' Range error',0
00002079= 54 45 53 54 00 00       1479  TEST     DC.B     'TEST',0,0
0000207F                          1480  * 
0000207F                          1481  *  COMTAB is the built-in command table. All entries are made up of 
0000207F                          1482  *         a string length + number of characters to match + the string 
0000207F                          1483  *         plus the address of the command relative to COMTAB 
0000207F                          1484  * 
00002000                          1485           ORG      $2000
00002000= 04 04                   1486  COMTAB   DC.B     4,4              JUMP <address> causes execution to 
00002002= 4A 55 4D 50             1487           DC.B     'JUMP'           begin at <address> 
00002006= FFFFF224                1488           DC.L     JUMP-COMTAB                                           
0000200A= 08 03                   1489           DC.B     8,3              MEMORY <address> examines contents of 
0000200C= 4D 45 4D 4F 52 59 ...   1490           DC.B     'MEMORY  '       <address> and allows them to be changed 
00002014= FFFFF23A                1491           DC.L     MEMORY-COMTAB 
00002018= 04 02                   1492           DC.B     4,2              LOAD <string> loads S1/S2 records 
0000201A= 4C 4F 41 44             1493           DC.B     'LOAD'           from the host. <string> is sent to host 
0000201E= FFFFF29A                1494           DC.L     LOAD-COMTAB 
00002022= 04 02                   1495           DC.B    4,2               GO <address> starts program execution 
00002024= 47 4F 20 20             1496           DC.B    'GO  '            at <address> and loads regs from TSK_T 
00002028= FFFFFB98                1497           DC.L    GO-COMTAB 
0000202C= 04 04                   1498           DC.B    4,4               HELP 
0000202E= 48 45 4C 50             1499           DC.B    'HELP'            
00002032= FFFFFA98                1500           DC.L    HELP-COMTAB      
00002036= 00 00                   1501           DC.B    0,0 
00002038                          1502  * 
00002038                          1503  ************************************************************************* 
00002038                          1504  ** 
00002038                          1505  *  This is a list of the information needed to setup the DCBs 
00002038                          1506  * 
00002038  =00002038               1507  DCB_LST  EQU     * 
00002038= 43 4F 4E 5F 49 4E ...   1508  DCB1     DC.B    'CON_IN  '          Device name (8 bytes) 
00002040= 0000148E 00008001       1509           DC.L    CON_IN,ACIA_1       Address of driver routine, device 
00002048= 0002                    1510           DC.W    2                   Number of words in parameter field 
0000204A= 43 4F 4E 5F 4F 55 ...   1511  DCB2     DC.B    'CON_OUT ' 
00002052= 000014BE 00008001       1512           DC.L    CON_OUT,ACIA_1 
0000205A= 0002                    1513           DC.W    2 
0000205C= 41 55 58 5F 49 4E ...   1514  DCB3     DC.B    'AUX_IN  ' 
00002064= 0000140E 00008001       1515           DC.L    AUX_IN,ACIA_2 
0000206C= 0002                    1516           DC.W    2 
0000206E= 41 55 58 5F 4F 55 ...   1517  DCB4     DC.B    'AUX_OUT ' 
00002076= 00001420 00008001       1518           DC.L    AUX_OUT,ACIA_2 
0000207E= 0002                    1519           DC.W    2          
00002080                          1520  
00002080                          1521  ************************************************************************* 
00002080                          1522  * 
00002080                          1523  *  DCB structure 
00002080                          1524  * 
00002080                          1525  *              ----------------------- 
00002080                          1526  *       0 ->   | DCB  name           | 
00002080                          1527  *              |---------------------| 
00002080                          1528  *       8 ->   | Device driver       | 
00002080                          1529  *              |---------------------| 
00002080                          1530  *      12 ->   | Device address      | 
00002080                          1531  *              |---------------------| 
00002080                          1532  *      16 ->   |Size of param block  | 
00002080                          1533  *              |---------------------| --- 
00002080                          1534  *      18 ->   |      Status         |   | 
00002080                          1535  *              | logical  | physical |   | S 
00002080                          1536  *              |---------------------|   | 
00002080                          1537  *              .                     .   . 
00002080                          1538  *              |---------------------| --- 
00002080                          1539  *    18+S ->   | Pointer to next DCB | 
00002080                          1540  * 
00002080                          1541           END RESET 

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ACIA_1              8001
ACIA_2              8001
ADD_0               15B4
ADD_ER              1AF4
ADR_DAT             1278
AGAIN1              19FE
AGAIN3              1868
ATOBCD              1832
AUX_IN              140E
AUX_IN1             1414
AUX_OT1             1426
AUX_OUT             1420
BANNER              1D3E
BCDTOA              18F4
BP_TAB              164
BRKPT               1B26
BR_CLR              1CA0
BR_CLR1             1CA8
BR_CLR2             1CB2
BR_GET              1BF6
BR_GET1             1C06
BR_GET2             1C12
BR_GET3             1C22
BR_GET4             1C2A
BR_SET              1C34
BR_SET1             1C42
BR_SET2             1C50
BS                  8
BUFFEND             103
BUFFER              394
BUFFPT              104
BUS_ER              1AE6
BYTE                1192
B_CLR               15AA
CN_IVEC             112
CN_OVEC             116
COMMAND             A
COMTAB              2000
CONVERT             190A
CON_I1              149C
CON_I2              14B4
CON_IN              148E
CON_OT1             14CC
CON_OT2             14E2
CON_OT3             14EA
CON_OUT             14BE
CR                  D
CRLF                1DD8
CTRL_A              1
DATA                4800
DCB1                2038
DCB2                204A
DCB3                205C
DCB4                206E
DCB_LST             2038
DELAY               13FA
DELAY1              1404
DIV0_ER             1B02
DIVNEG              15F8
DIV_0               15DE
DONE3               1890
DUMP                135A
DUMP1               136A
DUMP2               1376
DUMP3               1384
DUMP4               1398
DUMP5               13A6
DUMP6               13C0
DUMP7               13E4
ECHO                10C
ERMES1              1ECD
ERMES2              1EEB
ERMES3              1EFD
ERMES4              1F0B
ERMES5              1F19
ERMES6              1F33
ERMES7              206C
ESC                 1B
EXEC1               111A
EXEC2               112A
EXECUTE             1108
EXIT3               18F2
EXP12               18A6
EXP13               18A8
EXP3                1894
EXPO                19F6
EX_D1               1A2C
EX_DIS              1A1A
FIRST               194
FOO1                16DA
FOO10               1746
FOO11               1752
FOO12               175E
FOO13               176A
FOO14               1776
FOO15               1782
FOO16               178E
FOO17               179A
FOO18               17A6
FOO19               17B2
FOO2                16E6
FOO20               17BE
FOO21               17CA
FOO22               17E8
FOO23               17F8
FOO24               1808
FOO25               181A
FOO26               1824
FOO3                16F2
FOO4                16FE
FOO5                170A
FOO6                1716
FOO7                1722
FOO8                172E
FOO9                173A
FTRAP               161E
GB                  1BB8
GETCH2              1524
GETCH3              1534
GETCHAR             14FE
GETLINE             1090
GETLN2              109A
GETLN3              10B4
GETLN4              10BE
GETLN5              10C2
GO                  1B98
GO1                 1BA8
GO2                 1BB6
GROUP1              1B38
GROUP1A             1B56
GROUP2              1B6C
GROUP2A             1B78
HEADER              1DE3
HEADING             108A
HELP                1A98
HEX                 1174
HEX_OK              1190
IL_ER               1ACE
IO_OPEN             1570
IO_REQ              147C
JUMP                1224
JUMP1               1232
JUMPHELP            1F4D
LF                  A
LNBUFF              C4
LOAD                129A
LOAD1               12B6
LOAD2               12C2
LOAD3               12DC
LOAD4               12F6
LOAD5               1304
LOAD6               1306
LOAD6A              132A
LOAD7               133C
LOAD8               1352
LOADHELP            1FD0
LONGWD              11A8
MAN                 19B2
MAN1                19CC
MAXCHR              40
MAX_RAM             498
MC68881             80000
MEM1                1244
MEM2                1262
MEM3                1276
MEMHELP             1F83
MEMORY              123A
MES1                1DEF
MES10               1E52
MES11               1E68
MES12               1E76
MES13               1E7F
MES14               1E94
MES2                1DF8
MES2A               1E01
MES3                1E0A
MES4                1E28
MES8                1E32
MES9                1E40
MIN_RAM             494
MODIFY              1D58
MTOR                1646
MULNEG              160E
MUL_0               15D0
NEWLINE             106A
NOBR                1C5A
NOBR1               1C6A
NOBR2               1C78
NOBR3               1C88
NOBR4               1C8E
NOBR5               1C96
NOT_HEX             118C
NO_EXT              1040
NUL                 0
NULCA               164C
NULCA1              167E
NULCA2              16BA
NULREL              166E
NULREL1             16A0
NUM3                1858
OPEN1               1578
OPEN2               1580
OPEN3               158E
OPEN4               15A4
OPER                10
OUT1X               11F2
OUT1X1              1204
OUT2X               120C
OUT4X               1214
OUT8X               121C
PARAM               11AE
PARAM1              11B6
PARAM3              11DA
PARAM4              11DE
PARAM5              11EA
PARAM6              11EE
PARAMTR             108
POS                 1994
PRIV_ER             1B10
PS1                 107C
PS2                 1086
PSPACE              128C
PSTRING             107A
PUTASK              1538
PUTCHAR             154A
QUIT                1A18
RANGE               13EA
REGNAME             1EA4
REG_MD1             1CDA
REG_MD2             1CF0
REG_MD3             1D00
REG_MD4             1D1E
REG_MD5             1D2A
REG_MOD             1CBC
RESET               1000
RESPONSE            0
REST1               1BCE
RESTORE             1BBE
REV3                18B8
RTOM                1678
RTOR                16AA
SEARCH              1134
SEM                 1966
SETACIA             1054
SETNEG              15FE
SET_DCB             1432
SM                  1938
SPACE               20
SPUTCHAR            155E
SRCH2               114E
SRCH3               1152
SRCH4               115A
SRCH6               1164
SRCH7               116E
STACK               4400
ST_DCB1             1442
ST_DCB2             1446
SUB_0               15C2
TAIL                1DE9
TEST                2079
TIDY                10C6
TIDY1               10CC
TIDY2               10D8
TIDY3               10E2
TIDY4               10EC
TIDY5               10F6
TIDY6               1102
TRACE               1BE2
TRAP_0              16CE
TRAP_14             1826
TRAP_15             182C
TRAP_16             4E4E
TSK_T               11A
TVHELP              201A
TWOOR3              18CC
UTAB                10E
U_CASE              10D
WAIT                57
WARM                1044
WHERE               1DBE
WHY                 1D86
WORD                11A2
X_UN                1D2E
